


token UIdent (upper (letter | digit | '_')*) ;

-- Programs

{-Program. Prg ::= [Def] ;

Define.  Def ::= Ident "=" Exp ;
Deftype. Def ::= Ident ":" Type ;
Data.    Def ::= "data" UIdent "=" Con Type ;
Defexp.  Def ::= Exp ;

separator    Def "" ;
terminator   Def "" ;
separator    Ident "" ;

-- types
TLam.	Type ::= Type1 "->" Type ;
TPair.  Type  ::= Type1 "*" Type ;
TInt. 	Type1 ::= "Int" ;
TFloat. Type1 ::= "Float" ;
TVar. 	Type1 ::= Ident ;
TData.  Type1 ::= UIdent ;
_.      Type2 ::= "(" Type ")" ;

coercions Type 2 ;-}

-- Expressions
-- The indices on the "Exp" sets precedence levels.
-- Fix the precedences so they make sense.

-- I think this might make sense, but we should try to produce a test suite to test this.
-- I took some inspiration from various other .bnfc-files.

-- 1: An expression of higher levels can be used on lower levels.
-- 2: Any level expression is lifted to highest by wrapping in parentheses.

{- Layout syntax! See the rule for case of, there is some extra fluff there, e.g {}.
   Only works with the Haskell version! If it sees the {} and stuff it will work
   as intended, as the rule will match. If it does not see a { after of, it will
   insert one and insert the ; at appropriate places. Only demand is that we write each
   of the case branches starting on the same column. -}
layout "of";

ETup.   Exp  ::= "(" Exp "," Exp ")" ;
ECase.  Exp  ::= "case" Exp "of" "{" [PatMatch] "}";
ELet.   Exp  ::= "let" Pat "=" Exp "in" Exp ;
ELetR.  Exp  ::= "letrec" Pat "=" Exp "in" Exp ;
ECon.   Exp  ::= Con Exp ;
EApp.   Exp  ::= Exp Exp ;
-- Commenting this out removed 21 reduce conflicts! It automatically builds
-- a rule like this when you use coerce.
--_.      Exp  ::= "(" Exp ")" ;
ELam.   Exp  ::= "\\" Pat "->" Exp ;
EIf.    Exp  ::= "if" Exp "then" Exp "else" Exp ;
EOr.    Exp  ::= Exp1 "||" Exp ;
EAnd.   Exp1 ::= Exp2 "&&" Exp1 ;
ERel.   Exp2 ::= Exp2 RelOp Exp3 ;
EAdd.   Exp3 ::= Exp3 AddOp Exp4 ;
EMul.   Exp4 ::= Exp4 MulOp Exp5 ;
ENot.   Exp5 ::= "!" Exp6 ;
EConst. Exp6 ::= Const ;
EVar.   Exp6 ::= Ident ;

Plus.  AddOp ::= "+" ;
Minus. AddOp ::= "-" ;

Times. MulOp ::= "*" ;
Div.   MulOp ::= "/" ;

LTC. RelOp ::= "<" ;
LEC. RelOp ::= "<=" ;
GTC. RelOp ::= ">" ;
GEC. RelOp ::= ">=" ;
EQC. RelOp ::= "==" ;

coercions Exp 6 ;

-- Constructor
Constructor. Con ::= UIdent ;


-- Constants

CInt.     Const ::= Integer ;
CFloat.   Const ::= Double ;
CTrue.    Const ::= "True" ;
CFalse.   Const ::= "False" ;

-- Patterns

PVar.   Pat  ::=  Ident ;
PConst. Pat  ::=  Const ;
PNil.   Pat  ::=  "(" ")";
PTup.   Pat1 ::=  "(" Pat "," Pat ")" ;
PLay.   Pat2 ::=  Ident "as" Pat ;

coercions Pat 2 ;

-- Pattern matching

-- TODO we cannot match on constants atm
PConPat.  PatMatch ::= Con Pat "->" Exp ;
separator PatMatch ";"; 

