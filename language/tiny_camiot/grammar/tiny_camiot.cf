


token UIdent (upper (letter | digit | '_')*) ;

-- Expressions
-- The indices on the "Exp" sets precedence levels.
-- Fix the precedences so they make sense.

-- I think this might make sense, but we should try to produce a test suite to test this.
-- I took some inspiration from various other .bnfc-files.

-- 1: An expression of higher levels can be used on lower levels.
-- 2: Any level expression is lifted to highest by wrapping in parentheses.

ETup.   Exp ::= "(" Exp "," Exp ")" ;
ECase.  Exp ::= "case" Exp "of" [PatMatch] ;
ELet.   Exp ::= "let" Pat "=" Exp "in" Exp ;
ELetR.  Exp ::= "letrec" Pat "=" Exp "in" Exp ;
EApp.   Exp ::= Exp Exp ;
_.      Exp ::= "(" Exp ")" ;
ELam.   Exp  ::= "\\" Pat "->" Exp ;
EIf.    Exp  ::= "if" Exp "then" Exp "else" Exp ;
EOr.    Exp  ::= Exp1 "||" Exp ;
EAnd.   Exp1 ::= Exp2 "&&" Exp1 ;
ERel.   Exp2 ::= Exp2 RelOp Exp3 ;
EAdd.   Exp3 ::= Exp3 AddOp Exp4 ;
EMul.   Exp4 ::= Exp4 MulOp Exp5 ;
ENot.   Exp5 ::= "!" Exp6 ;
EConst. Exp6 ::= Const ;
EVar.   Exp6 ::= Ident ;
ECon.   Exp6 ::= Con Exp ;

Plus.  AddOp ::= "+" ;
Minus. AddOp ::= "-" ;

Times. MulOp ::= "*" ;
Div.   MulOp ::= "/" ;

LT. RelOp ::= "<" ;
LE. RelOp ::= "<=" ;
GT. RelOp ::= ">" ;
GE. RelOp ::= ">=" ;
EQ. RelOp ::= "==" ;

coercions Exp 6 ;

-- Constructor
Constructor. Con ::= UIdent ;


-- Constants

CInt.     Const ::= Integer ;
CFloat.   Const ::= Double ;
CTrue.    Const ::= "True" ;
CFalse.   Const ::= "False" ;

-- Patterns

PVar.   Pat  ::=  Ident ;
PConst. Pat  ::=  Const ;
PNil.   Pat  ::=  "(" ")";
PTup.   Pat1 ::=  "(" Pat "," Pat ")" ;
PLay.   Pat2 ::=  Ident "as" Pat ;

coercions Pat 2 ;

-- Pattern matching

PConPat.  PatMatch ::= Con Pat "->" Exp ;
separator PatMatch "|"; 

