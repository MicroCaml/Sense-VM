
build/TEST.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000301 	.word	0x08000301
 8000008:	08000303 	.word	0x08000303
 800000c:	08000303 	.word	0x08000303
 8000010:	08000303 	.word	0x08000303
 8000014:	08000303 	.word	0x08000303
 8000018:	08000303 	.word	0x08000303
 800001c:	08000303 	.word	0x08000303
 8000020:	08000303 	.word	0x08000303
 8000024:	08000303 	.word	0x08000303
 8000028:	08000303 	.word	0x08000303
 800002c:	08002161 	.word	0x08002161
 8000030:	08000303 	.word	0x08000303
 8000034:	08000303 	.word	0x08000303
 8000038:	08000303 	.word	0x08000303
 800003c:	08000303 	.word	0x08000303
 8000040:	08000303 	.word	0x08000303
 8000044:	08000303 	.word	0x08000303
 8000048:	08000303 	.word	0x08000303
 800004c:	08000303 	.word	0x08000303
 8000050:	08000303 	.word	0x08000303
 8000054:	08000303 	.word	0x08000303
 8000058:	08006d21 	.word	0x08006d21
 800005c:	08006cd1 	.word	0x08006cd1
 8000060:	08006c81 	.word	0x08006c81
 8000064:	08006c31 	.word	0x08006c31
 8000068:	08006be1 	.word	0x08006be1
 800006c:	08006a91 	.word	0x08006a91
 8000070:	08006a41 	.word	0x08006a41
 8000074:	080069f1 	.word	0x080069f1
 8000078:	080069a1 	.word	0x080069a1
 800007c:	08006961 	.word	0x08006961
 8000080:	08006911 	.word	0x08006911
 8000084:	080068c1 	.word	0x080068c1
 8000088:	08000303 	.word	0x08000303
 800008c:	08000303 	.word	0x08000303
 8000090:	08000303 	.word	0x08000303
 8000094:	08000303 	.word	0x08000303
 8000098:	08000303 	.word	0x08000303
 800009c:	08006b61 	.word	0x08006b61
 80000a0:	08000303 	.word	0x08000303
 80000a4:	08000303 	.word	0x08000303
 80000a8:	08000303 	.word	0x08000303
 80000ac:	08000303 	.word	0x08000303
 80000b0:	08005221 	.word	0x08005221
 80000b4:	08000303 	.word	0x08000303
 80000b8:	08000303 	.word	0x08000303
 80000bc:	08000303 	.word	0x08000303
 80000c0:	08000303 	.word	0x08000303
 80000c4:	08000303 	.word	0x08000303
 80000c8:	08000303 	.word	0x08000303
 80000cc:	08000303 	.word	0x08000303
 80000d0:	08000303 	.word	0x08000303
 80000d4:	08000303 	.word	0x08000303
 80000d8:	08000303 	.word	0x08000303
 80000dc:	08000303 	.word	0x08000303
 80000e0:	08006ad1 	.word	0x08006ad1
 80000e4:	08000303 	.word	0x08000303
 80000e8:	08000303 	.word	0x08000303
 80000ec:	08000303 	.word	0x08000303
 80000f0:	08000303 	.word	0x08000303
 80000f4:	08000303 	.word	0x08000303
 80000f8:	08000303 	.word	0x08000303
 80000fc:	08006871 	.word	0x08006871
 8000100:	08000303 	.word	0x08000303
 8000104:	08000303 	.word	0x08000303
 8000108:	08006051 	.word	0x08006051
 800010c:	08000303 	.word	0x08000303
 8000110:	08000303 	.word	0x08000303
 8000114:	08000303 	.word	0x08000303
 8000118:	08000303 	.word	0x08000303
 800011c:	08000303 	.word	0x08000303
 8000120:	08006831 	.word	0x08006831
 8000124:	080067e1 	.word	0x080067e1
 8000128:	08005c41 	.word	0x08005c41
 800012c:	08005bf1 	.word	0x08005bf1
 8000130:	08005bb1 	.word	0x08005bb1
 8000134:	08000303 	.word	0x08000303
 8000138:	08000303 	.word	0x08000303
 800013c:	08000303 	.word	0x08000303
 8000140:	08000303 	.word	0x08000303
 8000144:	08000303 	.word	0x08000303
 8000148:	08000303 	.word	0x08000303
 800014c:	08005a91 	.word	0x08005a91
 8000150:	08005b61 	.word	0x08005b61
 8000154:	08005b11 	.word	0x08005b11
 8000158:	08005ac1 	.word	0x08005ac1
 800015c:	08000303 	.word	0x08000303
 8000160:	08000303 	.word	0x08000303
 8000164:	08000303 	.word	0x08000303
 8000168:	08000303 	.word	0x08000303
 800016c:	08000303 	.word	0x08000303
 8000170:	08000303 	.word	0x08000303
 8000174:	08005a61 	.word	0x08005a61
 8000178:	08000303 	.word	0x08000303
 800017c:	08000303 	.word	0x08000303
 8000180:	08000303 	.word	0x08000303
 8000184:	08000303 	.word	0x08000303
 8000188:	08000303 	.word	0x08000303
 800018c:	08000303 	.word	0x08000303
 8000190:	08000303 	.word	0x08000303
 8000194:	08000303 	.word	0x08000303
 8000198:	08000303 	.word	0x08000303
 800019c:	08000303 	.word	0x08000303
 80001a0:	08000303 	.word	0x08000303
 80001a4:	08000303 	.word	0x08000303
 80001a8:	08000303 	.word	0x08000303
 80001ac:	08000303 	.word	0x08000303
 80001b0:	08000303 	.word	0x08000303
 80001b4:	08000303 	.word	0x08000303
 80001b8:	08000303 	.word	0x08000303
 80001bc:	08000303 	.word	0x08000303
 80001c0:	08000303 	.word	0x08000303
 80001c4:	08000303 	.word	0x08000303
 80001c8:	08000303 	.word	0x08000303
 80001cc:	08000303 	.word	0x08000303
 80001d0:	08000303 	.word	0x08000303
 80001d4:	08000303 	.word	0x08000303
 80001d8:	08000303 	.word	0x08000303
 80001dc:	08000303 	.word	0x08000303

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4838      	ldr	r0, [pc, #224]	; (80002c4 <endfiniloop+0x4>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4837      	ldr	r0, [pc, #220]	; (80002c8 <endfiniloop+0x8>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ee:	4837      	ldr	r0, [pc, #220]	; (80002cc <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f8:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80001fa:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80001fe:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 8000202:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 8000206:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800020a:	6008      	str	r0, [r1, #0]
                dsb
 800020c:	f3bf 8f4f 	dsb	sy
                isb
 8000210:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 8000214:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 8000218:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 800021c:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 8000220:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000224:	6008      	str	r0, [r1, #0]
                dsb
 8000226:	f3bf 8f4f 	dsb	sy
                isb
 800022a:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 800022e:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000232:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000236:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 800023a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800023e:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 8000240:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000242:	f380 8814 	msr	CONTROL, r0
                isb
 8000246:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 800024a:	f007 fbb9 	bl	80079c0 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800024e:	f004 fe77 	bl	8004f40 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000252:	481f      	ldr	r0, [pc, #124]	; (80002d0 <endfiniloop+0x10>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000254:	491f      	ldr	r1, [pc, #124]	; (80002d4 <endfiniloop+0x14>)
                ldr     r2, =__main_stack_end__
 8000256:	4a1b      	ldr	r2, [pc, #108]	; (80002c4 <endfiniloop+0x4>)

08000258 <msloop>:
msloop:
                cmp     r1, r2
 8000258:	4291      	cmp	r1, r2
                itt     lo
 800025a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000260:	e7fa      	bcc.n	8000258 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000262:	491d      	ldr	r1, [pc, #116]	; (80002d8 <endfiniloop+0x18>)
                ldr     r2, =__process_stack_end__
 8000264:	4a18      	ldr	r2, [pc, #96]	; (80002c8 <endfiniloop+0x8>)

08000266 <psloop>:
psloop:
                cmp     r1, r2
 8000266:	4291      	cmp	r1, r2
                itt     lo
 8000268:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800026a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800026e:	e7fa      	bcc.n	8000266 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 8000270:	491a      	ldr	r1, [pc, #104]	; (80002dc <endfiniloop+0x1c>)
                ldr     r2, =__data_base__
 8000272:	4a1b      	ldr	r2, [pc, #108]	; (80002e0 <endfiniloop+0x20>)
                ldr     r3, =__data_end__
 8000274:	4b1b      	ldr	r3, [pc, #108]	; (80002e4 <endfiniloop+0x24>)

08000276 <dloop>:
dloop:
                cmp     r2, r3
 8000276:	429a      	cmp	r2, r3
                ittt    lo
 8000278:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800027a:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800027e:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000282:	e7f8      	bcc.n	8000276 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000284:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000286:	4918      	ldr	r1, [pc, #96]	; (80002e8 <endfiniloop+0x28>)
                ldr     r2, =__bss_end__
 8000288:	4a18      	ldr	r2, [pc, #96]	; (80002ec <endfiniloop+0x2c>)

0800028a <bloop>:
bloop:
                cmp     r1, r2
 800028a:	4291      	cmp	r1, r2
                itt     lo
 800028c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800028e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000292:	e7fa      	bcc.n	800028a <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000294:	f007 fb5c 	bl	8007950 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000298:	f007 fb8a 	bl	80079b0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 800029c:	4c14      	ldr	r4, [pc, #80]	; (80002f0 <endfiniloop+0x30>)
                ldr     r5, =__init_array_end__
 800029e:	4d15      	ldr	r5, [pc, #84]	; (80002f4 <endfiniloop+0x34>)

080002a0 <initloop>:
initloop:
                cmp     r4, r5
 80002a0:	42ac      	cmp	r4, r5
                bge     endinitloop
 80002a2:	da03      	bge.n	80002ac <endinitloop>
                ldr     r1, [r4], #4
 80002a4:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002a8:	4788      	blx	r1
                b       initloop
 80002aa:	e7f9      	b.n	80002a0 <initloop>

080002ac <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80002ac:	f001 f830 	bl	8001310 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80002b0:	4c11      	ldr	r4, [pc, #68]	; (80002f8 <endfiniloop+0x38>)
                ldr     r5, =__fini_array_end__
 80002b2:	4d12      	ldr	r5, [pc, #72]	; (80002fc <endfiniloop+0x3c>)

080002b4 <finiloop>:
finiloop:
                cmp     r4, r5
 80002b4:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80002b6:	da03      	bge.n	80002c0 <endfiniloop>
                ldr     r1, [r4], #4
 80002b8:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002bc:	4788      	blx	r1
                b       finiloop
 80002be:	e7f9      	b.n	80002b4 <finiloop>

080002c0 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80002c0:	f007 bb6e 	b.w	80079a0 <__default_exit>
                /* Interrupts are globally masked initially.*/
                cpsid   i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80002c4:	20000400 	.word	0x20000400
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80002c8:	20000800 	.word	0x20000800
                msr     PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80002cc:	08000000 	.word	0x08000000

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80002d0:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80002d4:	20000000 	.word	0x20000000
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80002d8:	20000400 	.word	0x20000400
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 80002dc:	0800d680 	.word	0x0800d680
                ldr     r2, =__data_base__
 80002e0:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 80002e4:	20001174 	.word	0x20001174

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =__bss_base__
 80002e8:	20001178 	.word	0x20001178
                ldr     r2, =__bss_end__
 80002ec:	2000bf50 	.word	0x2000bf50
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 80002f0:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002f4:	080001e0 	.word	0x080001e0
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 80002f8:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002fc:	080001e0 	.word	0x080001e0

08000300 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000300:	e76e      	b.n	80001e0 <_crt0_entry>

08000302 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000302:	f000 f800 	bl	8000306 <_unhandled_exception>

08000306 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000306:	e7fe      	b.n	8000306 <_unhandled_exception>

08000308 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                /* Saving FPU context.*/
                vpush   {s16-s31}
 800030c:	ed2d 8a10 	vpush	{s16-s31}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000310:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000314:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 8000316:	469d      	mov	sp, r3
#endif
#endif

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
 8000318:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800031c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000320 <_port_thread_start>:
_port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      _port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 8000320:	f004 fd96 	bl	8004e50 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000324:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000326:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800032a:	4628      	mov	r0, r5
                blx     r4
 800032c:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800032e:	2000      	movs	r0, #0
                bl      chThdExit
 8000330:	f002 fa76 	bl	8002820 <chThdExit>

08000334 <_zombies>:
_zombies:       b       _zombies
 8000334:	e7fe      	b.n	8000334 <_zombies>

08000336 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 8000336:	f004 fd9b 	bl	8004e70 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 800033a:	f002 f951 	bl	80025e0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 800033e:	f004 fd87 	bl	8004e50 <_dbg_check_unlock>

08000342 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000342:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000344:	e7fe      	b.n	8000344 <_port_exit_from_isr+0x2>
	...

08000348 <memcpy>:
 8000348:	4684      	mov	ip, r0
 800034a:	ea41 0300 	orr.w	r3, r1, r0
 800034e:	f013 0303 	ands.w	r3, r3, #3
 8000352:	d16d      	bne.n	8000430 <memcpy+0xe8>
 8000354:	3a40      	subs	r2, #64	; 0x40
 8000356:	d341      	bcc.n	80003dc <memcpy+0x94>
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a4:	f840 3b04 	str.w	r3, [r0], #4
 80003a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ac:	f840 3b04 	str.w	r3, [r0], #4
 80003b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b4:	f840 3b04 	str.w	r3, [r0], #4
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003cc:	f840 3b04 	str.w	r3, [r0], #4
 80003d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d4:	f840 3b04 	str.w	r3, [r0], #4
 80003d8:	3a40      	subs	r2, #64	; 0x40
 80003da:	d2bd      	bcs.n	8000358 <memcpy+0x10>
 80003dc:	3230      	adds	r2, #48	; 0x30
 80003de:	d311      	bcc.n	8000404 <memcpy+0xbc>
 80003e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003e4:	f840 3b04 	str.w	r3, [r0], #4
 80003e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ec:	f840 3b04 	str.w	r3, [r0], #4
 80003f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003f4:	f840 3b04 	str.w	r3, [r0], #4
 80003f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003fc:	f840 3b04 	str.w	r3, [r0], #4
 8000400:	3a10      	subs	r2, #16
 8000402:	d2ed      	bcs.n	80003e0 <memcpy+0x98>
 8000404:	320c      	adds	r2, #12
 8000406:	d305      	bcc.n	8000414 <memcpy+0xcc>
 8000408:	f851 3b04 	ldr.w	r3, [r1], #4
 800040c:	f840 3b04 	str.w	r3, [r0], #4
 8000410:	3a04      	subs	r2, #4
 8000412:	d2f9      	bcs.n	8000408 <memcpy+0xc0>
 8000414:	3204      	adds	r2, #4
 8000416:	d008      	beq.n	800042a <memcpy+0xe2>
 8000418:	07d2      	lsls	r2, r2, #31
 800041a:	bf1c      	itt	ne
 800041c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000420:	f800 3b01 	strbne.w	r3, [r0], #1
 8000424:	d301      	bcc.n	800042a <memcpy+0xe2>
 8000426:	880b      	ldrh	r3, [r1, #0]
 8000428:	8003      	strh	r3, [r0, #0]
 800042a:	4660      	mov	r0, ip
 800042c:	4770      	bx	lr
 800042e:	bf00      	nop
 8000430:	2a08      	cmp	r2, #8
 8000432:	d313      	bcc.n	800045c <memcpy+0x114>
 8000434:	078b      	lsls	r3, r1, #30
 8000436:	d08d      	beq.n	8000354 <memcpy+0xc>
 8000438:	f010 0303 	ands.w	r3, r0, #3
 800043c:	d08a      	beq.n	8000354 <memcpy+0xc>
 800043e:	f1c3 0304 	rsb	r3, r3, #4
 8000442:	1ad2      	subs	r2, r2, r3
 8000444:	07db      	lsls	r3, r3, #31
 8000446:	bf1c      	itt	ne
 8000448:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800044c:	f800 3b01 	strbne.w	r3, [r0], #1
 8000450:	d380      	bcc.n	8000354 <memcpy+0xc>
 8000452:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000456:	f820 3b02 	strh.w	r3, [r0], #2
 800045a:	e77b      	b.n	8000354 <memcpy+0xc>
 800045c:	3a04      	subs	r2, #4
 800045e:	d3d9      	bcc.n	8000414 <memcpy+0xcc>
 8000460:	3a01      	subs	r2, #1
 8000462:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000466:	f800 3b01 	strb.w	r3, [r0], #1
 800046a:	d2f9      	bcs.n	8000460 <memcpy+0x118>
 800046c:	780b      	ldrb	r3, [r1, #0]
 800046e:	7003      	strb	r3, [r0, #0]
 8000470:	784b      	ldrb	r3, [r1, #1]
 8000472:	7043      	strb	r3, [r0, #1]
 8000474:	788b      	ldrb	r3, [r1, #2]
 8000476:	7083      	strb	r3, [r0, #2]
 8000478:	4660      	mov	r0, ip
 800047a:	4770      	bx	lr

0800047c <__aeabi_drsub>:
 800047c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000480:	e002      	b.n	8000488 <__adddf3>
 8000482:	bf00      	nop

08000484 <__aeabi_dsub>:
 8000484:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000488 <__adddf3>:
 8000488:	b530      	push	{r4, r5, lr}
 800048a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800048e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000492:	ea94 0f05 	teq	r4, r5
 8000496:	bf08      	it	eq
 8000498:	ea90 0f02 	teqeq	r0, r2
 800049c:	bf1f      	itttt	ne
 800049e:	ea54 0c00 	orrsne.w	ip, r4, r0
 80004a2:	ea55 0c02 	orrsne.w	ip, r5, r2
 80004a6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80004aa:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004ae:	f000 80e2 	beq.w	8000676 <__adddf3+0x1ee>
 80004b2:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80004b6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80004ba:	bfb8      	it	lt
 80004bc:	426d      	neglt	r5, r5
 80004be:	dd0c      	ble.n	80004da <__adddf3+0x52>
 80004c0:	442c      	add	r4, r5
 80004c2:	ea80 0202 	eor.w	r2, r0, r2
 80004c6:	ea81 0303 	eor.w	r3, r1, r3
 80004ca:	ea82 0000 	eor.w	r0, r2, r0
 80004ce:	ea83 0101 	eor.w	r1, r3, r1
 80004d2:	ea80 0202 	eor.w	r2, r0, r2
 80004d6:	ea81 0303 	eor.w	r3, r1, r3
 80004da:	2d36      	cmp	r5, #54	; 0x36
 80004dc:	bf88      	it	hi
 80004de:	bd30      	pophi	{r4, r5, pc}
 80004e0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80004e4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80004e8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80004ec:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80004f0:	d002      	beq.n	80004f8 <__adddf3+0x70>
 80004f2:	4240      	negs	r0, r0
 80004f4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80004f8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80004fc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000500:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000504:	d002      	beq.n	800050c <__adddf3+0x84>
 8000506:	4252      	negs	r2, r2
 8000508:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800050c:	ea94 0f05 	teq	r4, r5
 8000510:	f000 80a7 	beq.w	8000662 <__adddf3+0x1da>
 8000514:	f1a4 0401 	sub.w	r4, r4, #1
 8000518:	f1d5 0e20 	rsbs	lr, r5, #32
 800051c:	db0d      	blt.n	800053a <__adddf3+0xb2>
 800051e:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000522:	fa22 f205 	lsr.w	r2, r2, r5
 8000526:	1880      	adds	r0, r0, r2
 8000528:	f141 0100 	adc.w	r1, r1, #0
 800052c:	fa03 f20e 	lsl.w	r2, r3, lr
 8000530:	1880      	adds	r0, r0, r2
 8000532:	fa43 f305 	asr.w	r3, r3, r5
 8000536:	4159      	adcs	r1, r3
 8000538:	e00e      	b.n	8000558 <__adddf3+0xd0>
 800053a:	f1a5 0520 	sub.w	r5, r5, #32
 800053e:	f10e 0e20 	add.w	lr, lr, #32
 8000542:	2a01      	cmp	r2, #1
 8000544:	fa03 fc0e 	lsl.w	ip, r3, lr
 8000548:	bf28      	it	cs
 800054a:	f04c 0c02 	orrcs.w	ip, ip, #2
 800054e:	fa43 f305 	asr.w	r3, r3, r5
 8000552:	18c0      	adds	r0, r0, r3
 8000554:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000558:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800055c:	d507      	bpl.n	800056e <__adddf3+0xe6>
 800055e:	f04f 0e00 	mov.w	lr, #0
 8000562:	f1dc 0c00 	rsbs	ip, ip, #0
 8000566:	eb7e 0000 	sbcs.w	r0, lr, r0
 800056a:	eb6e 0101 	sbc.w	r1, lr, r1
 800056e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000572:	d31b      	bcc.n	80005ac <__adddf3+0x124>
 8000574:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000578:	d30c      	bcc.n	8000594 <__adddf3+0x10c>
 800057a:	0849      	lsrs	r1, r1, #1
 800057c:	ea5f 0030 	movs.w	r0, r0, rrx
 8000580:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000584:	f104 0401 	add.w	r4, r4, #1
 8000588:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800058c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000590:	f080 809a 	bcs.w	80006c8 <__adddf3+0x240>
 8000594:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000598:	bf08      	it	eq
 800059a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800059e:	f150 0000 	adcs.w	r0, r0, #0
 80005a2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80005a6:	ea41 0105 	orr.w	r1, r1, r5
 80005aa:	bd30      	pop	{r4, r5, pc}
 80005ac:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80005b0:	4140      	adcs	r0, r0
 80005b2:	eb41 0101 	adc.w	r1, r1, r1
 80005b6:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80005ba:	f1a4 0401 	sub.w	r4, r4, #1
 80005be:	d1e9      	bne.n	8000594 <__adddf3+0x10c>
 80005c0:	f091 0f00 	teq	r1, #0
 80005c4:	bf04      	itt	eq
 80005c6:	4601      	moveq	r1, r0
 80005c8:	2000      	moveq	r0, #0
 80005ca:	fab1 f381 	clz	r3, r1
 80005ce:	bf08      	it	eq
 80005d0:	3320      	addeq	r3, #32
 80005d2:	f1a3 030b 	sub.w	r3, r3, #11
 80005d6:	f1b3 0220 	subs.w	r2, r3, #32
 80005da:	da0c      	bge.n	80005f6 <__adddf3+0x16e>
 80005dc:	320c      	adds	r2, #12
 80005de:	dd08      	ble.n	80005f2 <__adddf3+0x16a>
 80005e0:	f102 0c14 	add.w	ip, r2, #20
 80005e4:	f1c2 020c 	rsb	r2, r2, #12
 80005e8:	fa01 f00c 	lsl.w	r0, r1, ip
 80005ec:	fa21 f102 	lsr.w	r1, r1, r2
 80005f0:	e00c      	b.n	800060c <__adddf3+0x184>
 80005f2:	f102 0214 	add.w	r2, r2, #20
 80005f6:	bfd8      	it	le
 80005f8:	f1c2 0c20 	rsble	ip, r2, #32
 80005fc:	fa01 f102 	lsl.w	r1, r1, r2
 8000600:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000604:	bfdc      	itt	le
 8000606:	ea41 010c 	orrle.w	r1, r1, ip
 800060a:	4090      	lslle	r0, r2
 800060c:	1ae4      	subs	r4, r4, r3
 800060e:	bfa2      	ittt	ge
 8000610:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000614:	4329      	orrge	r1, r5
 8000616:	bd30      	popge	{r4, r5, pc}
 8000618:	ea6f 0404 	mvn.w	r4, r4
 800061c:	3c1f      	subs	r4, #31
 800061e:	da1c      	bge.n	800065a <__adddf3+0x1d2>
 8000620:	340c      	adds	r4, #12
 8000622:	dc0e      	bgt.n	8000642 <__adddf3+0x1ba>
 8000624:	f104 0414 	add.w	r4, r4, #20
 8000628:	f1c4 0220 	rsb	r2, r4, #32
 800062c:	fa20 f004 	lsr.w	r0, r0, r4
 8000630:	fa01 f302 	lsl.w	r3, r1, r2
 8000634:	ea40 0003 	orr.w	r0, r0, r3
 8000638:	fa21 f304 	lsr.w	r3, r1, r4
 800063c:	ea45 0103 	orr.w	r1, r5, r3
 8000640:	bd30      	pop	{r4, r5, pc}
 8000642:	f1c4 040c 	rsb	r4, r4, #12
 8000646:	f1c4 0220 	rsb	r2, r4, #32
 800064a:	fa20 f002 	lsr.w	r0, r0, r2
 800064e:	fa01 f304 	lsl.w	r3, r1, r4
 8000652:	ea40 0003 	orr.w	r0, r0, r3
 8000656:	4629      	mov	r1, r5
 8000658:	bd30      	pop	{r4, r5, pc}
 800065a:	fa21 f004 	lsr.w	r0, r1, r4
 800065e:	4629      	mov	r1, r5
 8000660:	bd30      	pop	{r4, r5, pc}
 8000662:	f094 0f00 	teq	r4, #0
 8000666:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800066a:	bf06      	itte	eq
 800066c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000670:	3401      	addeq	r4, #1
 8000672:	3d01      	subne	r5, #1
 8000674:	e74e      	b.n	8000514 <__adddf3+0x8c>
 8000676:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800067a:	bf18      	it	ne
 800067c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000680:	d029      	beq.n	80006d6 <__adddf3+0x24e>
 8000682:	ea94 0f05 	teq	r4, r5
 8000686:	bf08      	it	eq
 8000688:	ea90 0f02 	teqeq	r0, r2
 800068c:	d005      	beq.n	800069a <__adddf3+0x212>
 800068e:	ea54 0c00 	orrs.w	ip, r4, r0
 8000692:	bf04      	itt	eq
 8000694:	4619      	moveq	r1, r3
 8000696:	4610      	moveq	r0, r2
 8000698:	bd30      	pop	{r4, r5, pc}
 800069a:	ea91 0f03 	teq	r1, r3
 800069e:	bf1e      	ittt	ne
 80006a0:	2100      	movne	r1, #0
 80006a2:	2000      	movne	r0, #0
 80006a4:	bd30      	popne	{r4, r5, pc}
 80006a6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80006aa:	d105      	bne.n	80006b8 <__adddf3+0x230>
 80006ac:	0040      	lsls	r0, r0, #1
 80006ae:	4149      	adcs	r1, r1
 80006b0:	bf28      	it	cs
 80006b2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80006b6:	bd30      	pop	{r4, r5, pc}
 80006b8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80006bc:	bf3c      	itt	cc
 80006be:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80006c2:	bd30      	popcc	{r4, r5, pc}
 80006c4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80006c8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80006cc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80006d0:	f04f 0000 	mov.w	r0, #0
 80006d4:	bd30      	pop	{r4, r5, pc}
 80006d6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80006da:	bf1a      	itte	ne
 80006dc:	4619      	movne	r1, r3
 80006de:	4610      	movne	r0, r2
 80006e0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80006e4:	bf1c      	itt	ne
 80006e6:	460b      	movne	r3, r1
 80006e8:	4602      	movne	r2, r0
 80006ea:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80006ee:	bf06      	itte	eq
 80006f0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80006f4:	ea91 0f03 	teqeq	r1, r3
 80006f8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80006fc:	bd30      	pop	{r4, r5, pc}
 80006fe:	bf00      	nop

08000700 <__aeabi_ui2d>:
 8000700:	f090 0f00 	teq	r0, #0
 8000704:	bf04      	itt	eq
 8000706:	2100      	moveq	r1, #0
 8000708:	4770      	bxeq	lr
 800070a:	b530      	push	{r4, r5, lr}
 800070c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000710:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000714:	f04f 0500 	mov.w	r5, #0
 8000718:	f04f 0100 	mov.w	r1, #0
 800071c:	e750      	b.n	80005c0 <__adddf3+0x138>
 800071e:	bf00      	nop

08000720 <__aeabi_i2d>:
 8000720:	f090 0f00 	teq	r0, #0
 8000724:	bf04      	itt	eq
 8000726:	2100      	moveq	r1, #0
 8000728:	4770      	bxeq	lr
 800072a:	b530      	push	{r4, r5, lr}
 800072c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000730:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000734:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8000738:	bf48      	it	mi
 800073a:	4240      	negmi	r0, r0
 800073c:	f04f 0100 	mov.w	r1, #0
 8000740:	e73e      	b.n	80005c0 <__adddf3+0x138>
 8000742:	bf00      	nop

08000744 <__aeabi_f2d>:
 8000744:	0042      	lsls	r2, r0, #1
 8000746:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800074a:	ea4f 0131 	mov.w	r1, r1, rrx
 800074e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000752:	bf1f      	itttt	ne
 8000754:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8000758:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800075c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000760:	4770      	bxne	lr
 8000762:	f092 0f00 	teq	r2, #0
 8000766:	bf14      	ite	ne
 8000768:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800076c:	4770      	bxeq	lr
 800076e:	b530      	push	{r4, r5, lr}
 8000770:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000774:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000778:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800077c:	e720      	b.n	80005c0 <__adddf3+0x138>
 800077e:	bf00      	nop

08000780 <__aeabi_ul2d>:
 8000780:	ea50 0201 	orrs.w	r2, r0, r1
 8000784:	bf08      	it	eq
 8000786:	4770      	bxeq	lr
 8000788:	b530      	push	{r4, r5, lr}
 800078a:	f04f 0500 	mov.w	r5, #0
 800078e:	e00a      	b.n	80007a6 <__aeabi_l2d+0x16>

08000790 <__aeabi_l2d>:
 8000790:	ea50 0201 	orrs.w	r2, r0, r1
 8000794:	bf08      	it	eq
 8000796:	4770      	bxeq	lr
 8000798:	b530      	push	{r4, r5, lr}
 800079a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800079e:	d502      	bpl.n	80007a6 <__aeabi_l2d+0x16>
 80007a0:	4240      	negs	r0, r0
 80007a2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80007a6:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80007aa:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80007ae:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80007b2:	f43f aedc 	beq.w	800056e <__adddf3+0xe6>
 80007b6:	f04f 0203 	mov.w	r2, #3
 80007ba:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80007be:	bf18      	it	ne
 80007c0:	3203      	addne	r2, #3
 80007c2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80007c6:	bf18      	it	ne
 80007c8:	3203      	addne	r2, #3
 80007ca:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80007ce:	f1c2 0320 	rsb	r3, r2, #32
 80007d2:	fa00 fc03 	lsl.w	ip, r0, r3
 80007d6:	fa20 f002 	lsr.w	r0, r0, r2
 80007da:	fa01 fe03 	lsl.w	lr, r1, r3
 80007de:	ea40 000e 	orr.w	r0, r0, lr
 80007e2:	fa21 f102 	lsr.w	r1, r1, r2
 80007e6:	4414      	add	r4, r2
 80007e8:	e6c1      	b.n	800056e <__adddf3+0xe6>
 80007ea:	bf00      	nop

080007ec <__aeabi_dmul>:
 80007ec:	b570      	push	{r4, r5, r6, lr}
 80007ee:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80007f2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80007f6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007fa:	bf1d      	ittte	ne
 80007fc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000800:	ea94 0f0c 	teqne	r4, ip
 8000804:	ea95 0f0c 	teqne	r5, ip
 8000808:	f000 f8de 	bleq	80009c8 <__aeabi_dmul+0x1dc>
 800080c:	442c      	add	r4, r5
 800080e:	ea81 0603 	eor.w	r6, r1, r3
 8000812:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000816:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800081a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800081e:	bf18      	it	ne
 8000820:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000824:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000828:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800082c:	d038      	beq.n	80008a0 <__aeabi_dmul+0xb4>
 800082e:	fba0 ce02 	umull	ip, lr, r0, r2
 8000832:	f04f 0500 	mov.w	r5, #0
 8000836:	fbe1 e502 	umlal	lr, r5, r1, r2
 800083a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800083e:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000842:	f04f 0600 	mov.w	r6, #0
 8000846:	fbe1 5603 	umlal	r5, r6, r1, r3
 800084a:	f09c 0f00 	teq	ip, #0
 800084e:	bf18      	it	ne
 8000850:	f04e 0e01 	orrne.w	lr, lr, #1
 8000854:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000858:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800085c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000860:	d204      	bcs.n	800086c <__aeabi_dmul+0x80>
 8000862:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000866:	416d      	adcs	r5, r5
 8000868:	eb46 0606 	adc.w	r6, r6, r6
 800086c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000870:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000874:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000878:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800087c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000880:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000884:	bf88      	it	hi
 8000886:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800088a:	d81e      	bhi.n	80008ca <__aeabi_dmul+0xde>
 800088c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000890:	bf08      	it	eq
 8000892:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000896:	f150 0000 	adcs.w	r0, r0, #0
 800089a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800089e:	bd70      	pop	{r4, r5, r6, pc}
 80008a0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80008a4:	ea46 0101 	orr.w	r1, r6, r1
 80008a8:	ea40 0002 	orr.w	r0, r0, r2
 80008ac:	ea81 0103 	eor.w	r1, r1, r3
 80008b0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80008b4:	bfc2      	ittt	gt
 80008b6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80008ba:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80008be:	bd70      	popgt	{r4, r5, r6, pc}
 80008c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80008c4:	f04f 0e00 	mov.w	lr, #0
 80008c8:	3c01      	subs	r4, #1
 80008ca:	f300 80ab 	bgt.w	8000a24 <__aeabi_dmul+0x238>
 80008ce:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80008d2:	bfde      	ittt	le
 80008d4:	2000      	movle	r0, #0
 80008d6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80008da:	bd70      	pople	{r4, r5, r6, pc}
 80008dc:	f1c4 0400 	rsb	r4, r4, #0
 80008e0:	3c20      	subs	r4, #32
 80008e2:	da35      	bge.n	8000950 <__aeabi_dmul+0x164>
 80008e4:	340c      	adds	r4, #12
 80008e6:	dc1b      	bgt.n	8000920 <__aeabi_dmul+0x134>
 80008e8:	f104 0414 	add.w	r4, r4, #20
 80008ec:	f1c4 0520 	rsb	r5, r4, #32
 80008f0:	fa00 f305 	lsl.w	r3, r0, r5
 80008f4:	fa20 f004 	lsr.w	r0, r0, r4
 80008f8:	fa01 f205 	lsl.w	r2, r1, r5
 80008fc:	ea40 0002 	orr.w	r0, r0, r2
 8000900:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000904:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000908:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800090c:	fa21 f604 	lsr.w	r6, r1, r4
 8000910:	eb42 0106 	adc.w	r1, r2, r6
 8000914:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000918:	bf08      	it	eq
 800091a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800091e:	bd70      	pop	{r4, r5, r6, pc}
 8000920:	f1c4 040c 	rsb	r4, r4, #12
 8000924:	f1c4 0520 	rsb	r5, r4, #32
 8000928:	fa00 f304 	lsl.w	r3, r0, r4
 800092c:	fa20 f005 	lsr.w	r0, r0, r5
 8000930:	fa01 f204 	lsl.w	r2, r1, r4
 8000934:	ea40 0002 	orr.w	r0, r0, r2
 8000938:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800093c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000940:	f141 0100 	adc.w	r1, r1, #0
 8000944:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000948:	bf08      	it	eq
 800094a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800094e:	bd70      	pop	{r4, r5, r6, pc}
 8000950:	f1c4 0520 	rsb	r5, r4, #32
 8000954:	fa00 f205 	lsl.w	r2, r0, r5
 8000958:	ea4e 0e02 	orr.w	lr, lr, r2
 800095c:	fa20 f304 	lsr.w	r3, r0, r4
 8000960:	fa01 f205 	lsl.w	r2, r1, r5
 8000964:	ea43 0302 	orr.w	r3, r3, r2
 8000968:	fa21 f004 	lsr.w	r0, r1, r4
 800096c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000970:	fa21 f204 	lsr.w	r2, r1, r4
 8000974:	ea20 0002 	bic.w	r0, r0, r2
 8000978:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800097c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000980:	bf08      	it	eq
 8000982:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000986:	bd70      	pop	{r4, r5, r6, pc}
 8000988:	f094 0f00 	teq	r4, #0
 800098c:	d10f      	bne.n	80009ae <__aeabi_dmul+0x1c2>
 800098e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000992:	0040      	lsls	r0, r0, #1
 8000994:	eb41 0101 	adc.w	r1, r1, r1
 8000998:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800099c:	bf08      	it	eq
 800099e:	3c01      	subeq	r4, #1
 80009a0:	d0f7      	beq.n	8000992 <__aeabi_dmul+0x1a6>
 80009a2:	ea41 0106 	orr.w	r1, r1, r6
 80009a6:	f095 0f00 	teq	r5, #0
 80009aa:	bf18      	it	ne
 80009ac:	4770      	bxne	lr
 80009ae:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80009b2:	0052      	lsls	r2, r2, #1
 80009b4:	eb43 0303 	adc.w	r3, r3, r3
 80009b8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80009bc:	bf08      	it	eq
 80009be:	3d01      	subeq	r5, #1
 80009c0:	d0f7      	beq.n	80009b2 <__aeabi_dmul+0x1c6>
 80009c2:	ea43 0306 	orr.w	r3, r3, r6
 80009c6:	4770      	bx	lr
 80009c8:	ea94 0f0c 	teq	r4, ip
 80009cc:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009d0:	bf18      	it	ne
 80009d2:	ea95 0f0c 	teqne	r5, ip
 80009d6:	d00c      	beq.n	80009f2 <__aeabi_dmul+0x206>
 80009d8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009dc:	bf18      	it	ne
 80009de:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009e2:	d1d1      	bne.n	8000988 <__aeabi_dmul+0x19c>
 80009e4:	ea81 0103 	eor.w	r1, r1, r3
 80009e8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80009ec:	f04f 0000 	mov.w	r0, #0
 80009f0:	bd70      	pop	{r4, r5, r6, pc}
 80009f2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009f6:	bf06      	itte	eq
 80009f8:	4610      	moveq	r0, r2
 80009fa:	4619      	moveq	r1, r3
 80009fc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a00:	d019      	beq.n	8000a36 <__aeabi_dmul+0x24a>
 8000a02:	ea94 0f0c 	teq	r4, ip
 8000a06:	d102      	bne.n	8000a0e <__aeabi_dmul+0x222>
 8000a08:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000a0c:	d113      	bne.n	8000a36 <__aeabi_dmul+0x24a>
 8000a0e:	ea95 0f0c 	teq	r5, ip
 8000a12:	d105      	bne.n	8000a20 <__aeabi_dmul+0x234>
 8000a14:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000a18:	bf1c      	itt	ne
 8000a1a:	4610      	movne	r0, r2
 8000a1c:	4619      	movne	r1, r3
 8000a1e:	d10a      	bne.n	8000a36 <__aeabi_dmul+0x24a>
 8000a20:	ea81 0103 	eor.w	r1, r1, r3
 8000a24:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000a28:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000a2c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000a30:	f04f 0000 	mov.w	r0, #0
 8000a34:	bd70      	pop	{r4, r5, r6, pc}
 8000a36:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000a3a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000a3e:	bd70      	pop	{r4, r5, r6, pc}

08000a40 <__aeabi_ddiv>:
 8000a40:	b570      	push	{r4, r5, r6, lr}
 8000a42:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000a46:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000a4a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000a4e:	bf1d      	ittte	ne
 8000a50:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000a54:	ea94 0f0c 	teqne	r4, ip
 8000a58:	ea95 0f0c 	teqne	r5, ip
 8000a5c:	f000 f8a7 	bleq	8000bae <__aeabi_ddiv+0x16e>
 8000a60:	eba4 0405 	sub.w	r4, r4, r5
 8000a64:	ea81 0e03 	eor.w	lr, r1, r3
 8000a68:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a6c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000a70:	f000 8088 	beq.w	8000b84 <__aeabi_ddiv+0x144>
 8000a74:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000a78:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000a7c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000a80:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000a84:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000a88:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000a8c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000a90:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000a94:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000a98:	429d      	cmp	r5, r3
 8000a9a:	bf08      	it	eq
 8000a9c:	4296      	cmpeq	r6, r2
 8000a9e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000aa2:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000aa6:	d202      	bcs.n	8000aae <__aeabi_ddiv+0x6e>
 8000aa8:	085b      	lsrs	r3, r3, #1
 8000aaa:	ea4f 0232 	mov.w	r2, r2, rrx
 8000aae:	1ab6      	subs	r6, r6, r2
 8000ab0:	eb65 0503 	sbc.w	r5, r5, r3
 8000ab4:	085b      	lsrs	r3, r3, #1
 8000ab6:	ea4f 0232 	mov.w	r2, r2, rrx
 8000aba:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000abe:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000ac2:	ebb6 0e02 	subs.w	lr, r6, r2
 8000ac6:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000aca:	bf22      	ittt	cs
 8000acc:	1ab6      	subcs	r6, r6, r2
 8000ace:	4675      	movcs	r5, lr
 8000ad0:	ea40 000c 	orrcs.w	r0, r0, ip
 8000ad4:	085b      	lsrs	r3, r3, #1
 8000ad6:	ea4f 0232 	mov.w	r2, r2, rrx
 8000ada:	ebb6 0e02 	subs.w	lr, r6, r2
 8000ade:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000ae2:	bf22      	ittt	cs
 8000ae4:	1ab6      	subcs	r6, r6, r2
 8000ae6:	4675      	movcs	r5, lr
 8000ae8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000aec:	085b      	lsrs	r3, r3, #1
 8000aee:	ea4f 0232 	mov.w	r2, r2, rrx
 8000af2:	ebb6 0e02 	subs.w	lr, r6, r2
 8000af6:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000afa:	bf22      	ittt	cs
 8000afc:	1ab6      	subcs	r6, r6, r2
 8000afe:	4675      	movcs	r5, lr
 8000b00:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000b04:	085b      	lsrs	r3, r3, #1
 8000b06:	ea4f 0232 	mov.w	r2, r2, rrx
 8000b0a:	ebb6 0e02 	subs.w	lr, r6, r2
 8000b0e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000b12:	bf22      	ittt	cs
 8000b14:	1ab6      	subcs	r6, r6, r2
 8000b16:	4675      	movcs	r5, lr
 8000b18:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000b1c:	ea55 0e06 	orrs.w	lr, r5, r6
 8000b20:	d018      	beq.n	8000b54 <__aeabi_ddiv+0x114>
 8000b22:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000b26:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000b2a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000b2e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000b32:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000b36:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000b3a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000b3e:	d1c0      	bne.n	8000ac2 <__aeabi_ddiv+0x82>
 8000b40:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000b44:	d10b      	bne.n	8000b5e <__aeabi_ddiv+0x11e>
 8000b46:	ea41 0100 	orr.w	r1, r1, r0
 8000b4a:	f04f 0000 	mov.w	r0, #0
 8000b4e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000b52:	e7b6      	b.n	8000ac2 <__aeabi_ddiv+0x82>
 8000b54:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000b58:	bf04      	itt	eq
 8000b5a:	4301      	orreq	r1, r0
 8000b5c:	2000      	moveq	r0, #0
 8000b5e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000b62:	bf88      	it	hi
 8000b64:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000b68:	f63f aeaf 	bhi.w	80008ca <__aeabi_dmul+0xde>
 8000b6c:	ebb5 0c03 	subs.w	ip, r5, r3
 8000b70:	bf04      	itt	eq
 8000b72:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000b76:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000b7a:	f150 0000 	adcs.w	r0, r0, #0
 8000b7e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000b82:	bd70      	pop	{r4, r5, r6, pc}
 8000b84:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000b88:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000b8c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000b90:	bfc2      	ittt	gt
 8000b92:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000b96:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000b9a:	bd70      	popgt	{r4, r5, r6, pc}
 8000b9c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000ba0:	f04f 0e00 	mov.w	lr, #0
 8000ba4:	3c01      	subs	r4, #1
 8000ba6:	e690      	b.n	80008ca <__aeabi_dmul+0xde>
 8000ba8:	ea45 0e06 	orr.w	lr, r5, r6
 8000bac:	e68d      	b.n	80008ca <__aeabi_dmul+0xde>
 8000bae:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000bb2:	ea94 0f0c 	teq	r4, ip
 8000bb6:	bf08      	it	eq
 8000bb8:	ea95 0f0c 	teqeq	r5, ip
 8000bbc:	f43f af3b 	beq.w	8000a36 <__aeabi_dmul+0x24a>
 8000bc0:	ea94 0f0c 	teq	r4, ip
 8000bc4:	d10a      	bne.n	8000bdc <__aeabi_ddiv+0x19c>
 8000bc6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000bca:	f47f af34 	bne.w	8000a36 <__aeabi_dmul+0x24a>
 8000bce:	ea95 0f0c 	teq	r5, ip
 8000bd2:	f47f af25 	bne.w	8000a20 <__aeabi_dmul+0x234>
 8000bd6:	4610      	mov	r0, r2
 8000bd8:	4619      	mov	r1, r3
 8000bda:	e72c      	b.n	8000a36 <__aeabi_dmul+0x24a>
 8000bdc:	ea95 0f0c 	teq	r5, ip
 8000be0:	d106      	bne.n	8000bf0 <__aeabi_ddiv+0x1b0>
 8000be2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000be6:	f43f aefd 	beq.w	80009e4 <__aeabi_dmul+0x1f8>
 8000bea:	4610      	mov	r0, r2
 8000bec:	4619      	mov	r1, r3
 8000bee:	e722      	b.n	8000a36 <__aeabi_dmul+0x24a>
 8000bf0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000bf4:	bf18      	it	ne
 8000bf6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000bfa:	f47f aec5 	bne.w	8000988 <__aeabi_dmul+0x19c>
 8000bfe:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000c02:	f47f af0d 	bne.w	8000a20 <__aeabi_dmul+0x234>
 8000c06:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000c0a:	f47f aeeb 	bne.w	80009e4 <__aeabi_dmul+0x1f8>
 8000c0e:	e712      	b.n	8000a36 <__aeabi_dmul+0x24a>

08000c10 <__gedf2>:
 8000c10:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8000c14:	e006      	b.n	8000c24 <__cmpdf2+0x4>
 8000c16:	bf00      	nop

08000c18 <__ledf2>:
 8000c18:	f04f 0c01 	mov.w	ip, #1
 8000c1c:	e002      	b.n	8000c24 <__cmpdf2+0x4>
 8000c1e:	bf00      	nop

08000c20 <__cmpdf2>:
 8000c20:	f04f 0c01 	mov.w	ip, #1
 8000c24:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000c28:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000c2c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c30:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000c34:	bf18      	it	ne
 8000c36:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000c3a:	d01b      	beq.n	8000c74 <__cmpdf2+0x54>
 8000c3c:	b001      	add	sp, #4
 8000c3e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000c42:	bf0c      	ite	eq
 8000c44:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000c48:	ea91 0f03 	teqne	r1, r3
 8000c4c:	bf02      	ittt	eq
 8000c4e:	ea90 0f02 	teqeq	r0, r2
 8000c52:	2000      	moveq	r0, #0
 8000c54:	4770      	bxeq	lr
 8000c56:	f110 0f00 	cmn.w	r0, #0
 8000c5a:	ea91 0f03 	teq	r1, r3
 8000c5e:	bf58      	it	pl
 8000c60:	4299      	cmppl	r1, r3
 8000c62:	bf08      	it	eq
 8000c64:	4290      	cmpeq	r0, r2
 8000c66:	bf2c      	ite	cs
 8000c68:	17d8      	asrcs	r0, r3, #31
 8000c6a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000c6e:	f040 0001 	orr.w	r0, r0, #1
 8000c72:	4770      	bx	lr
 8000c74:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000c78:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c7c:	d102      	bne.n	8000c84 <__cmpdf2+0x64>
 8000c7e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000c82:	d107      	bne.n	8000c94 <__cmpdf2+0x74>
 8000c84:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000c88:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c8c:	d1d6      	bne.n	8000c3c <__cmpdf2+0x1c>
 8000c8e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000c92:	d0d3      	beq.n	8000c3c <__cmpdf2+0x1c>
 8000c94:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000c98:	4770      	bx	lr
 8000c9a:	bf00      	nop

08000c9c <__aeabi_cdrcmple>:
 8000c9c:	4684      	mov	ip, r0
 8000c9e:	4610      	mov	r0, r2
 8000ca0:	4662      	mov	r2, ip
 8000ca2:	468c      	mov	ip, r1
 8000ca4:	4619      	mov	r1, r3
 8000ca6:	4663      	mov	r3, ip
 8000ca8:	e000      	b.n	8000cac <__aeabi_cdcmpeq>
 8000caa:	bf00      	nop

08000cac <__aeabi_cdcmpeq>:
 8000cac:	b501      	push	{r0, lr}
 8000cae:	f7ff ffb7 	bl	8000c20 <__cmpdf2>
 8000cb2:	2800      	cmp	r0, #0
 8000cb4:	bf48      	it	mi
 8000cb6:	f110 0f00 	cmnmi.w	r0, #0
 8000cba:	bd01      	pop	{r0, pc}

08000cbc <__aeabi_dcmpeq>:
 8000cbc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000cc0:	f7ff fff4 	bl	8000cac <__aeabi_cdcmpeq>
 8000cc4:	bf0c      	ite	eq
 8000cc6:	2001      	moveq	r0, #1
 8000cc8:	2000      	movne	r0, #0
 8000cca:	f85d fb08 	ldr.w	pc, [sp], #8
 8000cce:	bf00      	nop

08000cd0 <__aeabi_dcmplt>:
 8000cd0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000cd4:	f7ff ffea 	bl	8000cac <__aeabi_cdcmpeq>
 8000cd8:	bf34      	ite	cc
 8000cda:	2001      	movcc	r0, #1
 8000cdc:	2000      	movcs	r0, #0
 8000cde:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ce2:	bf00      	nop

08000ce4 <__aeabi_dcmple>:
 8000ce4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ce8:	f7ff ffe0 	bl	8000cac <__aeabi_cdcmpeq>
 8000cec:	bf94      	ite	ls
 8000cee:	2001      	movls	r0, #1
 8000cf0:	2000      	movhi	r0, #0
 8000cf2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000cf6:	bf00      	nop

08000cf8 <__aeabi_dcmpge>:
 8000cf8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000cfc:	f7ff ffce 	bl	8000c9c <__aeabi_cdrcmple>
 8000d00:	bf94      	ite	ls
 8000d02:	2001      	movls	r0, #1
 8000d04:	2000      	movhi	r0, #0
 8000d06:	f85d fb08 	ldr.w	pc, [sp], #8
 8000d0a:	bf00      	nop

08000d0c <__aeabi_dcmpgt>:
 8000d0c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000d10:	f7ff ffc4 	bl	8000c9c <__aeabi_cdrcmple>
 8000d14:	bf34      	ite	cc
 8000d16:	2001      	movcc	r0, #1
 8000d18:	2000      	movcs	r0, #0
 8000d1a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000d1e:	bf00      	nop

08000d20 <__aeabi_d2iz>:
 8000d20:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000d24:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000d28:	d215      	bcs.n	8000d56 <__aeabi_d2iz+0x36>
 8000d2a:	d511      	bpl.n	8000d50 <__aeabi_d2iz+0x30>
 8000d2c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000d30:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000d34:	d912      	bls.n	8000d5c <__aeabi_d2iz+0x3c>
 8000d36:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000d3a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000d3e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000d42:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000d46:	fa23 f002 	lsr.w	r0, r3, r2
 8000d4a:	bf18      	it	ne
 8000d4c:	4240      	negne	r0, r0
 8000d4e:	4770      	bx	lr
 8000d50:	f04f 0000 	mov.w	r0, #0
 8000d54:	4770      	bx	lr
 8000d56:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000d5a:	d105      	bne.n	8000d68 <__aeabi_d2iz+0x48>
 8000d5c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000d60:	bf08      	it	eq
 8000d62:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000d66:	4770      	bx	lr
 8000d68:	f04f 0000 	mov.w	r0, #0
 8000d6c:	4770      	bx	lr
 8000d6e:	bf00      	nop

08000d70 <__aeabi_uldivmod>:
 8000d70:	b953      	cbnz	r3, 8000d88 <__aeabi_uldivmod+0x18>
 8000d72:	b94a      	cbnz	r2, 8000d88 <__aeabi_uldivmod+0x18>
 8000d74:	2900      	cmp	r1, #0
 8000d76:	bf08      	it	eq
 8000d78:	2800      	cmpeq	r0, #0
 8000d7a:	bf1c      	itt	ne
 8000d7c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000d80:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000d84:	f000 b83c 	b.w	8000e00 <__aeabi_idiv0>
 8000d88:	b082      	sub	sp, #8
 8000d8a:	46ec      	mov	ip, sp
 8000d8c:	e92d 5000 	stmdb	sp!, {ip, lr}
 8000d90:	f000 f81e 	bl	8000dd0 <__gnu_uldivmod_helper>
 8000d94:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000d98:	b002      	add	sp, #8
 8000d9a:	bc0c      	pop	{r2, r3}
 8000d9c:	4770      	bx	lr
 8000d9e:	bf00      	nop

08000da0 <__gnu_ldivmod_helper>:
 8000da0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000da4:	9c06      	ldr	r4, [sp, #24]
 8000da6:	4615      	mov	r5, r2
 8000da8:	4606      	mov	r6, r0
 8000daa:	460f      	mov	r7, r1
 8000dac:	4698      	mov	r8, r3
 8000dae:	f000 f829 	bl	8000e04 <__divdi3>
 8000db2:	fb05 f301 	mul.w	r3, r5, r1
 8000db6:	fb00 3808 	mla	r8, r0, r8, r3
 8000dba:	fba5 2300 	umull	r2, r3, r5, r0
 8000dbe:	1ab2      	subs	r2, r6, r2
 8000dc0:	4443      	add	r3, r8
 8000dc2:	eb67 0303 	sbc.w	r3, r7, r3
 8000dc6:	e9c4 2300 	strd	r2, r3, [r4]
 8000dca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000dce:	bf00      	nop

08000dd0 <__gnu_uldivmod_helper>:
 8000dd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000dd4:	9c06      	ldr	r4, [sp, #24]
 8000dd6:	4690      	mov	r8, r2
 8000dd8:	4606      	mov	r6, r0
 8000dda:	460f      	mov	r7, r1
 8000ddc:	461d      	mov	r5, r3
 8000dde:	f000 f95f 	bl	80010a0 <__udivdi3>
 8000de2:	fb00 f505 	mul.w	r5, r0, r5
 8000de6:	fba0 2308 	umull	r2, r3, r0, r8
 8000dea:	fb08 5501 	mla	r5, r8, r1, r5
 8000dee:	1ab2      	subs	r2, r6, r2
 8000df0:	442b      	add	r3, r5
 8000df2:	eb67 0303 	sbc.w	r3, r7, r3
 8000df6:	e9c4 2300 	strd	r2, r3, [r4]
 8000dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000dfe:	bf00      	nop

08000e00 <__aeabi_idiv0>:
 8000e00:	4770      	bx	lr
 8000e02:	bf00      	nop

08000e04 <__divdi3>:
 8000e04:	2900      	cmp	r1, #0
 8000e06:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000e0a:	f2c0 80a6 	blt.w	8000f5a <__divdi3+0x156>
 8000e0e:	2600      	movs	r6, #0
 8000e10:	2b00      	cmp	r3, #0
 8000e12:	f2c0 809c 	blt.w	8000f4e <__divdi3+0x14a>
 8000e16:	4688      	mov	r8, r1
 8000e18:	4694      	mov	ip, r2
 8000e1a:	469e      	mov	lr, r3
 8000e1c:	4615      	mov	r5, r2
 8000e1e:	4604      	mov	r4, r0
 8000e20:	460f      	mov	r7, r1
 8000e22:	2b00      	cmp	r3, #0
 8000e24:	d13d      	bne.n	8000ea2 <__divdi3+0x9e>
 8000e26:	428a      	cmp	r2, r1
 8000e28:	d959      	bls.n	8000ede <__divdi3+0xda>
 8000e2a:	fab2 f382 	clz	r3, r2
 8000e2e:	b13b      	cbz	r3, 8000e40 <__divdi3+0x3c>
 8000e30:	f1c3 0220 	rsb	r2, r3, #32
 8000e34:	409f      	lsls	r7, r3
 8000e36:	fa20 f202 	lsr.w	r2, r0, r2
 8000e3a:	409d      	lsls	r5, r3
 8000e3c:	4317      	orrs	r7, r2
 8000e3e:	409c      	lsls	r4, r3
 8000e40:	0c29      	lsrs	r1, r5, #16
 8000e42:	0c22      	lsrs	r2, r4, #16
 8000e44:	fbb7 fef1 	udiv	lr, r7, r1
 8000e48:	b2a8      	uxth	r0, r5
 8000e4a:	fb01 771e 	mls	r7, r1, lr, r7
 8000e4e:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 8000e52:	fb00 f30e 	mul.w	r3, r0, lr
 8000e56:	42bb      	cmp	r3, r7
 8000e58:	d90a      	bls.n	8000e70 <__divdi3+0x6c>
 8000e5a:	197f      	adds	r7, r7, r5
 8000e5c:	f10e 32ff 	add.w	r2, lr, #4294967295	; 0xffffffff
 8000e60:	f080 8105 	bcs.w	800106e <__divdi3+0x26a>
 8000e64:	42bb      	cmp	r3, r7
 8000e66:	f240 8102 	bls.w	800106e <__divdi3+0x26a>
 8000e6a:	f1ae 0e02 	sub.w	lr, lr, #2
 8000e6e:	442f      	add	r7, r5
 8000e70:	1aff      	subs	r7, r7, r3
 8000e72:	b2a4      	uxth	r4, r4
 8000e74:	fbb7 f3f1 	udiv	r3, r7, r1
 8000e78:	fb01 7713 	mls	r7, r1, r3, r7
 8000e7c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 8000e80:	fb00 f003 	mul.w	r0, r0, r3
 8000e84:	42b8      	cmp	r0, r7
 8000e86:	d908      	bls.n	8000e9a <__divdi3+0x96>
 8000e88:	197f      	adds	r7, r7, r5
 8000e8a:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 8000e8e:	f080 80f0 	bcs.w	8001072 <__divdi3+0x26e>
 8000e92:	42b8      	cmp	r0, r7
 8000e94:	f240 80ed 	bls.w	8001072 <__divdi3+0x26e>
 8000e98:	3b02      	subs	r3, #2
 8000e9a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 8000e9e:	2200      	movs	r2, #0
 8000ea0:	e003      	b.n	8000eaa <__divdi3+0xa6>
 8000ea2:	428b      	cmp	r3, r1
 8000ea4:	d90f      	bls.n	8000ec6 <__divdi3+0xc2>
 8000ea6:	2200      	movs	r2, #0
 8000ea8:	4613      	mov	r3, r2
 8000eaa:	1c34      	adds	r4, r6, #0
 8000eac:	bf18      	it	ne
 8000eae:	2401      	movne	r4, #1
 8000eb0:	4260      	negs	r0, r4
 8000eb2:	f04f 0500 	mov.w	r5, #0
 8000eb6:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 8000eba:	4058      	eors	r0, r3
 8000ebc:	4051      	eors	r1, r2
 8000ebe:	1900      	adds	r0, r0, r4
 8000ec0:	4169      	adcs	r1, r5
 8000ec2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000ec6:	fab3 f283 	clz	r2, r3
 8000eca:	2a00      	cmp	r2, #0
 8000ecc:	f040 8086 	bne.w	8000fdc <__divdi3+0x1d8>
 8000ed0:	428b      	cmp	r3, r1
 8000ed2:	d302      	bcc.n	8000eda <__divdi3+0xd6>
 8000ed4:	4584      	cmp	ip, r0
 8000ed6:	f200 80db 	bhi.w	8001090 <__divdi3+0x28c>
 8000eda:	2301      	movs	r3, #1
 8000edc:	e7e5      	b.n	8000eaa <__divdi3+0xa6>
 8000ede:	b912      	cbnz	r2, 8000ee6 <__divdi3+0xe2>
 8000ee0:	2301      	movs	r3, #1
 8000ee2:	fbb3 f5f2 	udiv	r5, r3, r2
 8000ee6:	fab5 f085 	clz	r0, r5
 8000eea:	2800      	cmp	r0, #0
 8000eec:	d13b      	bne.n	8000f66 <__divdi3+0x162>
 8000eee:	1b78      	subs	r0, r7, r5
 8000ef0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000ef4:	fa1f fc85 	uxth.w	ip, r5
 8000ef8:	2201      	movs	r2, #1
 8000efa:	fbb0 f8fe 	udiv	r8, r0, lr
 8000efe:	0c21      	lsrs	r1, r4, #16
 8000f00:	fb0e 0718 	mls	r7, lr, r8, r0
 8000f04:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 8000f08:	fb0c f308 	mul.w	r3, ip, r8
 8000f0c:	42bb      	cmp	r3, r7
 8000f0e:	d907      	bls.n	8000f20 <__divdi3+0x11c>
 8000f10:	197f      	adds	r7, r7, r5
 8000f12:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
 8000f16:	d202      	bcs.n	8000f1e <__divdi3+0x11a>
 8000f18:	42bb      	cmp	r3, r7
 8000f1a:	f200 80bd 	bhi.w	8001098 <__divdi3+0x294>
 8000f1e:	4688      	mov	r8, r1
 8000f20:	1aff      	subs	r7, r7, r3
 8000f22:	b2a4      	uxth	r4, r4
 8000f24:	fbb7 f3fe 	udiv	r3, r7, lr
 8000f28:	fb0e 7713 	mls	r7, lr, r3, r7
 8000f2c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 8000f30:	fb0c fc03 	mul.w	ip, ip, r3
 8000f34:	45bc      	cmp	ip, r7
 8000f36:	d907      	bls.n	8000f48 <__divdi3+0x144>
 8000f38:	197f      	adds	r7, r7, r5
 8000f3a:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
 8000f3e:	d202      	bcs.n	8000f46 <__divdi3+0x142>
 8000f40:	45bc      	cmp	ip, r7
 8000f42:	f200 80a7 	bhi.w	8001094 <__divdi3+0x290>
 8000f46:	460b      	mov	r3, r1
 8000f48:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000f4c:	e7ad      	b.n	8000eaa <__divdi3+0xa6>
 8000f4e:	4252      	negs	r2, r2
 8000f50:	ea6f 0606 	mvn.w	r6, r6
 8000f54:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000f58:	e75d      	b.n	8000e16 <__divdi3+0x12>
 8000f5a:	4240      	negs	r0, r0
 8000f5c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000f60:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8000f64:	e754      	b.n	8000e10 <__divdi3+0xc>
 8000f66:	f1c0 0220 	rsb	r2, r0, #32
 8000f6a:	fa24 f102 	lsr.w	r1, r4, r2
 8000f6e:	fa07 f300 	lsl.w	r3, r7, r0
 8000f72:	4085      	lsls	r5, r0
 8000f74:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000f78:	40d7      	lsrs	r7, r2
 8000f7a:	4319      	orrs	r1, r3
 8000f7c:	fbb7 f2fe 	udiv	r2, r7, lr
 8000f80:	0c0b      	lsrs	r3, r1, #16
 8000f82:	fb0e 7712 	mls	r7, lr, r2, r7
 8000f86:	fa1f fc85 	uxth.w	ip, r5
 8000f8a:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 8000f8e:	fb0c f702 	mul.w	r7, ip, r2
 8000f92:	429f      	cmp	r7, r3
 8000f94:	fa04 f400 	lsl.w	r4, r4, r0
 8000f98:	d907      	bls.n	8000faa <__divdi3+0x1a6>
 8000f9a:	195b      	adds	r3, r3, r5
 8000f9c:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
 8000fa0:	d274      	bcs.n	800108c <__divdi3+0x288>
 8000fa2:	429f      	cmp	r7, r3
 8000fa4:	d972      	bls.n	800108c <__divdi3+0x288>
 8000fa6:	3a02      	subs	r2, #2
 8000fa8:	442b      	add	r3, r5
 8000faa:	1bdf      	subs	r7, r3, r7
 8000fac:	b289      	uxth	r1, r1
 8000fae:	fbb7 f8fe 	udiv	r8, r7, lr
 8000fb2:	fb0e 7318 	mls	r3, lr, r8, r7
 8000fb6:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8000fba:	fb0c f708 	mul.w	r7, ip, r8
 8000fbe:	429f      	cmp	r7, r3
 8000fc0:	d908      	bls.n	8000fd4 <__divdi3+0x1d0>
 8000fc2:	195b      	adds	r3, r3, r5
 8000fc4:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
 8000fc8:	d25c      	bcs.n	8001084 <__divdi3+0x280>
 8000fca:	429f      	cmp	r7, r3
 8000fcc:	d95a      	bls.n	8001084 <__divdi3+0x280>
 8000fce:	f1a8 0802 	sub.w	r8, r8, #2
 8000fd2:	442b      	add	r3, r5
 8000fd4:	1bd8      	subs	r0, r3, r7
 8000fd6:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 8000fda:	e78e      	b.n	8000efa <__divdi3+0xf6>
 8000fdc:	f1c2 0320 	rsb	r3, r2, #32
 8000fe0:	fa2c f103 	lsr.w	r1, ip, r3
 8000fe4:	fa0e fe02 	lsl.w	lr, lr, r2
 8000fe8:	fa20 f703 	lsr.w	r7, r0, r3
 8000fec:	ea41 0e0e 	orr.w	lr, r1, lr
 8000ff0:	fa08 f002 	lsl.w	r0, r8, r2
 8000ff4:	fa28 f103 	lsr.w	r1, r8, r3
 8000ff8:	ea4f 451e 	mov.w	r5, lr, lsr #16
 8000ffc:	4338      	orrs	r0, r7
 8000ffe:	fbb1 f8f5 	udiv	r8, r1, r5
 8001002:	0c03      	lsrs	r3, r0, #16
 8001004:	fb05 1118 	mls	r1, r5, r8, r1
 8001008:	fa1f f78e 	uxth.w	r7, lr
 800100c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8001010:	fb07 f308 	mul.w	r3, r7, r8
 8001014:	428b      	cmp	r3, r1
 8001016:	fa0c fc02 	lsl.w	ip, ip, r2
 800101a:	d909      	bls.n	8001030 <__divdi3+0x22c>
 800101c:	eb11 010e 	adds.w	r1, r1, lr
 8001020:	f108 39ff 	add.w	r9, r8, #4294967295	; 0xffffffff
 8001024:	d230      	bcs.n	8001088 <__divdi3+0x284>
 8001026:	428b      	cmp	r3, r1
 8001028:	d92e      	bls.n	8001088 <__divdi3+0x284>
 800102a:	f1a8 0802 	sub.w	r8, r8, #2
 800102e:	4471      	add	r1, lr
 8001030:	1ac9      	subs	r1, r1, r3
 8001032:	b280      	uxth	r0, r0
 8001034:	fbb1 f3f5 	udiv	r3, r1, r5
 8001038:	fb05 1113 	mls	r1, r5, r3, r1
 800103c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8001040:	fb07 f703 	mul.w	r7, r7, r3
 8001044:	428f      	cmp	r7, r1
 8001046:	d908      	bls.n	800105a <__divdi3+0x256>
 8001048:	eb11 010e 	adds.w	r1, r1, lr
 800104c:	f103 30ff 	add.w	r0, r3, #4294967295	; 0xffffffff
 8001050:	d216      	bcs.n	8001080 <__divdi3+0x27c>
 8001052:	428f      	cmp	r7, r1
 8001054:	d914      	bls.n	8001080 <__divdi3+0x27c>
 8001056:	3b02      	subs	r3, #2
 8001058:	4471      	add	r1, lr
 800105a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800105e:	1bc9      	subs	r1, r1, r7
 8001060:	fba3 890c 	umull	r8, r9, r3, ip
 8001064:	4549      	cmp	r1, r9
 8001066:	d309      	bcc.n	800107c <__divdi3+0x278>
 8001068:	d005      	beq.n	8001076 <__divdi3+0x272>
 800106a:	2200      	movs	r2, #0
 800106c:	e71d      	b.n	8000eaa <__divdi3+0xa6>
 800106e:	4696      	mov	lr, r2
 8001070:	e6fe      	b.n	8000e70 <__divdi3+0x6c>
 8001072:	4613      	mov	r3, r2
 8001074:	e711      	b.n	8000e9a <__divdi3+0x96>
 8001076:	4094      	lsls	r4, r2
 8001078:	4544      	cmp	r4, r8
 800107a:	d2f6      	bcs.n	800106a <__divdi3+0x266>
 800107c:	3b01      	subs	r3, #1
 800107e:	e7f4      	b.n	800106a <__divdi3+0x266>
 8001080:	4603      	mov	r3, r0
 8001082:	e7ea      	b.n	800105a <__divdi3+0x256>
 8001084:	4688      	mov	r8, r1
 8001086:	e7a5      	b.n	8000fd4 <__divdi3+0x1d0>
 8001088:	46c8      	mov	r8, r9
 800108a:	e7d1      	b.n	8001030 <__divdi3+0x22c>
 800108c:	4602      	mov	r2, r0
 800108e:	e78c      	b.n	8000faa <__divdi3+0x1a6>
 8001090:	4613      	mov	r3, r2
 8001092:	e70a      	b.n	8000eaa <__divdi3+0xa6>
 8001094:	3b02      	subs	r3, #2
 8001096:	e757      	b.n	8000f48 <__divdi3+0x144>
 8001098:	f1a8 0802 	sub.w	r8, r8, #2
 800109c:	442f      	add	r7, r5
 800109e:	e73f      	b.n	8000f20 <__divdi3+0x11c>

080010a0 <__udivdi3>:
 80010a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80010a4:	2b00      	cmp	r3, #0
 80010a6:	d144      	bne.n	8001132 <__udivdi3+0x92>
 80010a8:	428a      	cmp	r2, r1
 80010aa:	4615      	mov	r5, r2
 80010ac:	4604      	mov	r4, r0
 80010ae:	d94f      	bls.n	8001150 <__udivdi3+0xb0>
 80010b0:	fab2 f782 	clz	r7, r2
 80010b4:	460e      	mov	r6, r1
 80010b6:	b14f      	cbz	r7, 80010cc <__udivdi3+0x2c>
 80010b8:	f1c7 0320 	rsb	r3, r7, #32
 80010bc:	40b9      	lsls	r1, r7
 80010be:	fa20 f603 	lsr.w	r6, r0, r3
 80010c2:	fa02 f507 	lsl.w	r5, r2, r7
 80010c6:	430e      	orrs	r6, r1
 80010c8:	fa00 f407 	lsl.w	r4, r0, r7
 80010cc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80010d0:	0c23      	lsrs	r3, r4, #16
 80010d2:	fbb6 f0fe 	udiv	r0, r6, lr
 80010d6:	b2af      	uxth	r7, r5
 80010d8:	fb0e 6110 	mls	r1, lr, r0, r6
 80010dc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80010e0:	fb07 f100 	mul.w	r1, r7, r0
 80010e4:	4299      	cmp	r1, r3
 80010e6:	d909      	bls.n	80010fc <__udivdi3+0x5c>
 80010e8:	195b      	adds	r3, r3, r5
 80010ea:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 80010ee:	f080 80ec 	bcs.w	80012ca <__udivdi3+0x22a>
 80010f2:	4299      	cmp	r1, r3
 80010f4:	f240 80e9 	bls.w	80012ca <__udivdi3+0x22a>
 80010f8:	3802      	subs	r0, #2
 80010fa:	442b      	add	r3, r5
 80010fc:	1a5a      	subs	r2, r3, r1
 80010fe:	b2a4      	uxth	r4, r4
 8001100:	fbb2 f3fe 	udiv	r3, r2, lr
 8001104:	fb0e 2213 	mls	r2, lr, r3, r2
 8001108:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 800110c:	fb07 f703 	mul.w	r7, r7, r3
 8001110:	4297      	cmp	r7, r2
 8001112:	d908      	bls.n	8001126 <__udivdi3+0x86>
 8001114:	1952      	adds	r2, r2, r5
 8001116:	f103 31ff 	add.w	r1, r3, #4294967295	; 0xffffffff
 800111a:	f080 80d8 	bcs.w	80012ce <__udivdi3+0x22e>
 800111e:	4297      	cmp	r7, r2
 8001120:	f240 80d5 	bls.w	80012ce <__udivdi3+0x22e>
 8001124:	3b02      	subs	r3, #2
 8001126:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 800112a:	2600      	movs	r6, #0
 800112c:	4631      	mov	r1, r6
 800112e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001132:	428b      	cmp	r3, r1
 8001134:	d847      	bhi.n	80011c6 <__udivdi3+0x126>
 8001136:	fab3 f683 	clz	r6, r3
 800113a:	2e00      	cmp	r6, #0
 800113c:	d148      	bne.n	80011d0 <__udivdi3+0x130>
 800113e:	428b      	cmp	r3, r1
 8001140:	d302      	bcc.n	8001148 <__udivdi3+0xa8>
 8001142:	4282      	cmp	r2, r0
 8001144:	f200 80cd 	bhi.w	80012e2 <__udivdi3+0x242>
 8001148:	2001      	movs	r0, #1
 800114a:	4631      	mov	r1, r6
 800114c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001150:	b912      	cbnz	r2, 8001158 <__udivdi3+0xb8>
 8001152:	2501      	movs	r5, #1
 8001154:	fbb5 f5f2 	udiv	r5, r5, r2
 8001158:	fab5 f885 	clz	r8, r5
 800115c:	f1b8 0f00 	cmp.w	r8, #0
 8001160:	d177      	bne.n	8001252 <__udivdi3+0x1b2>
 8001162:	1b4a      	subs	r2, r1, r5
 8001164:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001168:	b2af      	uxth	r7, r5
 800116a:	2601      	movs	r6, #1
 800116c:	fbb2 f0fe 	udiv	r0, r2, lr
 8001170:	0c23      	lsrs	r3, r4, #16
 8001172:	fb0e 2110 	mls	r1, lr, r0, r2
 8001176:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 800117a:	fb07 f300 	mul.w	r3, r7, r0
 800117e:	428b      	cmp	r3, r1
 8001180:	d907      	bls.n	8001192 <__udivdi3+0xf2>
 8001182:	1949      	adds	r1, r1, r5
 8001184:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 8001188:	d202      	bcs.n	8001190 <__udivdi3+0xf0>
 800118a:	428b      	cmp	r3, r1
 800118c:	f200 80ba 	bhi.w	8001304 <__udivdi3+0x264>
 8001190:	4610      	mov	r0, r2
 8001192:	1ac9      	subs	r1, r1, r3
 8001194:	b2a4      	uxth	r4, r4
 8001196:	fbb1 f3fe 	udiv	r3, r1, lr
 800119a:	fb0e 1113 	mls	r1, lr, r3, r1
 800119e:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 80011a2:	fb07 f703 	mul.w	r7, r7, r3
 80011a6:	42a7      	cmp	r7, r4
 80011a8:	d908      	bls.n	80011bc <__udivdi3+0x11c>
 80011aa:	1964      	adds	r4, r4, r5
 80011ac:	f103 32ff 	add.w	r2, r3, #4294967295	; 0xffffffff
 80011b0:	f080 808f 	bcs.w	80012d2 <__udivdi3+0x232>
 80011b4:	42a7      	cmp	r7, r4
 80011b6:	f240 808c 	bls.w	80012d2 <__udivdi3+0x232>
 80011ba:	3b02      	subs	r3, #2
 80011bc:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80011c0:	4631      	mov	r1, r6
 80011c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80011c6:	2600      	movs	r6, #0
 80011c8:	4630      	mov	r0, r6
 80011ca:	4631      	mov	r1, r6
 80011cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80011d0:	f1c6 0420 	rsb	r4, r6, #32
 80011d4:	fa22 f504 	lsr.w	r5, r2, r4
 80011d8:	40b3      	lsls	r3, r6
 80011da:	432b      	orrs	r3, r5
 80011dc:	fa20 fc04 	lsr.w	ip, r0, r4
 80011e0:	fa01 f706 	lsl.w	r7, r1, r6
 80011e4:	fa21 f504 	lsr.w	r5, r1, r4
 80011e8:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 80011ec:	ea4c 0707 	orr.w	r7, ip, r7
 80011f0:	fbb5 f8fe 	udiv	r8, r5, lr
 80011f4:	0c39      	lsrs	r1, r7, #16
 80011f6:	fb0e 5518 	mls	r5, lr, r8, r5
 80011fa:	fa1f fc83 	uxth.w	ip, r3
 80011fe:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 8001202:	fb0c f108 	mul.w	r1, ip, r8
 8001206:	42a9      	cmp	r1, r5
 8001208:	fa02 f206 	lsl.w	r2, r2, r6
 800120c:	d904      	bls.n	8001218 <__udivdi3+0x178>
 800120e:	18ed      	adds	r5, r5, r3
 8001210:	f108 34ff 	add.w	r4, r8, #4294967295	; 0xffffffff
 8001214:	d367      	bcc.n	80012e6 <__udivdi3+0x246>
 8001216:	46a0      	mov	r8, r4
 8001218:	1a6d      	subs	r5, r5, r1
 800121a:	b2bf      	uxth	r7, r7
 800121c:	fbb5 f4fe 	udiv	r4, r5, lr
 8001220:	fb0e 5514 	mls	r5, lr, r4, r5
 8001224:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 8001228:	fb0c fc04 	mul.w	ip, ip, r4
 800122c:	458c      	cmp	ip, r1
 800122e:	d904      	bls.n	800123a <__udivdi3+0x19a>
 8001230:	18c9      	adds	r1, r1, r3
 8001232:	f104 35ff 	add.w	r5, r4, #4294967295	; 0xffffffff
 8001236:	d35c      	bcc.n	80012f2 <__udivdi3+0x252>
 8001238:	462c      	mov	r4, r5
 800123a:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 800123e:	ebcc 0101 	rsb	r1, ip, r1
 8001242:	fba4 2302 	umull	r2, r3, r4, r2
 8001246:	4299      	cmp	r1, r3
 8001248:	d348      	bcc.n	80012dc <__udivdi3+0x23c>
 800124a:	d044      	beq.n	80012d6 <__udivdi3+0x236>
 800124c:	4620      	mov	r0, r4
 800124e:	2600      	movs	r6, #0
 8001250:	e76c      	b.n	800112c <__udivdi3+0x8c>
 8001252:	f1c8 0420 	rsb	r4, r8, #32
 8001256:	fa01 f308 	lsl.w	r3, r1, r8
 800125a:	fa05 f508 	lsl.w	r5, r5, r8
 800125e:	fa20 f704 	lsr.w	r7, r0, r4
 8001262:	40e1      	lsrs	r1, r4
 8001264:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8001268:	431f      	orrs	r7, r3
 800126a:	fbb1 f6fe 	udiv	r6, r1, lr
 800126e:	0c3a      	lsrs	r2, r7, #16
 8001270:	fb0e 1116 	mls	r1, lr, r6, r1
 8001274:	fa1f fc85 	uxth.w	ip, r5
 8001278:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 800127c:	fb0c f206 	mul.w	r2, ip, r6
 8001280:	429a      	cmp	r2, r3
 8001282:	fa00 f408 	lsl.w	r4, r0, r8
 8001286:	d907      	bls.n	8001298 <__udivdi3+0x1f8>
 8001288:	195b      	adds	r3, r3, r5
 800128a:	f106 31ff 	add.w	r1, r6, #4294967295	; 0xffffffff
 800128e:	d237      	bcs.n	8001300 <__udivdi3+0x260>
 8001290:	429a      	cmp	r2, r3
 8001292:	d935      	bls.n	8001300 <__udivdi3+0x260>
 8001294:	3e02      	subs	r6, #2
 8001296:	442b      	add	r3, r5
 8001298:	1a9b      	subs	r3, r3, r2
 800129a:	b2bf      	uxth	r7, r7
 800129c:	fbb3 f0fe 	udiv	r0, r3, lr
 80012a0:	fb0e 3310 	mls	r3, lr, r0, r3
 80012a4:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 80012a8:	fb0c f100 	mul.w	r1, ip, r0
 80012ac:	4299      	cmp	r1, r3
 80012ae:	d907      	bls.n	80012c0 <__udivdi3+0x220>
 80012b0:	195b      	adds	r3, r3, r5
 80012b2:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 80012b6:	d221      	bcs.n	80012fc <__udivdi3+0x25c>
 80012b8:	4299      	cmp	r1, r3
 80012ba:	d91f      	bls.n	80012fc <__udivdi3+0x25c>
 80012bc:	3802      	subs	r0, #2
 80012be:	442b      	add	r3, r5
 80012c0:	1a5a      	subs	r2, r3, r1
 80012c2:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 80012c6:	4667      	mov	r7, ip
 80012c8:	e750      	b.n	800116c <__udivdi3+0xcc>
 80012ca:	4610      	mov	r0, r2
 80012cc:	e716      	b.n	80010fc <__udivdi3+0x5c>
 80012ce:	460b      	mov	r3, r1
 80012d0:	e729      	b.n	8001126 <__udivdi3+0x86>
 80012d2:	4613      	mov	r3, r2
 80012d4:	e772      	b.n	80011bc <__udivdi3+0x11c>
 80012d6:	40b0      	lsls	r0, r6
 80012d8:	4290      	cmp	r0, r2
 80012da:	d2b7      	bcs.n	800124c <__udivdi3+0x1ac>
 80012dc:	1e60      	subs	r0, r4, #1
 80012de:	2600      	movs	r6, #0
 80012e0:	e724      	b.n	800112c <__udivdi3+0x8c>
 80012e2:	4630      	mov	r0, r6
 80012e4:	e722      	b.n	800112c <__udivdi3+0x8c>
 80012e6:	42a9      	cmp	r1, r5
 80012e8:	d995      	bls.n	8001216 <__udivdi3+0x176>
 80012ea:	f1a8 0802 	sub.w	r8, r8, #2
 80012ee:	441d      	add	r5, r3
 80012f0:	e792      	b.n	8001218 <__udivdi3+0x178>
 80012f2:	458c      	cmp	ip, r1
 80012f4:	d9a0      	bls.n	8001238 <__udivdi3+0x198>
 80012f6:	3c02      	subs	r4, #2
 80012f8:	4419      	add	r1, r3
 80012fa:	e79e      	b.n	800123a <__udivdi3+0x19a>
 80012fc:	4610      	mov	r0, r2
 80012fe:	e7df      	b.n	80012c0 <__udivdi3+0x220>
 8001300:	460e      	mov	r6, r1
 8001302:	e7c9      	b.n	8001298 <__udivdi3+0x1f8>
 8001304:	3802      	subs	r0, #2
 8001306:	4429      	add	r1, r5
 8001308:	e743      	b.n	8001192 <__udivdi3+0xf2>
 800130a:	bf00      	nop
 800130c:	0000      	movs	r0, r0
	...

08001310 <main>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001310:	4bbe      	ldr	r3, [pc, #760]	; (800160c <main+0x2fc>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001312:	48bf      	ldr	r0, [pc, #764]	; (8001610 <main+0x300>)

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001314:	691a      	ldr	r2, [r3, #16]
 8001316:	ea6f 52c2 	mvn.w	r2, r2, lsl #23
 800131a:	ea6f 52d2 	mvn.w	r2, r2, lsr #23
  vsnprintf(buf, 2048, str, args);

  chprintf((BaseSequentialStream *)&SDU1,"%s", buf);
}

int main(void) {
 800131e:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8001322:	611a      	str	r2, [r3, #16]
 8001324:	691a      	ldr	r2, [r3, #16]
 8001326:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800132a:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 800132c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001330:	691a      	ldr	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8001332:	695a      	ldr	r2, [r3, #20]
 8001334:	615c      	str	r4, [r3, #20]
 8001336:	2100      	movs	r1, #0
 8001338:	695a      	ldr	r2, [r3, #20]
 800133a:	6159      	str	r1, [r3, #20]
 800133c:	695a      	ldr	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800133e:	6a1a      	ldr	r2, [r3, #32]
 8001340:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 8001344:	621a      	str	r2, [r3, #32]
 8001346:	6a1a      	ldr	r2, [r3, #32]
 8001348:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 800134c:	621a      	str	r2, [r3, #32]
 800134e:	6a1a      	ldr	r2, [r3, #32]
  rccResetAPB2(~0);
 8001350:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001352:	625c      	str	r4, [r3, #36]	; 0x24
 8001354:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001356:	6259      	str	r1, [r3, #36]	; 0x24
 8001358:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 800135a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800135c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001360:	641a      	str	r2, [r3, #64]	; 0x40
 8001362:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001364:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001368:	661a      	str	r2, [r3, #96]	; 0x60
 800136a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800136c:	6802      	ldr	r2, [r0, #0]
 800136e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001372:	6002      	str	r2, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001374:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001376:	f402 7240 	and.w	r2, r2, #768	; 0x300
 800137a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800137e:	b087      	sub	sp, #28
 8001380:	d003      	beq.n	800138a <main+0x7a>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001382:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001386:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8001388:	6719      	str	r1, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 800138a:	4da1      	ldr	r5, [pc, #644]	; (8001610 <main+0x300>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 800138c:	49a1      	ldr	r1, [pc, #644]	; (8001614 <main+0x304>)
 800138e:	686a      	ldr	r2, [r5, #4]
 8001390:	4ca1      	ldr	r4, [pc, #644]	; (8001618 <main+0x308>)
 8001392:	2000      	movs	r0, #0
 8001394:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001398:	606a      	str	r2, [r5, #4]
 800139a:	4603      	mov	r3, r0
 800139c:	460a      	mov	r2, r1
 800139e:	6008      	str	r0, [r1, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 80013a0:	4601      	mov	r1, r0
 80013a2:	58e0      	ldr	r0, [r4, r3]
 80013a4:	330c      	adds	r3, #12
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80013a6:	2bc0      	cmp	r3, #192	; 0xc0
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 80013a8:	6001      	str	r1, [r0, #0]
 80013aa:	f102 0208 	add.w	r2, r2, #8
    dma.streams[i].func = NULL;
 80013ae:	f842 1c04 	str.w	r1, [r2, #-4]
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80013b2:	d1f6      	bne.n	80013a2 <main+0x92>

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80013b4:	4999      	ldr	r1, [pc, #612]	; (800161c <main+0x30c>)
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
    dma.streams[i].func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80013b6:	4a9a      	ldr	r2, [pc, #616]	; (8001620 <main+0x310>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 80013b8:	f8df a290 	ldr.w	sl, [pc, #656]	; 800164c <main+0x33c>
 80013bc:	4b99      	ldr	r3, [pc, #612]	; (8001624 <main+0x314>)
 80013be:	2460      	movs	r4, #96	; 0x60
  dma.allocated_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
    dma.streams[i].func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80013c0:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80013c4:	f44f 7580 	mov.w	r5, #256	; 0x100
 80013c8:	f04f 0880 	mov.w	r8, #128	; 0x80
 80013cc:	f04f 0940 	mov.w	r9, #64	; 0x40
 80013d0:	f44f 7c00 	mov.w	ip, #512	; 0x200
 80013d4:	f44f 6e80 	mov.w	lr, #1024	; 0x400
 80013d8:	f44f 0700 	mov.w	r7, #8388608	; 0x800000
 80013dc:	6096      	str	r6, [r2, #8]
 80013de:	eb03 0008 	add.w	r0, r3, r8
  DMA1->HIFCR = 0xFFFFFFFFU;
 80013e2:	60d6      	str	r6, [r2, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 80013e4:	f8ca 6008 	str.w	r6, [sl, #8]

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
 80013e8:	2200      	movs	r2, #0
  DMA2->HIFCR = 0xFFFFFFFFU;
 80013ea:	f8ca 600c 	str.w	r6, [sl, #12]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80013ee:	f881 4306 	strb.w	r4, [r1, #774]	; 0x306
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80013f2:	f8c1 9180 	str.w	r9, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80013f6:	f8c1 9000 	str.w	r9, [r1]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80013fa:	f881 4307 	strb.w	r4, [r1, #775]	; 0x307
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80013fe:	f8c1 8180 	str.w	r8, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001402:	f8c1 8000 	str.w	r8, [r1]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001406:	f881 4308 	strb.w	r4, [r1, #776]	; 0x308
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800140a:	f8c1 5180 	str.w	r5, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800140e:	600d      	str	r5, [r1, #0]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001410:	f881 4309 	strb.w	r4, [r1, #777]	; 0x309
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001414:	f8c1 c180 	str.w	ip, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001418:	f8c1 c000 	str.w	ip, [r1]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800141c:	f881 430a 	strb.w	r4, [r1, #778]	; 0x30a
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001420:	f8c1 e180 	str.w	lr, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001424:	f8c1 e000 	str.w	lr, [r1]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001428:	f881 4317 	strb.w	r4, [r1, #791]	; 0x317
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800142c:	f8c1 7180 	str.w	r7, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001430:	600f      	str	r7, [r1, #0]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001432:	f881 4328 	strb.w	r4, [r1, #808]	; 0x328
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001436:	f8c1 5184 	str.w	r5, [r1, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800143a:	604d      	str	r5, [r1, #4]
 800143c:	601a      	str	r2, [r3, #0]
 800143e:	605a      	str	r2, [r3, #4]
 8001440:	3308      	adds	r3, #8
void _pal_lld_init(void) {

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
 8001442:	4283      	cmp	r3, r0
    _pal_init_event(i);
 8001444:	f04f 0100 	mov.w	r1, #0
void _pal_lld_init(void) {

#if PAL_USE_CALLBACKS || PAL_USE_WAIT || defined(__DOXYGEN__)
  unsigned i;

  for (i = 0; i < 16; i++) {
 8001448:	d1f8      	bne.n	800143c <main+0x12c>
 *
 * @init
 */
void dacObjectInit(DACDriver *dacp) {

  dacp->state = DAC_STOP;
 800144a:	f8df 8204 	ldr.w	r8, [pc, #516]	; 8001650 <main+0x340>
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 800144e:	4d76      	ldr	r5, [pc, #472]	; (8001628 <main+0x318>)
 */
void dac_lld_init(void) {

#if STM32_DAC_USE_DAC1_CH1
  dacObjectInit(&DACD1);
  DACD1.params  = &dac1_ch1_params;
 8001450:	4876      	ldr	r0, [pc, #472]	; (800162c <main+0x31c>)
  dacp->config = NULL;
 8001452:	f8c8 1010 	str.w	r1, [r8, #16]
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 8001456:	f108 0218 	add.w	r2, r8, #24
 *
 * @init
 */
void dacObjectInit(DACDriver *dacp) {

  dacp->state = DAC_STOP;
 800145a:	2301      	movs	r3, #1
 800145c:	f8c8 2018 	str.w	r2, [r8, #24]
  qp->prev = qp;
 8001460:	f8c8 201c 	str.w	r2, [r8, #28]
 8001464:	f888 3000 	strb.w	r3, [r8]
 8001468:	702b      	strb	r3, [r5, #0]
  dacp->config = NULL;
#if DAC_USE_WAIT
  dacp->thread = NULL;
 800146a:	f8c8 1014 	str.w	r1, [r8, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
 800146e:	f8c8 1020 	str.w	r1, [r8, #32]
  DACD1.dma = NULL;
 8001472:	f8c8 102c 	str.w	r1, [r8, #44]	; 0x2c
 */
void dac_lld_init(void) {

#if STM32_DAC_USE_DAC1_CH1
  dacObjectInit(&DACD1);
  DACD1.params  = &dac1_ch1_params;
 8001476:	f8c8 0028 	str.w	r0, [r8, #40]	; 0x28
  usbp->config       = NULL;
 800147a:	6069      	str	r1, [r5, #4]
 800147c:	f105 0320 	add.w	r3, r5, #32
 8001480:	f105 0234 	add.w	r2, r5, #52	; 0x34
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8001484:	f843 1f04 	str.w	r1, [r3, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001488:	4293      	cmp	r3, r2
    usbp->in_params[i]  = NULL;
 800148a:	f04f 0000 	mov.w	r0, #0
    usbp->out_params[i] = NULL;
 800148e:	6159      	str	r1, [r3, #20]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8001490:	d1f8      	bne.n	8001484 <main+0x174>
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8001492:	4a67      	ldr	r2, [pc, #412]	; (8001630 <main+0x320>)

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 8001494:	4b67      	ldr	r3, [pc, #412]	; (8001634 <main+0x324>)
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8001496:	8128      	strh	r0, [r5, #8]
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8001498:	2101      	movs	r1, #1
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.otg       = OTG_FS;
 800149a:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
 800149e:	7011      	strb	r1, [r2, #0]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
  usbp->receiving    = 0;
 80014a0:	8168      	strh	r0, [r5, #10]
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 80014a2:	6050      	str	r0, [r2, #4]
 80014a4:	f102 0120 	add.w	r1, r2, #32
 80014a8:	f102 0434 	add.w	r4, r2, #52	; 0x34
 80014ac:	66ee      	str	r6, [r5, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 80014ae:	672b      	str	r3, [r5, #112]	; 0x70
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 80014b0:	f841 0f04 	str.w	r0, [r1, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80014b4:	42a1      	cmp	r1, r4
    usbp->in_params[i]  = NULL;
 80014b6:	f04f 0300 	mov.w	r3, #0
    usbp->out_params[i] = NULL;
 80014ba:	6148      	str	r0, [r1, #20]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80014bc:	d1f8      	bne.n	80014b0 <main+0x1a0>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80014be:	4953      	ldr	r1, [pc, #332]	; (800160c <main+0x2fc>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80014c0:	4f5d      	ldr	r7, [pc, #372]	; (8001638 <main+0x328>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80014c2:	6c0e      	ldr	r6, [r1, #64]	; 0x40
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 80014c4:	8113      	strh	r3, [r2, #8]
 80014c6:	f046 0601 	orr.w	r6, r6, #1
 80014ca:	640e      	str	r6, [r1, #64]	; 0x40
 80014cc:	6e0e      	ldr	r6, [r1, #96]	; 0x60
  usbp->receiving    = 0;
 80014ce:	8153      	strh	r3, [r2, #10]
 80014d0:	f046 0601 	orr.w	r6, r6, #1
 80014d4:	660e      	str	r6, [r1, #96]	; 0x60
 80014d6:	6e09      	ldr	r1, [r1, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80014d8:	68be      	ldr	r6, [r7, #8]
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
 80014da:	4c58      	ldr	r4, [pc, #352]	; (800163c <main+0x32c>)

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80014dc:	484f      	ldr	r0, [pc, #316]	; (800161c <main+0x30c>)
  pqp->prev = pqp;
 80014de:	6064      	str	r4, [r4, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80014e0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80014e4:	f046 0e01 	orr.w	lr, r6, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80014e8:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80014ec:	f242 06cf 	movw	r6, #8399	; 0x20cf
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 80014f0:	f64f 7bf0 	movw	fp, #65520	; 0xfff0

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80014f4:	f8c7 e008 	str.w	lr, [r7, #8]

#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
  USBD2.otg       = OTG_HS;
 80014f8:	f8df a158 	ldr.w	sl, [pc, #344]	; 8001654 <main+0x344>

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80014fc:	628e      	str	r6, [r1, #40]	; 0x28
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80014fe:	f04f 0e01 	mov.w	lr, #1
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001502:	f8c1 c02c 	str.w	ip, [r1, #44]	; 0x2c
 8001506:	2780      	movs	r7, #128	; 0x80
 */
void _vt_init(void) {

  ch.vtlist.dlist.next = &ch.vtlist.dlist;
  ch.vtlist.dlist.prev = &ch.vtlist.dlist;
  ch.vtlist.dlist.delta = (sysinterval_t)-1;
 8001508:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800150c:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
  STM32_ST_TIM->CCMR1  = 0;
 8001510:	618b      	str	r3, [r1, #24]
  USBD2.otgparams = &hsparams;
 8001512:	f8df 9144 	ldr.w	r9, [pc, #324]	; 8001658 <main+0x348>
  pqp->prio = (tprio_t)0;
 8001516:	60a3      	str	r3, [r4, #8]
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8001518:	f104 0c40 	add.w	ip, r4, #64	; 0x40
  STM32_ST_TIM->CCR[0] = 0;
 800151c:	634b      	str	r3, [r1, #52]	; 0x34
 */
void _scheduler_init(void) {

  ch_pqueue_init(&ch.rlist.pqueue);
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 800151e:	6124      	str	r4, [r4, #16]
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8001520:	60cb      	str	r3, [r1, #12]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8001522:	6164      	str	r4, [r4, #20]
  STM32_ST_TIM->CR2    = 0;
 8001524:	604b      	str	r3, [r1, #4]
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8001526:	f8a4 b038 	strh.w	fp, [r4, #56]	; 0x38
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.dlist.next = &ch.vtlist.dlist;
 800152a:	f104 0b1c 	add.w	fp, r4, #28
  ch.vtlist.dlist.prev = &ch.vtlist.dlist;
  ch.vtlist.dlist.delta = (sysinterval_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 800152e:	62a3      	str	r3, [r4, #40]	; 0x28
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001530:	f8c1 e014 	str.w	lr, [r1, #20]
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8001534:	8767      	strh	r7, [r4, #58]	; 0x3a
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001536:	f8c1 e000 	str.w	lr, [r1]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.dlist.next = &ch.vtlist.dlist;
 800153a:	f8c4 b01c 	str.w	fp, [r4, #28]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800153e:	f880 731c 	strb.w	r7, [r0, #796]	; 0x31c
  ch.vtlist.dlist.prev = &ch.vtlist.dlist;
 8001542:	f8c4 b020 	str.w	fp, [r4, #32]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001546:	f8c0 6180 	str.w	r6, [r0, #384]	; 0x180

#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
  USBD2.otg       = OTG_HS;
 800154a:	f8c2 a06c 	str.w	sl, [r2, #108]	; 0x6c
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800154e:	6006      	str	r6, [r0, #0]
  USBD2.otgparams = &hsparams;
 8001550:	f8c2 9070 	str.w	r9, [r2, #112]	; 0x70
 *
 * @notapi
 */
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {

  pqp->next = pqp;
 8001554:	6024      	str	r4, [r4, #0]
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8001556:	f8c4 c03c 	str.w	ip, [r4, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800155a:	3301      	adds	r3, #1
 800155c:	eb04 1203 	add.w	r2, r4, r3, lsl #4
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001560:	2b80      	cmp	r3, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8001562:	f892 1030 	ldrb.w	r1, [r2, #48]	; 0x30
 8001566:	4835      	ldr	r0, [pc, #212]	; (800163c <main+0x32c>)
 8001568:	f36f 0102 	bfc	r1, #0, #3
 800156c:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001570:	d1f3      	bne.n	800155a <main+0x24a>
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 8001572:	4b33      	ldr	r3, [pc, #204]	; (8001640 <main+0x330>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8001574:	4933      	ldr	r1, [pc, #204]	; (8001644 <main+0x334>)
 8001576:	4a34      	ldr	r2, [pc, #208]	; (8001648 <main+0x338>)
 8001578:	600a      	str	r2, [r1, #0]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800157a:	2600      	movs	r6, #0
 800157c:	2700      	movs	r7, #0
 800157e:	f101 0b0c 	add.w	fp, r1, #12
 8001582:	e9cd 6704 	strd	r6, r7, [sp, #16]
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8001586:	f103 0210 	add.w	r2, r3, #16
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 800158a:	2614      	movs	r6, #20
 800158c:	f103 0724 	add.w	r7, r3, #36	; 0x24
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8001590:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 800165c <main+0x34c>
 8001594:	f8c1 b00c 	str.w	fp, [r1, #12]
  qp->prev = qp;
 8001598:	f8c1 b010 	str.w	fp, [r1, #16]
 800159c:	611a      	str	r2, [r3, #16]
 800159e:	f103 0b28 	add.w	fp, r3, #40	; 0x28
 80015a2:	221c      	movs	r2, #28
 80015a4:	619e      	str	r6, [r3, #24]
 80015a6:	625f      	str	r7, [r3, #36]	; 0x24
 80015a8:	f103 063c 	add.w	r6, r3, #60	; 0x3c
 80015ac:	f103 0740 	add.w	r7, r3, #64	; 0x40
  mp->align = align;
  mp->provider = provider;
 80015b0:	f8df c0ac 	ldr.w	ip, [pc, #172]	; 8001660 <main+0x350>
 80015b4:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8001664 <main+0x354>
  ch_memcore.topmem  = __heap_end__;
 80015b8:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 8001668 <main+0x358>
 80015bc:	f8c3 b028 	str.w	fp, [r3, #40]	; 0x28
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 80015c0:	631a      	str	r2, [r3, #48]	; 0x30
 80015c2:	f103 0b44 	add.w	fp, r3, #68	; 0x44
  H_NEXT(&default_heap.header) = NULL;
 80015c6:	2200      	movs	r2, #0
 80015c8:	63de      	str	r6, [r3, #60]	; 0x3c
 80015ca:	641f      	str	r7, [r3, #64]	; 0x40
  mp->align = align;
 80015cc:	2604      	movs	r6, #4
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80015ce:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 80015d2:	601b      	str	r3, [r3, #0]
  qp->prev = qp;
 80015d4:	605b      	str	r3, [r3, #4]
 80015d6:	f8c3 b044 	str.w	fp, [r3, #68]	; 0x44
 80015da:	604a      	str	r2, [r1, #4]
  H_PAGES(&default_heap.header) = 0;
 80015dc:	608a      	str	r2, [r1, #8]
 80015de:	614a      	str	r2, [r1, #20]
 80015e0:	609a      	str	r2, [r3, #8]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 80015e2:	615a      	str	r2, [r3, #20]
 80015e4:	62da      	str	r2, [r3, #44]	; 0x2c
  _vt_init();
  _trace_init();
  _oslib_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 80015e6:	6302      	str	r2, [r0, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 80015e8:	6342      	str	r2, [r0, #52]	; 0x34
  unsigned i;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80015ea:	f8c0 2884 	str.w	r2, [r0, #2180]	; 0x884
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 80015ee:	9201      	str	r2, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 80015f0:	9202      	str	r2, [sp, #8]
  tmp->n          = (ucnt_t)0;
 80015f2:	9203      	str	r2, [sp, #12]
  mp->object_size = size;
  mp->align = align;
 80015f4:	61de      	str	r6, [r3, #28]
 80015f6:	635e      	str	r6, [r3, #52]	; 0x34
  mp->provider = provider;
 80015f8:	f8c3 c020 	str.w	ip, [r3, #32]
 80015fc:	f8c3 c038 	str.w	ip, [r3, #56]	; 0x38
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8001600:	f8ce a000 	str.w	sl, [lr]
  ch_memcore.topmem  = __heap_end__;
 8001604:	f8ce 9004 	str.w	r9, [lr, #4]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001608:	9700      	str	r7, [sp, #0]
 800160a:	e02f      	b.n	800166c <main+0x35c>
 800160c:	40023800 	.word	0x40023800
 8001610:	40007000 	.word	0x40007000
 8001614:	2000a4d8 	.word	0x2000a4d8
 8001618:	0800c860 	.word	0x0800c860
 800161c:	e000e100 	.word	0xe000e100
 8001620:	40026000 	.word	0x40026000
 8001624:	2000a098 	.word	0x2000a098
 8001628:	2000a3cc 	.word	0x2000a3cc
 800162c:	0800c920 	.word	0x0800c920
 8001630:	2000a444 	.word	0x2000a444
 8001634:	0800c814 	.word	0x0800c814
 8001638:	e0042000 	.word	0xe0042000
 800163c:	2000b68c 	.word	0x2000b68c
 8001640:	2000a320 	.word	0x2000a320
 8001644:	2000a560 	.word	0x2000a560
 8001648:	080028e1 	.word	0x080028e1
 800164c:	40026400 	.word	0x40026400
 8001650:	2000a984 	.word	0x2000a984
 8001654:	40040000 	.word	0x40040000
 8001658:	0800cc70 	.word	0x0800cc70
 800165c:	2000bf14 	.word	0x2000bf14
 8001660:	080023c1 	.word	0x080023c1
 8001664:	2000bf50 	.word	0x2000bf50
 8001668:	20020000 	.word	0x20020000
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 800166c:	4668      	mov	r0, sp
 800166e:	f000 fdaf 	bl	80021d0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8001672:	4668      	mov	r0, sp
 8001674:	f000 fd84 	bl	8002180 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 8001678:	3e01      	subs	r6, #1
 800167a:	d1f7      	bne.n	800166c <main+0x35c>
  ch.tm.offset = tm.best;
 800167c:	4b9f      	ldr	r3, [pc, #636]	; (80018fc <main+0x5ec>)
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 800167e:	f8d4 c014 	ldr.w	ip, [r4, #20]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
 8001682:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 8001940 <main+0x630>
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8001686:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 8001944 <main+0x634>
 800168a:	9800      	ldr	r0, [sp, #0]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
  tp->state           = CH_STATE_WTSTART;
  tp->flags           = CH_FLAG_MODE_STATIC;
 800168c:	f884 6861 	strb.w	r6, [r4, #2145]	; 0x861
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 8001690:	f503 6204 	add.w	r2, r3, #2112	; 0x840
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
 8001694:	2780      	movs	r7, #128	; 0x80
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
 8001696:	f04f 0e01 	mov.w	lr, #1
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 800169a:	f603 016c 	addw	r1, r3, #2156	; 0x86c
 *
 * @notapi
 */
static inline void ch_list_init(ch_list_t *lp) {

  lp->next = lp;
 800169e:	f603 0a68 	addw	sl, r3, #2152	; 0x868
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
 80016a2:	f8c4 7848 	str.w	r7, [r4, #2120]	; 0x848
  tp->flags           = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks           = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio        = prio;
 80016a6:	f8c4 787c 	str.w	r7, [r4, #2172]	; 0x87c
  tp->mtxlist         = NULL;
 80016aa:	f8c4 6878 	str.w	r6, [r4, #2168]	; 0x878
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending        = (eventmask_t)0;
 80016ae:	f8c4 6874 	str.w	r6, [r4, #2164]	; 0x874
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 80016b2:	f8c4 4850 	str.w	r4, [r4, #2128]	; 0x850
 80016b6:	f8c4 c854 	str.w	ip, [r4, #2132]	; 0x854
 80016ba:	f8c4 0884 	str.w	r0, [r4, #2180]	; 0x884
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
 80016be:	f884 e862 	strb.w	lr, [r4, #2146]	; 0x862
  tp->name            = name;
 80016c2:	f8c4 b858 	str.w	fp, [r4, #2136]	; 0x858
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80016c6:	2720      	movs	r7, #32
  REG_INSERT(tp);
 80016c8:	f8cc 2010 	str.w	r2, [ip, #16]
 80016cc:	6162      	str	r2, [r4, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80016ce:	61a2      	str	r2, [r4, #24]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80016d0:	f884 e860 	strb.w	lr, [r4, #2144]	; 0x860
 80016d4:	f8c4 a868 	str.w	sl, [r4, #2152]	; 0x868
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 80016d8:	f8c4 186c 	str.w	r1, [r4, #2156]	; 0x86c
  qp->prev = qp;
 80016dc:	f8c4 1870 	str.w	r1, [r4, #2160]	; 0x870
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 80016e0:	f8c4 985c 	str.w	r9, [r4, #2140]	; 0x85c
 80016e4:	f387 8811 	msr	BASEPRI, r7
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80016e8:	b662      	cpsie	i
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80016ea:	4a85      	ldr	r2, [pc, #532]	; (8001900 <main+0x5f0>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80016ec:	4985      	ldr	r1, [pc, #532]	; (8001904 <main+0x5f4>)
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80016ee:	f8d2 a00c 	ldr.w	sl, [r2, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80016f2:	f8df 9254 	ldr.w	r9, [pc, #596]	; 8001948 <main+0x638>
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80016f6:	4884      	ldr	r0, [pc, #528]	; (8001908 <main+0x5f8>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80016f8:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
 80016fc:	ea0a 0c0c 	and.w	ip, sl, ip
  reg_value  =  (reg_value                                   |
 8001700:	ea4c 0101 	orr.w	r1, ip, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8001704:	60d1      	str	r1, [r2, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001706:	f8d9 100c 	ldr.w	r1, [r9, #12]
 800170a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 800170e:	f8c9 100c 	str.w	r1, [r9, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001712:	6801      	ldr	r1, [r0, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001714:	f04f 0c10 	mov.w	ip, #16
 8001718:	ea41 010e 	orr.w	r1, r1, lr
 800171c:	6001      	str	r1, [r0, #0]
 800171e:	f882 c01f 	strb.w	ip, [r2, #31]
 8001722:	f882 7022 	strb.w	r7, [r2, #34]	; 0x22
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001726:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001728:	b90a      	cbnz	r2, 800172e <main+0x41e>
 800172a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800172c:	b113      	cbz	r3, 8001734 <main+0x424>
    chSysHalt("SV#3");
 800172e:	4877      	ldr	r0, [pc, #476]	; (800190c <main+0x5fc>)
 8001730:	f003 fb26 	bl	8004d80 <chSysHalt>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8001734:	f386 8811 	msr	BASEPRI, r6
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001738:	b662      	cpsie	i
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 800173a:	4875      	ldr	r0, [pc, #468]	; (8001910 <main+0x600>)
 800173c:	f001 f8f8 	bl	8002930 <chRegFindThreadByWorkingArea>
 8001740:	b110      	cbz	r0, 8001748 <main+0x438>
 8001742:	4874      	ldr	r0, [pc, #464]	; (8001914 <main+0x604>)
 8001744:	f003 fb1c 	bl	8004d80 <chSysHalt>
 8001748:	4a71      	ldr	r2, [pc, #452]	; (8001910 <main+0x600>)
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 800174a:	2355      	movs	r3, #85	; 0x55
 800174c:	5593      	strb	r3, [r2, r6]
 800174e:	3601      	adds	r6, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8001750:	f5b6 7fb0 	cmp.w	r6, #352	; 0x160
    *startp++ = v;
 8001754:	f8df 91b8 	ldr.w	r9, [pc, #440]	; 8001910 <main+0x600>
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8001758:	d1f8      	bne.n	800174c <main+0x43c>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800175a:	2320      	movs	r3, #32
 800175c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001760:	f003 fb86 	bl	8004e70 <_dbg_check_lock>
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
 8001764:	f000 fdf4 	bl	8002350 <chDbgCheckClassI>
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001768:	2300      	movs	r3, #0
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 800176a:	6966      	ldr	r6, [r4, #20]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800176c:	f8df c1dc 	ldr.w	ip, [pc, #476]	; 800194c <main+0x63c>
 8001770:	f8c9 30f8 	str.w	r3, [r9, #248]	; 0xf8
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
 8001774:	2101      	movs	r1, #1
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 8001776:	f509 728c 	add.w	r2, r9, #280	; 0x118
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
  tp->state           = CH_STATE_WTSTART;
 800177a:	f04f 0e02 	mov.w	lr, #2
  tp->flags           = CH_FLAG_MODE_STATIC;
 800177e:	f889 3139 	strb.w	r3, [r9, #313]	; 0x139
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks           = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio        = prio;
  tp->mtxlist         = NULL;
 8001782:	f8c9 3150 	str.w	r3, [r9, #336]	; 0x150
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending        = (eventmask_t)0;
 8001786:	f8c9 314c 	str.w	r3, [r9, #332]	; 0x14c
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
 800178a:	f8c9 1120 	str.w	r1, [r9, #288]	; 0x120
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 800178e:	f509 73a2 	add.w	r3, r9, #324	; 0x144
  tp->flags           = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks           = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio        = prio;
 8001792:	f8c9 1154 	str.w	r1, [r9, #340]	; 0x154
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
 8001796:	f889 113a 	strb.w	r1, [r9, #314]	; 0x13a
  tp->name            = name;
 800179a:	485f      	ldr	r0, [pc, #380]	; (8001918 <main+0x608>)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800179c:	4f5f      	ldr	r7, [pc, #380]	; (800191c <main+0x60c>)
 800179e:	f8c9 c0f4 	str.w	ip, [r9, #244]	; 0xf4
 *
 * @notapi
 */
static inline void ch_list_init(ch_list_t *lp) {

  lp->next = lp;
 80017a2:	f509 71a0 	add.w	r1, r9, #320	; 0x140
 80017a6:	f109 0ab4 	add.w	sl, r9, #180	; 0xb4
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
  tp->state           = CH_STATE_WTSTART;
 80017aa:	f889 e138 	strb.w	lr, [r9, #312]	; 0x138
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
 80017ae:	f8c9 0130 	str.w	r0, [r9, #304]	; 0x130
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80017b2:	f8c9 9134 	str.w	r9, [r9, #308]	; 0x134
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 80017b6:	4610      	mov	r0, r2
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 80017b8:	f8c9 4128 	str.w	r4, [r9, #296]	; 0x128
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80017bc:	f8c9 a124 	str.w	sl, [r9, #292]	; 0x124
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 80017c0:	f8c9 612c 	str.w	r6, [r9, #300]	; 0x12c
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80017c4:	f8c9 7114 	str.w	r7, [r9, #276]	; 0x114
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 80017c8:	6132      	str	r2, [r6, #16]
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 80017ca:	f8c9 3144 	str.w	r3, [r9, #324]	; 0x144
  qp->prev = qp;
 80017ce:	f8c9 3148 	str.w	r3, [r9, #328]	; 0x148
 *
 * @notapi
 */
static inline void ch_list_init(ch_list_t *lp) {

  lp->next = lp;
 80017d2:	f8c9 1140 	str.w	r1, [r9, #320]	; 0x140
 80017d6:	6162      	str	r2, [r4, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 80017d8:	f006 fd5a 	bl	8008290 <chSchWakeupS.constprop.34>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80017dc:	f003 fb38 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80017e0:	6823      	ldr	r3, [r4, #0]
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 80017e2:	4a46      	ldr	r2, [pc, #280]	; (80018fc <main+0x5ec>)
 80017e4:	42a3      	cmp	r3, r4
 80017e6:	d004      	beq.n	80017f2 <main+0x4e2>
 80017e8:	6992      	ldr	r2, [r2, #24]
 80017ea:	689b      	ldr	r3, [r3, #8]
 80017ec:	6892      	ldr	r2, [r2, #8]
 80017ee:	429a      	cmp	r2, r3
 80017f0:	d351      	bcc.n	8001896 <main+0x586>
 80017f2:	2200      	movs	r2, #0
 80017f4:	f382 8811 	msr	BASEPRI, r2
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
 80017f8:	4e49      	ldr	r6, [pc, #292]	; (8001920 <main+0x610>)
 80017fa:	4b4a      	ldr	r3, [pc, #296]	; (8001924 <main+0x614>)
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
  ibqp->top       = NULL;
  ibqp->notify    = infy;
 80017fc:	f8df e150 	ldr.w	lr, [pc, #336]	; 8001950 <main+0x640>

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
 8001800:	61b2      	str	r2, [r6, #24]
 8001802:	4630      	mov	r0, r6
  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8001804:	f206 498c 	addw	r9, r6, #1164	; 0x48c
 8001808:	f840 3b04 	str.w	r3, [r0], #4
  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
 800180c:	f106 017c 	add.w	r1, r6, #124	; 0x7c
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8001810:	f506 7321 	add.w	r3, r6, #644	; 0x284
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 8001814:	f106 0a0c 	add.w	sl, r6, #12
 8001818:	f106 0c44 	add.w	ip, r6, #68	; 0x44
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
  obqp->top       = NULL;
  obqp->notify    = onfy;
 800181c:	f8df b134 	ldr.w	fp, [pc, #308]	; 8001954 <main+0x644>
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
 8001820:	6372      	str	r2, [r6, #52]	; 0x34
  ibqp->top       = NULL;
 8001822:	63b2      	str	r2, [r6, #56]	; 0x38
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
 8001824:	66f2      	str	r2, [r6, #108]	; 0x6c
  obqp->top       = NULL;
 8001826:	6732      	str	r2, [r6, #112]	; 0x70
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
  ibqp->top       = NULL;
  ibqp->notify    = infy;
 8001828:	f8c6 e03c 	str.w	lr, [r6, #60]	; 0x3c
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 800182c:	2201      	movs	r2, #1
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
 800182e:	f44f 7e82 	mov.w	lr, #260	; 0x104
  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8001832:	f8c6 905c 	str.w	r9, [r6, #92]	; 0x5c
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
 8001836:	f04f 0902 	mov.w	r9, #2
  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800183a:	6273      	str	r3, [r6, #36]	; 0x24
  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
 800183c:	65b3      	str	r3, [r6, #88]	; 0x58
  obqp->bwrptr    = bp;
 800183e:	6573      	str	r3, [r6, #84]	; 0x54
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
 8001840:	66b3      	str	r3, [r6, #104]	; 0x68
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
  ibqp->top       = NULL;
  ibqp->notify    = infy;
  ibqp->link      = link;
 8001842:	6436      	str	r6, [r6, #64]	; 0x40
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
  obqp->top       = NULL;
  obqp->notify    = onfy;
  obqp->link      = link;
 8001844:	67b6      	str	r6, [r6, #120]	; 0x78
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
  obqp->top       = NULL;
  obqp->notify    = onfy;
 8001846:	f8c6 b074 	str.w	fp, [r6, #116]	; 0x74
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 800184a:	6070      	str	r0, [r6, #4]
 800184c:	f8c6 a00c 	str.w	sl, [r6, #12]
  qp->prev = qp;
 8001850:	f8c6 a010 	str.w	sl, [r6, #16]
  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
 8001854:	6231      	str	r1, [r6, #32]
  ibqp->bwrptr    = bp;
 8001856:	61f1      	str	r1, [r6, #28]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
 8001858:	6331      	str	r1, [r6, #48]	; 0x30
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 800185a:	f8c6 c044 	str.w	ip, [r6, #68]	; 0x44
  qp->prev = qp;
 800185e:	f8c6 c048 	str.w	ip, [r6, #72]	; 0x48
 8001862:	7232      	strb	r2, [r6, #8]
                   size_t size, size_t n, bqnotify_t infy, void *link) {

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
 8001864:	7532      	strb	r2, [r6, #20]
                   size_t size, size_t n, bqnotify_t onfy, void *link) {

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
 8001866:	f886 204c 	strb.w	r2, [r6, #76]	; 0x4c
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
 800186a:	f8c6 e028 	str.w	lr, [r6, #40]	; 0x28
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
 800186e:	f8c6 e060 	str.w	lr, [r6, #96]	; 0x60
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
 8001872:	f8c6 902c 	str.w	r9, [r6, #44]	; 0x2c

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
 8001876:	f8c6 9050 	str.w	r9, [r6, #80]	; 0x50
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
 800187a:	f8c6 9064 	str.w	r9, [r6, #100]	; 0x64
 800187e:	2320      	movs	r3, #32
 8001880:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001884:	f003 faf4 	bl	8004e70 <_dbg_check_lock>
  USBDriver *usbp = config->usbp;

  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 8001888:	7a33      	ldrb	r3, [r6, #8]
 800188a:	3b01      	subs	r3, #1
 800188c:	2b01      	cmp	r3, #1
 800188e:	d905      	bls.n	800189c <main+0x58c>
 8001890:	4825      	ldr	r0, [pc, #148]	; (8001928 <main+0x618>)
 8001892:	f003 fa75 	bl	8004d80 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8001896:	4825      	ldr	r0, [pc, #148]	; (800192c <main+0x61c>)
 8001898:	f003 fa72 	bl	8004d80 <chSysHalt>
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 800189c:	4b24      	ldr	r3, [pc, #144]	; (8001930 <main+0x620>)
 800189e:	f8c6 348c 	str.w	r3, [r6, #1164]	; 0x48c
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80018a2:	626e      	str	r6, [r5, #36]	; 0x24
  usbp->out_params[config->bulk_out - 1U] = sdup;
 80018a4:	63ae      	str	r6, [r5, #56]	; 0x38
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
 80018a6:	62ae      	str	r6, [r5, #40]	; 0x28
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 80018a8:	f886 9008 	strb.w	r9, [r6, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80018ac:	f003 fad0 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80018b0:	6823      	ldr	r3, [r4, #0]
 80018b2:	4a12      	ldr	r2, [pc, #72]	; (80018fc <main+0x5ec>)
 80018b4:	42a3      	cmp	r3, r4
 80018b6:	d004      	beq.n	80018c2 <main+0x5b2>
 80018b8:	6992      	ldr	r2, [r2, #24]
 80018ba:	689b      	ldr	r3, [r3, #8]
 80018bc:	6892      	ldr	r2, [r2, #8]
 80018be:	429a      	cmp	r2, r3
 80018c0:	d319      	bcc.n	80018f6 <main+0x5e6>
 80018c2:	f04f 0900 	mov.w	r9, #0
 80018c6:	f389 8811 	msr	BASEPRI, r9
  chSysInit();

  sduObjectInit(&SDU1);
  sduStart(&SDU1, &serusbcfg);

  usbDisconnectBus(serusbcfg.usbp);
 80018ca:	6eea      	ldr	r2, [r5, #108]	; 0x6c
 80018cc:	4e19      	ldr	r6, [pc, #100]	; (8001934 <main+0x624>)
 80018ce:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80018d0:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80018d4:	6393      	str	r3, [r2, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 80018d6:	f643 2098 	movw	r0, #15000	; 0x3a98
 80018da:	f001 fa31 	bl	8002d40 <chThdSleep>
 80018de:	2320      	movs	r3, #32
 80018e0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80018e4:	f003 fac4 	bl	8004e70 <_dbg_check_lock>
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 80018e8:	782b      	ldrb	r3, [r5, #0]
 80018ea:	1e5a      	subs	r2, r3, #1
 80018ec:	2a01      	cmp	r2, #1
 80018ee:	d933      	bls.n	8001958 <main+0x648>
 80018f0:	4811      	ldr	r0, [pc, #68]	; (8001938 <main+0x628>)
 80018f2:	f003 fa45 	bl	8004d80 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80018f6:	4811      	ldr	r0, [pc, #68]	; (800193c <main+0x62c>)
 80018f8:	f003 fa42 	bl	8004d80 <chSysHalt>
 80018fc:	2000b68c 	.word	0x2000b68c
 8001900:	e000ed00 	.word	0xe000ed00
 8001904:	05fa0300 	.word	0x05fa0300
 8001908:	e0001000 	.word	0xe0001000
 800190c:	0800cc7c 	.word	0x0800cc7c
 8001910:	2000a140 	.word	0x2000a140
 8001914:	0800c7a0 	.word	0x0800c7a0
 8001918:	0800cc84 	.word	0x0800cc84
 800191c:	08000321 	.word	0x08000321
 8001920:	2000b1fc 	.word	0x2000b1fc
 8001924:	0800c7b8 	.word	0x0800c7b8
 8001928:	0800c7ec 	.word	0x0800c7ec
 800192c:	0800c7ac 	.word	0x0800c7ac
 8001930:	0800c820 	.word	0x0800c820
 8001934:	2000a3cc 	.word	0x2000a3cc
 8001938:	0800c7e0 	.word	0x0800c7e0
 800193c:	0800c7f8 	.word	0x0800c7f8
 8001940:	0800c834 	.word	0x0800c834
 8001944:	20000400 	.word	0x20000400
 8001948:	e000edf0 	.word	0xe000edf0
 800194c:	08004d51 	.word	0x08004d51
 8001950:	080077e1 	.word	0x080077e1
 8001954:	080078e1 	.word	0x080078e1
                "invalid state");
  usbp->config = config;
 8001958:	4aba      	ldr	r2, [pc, #744]	; (8001c44 <main+0x934>)
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800195a:	f8c6 900c 	str.w	r9, [r6, #12]
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 800195e:	2b01      	cmp	r3, #1
 8001960:	f8c6 9010 	str.w	r9, [r6, #16]
 8001964:	f8c6 9014 	str.w	r9, [r6, #20]
 8001968:	f8c6 9018 	str.w	r9, [r6, #24]
 800196c:	f8c6 901c 	str.w	r9, [r6, #28]
 8001970:	f8c6 9020 	str.w	r9, [r6, #32]
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8001974:	6072      	str	r2, [r6, #4]
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8001976:	6ef6      	ldr	r6, [r6, #108]	; 0x6c

  if (usbp->state == USB_STOP) {
 8001978:	f000 81cf 	beq.w	8001d1a <main+0xa0a>
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
  usbp->state = USB_READY;
 800197c:	2302      	movs	r3, #2
 800197e:	702b      	strb	r3, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001980:	f003 fa66 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8001984:	6823      	ldr	r3, [r4, #0]
 8001986:	4ab0      	ldr	r2, [pc, #704]	; (8001c48 <main+0x938>)
 8001988:	42a3      	cmp	r3, r4
 800198a:	d005      	beq.n	8001998 <main+0x688>
 800198c:	6992      	ldr	r2, [r2, #24]
 800198e:	689b      	ldr	r3, [r3, #8]
 8001990:	6892      	ldr	r2, [r2, #8]
 8001992:	429a      	cmp	r2, r3
 8001994:	f0c0 8241 	bcc.w	8001e1a <main+0xb0a>
 8001998:	2300      	movs	r3, #0
 800199a:	f383 8811 	msr	BASEPRI, r3
  usbStart(serusbcfg.usbp, &usbcfg);
  usbConnectBus(serusbcfg.usbp);
 800199e:	6eea      	ldr	r2, [r5, #108]	; 0x6c

  int res = 0;
  bool r = false;

#if (VMC_NUM_CONTAINERS >= 1)
  msg_pools[0] = &msg_pool1;
 80019a0:	f8df a2f8 	ldr.w	sl, [pc, #760]	; 8001c9c <main+0x98c>
 80019a4:	6b93      	ldr	r3, [r2, #56]	; 0x38
 80019a6:	4da9      	ldr	r5, [pc, #676]	; (8001c4c <main+0x93c>)
 80019a8:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80019ac:	6393      	str	r3, [r2, #56]	; 0x38
  chThdSleepMilliseconds(500);
 80019ae:	f241 3088 	movw	r0, #5000	; 0x1388
 80019b2:	f001 f9c5 	bl	8002d40 <chThdSleep>

  chThdSleepMilliseconds(2000);
 80019b6:	f644 6020 	movw	r0, #20000	; 0x4e20
 80019ba:	f001 f9c1 	bl	8002d40 <chThdSleep>

  chprintf((BaseSequentialStream *)&SDU1,"Starting up!\r\n");
 80019be:	49a4      	ldr	r1, [pc, #656]	; (8001c50 <main+0x940>)
 80019c0:	48a4      	ldr	r0, [pc, #656]	; (8001c54 <main+0x944>)
 80019c2:	f006 fa8d 	bl	8007ee0 <chprintf.constprop.35>

  chThdSleepMilliseconds(500);
 80019c6:	f241 3088 	movw	r0, #5000	; 0x1388
 80019ca:	f001 f9b9 	bl	8002d40 <chThdSleep>
/* Debug print facility */

void (*dbg_print_fun)(const char *str, va_list args) = NULL;

void chibios_register_dbg_print(void (*f)(const char *str, va_list args)) {
  dbg_print_fun = f;
 80019ce:	4aa2      	ldr	r2, [pc, #648]	; (8001c58 <main+0x948>)

  int res = 0;
  bool r = false;

#if (VMC_NUM_CONTAINERS >= 1)
  msg_pools[0] = &msg_pool1;
 80019d0:	4ba2      	ldr	r3, [pc, #648]	; (8001c5c <main+0x94c>)
/* Debug print facility */

void (*dbg_print_fun)(const char *str, va_list args) = NULL;

void chibios_register_dbg_print(void (*f)(const char *str, va_list args)) {
  dbg_print_fun = f;
 80019d2:	49a3      	ldr	r1, [pc, #652]	; (8001c60 <main+0x950>)
 80019d4:	6011      	str	r1, [r2, #0]

  int res = 0;
  bool r = false;

#if (VMC_NUM_CONTAINERS >= 1)
  msg_pools[0] = &msg_pool1;
 80019d6:	f8c3 a000 	str.w	sl, [r3]
 80019da:	2640      	movs	r6, #64	; 0x40
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {

  chPoolFree(mp, objp);
 80019dc:	f8df 92bc 	ldr.w	r9, [pc, #700]	; 8001c9c <main+0x98c>
 80019e0:	4629      	mov	r1, r5
 80019e2:	4648      	mov	r0, r9
 80019e4:	f000 ff4c 	bl	8002880 <chPoolFree>
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80019e8:	f8da 3004 	ldr.w	r3, [sl, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 80019ec:	3e01      	subs	r6, #1
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80019ee:	441d      	add	r5, r3
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 80019f0:	d1f4      	bne.n	80019dc <main+0x6cc>
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
 80019f2:	489c      	ldr	r0, [pc, #624]	; (8001c64 <main+0x954>)
 80019f4:	4b9c      	ldr	r3, [pc, #624]	; (8001c68 <main+0x958>)
     chMBObjectInit(&mb[i], b[i], MAX_MESSAGES);

     chibios_interop[i].mb = &mb[i];
     chibios_interop[i].msg_pool = msg_pools[i];
     chibios_interop[i].send_message = send_message;
     vm_containers[i].backend_custom = (void*)&chibios_interop[i];
 80019f6:	4d9d      	ldr	r5, [pc, #628]	; (8001c6c <main+0x95c>)
  // it doesn't need to be as it is a uint8_t type.

  unsigned int value_flags_start = sizeof(heap_cell_t) * n_cells;
  unsigned int flags_start = value_flags_start + (sizeof(heap_flags_t) * n_cells);

  heap->cells = (heap_cell_t *)mem;
 80019f8:	4a9d      	ldr	r2, [pc, #628]	; (8001c70 <main+0x960>)
#endif

  for (int i = 0; i < VMC_NUM_CONTAINERS; i ++) {
     chMBObjectInit(&mb[i], b[i], MAX_MESSAGES);

     chibios_interop[i].mb = &mb[i];
 80019fa:	499e      	ldr	r1, [pc, #632]	; (8001c74 <main+0x964>)
     chibios_interop[i].msg_pool = msg_pools[i];
     chibios_interop[i].send_message = send_message;
 80019fc:	f8df c2a0 	ldr.w	ip, [pc, #672]	; 8001ca0 <main+0x990>
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
  mbp->cnt    = (size_t)0;
 8001a00:	611e      	str	r6, [r3, #16]
     vm_containers[i].backend_custom = (void*)&chibios_interop[i];
 8001a02:	f241 4e44 	movw	lr, #5188	; 0x1444
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8001a06:	f500 7b80 	add.w	fp, r0, #256	; 0x100
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
  heap->flags = (uint8_t *)(mem + flags_start);
  heap->bptr = (uintptr_t)mem;

  for (unsigned int i = 0; i < n_cells; i ++) {
 8001a0a:	46b2      	mov	sl, r6
 8001a0c:	f845 100e 	str.w	r1, [r5, lr]
  mbp->cnt    = (size_t)0;
  mbp->reset  = false;
 8001a10:	751e      	strb	r6, [r3, #20]
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 8001a12:	f103 0e18 	add.w	lr, r3, #24
 8001a16:	f103 0620 	add.w	r6, r3, #32
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
 8001a1a:	6018      	str	r0, [r3, #0]
  mbp->rdptr  = buf;
 8001a1c:	60d8      	str	r0, [r3, #12]
  mbp->wrptr  = buf;
 8001a1e:	6098      	str	r0, [r3, #8]
  mbp->top    = &buf[n];
 8001a20:	f8c3 b004 	str.w	fp, [r3, #4]

  unsigned int value_flags_start = sizeof(heap_cell_t) * n_cells;
  unsigned int flags_start = value_flags_start + (sizeof(heap_flags_t) * n_cells);

  heap->cells = (heap_cell_t *)mem;
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
 8001a24:	f502 609d 	add.w	r0, r2, #1256	; 0x4e8
  heap->flags = (uint8_t *)(mem + flags_start);
 8001a28:	f202 7b5c 	addw	fp, r2, #1884	; 0x75c
 8001a2c:	621e      	str	r6, [r3, #32]
  qp->prev = qp;
 8001a2e:	625e      	str	r6, [r3, #36]	; 0x24

  unsigned int value_flags_start = sizeof(heap_cell_t) * n_cells;
  unsigned int flags_start = value_flags_start + (sizeof(heap_flags_t) * n_cells);

  heap->cells = (heap_cell_t *)mem;
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
 8001a30:	6168      	str	r0, [r5, #20]
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 8001a32:	f8c3 e018 	str.w	lr, [r3, #24]
  qp->prev = qp;
 8001a36:	f8c3 e01c 	str.w	lr, [r3, #28]
#endif

  for (int i = 0; i < VMC_NUM_CONTAINERS; i ++) {
     chMBObjectInit(&mb[i], b[i], MAX_MESSAGES);

     chibios_interop[i].mb = &mb[i];
 8001a3a:	604b      	str	r3, [r1, #4]
     chibios_interop[i].msg_pool = msg_pools[i];
 8001a3c:	f8c1 9000 	str.w	r9, [r1]
     chibios_interop[i].send_message = send_message;
 8001a40:	f8c1 c008 	str.w	ip, [r1, #8]
  // it doesn't need to be as it is a uint8_t type.

  unsigned int value_flags_start = sizeof(heap_cell_t) * n_cells;
  unsigned int flags_start = value_flags_start + (sizeof(heap_flags_t) * n_cells);

  heap->cells = (heap_cell_t *)mem;
 8001a44:	602a      	str	r2, [r5, #0]
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
  heap->flags = (uint8_t *)(mem + flags_start);
  heap->bptr = (uintptr_t)mem;
 8001a46:	606a      	str	r2, [r5, #4]
  unsigned int value_flags_start = sizeof(heap_cell_t) * n_cells;
  unsigned int flags_start = value_flags_start + (sizeof(heap_flags_t) * n_cells);

  heap->cells = (heap_cell_t *)mem;
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
  heap->flags = (uint8_t *)(mem + flags_start);
 8001a48:	f8c5 b018 	str.w	fp, [r5, #24]
  heap->bptr = (uintptr_t)mem;

  for (unsigned int i = 0; i < n_cells; i ++) {
    heap->cells[i].snd = i + 1;
    heap->flags[i] = 0;
 8001a4c:	4656      	mov	r6, sl
    heap->value_flags[i].snd = VALUE_PTR_BIT;
 8001a4e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
  heap->flags = (uint8_t *)(mem + flags_start);
  heap->bptr = (uintptr_t)mem;

  for (unsigned int i = 0; i < n_cells; i ++) {
    heap->cells[i].snd = i + 1;
 8001a52:	682a      	ldr	r2, [r5, #0]
    heap->flags[i] = 0;
 8001a54:	f8d5 e018 	ldr.w	lr, [r5, #24]
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
  heap->flags = (uint8_t *)(mem + flags_start);
  heap->bptr = (uintptr_t)mem;

  for (unsigned int i = 0; i < n_cells; i ++) {
    heap->cells[i].snd = i + 1;
 8001a58:	4b84      	ldr	r3, [pc, #528]	; (8001c6c <main+0x95c>)
 8001a5a:	eb02 02ca 	add.w	r2, r2, sl, lsl #3
 8001a5e:	f10a 0101 	add.w	r1, sl, #1
 8001a62:	6051      	str	r1, [r2, #4]
    heap->flags[i] = 0;
 8001a64:	f80e 600a 	strb.w	r6, [lr, sl]
    heap->value_flags[i].snd = VALUE_PTR_BIT;
 8001a68:	696a      	ldr	r2, [r5, #20]
 8001a6a:	eb02 028a 	add.w	r2, r2, sl, lsl #2
 8001a6e:	468a      	mov	sl, r1
  heap->cells = (heap_cell_t *)mem;
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
  heap->flags = (uint8_t *)(mem + flags_start);
  heap->bptr = (uintptr_t)mem;

  for (unsigned int i = 0; i < n_cells; i ++) {
 8001a70:	f1ba 0f9d 	cmp.w	sl, #157	; 0x9d
    heap->cells[i].snd = i + 1;
    heap->flags[i] = 0;
    heap->value_flags[i].snd = VALUE_PTR_BIT;
 8001a74:	8050      	strh	r0, [r2, #2]
  heap->flags = (uint8_t *)(mem + flags_start);
  heap->bptr = (uintptr_t)mem;

  for (unsigned int i = 0; i < n_cells; i ++) {
    heap->cells[i].snd = i + 1;
    heap->flags[i] = 0;
 8001a76:	f04f 0100 	mov.w	r1, #0
  heap->cells = (heap_cell_t *)mem;
  heap->value_flags = (heap_flags_t*)(mem + value_flags_start);
  heap->flags = (uint8_t *)(mem + flags_start);
  heap->bptr = (uintptr_t)mem;

  for (unsigned int i = 0; i < n_cells; i ++) {
 8001a7a:	d1ea      	bne.n	8001a52 <main+0x742>
    heap->cells[i].snd = i + 1;
    heap->flags[i] = 0;
    heap->value_flags[i].snd = VALUE_PTR_BIT;
  }

  heap->cells[n_cells-1].snd = HEAP_NULL;
 8001a7c:	6818      	ldr	r0, [r3, #0]
 8001a7e:	4e7e      	ldr	r6, [pc, #504]	; (8001c78 <main+0x968>)
  #if VMC_NUM_CONTAINERS >= 1
  rl = heap_init(&vm_containers[VMC_CONTAINER_1].heap, vmc_container_1_heap, VMC_CONTAINER_1_HEAP_SIZE_BYTES);

  if (!rl) return -2;

  vm_containers[VMC_CONTAINER_1].stack_memory   = vmc_container_1_stack;
 8001a80:	f8df 9220 	ldr.w	r9, [pc, #544]	; 8001ca4 <main+0x994>
  vm_containers[VMC_CONTAINER_1].code_memory    = vmc_container_1_code;
 8001a84:	f8df c220 	ldr.w	ip, [pc, #544]	; 8001ca8 <main+0x998>
  vm_containers[VMC_CONTAINER_1].arrays_memory  = vmc_container_1_arrays;
 8001a88:	f8df e220 	ldr.w	lr, [pc, #544]	; 8001cac <main+0x99c>
  heap->sweep_pos  = 0;
  heap->size_bytes = size_bytes;
  heap->size_cells = n_cells;
 8001a8c:	f8c3 a00c 	str.w	sl, [r3, #12]
    heap->cells[i].snd = i + 1;
    heap->flags[i] = 0;
    heap->value_flags[i].snd = VALUE_PTR_BIT;
  }

  heap->cells[n_cells-1].snd = HEAP_NULL;
 8001a90:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
  heap->sweep_pos  = 0;
  heap->size_bytes = size_bytes;
 8001a94:	f44f 6a00 	mov.w	sl, #2048	; 0x800
    heap->cells[i].snd = i + 1;
    heap->flags[i] = 0;
    heap->value_flags[i].snd = VALUE_PTR_BIT;
  }

  heap->cells[n_cells-1].snd = HEAP_NULL;
 8001a98:	f8c0 b4e4 	str.w	fp, [r0, #1252]	; 0x4e4
  vm_containers[VMC_CONTAINER_1].current_running_context_id = 0;

  vm_containers[VMC_CONTAINER_1].code_size = sizeof(vmc_container_1_code);
 8001a9c:	f240 3b33 	movw	fp, #819	; 0x333
  heap->sweep_pos  = 0;
  heap->size_bytes = size_bytes;
 8001aa0:	f8c3 a008 	str.w	sl, [r3, #8]
  #if VMC_NUM_CONTAINERS >= 1
  rl = heap_init(&vm_containers[VMC_CONTAINER_1].heap, vmc_container_1_heap, VMC_CONTAINER_1_HEAP_SIZE_BYTES);

  if (!rl) return -2;

  vm_containers[VMC_CONTAINER_1].stack_memory   = vmc_container_1_stack;
 8001aa4:	f8c3 901c 	str.w	r9, [r3, #28]
  vm_containers[VMC_CONTAINER_1].code_memory    = vmc_container_1_code;
 8001aa8:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
    heap->flags[i] = 0;
    heap->value_flags[i].snd = VALUE_PTR_BIT;
  }

  heap->cells[n_cells-1].snd = HEAP_NULL;
  heap->sweep_pos  = 0;
 8001aac:	6119      	str	r1, [r3, #16]
  return 1; /* Maybe have some error codes in relation to this fun */
}

static bool init_all_chans(Channel_t *c, uint8_t *mem){

  int mem_offset = 0;
 8001aae:	460a      	mov	r2, r1
  if (!rl) return -2;

  vm_containers[VMC_CONTAINER_1].stack_memory   = vmc_container_1_stack;
  vm_containers[VMC_CONTAINER_1].code_memory    = vmc_container_1_code;
  vm_containers[VMC_CONTAINER_1].arrays_memory  = vmc_container_1_arrays;
  vm_containers[VMC_CONTAINER_1].current_running_context_id = 0;
 8001ab0:	f883 102c 	strb.w	r1, [r3, #44]	; 0x2c
 8001ab4:	4630      	mov	r0, r6

  if (!rl) return -2;

  vm_containers[VMC_CONTAINER_1].stack_memory   = vmc_container_1_stack;
  vm_containers[VMC_CONTAINER_1].code_memory    = vmc_container_1_code;
  vm_containers[VMC_CONTAINER_1].arrays_memory  = vmc_container_1_arrays;
 8001ab6:	f8c3 e020 	str.w	lr, [r3, #32]
  vm_containers[VMC_CONTAINER_1].current_running_context_id = 0;

  vm_containers[VMC_CONTAINER_1].code_size = sizeof(vmc_container_1_code);
 8001aba:	f8c3 b028 	str.w	fp, [r3, #40]	; 0x28

#include<channel.h>


int channel_init(Channel_t *c, chan_send_queue_t sq, chan_recv_queue_t rq){
  c->sendq = sq;
 8001abe:	f04f 0903 	mov.w	r9, #3
 8001ac2:	f04f 0c02 	mov.w	ip, #2
  c->recvq = rq;
  c->in_use = false;
  c->sync_driver_no = DRIVER_NULL;
 8001ac6:	f04f 0aff 	mov.w	sl, #255	; 0xff

#include<chan_send_queue.h>

int chan_send_q_init(chan_send_queue_t *q, uint8_t *mem, unsigned int size_bytes){

  if (!mem || !q || size_bytes < sizeof(send_data_t)) return 0;
 8001aca:	eb16 0b02 	adds.w	fp, r6, r2
 8001ace:	f000 81ad 	beq.w	8001e2c <main+0xb1c>
 8001ad2:	f102 0e3c 	add.w	lr, r2, #60	; 0x3c
#include <SVM_DEBUG.h>
#include<chan_recv_queue.h>

int chan_recv_q_init(chan_recv_queue_t *q, uint8_t *mem, unsigned int size_bytes){

  if (!mem || !q || size_bytes < sizeof(recv_data_t)) return 0;
 8001ad6:	eb10 0e0e 	adds.w	lr, r0, lr
 8001ada:	f000 81a7 	beq.w	8001e2c <main+0xb1c>
 8001ade:	3260      	adds	r2, #96	; 0x60
  int mem_offset = 0;

  size_t sd_size = sizeof(send_data_t);
  size_t rd_size = sizeof(recv_data_t);

  for(int i = 0; i < MAX_CHANNELS; i++){
 8001ae0:	f5b2 5f16 	cmp.w	r2, #9600	; 0x2580

#include<channel.h>


int channel_init(Channel_t *c, chan_send_queue_t sq, chan_recv_queue_t rq){
  c->sendq = sq;
 8001ae4:	f8c3 b0f4 	str.w	fp, [r3, #244]	; 0xf4
 8001ae8:	f8c3 90f8 	str.w	r9, [r3, #248]	; 0xf8
 8001aec:	f8c3 10fc 	str.w	r1, [r3, #252]	; 0xfc
 8001af0:	f8c3 c100 	str.w	ip, [r3, #256]	; 0x100
 8001af4:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
  c->recvq = rq;
 8001af8:	f8c3 e108 	str.w	lr, [r3, #264]	; 0x108
 8001afc:	f8c3 910c 	str.w	r9, [r3, #268]	; 0x10c
 8001b00:	f8c3 1110 	str.w	r1, [r3, #272]	; 0x110
 8001b04:	f8c3 c114 	str.w	ip, [r3, #276]	; 0x114
 8001b08:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
  c->in_use = false;
 8001b0c:	f883 111c 	strb.w	r1, [r3, #284]	; 0x11c
  c->sync_driver_no = DRIVER_NULL;
 8001b10:	f883 a11d 	strb.w	sl, [r3, #285]	; 0x11d
 8001b14:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8001b18:	d1d7      	bne.n	8001aca <main+0x7ba>
 8001b1a:	4a58      	ldr	r2, [pc, #352]	; (8001c7c <main+0x96c>)
 8001b1c:	69ee      	ldr	r6, [r5, #28]
 8001b1e:	f102 09c0 	add.w	r9, r2, #192	; 0xc0
  // Maybe make sure that the s->data becomes 4 bytes aligned?
  s->data = (UINT*)mem;

  s->flags = (value_flags_t*)(mem + sizeof(UINT) * num_elt);

  s->sp = 0;
 8001b22:	f04f 0c00 	mov.w	ip, #0
  s->size = num_elt;
 8001b26:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
    int offset = i * CONTEXT_STACK_SPACE;

    int st_status = stack_init(&ctx[i].stack
                               , &mem[offset]
                               , CONTEXT_STACK_SPACE);
    ctx[i].deadline = TIME_MAX;
 8001b2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001b2e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff

#include <stack.h>

int stack_init(cam_stack_t *s, uint8_t *mem, unsigned int size_bytes) {

  if (!mem || !s || size_bytes < 256) return 0;
 8001b32:	2e00      	cmp	r6, #0
 8001b34:	f000 8174 	beq.w	8001e20 <main+0xb10>
 8001b38:	f106 03a8 	add.w	r3, r6, #168	; 0xa8

  unsigned int num_elt = size_bytes / (sizeof(UINT) + sizeof(value_flags_t));

  // Maybe make sure that the s->data becomes 4 bytes aligned?
  s->data = (UINT*)mem;
 8001b3c:	6116      	str	r6, [r2, #16]

  s->flags = (value_flags_t*)(mem + sizeof(UINT) * num_elt);
 8001b3e:	60d3      	str	r3, [r2, #12]

  s->sp = 0;
 8001b40:	f8c2 c014 	str.w	ip, [r2, #20]
  s->size = num_elt;
 8001b44:	f8c2 e018 	str.w	lr, [r2, #24]
 8001b48:	e9c2 010a 	strd	r0, r1, [r2, #40]	; 0x28
 8001b4c:	3230      	adds	r2, #48	; 0x30

  if (VMC_MAX_CONTEXTS * CONTEXT_STACK_SPACE > memory_size) {
    return false; /* Not enough space for that many stacks */
  }

  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
 8001b4e:	454a      	cmp	r2, r9
 8001b50:	f506 7680 	add.w	r6, r6, #256	; 0x100
  // Maybe make sure that the s->data becomes 4 bytes aligned?
  s->data = (UINT*)mem;

  s->flags = (value_flags_t*)(mem + sizeof(UINT) * num_elt);

  s->sp = 0;
 8001b54:	f04f 0300 	mov.w	r3, #0
 8001b58:	d1eb      	bne.n	8001b32 <main+0x822>
  }



  /* Initialize system time */
  if (!sys_time_init((void *)vm_containers[VMC_CONTAINER_1].backend_custom)) {
 8001b5a:	f241 4244 	movw	r2, #5188	; 0x1444
            , unsigned int size_bytes
            , Comparator_t c){

  if (!mem || !pq || size_bytes < sizeof(pq_data_t)) return -1;
  unsigned int num_elt = size_bytes / sizeof(pq_data_t);
  pq->capacity = num_elt;
 8001b5e:	f241 2628 	movw	r6, #4648	; 0x1228
 8001b62:	58a9      	ldr	r1, [r5, r2]
  pq->size = 0;
  pq->data = (pq_data_t*)mem;
  pq->cmp  = c;
 8001b64:	4a46      	ldr	r2, [pc, #280]	; (8001c80 <main+0x970>)

  if (!mem || !pq || size_bytes < sizeof(pq_data_t)) return -1;
  unsigned int num_elt = size_bytes / sizeof(pq_data_t);
  pq->capacity = num_elt;
  pq->size = 0;
  pq->data = (pq_data_t*)mem;
 8001b66:	f8df a148 	ldr.w	sl, [pc, #328]	; 8001cb0 <main+0x9a0>
  pq->cmp  = c;
 8001b6a:	7013      	strb	r3, [r2, #0]
            , unsigned int size_bytes
            , Comparator_t c){

  if (!mem || !pq || size_bytes < sizeof(pq_data_t)) return -1;
  unsigned int num_elt = size_bytes / sizeof(pq_data_t);
  pq->capacity = num_elt;
 8001b6c:	f241 2e38 	movw	lr, #4664	; 0x1238
 8001b70:	2204      	movs	r2, #4
 8001b72:	51aa      	str	r2, [r5, r6]
 8001b74:	f845 200e 	str.w	r2, [r5, lr]
  pq->size = 0;
 8001b78:	f241 2b2c 	movw	fp, #4652	; 0x122c
  pq->data = (pq_data_t*)mem;
 8001b7c:	f241 2924 	movw	r9, #4644	; 0x1224
  pq->cmp  = c;
 8001b80:	f241 2c30 	movw	ip, #4656	; 0x1230
            , Comparator_t c){

  if (!mem || !pq || size_bytes < sizeof(pq_data_t)) return -1;
  unsigned int num_elt = size_bytes / sizeof(pq_data_t);
  pq->capacity = num_elt;
  pq->size = 0;
 8001b84:	f241 263c 	movw	r6, #4668	; 0x123c
  pq->data = (pq_data_t*)mem;
 8001b88:	f241 2234 	movw	r2, #4660	; 0x1234
 8001b8c:	483d      	ldr	r0, [pc, #244]	; (8001c84 <main+0x974>)
            , Comparator_t c){

  if (!mem || !pq || size_bytes < sizeof(pq_data_t)) return -1;
  unsigned int num_elt = size_bytes / sizeof(pq_data_t);
  pq->capacity = num_elt;
  pq->size = 0;
 8001b8e:	f845 300b 	str.w	r3, [r5, fp]
  pq->data = (pq_data_t*)mem;
  pq->cmp  = c;
 8001b92:	f04f 0e01 	mov.w	lr, #1

  if (!mem || !pq || size_bytes < sizeof(pq_data_t)) return -1;
  unsigned int num_elt = size_bytes / sizeof(pq_data_t);
  pq->capacity = num_elt;
  pq->size = 0;
  pq->data = (pq_data_t*)mem;
 8001b96:	f845 a009 	str.w	sl, [r5, r9]
  pq->cmp  = c;
 8001b9a:	f805 e00c 	strb.w	lr, [r5, ip]
            , Comparator_t c){

  if (!mem || !pq || size_bytes < sizeof(pq_data_t)) return -1;
  unsigned int num_elt = size_bytes / sizeof(pq_data_t);
  pq->capacity = num_elt;
  pq->size = 0;
 8001b9e:	51ab      	str	r3, [r5, r6]
  pq->data = (pq_data_t*)mem;
 8001ba0:	50a8      	str	r0, [r5, r2]
static uint32_t counter_freq;


bool sys_time_init(void *os_interop) {

  if (!os_interop) return false;
 8001ba2:	2900      	cmp	r1, #0
 8001ba4:	f000 8142 	beq.w	8001e2c <main+0xb1c>

  interop = (chibios_interop_t*)os_interop;
 8001ba8:	f8df c108 	ldr.w	ip, [pc, #264]	; 8001cb4 <main+0x9a4>

  counter_high_word = 0xFFFFFFFF;
 8001bac:	4e36      	ldr	r6, [pc, #216]	; (8001c88 <main+0x978>)
  counter_freq = 0; /* TODO: Figure out how to compute this.
 8001bae:	4837      	ldr	r0, [pc, #220]	; (8001c8c <main+0x97c>)

  alarm.active = false;
  alarm.alarm_time = 0;


  COMB_EXPAND(rccEnableTIM, SYS_TIMER)(true);
 8001bb0:	4a37      	ldr	r2, [pc, #220]	; (8001c90 <main+0x980>)

bool sys_time_init(void *os_interop) {

  if (!os_interop) return false;

  interop = (chibios_interop_t*)os_interop;
 8001bb2:	f8cc 1000 	str.w	r1, [ip]

  counter_high_word = 0xFFFFFFFF;
 8001bb6:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8001bba:	f8c6 c000 	str.w	ip, [r6]
  counter_freq = 0; /* TODO: Figure out how to compute this.
 8001bbe:	6003      	str	r3, [r0, #0]

  alarm.active = false;
  alarm.alarm_time = 0;


  COMB_EXPAND(rccEnableTIM, SYS_TIMER)(true);
 8001bc0:	6c10      	ldr	r0, [r2, #64]	; 0x40
  counter_high_word = 0xFFFFFFFF;
  counter_freq = 0; /* TODO: Figure out how to compute this.
  		       I think it is 84Mhz / (tim->PSC+1)
  		     */

  alarm.active = false;
 8001bc2:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 8001cb8 <main+0x9a8>

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001bc6:	4933      	ldr	r1, [pc, #204]	; (8001c94 <main+0x984>)
 8001bc8:	f889 3000 	strb.w	r3, [r9]
  alarm.alarm_time = 0;


  COMB_EXPAND(rccEnableTIM, SYS_TIMER)(true);
 8001bcc:	f040 0008 	orr.w	r0, r0, #8
 8001bd0:	6410      	str	r0, [r2, #64]	; 0x40
 8001bd2:	6e10      	ldr	r0, [r2, #96]	; 0x60

  nvicEnableVector(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER,_NUMBER)) ,
  		   COMB_EXPAND(STM32_GPT_TIM, COMB_EXPAND(SYS_TIMER, _IRQ_PRIORITY))); /* use GPT level prio */


  tim->PSC = 0; //0xFFFF;     // counter rate is input_clock / (0xFFFF+1)
 8001bd4:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 8001cbc <main+0x9ac>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001bd8:	4e2f      	ldr	r6, [pc, #188]	; (8001c98 <main+0x988>)

  alarm.active = false;
  alarm.alarm_time = 0;


  COMB_EXPAND(rccEnableTIM, SYS_TIMER)(true);
 8001bda:	f040 0008 	orr.w	r0, r0, #8
 8001bde:	6610      	str	r0, [r2, #96]	; 0x60
 8001be0:	6e10      	ldr	r0, [r2, #96]	; 0x60
  COMB_EXPAND(rccResetTIM, SYS_TIMER)();
 8001be2:	6a10      	ldr	r0, [r2, #32]
 8001be4:	f040 0008 	orr.w	r0, r0, #8
 8001be8:	6210      	str	r0, [r2, #32]
 8001bea:	6a10      	ldr	r0, [r2, #32]
 8001bec:	f020 0008 	bic.w	r0, r0, #8
 8001bf0:	6210      	str	r0, [r2, #32]
 8001bf2:	2070      	movs	r0, #112	; 0x70
 8001bf4:	6a12      	ldr	r2, [r2, #32]
 8001bf6:	f881 0332 	strb.w	r0, [r1, #818]	; 0x332
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001bfa:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001bfe:	f8c1 2184 	str.w	r2, [r1, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001c02:	604a      	str	r2, [r1, #4]

  nvicEnableVector(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER,_NUMBER)) ,
  		   COMB_EXPAND(STM32_GPT_TIM, COMB_EXPAND(SYS_TIMER, _IRQ_PRIORITY))); /* use GPT level prio */


  tim->PSC = 0; //0xFFFF;     // counter rate is input_clock / (0xFFFF+1)
 8001c04:	f8da 2000 	ldr.w	r2, [sl]
  counter_freq = 0; /* TODO: Figure out how to compute this.
  		       I think it is 84Mhz / (tim->PSC+1)
  		     */

  alarm.active = false;
  alarm.alarm_time = 0;
 8001c08:	2000      	movs	r0, #0
 8001c0a:	2100      	movs	r1, #0

  nvicEnableVector(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER,_NUMBER)) ,
  		   COMB_EXPAND(STM32_GPT_TIM, COMB_EXPAND(SYS_TIMER, _IRQ_PRIORITY))); /* use GPT level prio */


  tim->PSC = 0; //0xFFFF;     // counter rate is input_clock / (0xFFFF+1)
 8001c0c:	6293      	str	r3, [r2, #40]	; 0x28
  counter_freq = 0; /* TODO: Figure out how to compute this.
  		       I think it is 84Mhz / (tim->PSC+1)
  		     */

  alarm.active = false;
  alarm.alarm_time = 0;
 8001c0e:	e9c9 0102 	strd	r0, r1, [r9, #8]
  nvicEnableVector(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER,_NUMBER)) ,
  		   COMB_EXPAND(STM32_GPT_TIM, COMB_EXPAND(SYS_TIMER, _IRQ_PRIORITY))); /* use GPT level prio */


  tim->PSC = 0; //0xFFFF;     // counter rate is input_clock / (0xFFFF+1)
  tim->ARR = 0xFFFFFFFF; // Value when counter should flip to zero.
 8001c12:	f8c2 c02c 	str.w	ip, [r2, #44]	; 0x2c

  tim->CCR[0] = 0xFFFFFFFF; /* init compare values */
 8001c16:	f8c2 c034 	str.w	ip, [r2, #52]	; 0x34
  tim->CCR[1] = 0x0;
 8001c1a:	6393      	str	r3, [r2, #56]	; 0x38
  tim->CCR[2] = 0x0;
 8001c1c:	63d3      	str	r3, [r2, #60]	; 0x3c
  tim->CCR[3] = 0x0;
 8001c1e:	6413      	str	r3, [r2, #64]	; 0x40

  tim->CCER = 0x1; /* activate compare on ccr channel 1 */
 8001c20:	f8c2 e020 	str.w	lr, [r2, #32]

  /* TODO: make sure we get "greater than or equal to" comparison on the CCR */

  tim->CNT = 0;
 8001c24:	6253      	str	r3, [r2, #36]	; 0x24
  tim->EGR = 0x1; // Update event (Makes all the configurations stick)
 8001c26:	f8c2 e014 	str.w	lr, [r2, #20]

  tim->CR1 = 0x1; // enable
 8001c2a:	f8c2 e000 	str.w	lr, [r2]
  tim->DIER |= 0x1; /* activate interrupt on "update event" (for example overflow) */
 8001c2e:	68d0      	ldr	r0, [r2, #12]
 8001c30:	2103      	movs	r1, #3
 8001c32:	ea40 000e 	orr.w	r0, r0, lr
 8001c36:	60d0      	str	r0, [r2, #12]
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8001c38:	4689      	mov	r9, r1
 8001c3a:	2010      	movs	r0, #16
      m4 = 15 << ((bit & 7) * 4);
 8001c3c:	f04f 0c0f 	mov.w	ip, #15
 8001c40:	e03e      	b.n	8001cc0 <main+0x9b0>
 8001c42:	bf00      	nop
 8001c44:	0800c804 	.word	0x0800c804
 8001c48:	2000b68c 	.word	0x2000b68c
 8001c4c:	200023c8 	.word	0x200023c8
 8001c50:	0800cc8c 	.word	0x0800cc8c
 8001c54:	2000b1fc 	.word	0x2000b1fc
 8001c58:	2000a368 	.word	0x2000a368
 8001c5c:	2000a980 	.word	0x2000a980
 8001c60:	08005d21 	.word	0x08005d21
 8001c64:	20001978 	.word	0x20001978
 8001c68:	2000a118 	.word	0x2000a118
 8001c6c:	20004f58 	.word	0x20004f58
 8001c70:	20001178 	.word	0x20001178
 8001c74:	2000a314 	.word	0x2000a314
 8001c78:	200029c8 	.word	0x200029c8
 8001c7c:	20004f88 	.word	0x20004f88
 8001c80:	20006198 	.word	0x20006198
 8001c84:	2000a36c 	.word	0x2000a36c
 8001c88:	20004f50 	.word	0x20004f50
 8001c8c:	2000a55c 	.word	0x2000a55c
 8001c90:	40023800 	.word	0x40023800
 8001c94:	e000e100 	.word	0xe000e100
 8001c98:	40020000 	.word	0x40020000
 8001c9c:	20000800 	.word	0x20000800
 8001ca0:	08005d61 	.word	0x08005d61
 8001ca4:	2000a57c 	.word	0x2000a57c
 8001ca8:	0800c93c 	.word	0x0800c93c
 8001cac:	200029c8 	.word	0x200029c8
 8001cb0:	2000a2a0 	.word	0x2000a2a0
 8001cb4:	2000a97c 	.word	0x2000a97c
 8001cb8:	2000a300 	.word	0x2000a300
 8001cbc:	20000810 	.word	0x20000810
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8001cc0:	2b04      	cmp	r3, #4
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 8001cc2:	ea4f 0050 	mov.w	r0, r0, lsr #1
    if (!mask)
 8001cc6:	f000 8129 	beq.w	8001f1c <main+0xc0c>
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8001cca:	07c2      	lsls	r2, r0, #31
    if (!mask)
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8001ccc:	ea4f 0181 	mov.w	r1, r1, lsl #2
    bit++;
 8001cd0:	f103 0301 	add.w	r3, r3, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8001cd4:	d5f4      	bpl.n	8001cc0 <main+0x9b0>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001cd6:	6872      	ldr	r2, [r6, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8001cd8:	fa0e fa03 	lsl.w	sl, lr, r3
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001cdc:	ea22 020a 	bic.w	r2, r2, sl
 8001ce0:	6072      	str	r2, [r6, #4]
 8001ce2:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001ce6:	68b2      	ldr	r2, [r6, #8]
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8001ce8:	fa09 fa0a 	lsl.w	sl, r9, sl
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001cec:	ea6f 0a0a 	mvn.w	sl, sl
 8001cf0:	ea0a 0202 	and.w	r2, sl, r2
 8001cf4:	60b2      	str	r2, [r6, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001cf6:	68f2      	ldr	r2, [r6, #12]
 8001cf8:	ea0a 0202 	and.w	r2, sl, r2
 8001cfc:	60f2      	str	r2, [r6, #12]
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8001cfe:	6832      	ldr	r2, [r6, #0]
 8001d00:	ea0a 0202 	and.w	r2, sl, r2
 8001d04:	430a      	orrs	r2, r1
 8001d06:	6032      	str	r2, [r6, #0]
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001d08:	6a32      	ldr	r2, [r6, #32]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001d0a:	ea4f 0a83 	mov.w	sl, r3, lsl #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8001d0e:	fa0c fa0a 	lsl.w	sl, ip, sl
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001d12:	ea22 020a 	bic.w	r2, r2, sl
 8001d16:	6232      	str	r2, [r6, #32]
 8001d18:	e7d2      	b.n	8001cc0 <main+0x9b0>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(true);
 8001d1a:	4bbd      	ldr	r3, [pc, #756]	; (8002010 <main+0xd00>)

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001d1c:	4abd      	ldr	r2, [pc, #756]	; (8002014 <main+0xd04>)
 8001d1e:	6b59      	ldr	r1, [r3, #52]	; 0x34
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8001d20:	f8df e340 	ldr.w	lr, [pc, #832]	; 8002064 <main+0xd54>
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8001d24:	48bc      	ldr	r0, [pc, #752]	; (8002018 <main+0xd08>)
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(true);
 8001d26:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001d2a:	6359      	str	r1, [r3, #52]	; 0x34
 8001d2c:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8001d2e:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001d32:	6559      	str	r1, [r3, #84]	; 0x54
 8001d34:	6d59      	ldr	r1, [r3, #84]	; 0x54
      rccResetOTG_FS();
 8001d36:	6959      	ldr	r1, [r3, #20]
 8001d38:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8001d3c:	6159      	str	r1, [r3, #20]
 8001d3e:	6959      	ldr	r1, [r3, #20]
 8001d40:	f021 0180 	bic.w	r1, r1, #128	; 0x80
 8001d44:	6159      	str	r1, [r3, #20]
 8001d46:	f04f 0be0 	mov.w	fp, #224	; 0xe0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d4a:	2108      	movs	r1, #8

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8001d4c:	f04f 0ac0 	mov.w	sl, #192	; 0xc0
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8001d50:	f44f 2c50 	mov.w	ip, #851968	; 0xd0000

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(true);
      rccResetOTG_FS();
 8001d54:	695b      	ldr	r3, [r3, #20]

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001d56:	f882 b343 	strb.w	fp, [r2, #835]	; 0x343
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d5a:	f8c2 1188 	str.w	r1, [r2, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001d5e:	6091      	str	r1, [r2, #8]
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8001d60:	f8c6 e00c 	str.w	lr, [r6, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8001d64:	f8c6 0800 	str.w	r0, [r6, #2048]	; 0x800
#endif
    }
#endif

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8001d68:	f8c6 9e00 	str.w	r9, [r6, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8001d6c:	f8c6 a000 	str.w	sl, [r6]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8001d70:	f8c6 c038 	str.w	ip, [r6, #56]	; 0x38

static void otg_core_reset(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8001d74:	6933      	ldr	r3, [r6, #16]
 8001d76:	2b00      	cmp	r3, #0
 8001d78:	dafc      	bge.n	8001d74 <main+0xa64>
    ;

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8001d7a:	2301      	movs	r3, #1
 8001d7c:	6133      	str	r3, [r6, #16]
 * @xclass
 */
#if (PORT_SUPPORTS_RT == TRUE) || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8001d7e:	200c      	movs	r0, #12
 8001d80:	f002 ffee 	bl	8004d60 <chSysPolledDelayX>
  osalSysPolledDelayX(12);
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8001d84:	6933      	ldr	r3, [r6, #16]
 8001d86:	07d9      	lsls	r1, r3, #31
 8001d88:	d4fc      	bmi.n	8001d84 <main+0xa74>
 8001d8a:	2012      	movs	r0, #18
 8001d8c:	f002 ffe8 	bl	8004d60 <chSysPolledDelayX>
    ;

  osalSysPolledDelayX(18);

  /* Wait AHB idle condition again.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8001d90:	6933      	ldr	r3, [r6, #16]
 8001d92:	2b00      	cmp	r3, #0
 8001d94:	dafc      	bge.n	8001d90 <main+0xa80>

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001d96:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001d98:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
 8001d9a:	f8d3 9008 	ldr.w	r9, [r3, #8]

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8001d9e:	2300      	movs	r3, #0
 8001da0:	60b3      	str	r3, [r6, #8]

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001da2:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8001da6:	0159      	lsls	r1, r3, #5
 8001da8:	1842      	adds	r2, r0, r1
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {

    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8001daa:	f8d2 e900 	ldr.w	lr, [r2, #2304]	; 0x900
 8001dae:	f1be 0f00 	cmp.w	lr, #0
 8001db2:	da05      	bge.n	8001dc0 <main+0xab0>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8001db4:	f8d2 e900 	ldr.w	lr, [r2, #2304]	; 0x900
 8001db8:	f04e 4e80 	orr.w	lr, lr, #1073741824	; 0x40000000
 8001dbc:	f8c2 e900 	str.w	lr, [r2, #2304]	; 0x900
    }

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8001dc0:	f8d2 eb00 	ldr.w	lr, [r2, #2816]	; 0xb00
 8001dc4:	f1be 0f00 	cmp.w	lr, #0
 8001dc8:	da05      	bge.n	8001dd6 <main+0xac6>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8001dca:	f8d2 eb00 	ldr.w	lr, [r2, #2816]	; 0xb00
 8001dce:	f04e 4e80 	orr.w	lr, lr, #1073741824	; 0x40000000
 8001dd2:	f8c2 eb00 	str.w	lr, [r2, #2816]	; 0xb00
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001dd6:	1842      	adds	r2, r0, r1

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001dd8:	3301      	adds	r3, #1
 8001dda:	454b      	cmp	r3, r9

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8001ddc:	f8c2 c908 	str.w	ip, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8001de0:	f8c2 cb08 	str.w	ip, [r2, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8001de4:	d9df      	bls.n	8001da6 <main+0xa96>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 8001de6:	686b      	ldr	r3, [r5, #4]
 8001de8:	68da      	ldr	r2, [r3, #12]
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8001dea:	f04f 1101 	mov.w	r1, #65537	; 0x10001
    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8001dee:	2300      	movs	r3, #0
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8001df0:	f8c0 181c 	str.w	r1, [r0, #2076]	; 0x81c
    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8001df4:	f8c6 3810 	str.w	r3, [r6, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8001df8:	f8c6 3814 	str.w	r3, [r6, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8001dfc:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8001e00:	2a00      	cmp	r2, #0
 8001e02:	f000 8088 	beq.w	8001f16 <main+0xc06>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8001e06:	4b85      	ldr	r3, [pc, #532]	; (800201c <main+0xd0c>)
 8001e08:	61b3      	str	r3, [r6, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8001e0a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001e0e:	6173      	str	r3, [r6, #20]

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8001e10:	68b3      	ldr	r3, [r6, #8]
 8001e12:	f043 0301 	orr.w	r3, r3, #1
 8001e16:	60b3      	str	r3, [r6, #8]
 8001e18:	e5b0      	b.n	800197c <main+0x66c>
 8001e1a:	4881      	ldr	r0, [pc, #516]	; (8002020 <main+0xd10>)
 8001e1c:	f002 ffb0 	bl	8004d80 <chSysHalt>
    int offset = i * CONTEXT_STACK_SPACE;

    int st_status = stack_init(&ctx[i].stack
                               , &mem[offset]
                               , CONTEXT_STACK_SPACE);
    ctx[i].deadline = TIME_MAX;
 8001e20:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001e24:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001e28:	e9c2 010a 	strd	r0, r1, [r2, #40]	; 0x28

  chibios_register_dbg_print(print_it);

  if (!chibios_sensevm_init()) {
     chprintf((BaseSequentialStream *)&SDU1, "SenseVM init failed!\r\n");
 8001e2c:	487d      	ldr	r0, [pc, #500]	; (8002024 <main+0xd14>)
 8001e2e:	497e      	ldr	r1, [pc, #504]	; (8002028 <main+0xd18>)
 8001e30:	f006 f856 	bl	8007ee0 <chprintf.constprop.35>

  bool r = true;

  for (int i = 0; i < VMC_NUM_CONTAINERS; i++) {

    thread_data[i].container = &vm_containers[i];
 8001e34:	f8df 8230 	ldr.w	r8, [pc, #560]	; 8002068 <main+0xd58>
    thread_data[i].container_name = container_names[i];
 8001e38:	4b7c      	ldr	r3, [pc, #496]	; (800202c <main+0xd1c>)
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8001e3a:	487d      	ldr	r0, [pc, #500]	; (8002030 <main+0xd20>)

  bool r = true;

  for (int i = 0; i < VMC_NUM_CONTAINERS; i++) {

    thread_data[i].container = &vm_containers[i];
 8001e3c:	f8c8 5000 	str.w	r5, [r8]
    thread_data[i].container_name = container_names[i];
 8001e40:	f8c8 3004 	str.w	r3, [r8, #4]
 8001e44:	f000 fd74 	bl	8002930 <chRegFindThreadByWorkingArea>
 8001e48:	b110      	cbz	r0, 8001e50 <main+0xb40>
 8001e4a:	487a      	ldr	r0, [pc, #488]	; (8002034 <main+0xd24>)
 8001e4c:	f002 ff98 	bl	8004d80 <chSysHalt>
 8001e50:	4b77      	ldr	r3, [pc, #476]	; (8002030 <main+0xd20>)
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8001e52:	2155      	movs	r1, #85	; 0x55
 8001e54:	f503 6215 	add.w	r2, r3, #2384	; 0x950
 8001e58:	f803 1b01 	strb.w	r1, [r3], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8001e5c:	4293      	cmp	r3, r2
 8001e5e:	4d74      	ldr	r5, [pc, #464]	; (8002030 <main+0xd20>)
 8001e60:	d3fa      	bcc.n	8001e58 <main+0xb48>
 8001e62:	2320      	movs	r3, #32
 8001e64:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001e68:	f003 f802 	bl	8004e70 <_dbg_check_lock>
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 8001e6c:	6962      	ldr	r2, [r4, #20]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
 8001e6e:	4872      	ldr	r0, [pc, #456]	; (8002038 <main+0xd28>)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001e70:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 800206c <main+0xd5c>
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 8001e74:	f8c5 291c 	str.w	r2, [r5, #2332]	; 0x91c
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
  tp->state           = CH_STATE_WTSTART;
  tp->flags           = CH_FLAG_MODE_STATIC;
 8001e78:	2300      	movs	r3, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
 8001e7a:	216c      	movs	r1, #108	; 0x6c
  tp->state           = CH_STATE_WTSTART;
 8001e7c:	f04f 0c02 	mov.w	ip, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
 8001e80:	f04f 0e01 	mov.w	lr, #1
  tp->name            = name;
  REG_INSERT(tp);
 8001e84:	f605 1608 	addw	r6, r5, #2312	; 0x908
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
 8001e88:	f8c5 1910 	str.w	r1, [r5, #2320]	; 0x910
  tp->flags           = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks           = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio        = prio;
 8001e8c:	f8c5 1944 	str.w	r1, [r5, #2372]	; 0x944
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
  tp->state           = CH_STATE_WTSTART;
  tp->flags           = CH_FLAG_MODE_STATIC;
 8001e90:	f885 3929 	strb.w	r3, [r5, #2345]	; 0x929
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks           = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio        = prio;
  tp->mtxlist         = NULL;
 8001e94:	f8c5 3940 	str.w	r3, [r5, #2368]	; 0x940
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending        = (eventmask_t)0;
 8001e98:	f8c5 393c 	str.w	r3, [r5, #2364]	; 0x93c
 *
 * @notapi
 */
static inline void ch_list_init(ch_list_t *lp) {

  lp->next = lp;
 8001e9c:	f505 6113 	add.w	r1, r5, #2352	; 0x930
 *
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
 8001ea0:	f605 1334 	addw	r3, r5, #2356	; 0x934
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001ea4:	f605 0aa4 	addw	sl, r5, #2212	; 0x8a4
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->hdr.pqueue.prio = prio;
  tp->state           = CH_STATE_WTSTART;
 8001ea8:	f885 c928 	strb.w	ip, [r5, #2344]	; 0x928
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
 8001eac:	f885 e92a 	strb.w	lr, [r5, #2346]	; 0x92a
  tp->name            = name;
 8001eb0:	f8c5 0920 	str.w	r0, [r5, #2336]	; 0x920
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8001eb4:	f8c5 5924 	str.w	r5, [r5, #2340]	; 0x924
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001eb8:	f8c5 88e8 	str.w	r8, [r5, #2280]	; 0x8e8
 8001ebc:	f8c5 7904 	str.w	r7, [r5, #2308]	; 0x904
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 8001ec0:	f8c5 4918 	str.w	r4, [r5, #2328]	; 0x918
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001ec4:	f8c5 a914 	str.w	sl, [r5, #2324]	; 0x914
 8001ec8:	f8c5 98e4 	str.w	r9, [r5, #2276]	; 0x8e4

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8001ecc:	4630      	mov	r0, r6
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 8001ece:	6116      	str	r6, [r2, #16]
 8001ed0:	f8c5 3934 	str.w	r3, [r5, #2356]	; 0x934
  qp->prev = qp;
 8001ed4:	f8c5 3938 	str.w	r3, [r5, #2360]	; 0x938
 *
 * @notapi
 */
static inline void ch_list_init(ch_list_t *lp) {

  lp->next = lp;
 8001ed8:	f8c5 1930 	str.w	r1, [r5, #2352]	; 0x930
 8001edc:	6166      	str	r6, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8001ede:	f006 f9d7 	bl	8008290 <chSchWakeupS.constprop.34>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001ee2:	f002 ffb5 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8001ee6:	6823      	ldr	r3, [r4, #0]
  tp->time            = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs            = (trefs_t)1;
  tp->name            = name;
  REG_INSERT(tp);
 8001ee8:	4a54      	ldr	r2, [pc, #336]	; (800203c <main+0xd2c>)
 8001eea:	42a3      	cmp	r3, r4
 8001eec:	d005      	beq.n	8001efa <main+0xbea>
 8001eee:	6992      	ldr	r2, [r2, #24]
 8001ef0:	689b      	ldr	r3, [r3, #8]
 8001ef2:	6892      	ldr	r2, [r2, #8]
 8001ef4:	429a      	cmp	r2, r3
 8001ef6:	f4ff acce 	bcc.w	8001896 <main+0x586>
 8001efa:	2300      	movs	r3, #0
 8001efc:	f383 8811 	msr	BASEPRI, r3

    threads[i] = chThdCreateStatic(thread_wa[i],
 8001f00:	4b4f      	ldr	r3, [pc, #316]	; (8002040 <main+0xd30>)
  }

  if (!chibios_start_container_threads()) {
     chprintf((BaseSequentialStream *)&SDU1, "SenseVM failed to start container threads!\r\n");
  } else {
    chprintf((BaseSequentialStream *)&SDU1, "SenseVM container threads started!\r\n");
 8001f02:	4848      	ldr	r0, [pc, #288]	; (8002024 <main+0xd14>)
 8001f04:	494f      	ldr	r1, [pc, #316]	; (8002044 <main+0xd34>)
 8001f06:	601e      	str	r6, [r3, #0]
 8001f08:	f005 ffea 	bl	8007ee0 <chprintf.constprop.35>

  // Why is this needed ??
  // Why can we not just let the main thread die here ?
  
  while (true) {
    chThdSleepMilliseconds(1000);
 8001f0c:	f242 7010 	movw	r0, #10000	; 0x2710
 8001f10:	f000 ff16 	bl	8002d40 <chThdSleep>
 8001f14:	e7fa      	b.n	8001f0c <main+0xbfc>
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8001f16:	4b4c      	ldr	r3, [pc, #304]	; (8002048 <main+0xd38>)
 8001f18:	61b3      	str	r3, [r6, #24]
 8001f1a:	e776      	b.n	8001e0a <main+0xafa>
  LL_PWM_DRIVER_GROUP_START(ll_pwm_driver_group0);
  #endif

  #if VMC_CONTAINER_1_USE_DAC_0
  {
    LL_DAC_DRIVER_INIT(ll_dac, 0, drv_num);
 8001f1c:	4e4b      	ldr	r6, [pc, #300]	; (800204c <main+0xd3c>)
 8001f1e:	f8df 9150 	ldr.w	r9, [pc, #336]	; 8002070 <main+0xd60>
 8001f22:	f8c6 8010 	str.w	r8, [r6, #16]
 8001f26:	2300      	movs	r3, #0
 8001f28:	f240 72ff 	movw	r2, #2047	; 0x7ff
 8001f2c:	75b3      	strb	r3, [r6, #22]
 8001f2e:	61b3      	str	r3, [r6, #24]
 8001f30:	60b3      	str	r3, [r6, #8]
 8001f32:	82b2      	strh	r2, [r6, #20]
 8001f34:	2320      	movs	r3, #32
 8001f36:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001f3a:	f002 ff99 	bl	8004e70 <_dbg_check_lock>

  osalDbgCheck(dacp != NULL);

  osalSysLock();

  osalDbgAssert((dacp->state == DAC_STOP) || (dacp->state == DAC_READY),
 8001f3e:	f898 3000 	ldrb.w	r3, [r8]
 8001f42:	1e5a      	subs	r2, r3, #1
 8001f44:	2a01      	cmp	r2, #1
 8001f46:	d902      	bls.n	8001f4e <main+0xc3e>
 8001f48:	4841      	ldr	r0, [pc, #260]	; (8002050 <main+0xd40>)
 8001f4a:	f002 ff19 	bl	8004d80 <chSysHalt>
                "invalid state");

  dacp->config = config;
 8001f4e:	f106 0214 	add.w	r2, r6, #20
 */
void dac_lld_start(DACDriver *dacp) {

  /* If the driver is in DAC_STOP state then a full initialization is
     required.*/
  if (dacp->state == DAC_STOP) {
 8001f52:	2b01      	cmp	r3, #1
 8001f54:	f8c9 2010 	str.w	r2, [r9, #16]
 8001f58:	d11e      	bne.n	8001f98 <main+0xc88>
    dacchannel_t channel = 0;

    /* Enabling the clock source.*/
#if STM32_DAC_USE_DAC1_CH1
    if (&DACD1 == dacp) {
      rccEnableDAC1(true);
 8001f5a:	4b2d      	ldr	r3, [pc, #180]	; (8002010 <main+0xd00>)
       zero.*/
#if STM32_DAC_DUAL_MODE == FALSE
    {
      uint32_t cr;

      cr = dacp->params->dac->CR;
 8001f5c:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
    dacchannel_t channel = 0;

    /* Enabling the clock source.*/
#if STM32_DAC_USE_DAC1_CH1
    if (&DACD1 == dacp) {
      rccEnableDAC1(true);
 8001f60:	6c1a      	ldr	r2, [r3, #64]	; 0x40
       zero.*/
#if STM32_DAC_DUAL_MODE == FALSE
    {
      uint32_t cr;

      cr = dacp->params->dac->CR;
 8001f62:	f8d0 e000 	ldr.w	lr, [r0]
      cr &= dacp->params->regmask;
      cr |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
      dacp->params->dac->CR = cr;
      dac_lld_put_channel(dacp, channel, dacp->config->init);
 8001f66:	8ab1      	ldrh	r1, [r6, #20]
    dacchannel_t channel = 0;

    /* Enabling the clock source.*/
#if STM32_DAC_USE_DAC1_CH1
    if (&DACD1 == dacp) {
      rccEnableDAC1(true);
 8001f68:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8001f6c:	641a      	str	r2, [r3, #64]	; 0x40
 8001f6e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001f70:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8001f74:	661a      	str	r2, [r3, #96]	; 0x60
    {
      uint32_t cr;

      cr = dacp->params->dac->CR;
      cr &= dacp->params->regmask;
      cr |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
 8001f76:	69b2      	ldr	r2, [r6, #24]
    dacchannel_t channel = 0;

    /* Enabling the clock source.*/
#if STM32_DAC_USE_DAC1_CH1
    if (&DACD1 == dacp) {
      rccEnableDAC1(true);
 8001f78:	6e1b      	ldr	r3, [r3, #96]	; 0x60
#if STM32_DAC_DUAL_MODE == FALSE
    {
      uint32_t cr;

      cr = dacp->params->dac->CR;
      cr &= dacp->params->regmask;
 8001f7a:	68c3      	ldr	r3, [r0, #12]
       zero.*/
#if STM32_DAC_DUAL_MODE == FALSE
    {
      uint32_t cr;

      cr = dacp->params->dac->CR;
 8001f7c:	f8de c000 	ldr.w	ip, [lr]
      cr &= dacp->params->regmask;
      cr |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
 8001f80:	6880      	ldr	r0, [r0, #8]
 8001f82:	f042 0201 	orr.w	r2, r2, #1
 8001f86:	4082      	lsls	r2, r0
#if STM32_DAC_DUAL_MODE == FALSE
    {
      uint32_t cr;

      cr = dacp->params->dac->CR;
      cr &= dacp->params->regmask;
 8001f88:	ea0c 0303 	and.w	r3, ip, r3
      cr |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
 8001f8c:	4313      	orrs	r3, r2
      dacp->params->dac->CR = cr;
      dac_lld_put_channel(dacp, channel, dacp->config->init);
 8001f8e:	4648      	mov	r0, r9
      uint32_t cr;

      cr = dacp->params->dac->CR;
      cr &= dacp->params->regmask;
      cr |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
      dacp->params->dac->CR = cr;
 8001f90:	f8ce 3000 	str.w	r3, [lr]
      dac_lld_put_channel(dacp, channel, dacp->config->init);
 8001f94:	f005 ff7c 	bl	8007e90 <dac_lld_put_channel.constprop.51>
  dac_lld_start(dacp);
  dacp->state = DAC_READY;
 8001f98:	2302      	movs	r3, #2
 8001f9a:	f888 3000 	strb.w	r3, [r8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001f9e:	f002 ff57 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8001fa2:	6823      	ldr	r3, [r4, #0]
 8001fa4:	4a25      	ldr	r2, [pc, #148]	; (800203c <main+0xd2c>)
 8001fa6:	42a3      	cmp	r3, r4
 8001fa8:	d004      	beq.n	8001fb4 <main+0xca4>
 8001faa:	6992      	ldr	r2, [r2, #24]
 8001fac:	689b      	ldr	r3, [r3, #8]
 8001fae:	6892      	ldr	r2, [r2, #8]
 8001fb0:	429a      	cmp	r2, r3
 8001fb2:	d32a      	bcc.n	800200a <main+0xcfa>
 8001fb4:	2300      	movs	r3, #0
 8001fb6:	f383 8811 	msr	BASEPRI, r3

    ll_driver_t lld;
    if (ll_dac_init(&lld, &ll_dac)) {
       vm_containers[VMC_CONTAINER_1].drivers[drv_num] = lld;
 8001fba:	f241 2c44 	movw	ip, #4676	; 0x1244
 8001fbe:	f241 2348 	movw	r3, #4680	; 0x1248
 8001fc2:	f241 214c 	movw	r1, #4684	; 0x124c
 8001fc6:	f241 2850 	movw	r8, #4688	; 0x1250
 8001fca:	f241 2e54 	movw	lr, #4692	; 0x1254
 8001fce:	f241 2258 	movw	r2, #4696	; 0x1258
 8001fd2:	f241 2b5c 	movw	fp, #4700	; 0x125c
 8001fd6:	2001      	movs	r0, #1
 8001fd8:	f845 600c 	str.w	r6, [r5, ip]
 8001fdc:	54e8      	strb	r0, [r5, r3]
 8001fde:	f8df a094 	ldr.w	sl, [pc, #148]	; 8002074 <main+0xd64>
 8001fe2:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8002078 <main+0xd68>
 8001fe6:	f8df c094 	ldr.w	ip, [pc, #148]	; 800207c <main+0xd6c>
 8001fea:	4e1a      	ldr	r6, [pc, #104]	; (8002054 <main+0xd44>)
 8001fec:	4b1a      	ldr	r3, [pc, #104]	; (8002058 <main+0xd48>)
 8001fee:	f845 a001 	str.w	sl, [r5, r1]
 8001ff2:	f845 9008 	str.w	r9, [r5, r8]
  chibios_register_dbg_print(print_it);

  if (!chibios_sensevm_init()) {
     chprintf((BaseSequentialStream *)&SDU1, "SenseVM init failed!\r\n");
  } else {
    chprintf((BaseSequentialStream *)&SDU1, "SenseVM initialized!\r\n");
 8001ff6:	4919      	ldr	r1, [pc, #100]	; (800205c <main+0xd4c>)
 8001ff8:	f845 c00e 	str.w	ip, [r5, lr]
 8001ffc:	50ae      	str	r6, [r5, r2]
 8001ffe:	f845 300b 	str.w	r3, [r5, fp]
 8002002:	4808      	ldr	r0, [pc, #32]	; (8002024 <main+0xd14>)
 8002004:	f005 ff6c 	bl	8007ee0 <chprintf.constprop.35>
 8002008:	e714      	b.n	8001e34 <main+0xb24>
 800200a:	4815      	ldr	r0, [pc, #84]	; (8002060 <main+0xd50>)
 800200c:	f002 feb8 	bl	8004d80 <chSysHalt>
 8002010:	40023800 	.word	0x40023800
 8002014:	e000e100 	.word	0xe000e100
 8002018:	02200003 	.word	0x02200003
 800201c:	c0303c08 	.word	0xc0303c08
 8002020:	0800c788 	.word	0x0800c788
 8002024:	2000b1fc 	.word	0x2000b1fc
 8002028:	0800ccb4 	.word	0x0800ccb4
 800202c:	0800cccc 	.word	0x0800cccc
 8002030:	20001a78 	.word	0x20001a78
 8002034:	0800c84c 	.word	0x0800c84c
 8002038:	0800ccd0 	.word	0x0800ccd0
 800203c:	2000b68c 	.word	0x2000b68c
 8002040:	2000a310 	.word	0x2000a310
 8002044:	0800ccd8 	.word	0x0800ccd8
 8002048:	c0303c00 	.word	0xc0303c00
 800204c:	2000a4bc 	.word	0x2000a4bc
 8002050:	0800c828 	.word	0x0800c828
 8002054:	08005d01 	.word	0x08005d01
 8002058:	08005cf1 	.word	0x08005cf1
 800205c:	0800cc9c 	.word	0x0800cc9c
 8002060:	0800c794 	.word	0x0800c794
 8002064:	40001440 	.word	0x40001440
 8002068:	20004f48 	.word	0x20004f48
 800206c:	080063a1 	.word	0x080063a1
 8002070:	2000a984 	.word	0x2000a984
 8002074:	08005cc1 	.word	0x08005cc1
 8002078:	08006021 	.word	0x08006021
 800207c:	08005d11 	.word	0x08005d11

08002080 <eval_snd>:
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
}

void eval_snd(vmc_t *vmc, INT *pc_idx) {
 8002080:	b530      	push	{r4, r5, lr}
  (*pc_idx)++;
 8002082:	680b      	ldr	r3, [r1, #0]
 8002084:	3301      	adds	r3, #1
 8002086:	600b      	str	r3, [r1, #0]
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002088:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800208c:	3301      	adds	r3, #1
 800208e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002092:	eb00 1303 	add.w	r3, r0, r3, lsl #4
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
}

void eval_snd(vmc_t *vmc, INT *pc_idx) {
 8002096:	b083      	sub	sp, #12
 8002098:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)e.value);
 800209a:	685a      	ldr	r2, [r3, #4]
 800209c:	4601      	mov	r1, r0
 800209e:	4668      	mov	r0, sp
 80020a0:	f006 fcf6 	bl	8008a90 <heap_snd>
  vmc->contexts[vmc->current_running_context_id].env = v;
 80020a4:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80020a8:	e89d 0003 	ldmia.w	sp, {r0, r1}
 80020ac:	3301      	adds	r3, #1
 80020ae:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80020b2:	eb04 1403 	add.w	r4, r4, r3, lsl #4
 80020b6:	e884 0003 	stmia.w	r4, {r0, r1}
}
 80020ba:	b003      	add	sp, #12
 80020bc:	bd30      	pop	{r4, r5, pc}
 80020be:	bf00      	nop

080020c0 <eval_fst>:
    start = start | vmc->context_used[i];
  }
  return !start;
}

void eval_fst(vmc_t *vmc, INT *pc_idx) {
 80020c0:	b530      	push	{r4, r5, lr}
  (*pc_idx)++;
 80020c2:	680b      	ldr	r3, [r1, #0]
 80020c4:	3301      	adds	r3, #1
 80020c6:	600b      	str	r3, [r1, #0]
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80020c8:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 80020cc:	3301      	adds	r3, #1
 80020ce:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80020d2:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    start = start | vmc->context_used[i];
  }
  return !start;
}

void eval_fst(vmc_t *vmc, INT *pc_idx) {
 80020d6:	b083      	sub	sp, #12
 80020d8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
 80020da:	685a      	ldr	r2, [r3, #4]
 80020dc:	4601      	mov	r1, r0
 80020de:	4668      	mov	r0, sp
 80020e0:	f006 fce6 	bl	8008ab0 <heap_fst>
  vmc->contexts[vmc->current_running_context_id].env = v;
 80020e4:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80020e8:	e89d 0003 	ldmia.w	sp, {r0, r1}
 80020ec:	3301      	adds	r3, #1
 80020ee:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80020f2:	eb04 1403 	add.w	r4, r4, r3, lsl #4
 80020f6:	e884 0003 	stmia.w	r4, {r0, r1}
}
 80020fa:	b003      	add	sp, #12
 80020fc:	bd30      	pop	{r4, r5, pc}
 80020fe:	bf00      	nop

08002100 <_port_irq_epilogue>:
 8002100:	2320      	movs	r3, #32
 8002102:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8002106:	4b10      	ldr	r3, [pc, #64]	; (8002148 <_port_irq_epilogue+0x48>)
 8002108:	685b      	ldr	r3, [r3, #4]
 800210a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800210e:	d102      	bne.n	8002116 <_port_irq_epilogue+0x16>
 8002110:	f383 8811 	msr	BASEPRI, r3
 8002114:	4770      	bx	lr
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
#else
  uint32_t result;

  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8002116:	eef1 3a10 	vmrs	r3, fpscr
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800211a:	f3ef 8309 	mrs	r3, PSP
    s_psp = __get_PSP();
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 800211e:	3b68      	subs	r3, #104	; 0x68

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8002120:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ectxp->fpscr = FPU->FPDSCR;
 8002124:	4a09      	ldr	r2, [pc, #36]	; (800214c <_port_irq_epilogue+0x4c>)

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8002126:	61d9      	str	r1, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ectxp->fpscr = FPU->FPDSCR;
 8002128:	68d2      	ldr	r2, [r2, #12]
 800212a:	661a      	str	r2, [r3, #96]	; 0x60
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800212c:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
 8002130:	4a07      	ldr	r2, [pc, #28]	; (8002150 <_port_irq_epilogue+0x50>)
 8002132:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
 8002134:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8002136:	6889      	ldr	r1, [r1, #8]
 8002138:	6892      	ldr	r2, [r2, #8]
 800213a:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 800213c:	bf8c      	ite	hi
 800213e:	4a05      	ldrhi	r2, [pc, #20]	; (8002154 <_port_irq_epilogue+0x54>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 8002140:	4a05      	ldrls	r2, [pc, #20]	; (8002158 <_port_irq_epilogue+0x58>)
 8002142:	619a      	str	r2, [r3, #24]
 8002144:	4770      	bx	lr
 8002146:	bf00      	nop
 8002148:	e000ed00 	.word	0xe000ed00
 800214c:	e000ef30 	.word	0xe000ef30
 8002150:	2000b68c 	.word	0x2000b68c
 8002154:	08000337 	.word	0x08000337
 8002158:	08000342 	.word	0x08000342
 800215c:	00000000 	.word	0x00000000

08002160 <SVC_Handler>:
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002160:	f3ef 8309 	mrs	r3, PSP
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);

#if CORTEX_USE_FPU == TRUE
    /* Enforcing unstacking of the FP part of the context.*/
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8002164:	4905      	ldr	r1, [pc, #20]	; (800217c <SVC_Handler+0x1c>)
 8002166:	684a      	ldr	r2, [r1, #4]
 8002168:	f022 0201 	bic.w	r2, r2, #1
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 800216c:	3368      	adds	r3, #104	; 0x68

#if CORTEX_USE_FPU == TRUE
    /* Enforcing unstacking of the FP part of the context.*/
    FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 800216e:	604a      	str	r2, [r1, #4]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002170:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002174:	2300      	movs	r3, #0
 8002176:	f383 8811 	msr	BASEPRI, r3
 800217a:	4770      	bx	lr
 800217c:	e000ef30 	.word	0xe000ef30

08002180 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002180:	4b0f      	ldr	r3, [pc, #60]	; (80021c0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002182:	4910      	ldr	r1, [pc, #64]	; (80021c4 <chTMStopMeasurementX+0x44>)
 8002184:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002186:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8002188:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800218a:	f8d1 7884 	ldr.w	r7, [r1, #2180]	; 0x884
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 800218e:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002190:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8002192:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002196:	1ad3      	subs	r3, r2, r3
 8002198:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 800219a:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 800219c:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800219e:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80021a0:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 80021a4:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80021a6:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 80021aa:	bf88      	it	hi
 80021ac:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 80021ae:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80021b0:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80021b2:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 80021b6:	bf38      	it	cc
 80021b8:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80021ba:	bcf0      	pop	{r4, r5, r6, r7}
 80021bc:	4770      	bx	lr
 80021be:	bf00      	nop
 80021c0:	e0001000 	.word	0xe0001000
 80021c4:	2000b68c 	.word	0x2000b68c
	...

080021d0 <chTMStartMeasurementX>:
 80021d0:	4b01      	ldr	r3, [pc, #4]	; (80021d8 <chTMStartMeasurementX+0x8>)
 80021d2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80021d4:	6083      	str	r3, [r0, #8]
 80021d6:	4770      	bx	lr
 80021d8:	e0001000 	.word	0xe0001000
 80021dc:	00000000 	.word	0x00000000

080021e0 <trace_next.lto_priv.115>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(void) {
 80021e0:	b410      	push	{r4}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80021e2:	4a0b      	ldr	r2, [pc, #44]	; (8002210 <trace_next.lto_priv.115+0x30>)
 80021e4:	480b      	ldr	r0, [pc, #44]	; (8002214 <trace_next.lto_priv.115+0x34>)
 80021e6:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80021e8:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 80021ec:	6819      	ldr	r1, [r3, #0]
 80021ee:	6a64      	ldr	r4, [r4, #36]	; 0x24
 *
 * @notapi
 */
NOINLINE static void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80021f0:	605c      	str	r4, [r3, #4]
 80021f2:	6840      	ldr	r0, [r0, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 80021f4:	f360 211f 	bfi	r1, r0, #8, #24
 80021f8:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 80021fc:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 8002200:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8002202:	bf28      	it	cs
 8002204:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 8002208:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 800220a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800220e:	4770      	bx	lr
 8002210:	2000b68c 	.word	0x2000b68c
 8002214:	e0001000 	.word	0xe0001000
	...

08002220 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002220:	4b0b      	ldr	r3, [pc, #44]	; (8002250 <_trace_isr_leave+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 8002222:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002224:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 8002226:	f004 0402 	and.w	r4, r4, #2
 800222a:	b2a4      	uxth	r4, r4
 800222c:	b97c      	cbnz	r4, 800224e <_trace_isr_leave+0x2e>
 800222e:	2220      	movs	r2, #32
 8002230:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002234:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002236:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002238:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800223a:	2103      	movs	r1, #3
 800223c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002240:	f364 03c7 	bfi	r3, r4, #3, #5
 8002244:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 8002246:	f7ff ffcb 	bl	80021e0 <trace_next.lto_priv.115>
 800224a:	f384 8811 	msr	BASEPRI, r4
 800224e:	bd10      	pop	{r4, pc}
 8002250:	2000b68c 	.word	0x2000b68c
	...

08002260 <_trace_isr_enter>:
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002260:	4b0b      	ldr	r3, [pc, #44]	; (8002290 <_trace_isr_enter+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 8002262:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002264:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 8002266:	f004 0402 	and.w	r4, r4, #2
 800226a:	b2a4      	uxth	r4, r4
 800226c:	b97c      	cbnz	r4, 800228e <_trace_isr_enter+0x2e>
 800226e:	2220      	movs	r2, #32
 8002270:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002274:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002276:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002278:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800227a:	2102      	movs	r1, #2
 800227c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002280:	f364 03c7 	bfi	r3, r4, #3, #5
 8002284:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 8002286:	f7ff ffab 	bl	80021e0 <trace_next.lto_priv.115>
 800228a:	f384 8811 	msr	BASEPRI, r4
 800228e:	bd10      	pop	{r4, pc}
 8002290:	2000b68c 	.word	0x2000b68c
	...

080022a0 <_trace_switch>:
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80022a0:	4b0c      	ldr	r3, [pc, #48]	; (80022d4 <_trace_switch+0x34>)
 80022a2:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 80022a4:	07d2      	lsls	r2, r2, #31
 80022a6:	d500      	bpl.n	80022aa <_trace_switch+0xa>
 80022a8:	4770      	bx	lr
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80022aa:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 80022ac:	b410      	push	{r4}
  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80022ae:	699c      	ldr	r4, [r3, #24]
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80022b0:	7813      	ldrb	r3, [r2, #0]
 80022b2:	2001      	movs	r0, #1
 80022b4:	f360 0302 	bfi	r3, r0, #0, #3
 80022b8:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80022ba:	f891 0020 	ldrb.w	r0, [r1, #32]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80022be:	6094      	str	r4, [r2, #8]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80022c0:	f360 03c7 	bfi	r3, r0, #3, #5
 80022c4:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80022c6:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 80022c8:	60d3      	str	r3, [r2, #12]
    trace_next();
  }
}
 80022ca:	f85d 4b04 	ldr.w	r4, [sp], #4
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
    trace_next();
 80022ce:	f7ff bf87 	b.w	80021e0 <trace_next.lto_priv.115>
 80022d2:	bf00      	nop
 80022d4:	2000b68c 	.word	0x2000b68c
	...

080022e0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 80022e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80022e2:	4b05      	ldr	r3, [pc, #20]	; (80022f8 <chDbgCheckClassS+0x18>)
 80022e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80022e6:	b91a      	cbnz	r2, 80022f0 <chDbgCheckClassS+0x10>
 80022e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80022ea:	2b00      	cmp	r3, #0
 80022ec:	dd00      	ble.n	80022f0 <chDbgCheckClassS+0x10>
 80022ee:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 80022f0:	4802      	ldr	r0, [pc, #8]	; (80022fc <chDbgCheckClassS+0x1c>)
 80022f2:	f002 fd45 	bl	8004d80 <chSysHalt>
 80022f6:	bf00      	nop
 80022f8:	2000b68c 	.word	0x2000b68c
 80022fc:	0800cd84 	.word	0x0800cd84

08002300 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8002300:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8002302:	4c11      	ldr	r4, [pc, #68]	; (8002348 <chSchGoSleepS+0x48>)
 8002304:	69a5      	ldr	r5, [r4, #24]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8002306:	4606      	mov	r6, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 8002308:	f7ff ffea 	bl	80022e0 <chDbgCheckClassS>
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
 800230c:	6823      	ldr	r3, [r4, #0]

  /* New state.*/
  otp->state = newstate;
 800230e:	f885 6020 	strb.w	r6, [r5, #32]

  pqp->next       = p->next;
 8002312:	681a      	ldr	r2, [r3, #0]
 8002314:	6022      	str	r2, [r4, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  currp->state = CH_STATE_CURRENT;
 8002316:	2101      	movs	r1, #1
  pqp->next->prev = pqp;
 8002318:	6054      	str	r4, [r2, #4]
  if (currp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800231a:	4618      	mov	r0, r3
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  currp->state = CH_STATE_CURRENT;
 800231c:	f883 1020 	strb.w	r1, [r3, #32]
  if (currp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002320:	4629      	mov	r1, r5
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
 8002322:	61a3      	str	r3, [r4, #24]
  if (currp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002324:	f7ff ffbc 	bl	80022a0 <_trace_switch>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002328:	f3ef 8309 	mrs	r3, PSP
 800232c:	69ea      	ldr	r2, [r5, #28]
 800232e:	3b64      	subs	r3, #100	; 0x64
 8002330:	429a      	cmp	r2, r3
 8002332:	d805      	bhi.n	8002340 <chSchGoSleepS+0x40>
 8002334:	69a0      	ldr	r0, [r4, #24]
 8002336:	4629      	mov	r1, r5
}
 8002338:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800233c:	f7fd bfe4 	b.w	8000308 <_port_switch>
 8002340:	4802      	ldr	r0, [pc, #8]	; (800234c <chSchGoSleepS+0x4c>)
 8002342:	f002 fd1d 	bl	8004d80 <chSysHalt>
 8002346:	bf00      	nop
 8002348:	2000b68c 	.word	0x2000b68c
 800234c:	0800cd8c 	.word	0x0800cd8c

08002350 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002350:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002352:	4b05      	ldr	r3, [pc, #20]	; (8002368 <chDbgCheckClassI+0x18>)
 8002354:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002356:	2a00      	cmp	r2, #0
 8002358:	db03      	blt.n	8002362 <chDbgCheckClassI+0x12>
 800235a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800235c:	2b00      	cmp	r3, #0
 800235e:	dd00      	ble.n	8002362 <chDbgCheckClassI+0x12>
 8002360:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 8002362:	4802      	ldr	r0, [pc, #8]	; (800236c <chDbgCheckClassI+0x1c>)
 8002364:	f002 fd0c 	bl	8004d80 <chSysHalt>
 8002368:	2000b68c 	.word	0x2000b68c
 800236c:	0800cd9c 	.word	0x0800cd9c

08002370 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8002370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002372:	460c      	mov	r4, r1
 8002374:	4606      	mov	r6, r0
 8002376:	4615      	mov	r5, r2
  uint8_t *p, *prev;

  chDbgCheckClassI();
 8002378:	f7ff ffea 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800237c:	b18c      	cbz	r4, 80023a2 <chCoreAllocFromTopI+0x32>
 800237e:	1e60      	subs	r0, r4, #1
 8002380:	ea10 0104 	ands.w	r1, r0, r4
 8002384:	d10d      	bne.n	80023a2 <chCoreAllocFromTopI+0x32>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8002386:	4f09      	ldr	r7, [pc, #36]	; (80023ac <chCoreAllocFromTopI+0x3c>)
 8002388:	687b      	ldr	r3, [r7, #4]
 800238a:	4264      	negs	r4, r4
 800238c:	1b9e      	subs	r6, r3, r6
 800238e:	ea06 0004 	and.w	r0, r6, r4
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8002392:	683c      	ldr	r4, [r7, #0]

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;
 8002394:	1b42      	subs	r2, r0, r5

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8002396:	42a2      	cmp	r2, r4
 8002398:	d306      	bcc.n	80023a8 <chCoreAllocFromTopI+0x38>
 800239a:	4293      	cmp	r3, r2
 800239c:	d304      	bcc.n	80023a8 <chCoreAllocFromTopI+0x38>
    return NULL;
  }

  ch_memcore.topmem = prev;
 800239e:	607a      	str	r2, [r7, #4]
 80023a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80023a2:	4803      	ldr	r0, [pc, #12]	; (80023b0 <chCoreAllocFromTopI+0x40>)
 80023a4:	f002 fcec 	bl	8004d80 <chSysHalt>
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
    return NULL;
 80023a8:	4608      	mov	r0, r1
  }

  ch_memcore.topmem = prev;

  return p;
}
 80023aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80023ac:	2000bf14 	.word	0x2000bf14
 80023b0:	0800cdd8 	.word	0x0800cdd8
	...

080023c0 <chCoreAllocAlignedI.lto_priv.79>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80023c0:	2200      	movs	r2, #0
 80023c2:	f7ff bfd5 	b.w	8002370 <chCoreAllocFromTopI>
 80023c6:	bf00      	nop
	...

080023d0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80023d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80023d4:	4689      	mov	r9, r1
 80023d6:	b087      	sub	sp, #28
 80023d8:	4606      	mov	r6, r0

  chDbgCheckClassS();
 80023da:	f7ff ff81 	bl	80022e0 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 80023de:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
 80023e2:	d056      	beq.n	8002492 <chSchGoSleepTimeoutS+0xc2>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 80023e4:	4f59      	ldr	r7, [pc, #356]	; (800254c <chSchGoSleepTimeoutS+0x17c>)
 80023e6:	69bc      	ldr	r4, [r7, #24]
                vtfunc_t vtfunc, void *par) {
  virtual_timers_list_t *vtlp = &ch.vtlist;
  delta_list_t *dlp;
  sysinterval_t delta;

  chDbgCheckClassI();
 80023e8:	f7ff ffb2 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 80023ec:	f1b9 0f00 	cmp.w	r9, #0
 80023f0:	d04c      	beq.n	800248c <chSchGoSleepTimeoutS+0xbc>
 *
 * @notapi
 */
static inline bool is_vtlist_empty(delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
 80023f2:	46b8      	mov	r8, r7
    sysinterval_t deltanow;

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80023f4:	f1b9 0f01 	cmp.w	r9, #1
 *
 * @notapi
 */
static inline bool is_vtlist_empty(delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
 80023f8:	f858 3f1c 	ldr.w	r3, [r8, #28]!

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 80023fc:	4854      	ldr	r0, [pc, #336]	; (8002550 <chSchGoSleepTimeoutS+0x180>)
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 80023fe:	9405      	str	r4, [sp, #20]
 8002400:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    sysinterval_t deltanow;

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002404:	bf08      	it	eq
 8002406:	f04f 0902 	moveq.w	r9, #2
    }

    /* Special case where the timers list is empty.*/
    if (is_vtlist_empty(&vtlp->dlist)) {
 800240a:	4543      	cmp	r3, r8
 800240c:	6a51      	ldr	r1, [r2, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 800240e:	9004      	str	r0, [sp, #16]
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (is_vtlist_empty(&vtlp->dlist)) {
 8002410:	d07f      	beq.n	8002512 <chSchGoSleepTimeoutS+0x142>
      return;
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    deltanow = chTimeDiffX(vtlp->lasttime, now);
 8002412:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002414:	1a0d      	subs	r5, r1, r0
    delta    = deltanow + delay;

    /* Scenario where a very large delay exceeded the numeric range, it
       requires a special handling, the compression procedure.*/
    if (delta < deltanow) {
 8002416:	eb19 0405 	adds.w	r4, r9, r5
 800241a:	d243      	bcs.n	80024a4 <chSchGoSleepTimeoutS+0xd4>
      vt_list_compress(vtlp, deltanow);
      delta -= deltanow;
    }
    else if (delta < vtlp->dlist.next->delta) {
 800241c:	689a      	ldr	r2, [r3, #8]
 800241e:	4294      	cmp	r4, r2
 8002420:	d355      	bcc.n	80024ce <chSchGoSleepTimeoutS+0xfe>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  dlp = vtlp->dlist.next;
  while (dlp->delta < delta) {
 8002422:	4294      	cmp	r4, r2
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(dlp != &vtp->dlist, "timer already armed");
 8002424:	ad01      	add	r5, sp, #4
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  dlp = vtlp->dlist.next;
  while (dlp->delta < delta) {
 8002426:	d906      	bls.n	8002436 <chSchGoSleepTimeoutS+0x66>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(dlp != &vtp->dlist, "timer already armed");
 8002428:	42ab      	cmp	r3, r5
 800242a:	d02f      	beq.n	800248c <chSchGoSleepTimeoutS+0xbc>

    delta -= dlp->delta;
    dlp = dlp->next;
 800242c:	681b      	ldr	r3, [r3, #0]
  dlp = vtlp->dlist.next;
  while (dlp->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(dlp != &vtp->dlist, "timer already armed");

    delta -= dlp->delta;
 800242e:	1aa4      	subs	r4, r4, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  dlp = vtlp->dlist.next;
  while (dlp->delta < delta) {
 8002430:	689a      	ldr	r2, [r3, #8]
 8002432:	4294      	cmp	r4, r2
 8002434:	d8f8      	bhi.n	8002428 <chSchGoSleepTimeoutS+0x58>
    dlp = dlp->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->dlist.next       = dlp;
  vtp->dlist.prev       = vtp->dlist.next->prev;
 8002436:	685a      	ldr	r2, [r3, #4]
 8002438:	9202      	str	r2, [sp, #8]
    delta -= dlp->delta;
    dlp = dlp->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->dlist.next       = dlp;
 800243a:	9301      	str	r3, [sp, #4]
  vtp->dlist.prev       = vtp->dlist.next->prev;
  vtp->dlist.prev->next = &vtp->dlist;
 800243c:	6015      	str	r5, [r2, #0]
  dlp->prev             = &vtp->dlist;
 800243e:	605d      	str	r5, [r3, #4]
  vtp->dlist.delta      = delta;
 8002440:	9403      	str	r4, [sp, #12]

  /* Calculate new delta for the following entry.*/
  dlp->delta -= delta;
 8002442:	689a      	ldr	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  vtlp->dlist.delta = (sysinterval_t)-1;
 8002444:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  vtp->dlist.prev->next = &vtp->dlist;
  dlp->prev             = &vtp->dlist;
  vtp->dlist.delta      = delta;

  /* Calculate new delta for the following entry.*/
  dlp->delta -= delta;
 8002448:	1b14      	subs	r4, r2, r4
 800244a:	609c      	str	r4, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  vtlp->dlist.delta = (sysinterval_t)-1;
 800244c:	6279      	str	r1, [r7, #36]	; 0x24
    chSchGoSleepS(newstate);
 800244e:	4630      	mov	r0, r6
 8002450:	f7ff ff56 	bl	8002300 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8002454:	f7ff ff7c 	bl	8002350 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8002458:	9b04      	ldr	r3, [sp, #16]
 800245a:	b1f3      	cbz	r3, 800249a <chSchGoSleepTimeoutS+0xca>
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
  virtual_timers_list_t *vtlp = &ch.vtlist;

  chDbgCheckClassI();
 800245c:	f7ff ff78 	bl	8002350 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!is_first_timer(&vtlp->dlist, &vtp->dlist)) {
 8002460:	69fb      	ldr	r3, [r7, #28]
 8002462:	483a      	ldr	r0, [pc, #232]	; (800254c <chSchGoSleepTimeoutS+0x17c>)
 8002464:	42ab      	cmp	r3, r5
 8002466:	d038      	beq.n	80024da <chSchGoSleepTimeoutS+0x10a>
    /* Removing the element from the delta list.*/
    vtp->dlist.prev->next = vtp->dlist.next;
 8002468:	9a02      	ldr	r2, [sp, #8]
 800246a:	9b01      	ldr	r3, [sp, #4]
 800246c:	6013      	str	r3, [r2, #0]
    vtp->dlist.next->prev = vtp->dlist.prev;
 800246e:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;
 8002470:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (is_timer(&vtlp->dlist, vtp->dlist.next))
 8002472:	4543      	cmp	r3, r8
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!is_first_timer(&vtlp->dlist, &vtp->dlist)) {
    /* Removing the element from the delta list.*/
    vtp->dlist.prev->next = vtp->dlist.next;
    vtp->dlist.next->prev = vtp->dlist.prev;
 8002474:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002476:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (is_timer(&vtlp->dlist, vtp->dlist.next))
 8002478:	d00f      	beq.n	800249a <chSchGoSleepTimeoutS+0xca>
      vtp->dlist.next->delta += vtp->dlist.delta;
 800247a:	6899      	ldr	r1, [r3, #8]
 800247c:	9a03      	ldr	r2, [sp, #12]
 800247e:	440a      	add	r2, r1
 8002480:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8002482:	69bb      	ldr	r3, [r7, #24]
 8002484:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8002486:	b007      	add	sp, #28
 8002488:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  virtual_timers_list_t *vtlp = &ch.vtlist;
  delta_list_t *dlp;
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800248c:	4831      	ldr	r0, [pc, #196]	; (8002554 <chSchGoSleepTimeoutS+0x184>)
 800248e:	f002 fc77 	bl	8004d80 <chSysHalt>
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8002492:	4630      	mov	r0, r6
 8002494:	f7ff ff34 	bl	8002300 <chSchGoSleepS>
 8002498:	4f2c      	ldr	r7, [pc, #176]	; (800254c <chSchGoSleepTimeoutS+0x17c>)
  }

  return currp->u.rdymsg;
 800249a:	69bb      	ldr	r3, [r7, #24]
 800249c:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 800249e:	b007      	add	sp, #28
 80024a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                             sysinterval_t deltanow) {
  delta_list_t *dlp = vtlp->dlist.next;

  /* The loop is bounded because the delta list header has the delta field
     set to (sysinterval_t)-1 which is larger than all deltas.*/
  while (dlp->delta < deltanow) {
 80024a4:	6898      	ldr	r0, [r3, #8]
 80024a6:	4285      	cmp	r5, r0
 80024a8:	d945      	bls.n	8002536 <chSchGoSleepTimeoutS+0x166>
 80024aa:	461a      	mov	r2, r3
    deltanow  -= dlp->delta;
    dlp->delta = (sysinterval_t)0;
 80024ac:	2100      	movs	r1, #0
 80024ae:	6091      	str	r1, [r2, #8]
    dlp        = dlp->next;
 80024b0:	6812      	ldr	r2, [r2, #0]
  delta_list_t *dlp = vtlp->dlist.next;

  /* The loop is bounded because the delta list header has the delta field
     set to (sysinterval_t)-1 which is larger than all deltas.*/
  while (dlp->delta < deltanow) {
    deltanow  -= dlp->delta;
 80024b2:	1a2d      	subs	r5, r5, r0
                             sysinterval_t deltanow) {
  delta_list_t *dlp = vtlp->dlist.next;

  /* The loop is bounded because the delta list header has the delta field
     set to (sysinterval_t)-1 which is larger than all deltas.*/
  while (dlp->delta < deltanow) {
 80024b4:	6890      	ldr	r0, [r2, #8]
 80024b6:	42a8      	cmp	r0, r5
 80024b8:	d3f9      	bcc.n	80024ae <chSchGoSleepTimeoutS+0xde>
    deltanow  -= dlp->delta;
    dlp->delta = (sysinterval_t)0;
    dlp        = dlp->next;
  }

  vtlp->lasttime = vtlp->lasttime + deltanow;
 80024ba:	6abc      	ldr	r4, [r7, #40]	; 0x28

  /* Adjusting next timer in the list, if any.*/
  if (is_timer(&vtlp->dlist, dlp)) {
 80024bc:	4542      	cmp	r2, r8
    deltanow  -= dlp->delta;
    dlp->delta = (sysinterval_t)0;
    dlp        = dlp->next;
  }

  vtlp->lasttime = vtlp->lasttime + deltanow;
 80024be:	442c      	add	r4, r5
 80024c0:	62bc      	str	r4, [r7, #40]	; 0x28

  /* Adjusting next timer in the list, if any.*/
  if (is_timer(&vtlp->dlist, dlp)) {
 80024c2:	d001      	beq.n	80024c8 <chSchGoSleepTimeoutS+0xf8>
    dlp->delta -= deltanow;
 80024c4:	1b45      	subs	r5, r0, r5
 80024c6:	6095      	str	r5, [r2, #8]

    /* Scenario where a very large delay exceeded the numeric range, it
       requires a special handling, the compression procedure.*/
    if (delta < deltanow) {
      vt_list_compress(vtlp, deltanow);
      delta -= deltanow;
 80024c8:	464c      	mov	r4, r9
 80024ca:	689a      	ldr	r2, [r3, #8]
 80024cc:	e7a9      	b.n	8002422 <chSchGoSleepTimeoutS+0x52>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80024ce:	4420      	add	r0, r4
 80024d0:	f005 fa2e 	bl	8007930 <stSetAlarm>
 80024d4:	69fb      	ldr	r3, [r7, #28]
 80024d6:	689a      	ldr	r2, [r3, #8]
 80024d8:	e7a3      	b.n	8002422 <chSchGoSleepTimeoutS+0x52>

    return;
  }

  /* Removing the first timer from the list.*/
  vtlp->dlist.next = vtp->dlist.next;
 80024da:	9b01      	ldr	r3, [sp, #4]
 80024dc:	61c3      	str	r3, [r0, #28]
  vtlp->dlist.next->prev = &vtlp->dlist;
  vtp->func = NULL;
 80024de:	2100      	movs	r1, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (is_vtlist_empty(&vtlp->dlist)) {
 80024e0:	4543      	cmp	r3, r8
    return;
  }

  /* Removing the first timer from the list.*/
  vtlp->dlist.next = vtp->dlist.next;
  vtlp->dlist.next->prev = &vtlp->dlist;
 80024e2:	f8c3 8004 	str.w	r8, [r3, #4]
 *
 * @notapi
 */
static inline bool is_vtlist_empty(delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
 80024e6:	461a      	mov	r2, r3
  }

  /* Removing the first timer from the list.*/
  vtlp->dlist.next = vtp->dlist.next;
  vtlp->dlist.next->prev = &vtlp->dlist;
  vtp->func = NULL;
 80024e8:	9104      	str	r1, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (is_vtlist_empty(&vtlp->dlist)) {
 80024ea:	d02a      	beq.n	8002542 <chSchGoSleepTimeoutS+0x172>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 80024ec:	9c03      	ldr	r4, [sp, #12]
 80024ee:	689b      	ldr	r3, [r3, #8]
 80024f0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80024f4:	4423      	add	r3, r4
 80024f6:	6093      	str	r3, [r2, #8]
/*  if (vtlp->dlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX());
 80024f8:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80024fa:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 80024fc:	1a12      	subs	r2, r2, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 80024fe:	4293      	cmp	r3, r2
 8002500:	d9cb      	bls.n	800249a <chSchGoSleepTimeoutS+0xca>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8002502:	1a99      	subs	r1, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002504:	2901      	cmp	r1, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002506:	bf98      	it	ls
 8002508:	1c93      	addls	r3, r2, #2
 800250a:	4418      	add	r0, r3
 800250c:	f005 fa10 	bl	8007930 <stSetAlarm>
 8002510:	e7c3      	b.n	800249a <chSchGoSleepTimeoutS+0xca>
    /* Special case where the timers list is empty.*/
    if (is_vtlist_empty(&vtlp->dlist)) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      vtlp->lasttime = now;
 8002512:	62b9      	str	r1, [r7, #40]	; 0x28
      vtlp->dlist.next = &vtp->dlist;
      vtlp->dlist.prev = &vtp->dlist;
      vtp->dlist.next = &vtlp->dlist;
      vtp->dlist.prev = &vtlp->dlist;
      vtp->dlist.delta = delay;
 8002514:	f8cd 900c 	str.w	r9, [sp, #12]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002518:	68d0      	ldr	r0, [r2, #12]
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      vtlp->lasttime = now;
      vtlp->dlist.next = &vtp->dlist;
      vtlp->dlist.prev = &vtp->dlist;
      vtp->dlist.next = &vtlp->dlist;
 800251a:	9301      	str	r3, [sp, #4]
    if (is_vtlist_empty(&vtlp->dlist)) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      vtlp->lasttime = now;
      vtlp->dlist.next = &vtp->dlist;
 800251c:	ad01      	add	r5, sp, #4
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800251e:	f010 0002 	ands.w	r0, r0, #2
      vtlp->dlist.prev = &vtp->dlist;
      vtp->dlist.next = &vtlp->dlist;
      vtp->dlist.prev = &vtlp->dlist;
 8002522:	9302      	str	r3, [sp, #8]
    if (is_vtlist_empty(&vtlp->dlist)) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      vtlp->lasttime = now;
      vtlp->dlist.next = &vtp->dlist;
 8002524:	61fd      	str	r5, [r7, #28]
      vtlp->dlist.prev = &vtp->dlist;
 8002526:	623d      	str	r5, [r7, #32]
 8002528:	d108      	bne.n	800253c <chSchGoSleepTimeoutS+0x16c>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 800252a:	4449      	add	r1, r9
static inline void st_lld_start_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
  STM32_ST_TIM->SR     = 0;
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800252c:	2302      	movs	r3, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800252e:	6351      	str	r1, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8002530:	6110      	str	r0, [r2, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002532:	60d3      	str	r3, [r2, #12]
 8002534:	e78b      	b.n	800244e <chSchGoSleepTimeoutS+0x7e>
    deltanow  -= dlp->delta;
    dlp->delta = (sysinterval_t)0;
    dlp        = dlp->next;
  }

  vtlp->lasttime = vtlp->lasttime + deltanow;
 8002536:	62b9      	str	r1, [r7, #40]	; 0x28
 8002538:	461a      	mov	r2, r3
 800253a:	e7c3      	b.n	80024c4 <chSchGoSleepTimeoutS+0xf4>
 800253c:	4806      	ldr	r0, [pc, #24]	; (8002558 <chSchGoSleepTimeoutS+0x188>)
 800253e:	f002 fc1f 	bl	8004d80 <chSysHalt>
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8002542:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002546:	60d9      	str	r1, [r3, #12]
 8002548:	e7a7      	b.n	800249a <chSchGoSleepTimeoutS+0xca>
 800254a:	bf00      	nop
 800254c:	2000b68c 	.word	0x2000b68c
 8002550:	08002781 	.word	0x08002781
 8002554:	0800cdec 	.word	0x0800cdec
 8002558:	0800cdf8 	.word	0x0800cdf8
 800255c:	00000000 	.word	0x00000000

08002560 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8002560:	b169      	cbz	r1, 800257e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
 8002562:	4b08      	ldr	r3, [pc, #32]	; (8002584 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8002564:	b410      	push	{r4}
 8002566:	4602      	mov	r2, r0
 * @notapi
 */
static inline void ch_queue_insert(ch_queue_t *p, ch_queue_t *qp) {

  p->next       = qp;
  p->prev       = qp->prev;
 8002568:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
 800256a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800256c:	2004      	movs	r0, #4
 800256e:	e883 0014 	stmia.w	r3, {r2, r4}
  p->prev->next = p;
 8002572:	6023      	str	r3, [r4, #0]
  qp->prev      = p;
 8002574:	6053      	str	r3, [r2, #4]
}
 8002576:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&currp->hdr.queue, &tqp->queue);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800257a:	f7ff bf29 	b.w	80023d0 <chSchGoSleepTimeoutS>
}
 800257e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002582:	4770      	bx	lr
 8002584:	2000b68c 	.word	0x2000b68c
	...

08002590 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 8002590:	b510      	push	{r4, lr}
 8002592:	4604      	mov	r4, r0

  chDbgCheckClassI();
 8002594:	f7ff fedc 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8002598:	b1a4      	cbz	r4, 80025c4 <chSchReadyAheadI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800259a:	f894 3020 	ldrb.w	r3, [r4, #32]
 800259e:	b18b      	cbz	r3, 80025c4 <chSchReadyAheadI+0x34>
 80025a0:	2b0f      	cmp	r3, #15
 80025a2:	d00f      	beq.n	80025c4 <chSchReadyAheadI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80025a4:	2200      	movs	r2, #0
 80025a6:	68a1      	ldr	r1, [r4, #8]

  /* Insertion in the priority queue.*/
  return (thread_t *)ch_pqueue_insert_ahead(&ch.rlist.pqueue,
 80025a8:	4b08      	ldr	r3, [pc, #32]	; (80025cc <chSchReadyAheadI+0x3c>)
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80025aa:	f884 2020 	strb.w	r2, [r4, #32]
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue.*/
  do {
    pqp = pqp->next;
 80025ae:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio > p->prio);
 80025b0:	689a      	ldr	r2, [r3, #8]
 80025b2:	428a      	cmp	r2, r1
 80025b4:	d8fb      	bhi.n	80025ae <chSchReadyAheadI+0x1e>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
 80025b6:	685a      	ldr	r2, [r3, #4]
 80025b8:	6062      	str	r2, [r4, #4]
  do {
    pqp = pqp->next;
  } while (pqp->prio > p->prio);

  /* Insertion on prev.*/
  p->next       = pqp;
 80025ba:	6023      	str	r3, [r4, #0]

  /* Insertion in the priority queue.*/
  return (thread_t *)ch_pqueue_insert_ahead(&ch.rlist.pqueue,
                                            &tp->hdr.pqueue);
}
 80025bc:	4620      	mov	r0, r4
  p->prev       = pqp->prev;
  p->prev->next = p;
 80025be:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 80025c0:	605c      	str	r4, [r3, #4]
 80025c2:	bd10      	pop	{r4, pc}
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 80025c4:	4802      	ldr	r0, [pc, #8]	; (80025d0 <chSchReadyAheadI+0x40>)
 80025c6:	f002 fbdb 	bl	8004d80 <chSysHalt>
 80025ca:	bf00      	nop
 80025cc:	2000b68c 	.word	0x2000b68c
 80025d0:	0800cdc4 	.word	0x0800cdc4
	...

080025e0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80025e0:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 80025e2:	4c10      	ldr	r4, [pc, #64]	; (8002624 <chSchDoReschedule+0x44>)
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;
 80025e4:	6823      	ldr	r3, [r4, #0]
 80025e6:	69a0      	ldr	r0, [r4, #24]

  pqp->next       = p->next;
 80025e8:	681a      	ldr	r2, [r3, #0]
 80025ea:	6022      	str	r2, [r4, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  currp->state = CH_STATE_CURRENT;
 80025ec:	2101      	movs	r1, #1
  pqp->next->prev = pqp;
 80025ee:	6054      	str	r4, [r2, #4]
 80025f0:	f883 1020 	strb.w	r1, [r3, #32]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
 80025f4:	61a3      	str	r3, [r4, #24]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 80025f6:	f7ff ffcb 	bl	8002590 <chSchReadyAheadI>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80025fa:	4601      	mov	r1, r0
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 80025fc:	4605      	mov	r5, r0
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80025fe:	69a0      	ldr	r0, [r4, #24]
 8002600:	f7ff fe4e 	bl	80022a0 <_trace_switch>
 8002604:	f3ef 8309 	mrs	r3, PSP
 8002608:	69ea      	ldr	r2, [r5, #28]
 800260a:	3b64      	subs	r3, #100	; 0x64
 800260c:	429a      	cmp	r2, r3
 800260e:	d805      	bhi.n	800261c <chSchDoReschedule+0x3c>
 8002610:	69a0      	ldr	r0, [r4, #24]
 8002612:	4629      	mov	r1, r5
}
 8002614:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002618:	f7fd be76 	b.w	8000308 <_port_switch>
 800261c:	4802      	ldr	r0, [pc, #8]	; (8002628 <chSchDoReschedule+0x48>)
 800261e:	f002 fbaf 	bl	8004d80 <chSysHalt>
 8002622:	bf00      	nop
 8002624:	2000b68c 	.word	0x2000b68c
 8002628:	0800cd8c 	.word	0x0800cd8c
 800262c:	00000000 	.word	0x00000000

08002630 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8002630:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.pqueue) > currp->hdr.pqueue.prio;
 8002632:	4c14      	ldr	r4, [pc, #80]	; (8002684 <chSchRescheduleS+0x54>)

  chDbgCheckClassS();
 8002634:	f7ff fe54 	bl	80022e0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8002638:	f7ff fe8a 	bl	8002350 <chDbgCheckClassI>

  return firstprio(&ch.rlist.pqueue) > currp->hdr.pqueue.prio;
 800263c:	6823      	ldr	r3, [r4, #0]
 800263e:	69a0      	ldr	r0, [r4, #24]

  if (chSchIsRescRequiredI()) {
 8002640:	6899      	ldr	r1, [r3, #8]
 8002642:	6882      	ldr	r2, [r0, #8]
 8002644:	4291      	cmp	r1, r2
 8002646:	d800      	bhi.n	800264a <chSchRescheduleS+0x1a>
 8002648:	bd38      	pop	{r3, r4, r5, pc}
 * @notapi
 */
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
  ch_priority_queue_t *p = pqp->next;

  pqp->next       = p->next;
 800264a:	681a      	ldr	r2, [r3, #0]
 800264c:	6022      	str	r2, [r4, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  currp->state = CH_STATE_CURRENT;
 800264e:	2101      	movs	r1, #1
  pqp->next->prev = pqp;
 8002650:	6054      	str	r4, [r2, #4]
 8002652:	f883 1020 	strb.w	r1, [r3, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
 8002656:	61a3      	str	r3, [r4, #24]
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8002658:	f7ff ff9a 	bl	8002590 <chSchReadyAheadI>

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800265c:	4601      	mov	r1, r0
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 800265e:	4605      	mov	r5, r0

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002660:	69a0      	ldr	r0, [r4, #24]
 8002662:	f7ff fe1d 	bl	80022a0 <_trace_switch>
 8002666:	f3ef 8309 	mrs	r3, PSP
 800266a:	69ea      	ldr	r2, [r5, #28]
 800266c:	3b64      	subs	r3, #100	; 0x64
 800266e:	429a      	cmp	r2, r3
 8002670:	d805      	bhi.n	800267e <chSchRescheduleS+0x4e>
 8002672:	69a0      	ldr	r0, [r4, #24]
 8002674:	4629      	mov	r1, r5
  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
  }
}
 8002676:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800267a:	f7fd be45 	b.w	8000308 <_port_switch>
 800267e:	4802      	ldr	r0, [pc, #8]	; (8002688 <chSchRescheduleS+0x58>)
 8002680:	f002 fb7e 	bl	8004d80 <chSysHalt>
 8002684:	2000b68c 	.word	0x2000b68c
 8002688:	0800cd8c 	.word	0x0800cd8c
 800268c:	00000000 	.word	0x00000000

08002690 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8002690:	b510      	push	{r4, lr}
 8002692:	4604      	mov	r4, r0

  chDbgCheckClassI();
 8002694:	f7ff fe5c 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8002698:	b1a4      	cbz	r4, 80026c4 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800269a:	f894 3020 	ldrb.w	r3, [r4, #32]
 800269e:	b18b      	cbz	r3, 80026c4 <chSchReadyI+0x34>
 80026a0:	2b0f      	cmp	r3, #15
 80026a2:	d00f      	beq.n	80026c4 <chSchReadyI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80026a4:	2200      	movs	r2, #0
 80026a6:	68a1      	ldr	r1, [r4, #8]

  /* Insertion in the priority queue.*/
  return (thread_t *)ch_pqueue_insert_behind(&ch.rlist.pqueue,
 80026a8:	4b08      	ldr	r3, [pc, #32]	; (80026cc <chSchReadyI+0x3c>)
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80026aa:	f884 2020 	strb.w	r2, [r4, #32]
static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue.*/
  do {
    pqp = pqp->next;
 80026ae:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
 80026b0:	689a      	ldr	r2, [r3, #8]
 80026b2:	428a      	cmp	r2, r1
 80026b4:	d2fb      	bcs.n	80026ae <chSchReadyI+0x1e>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
 80026b6:	685a      	ldr	r2, [r3, #4]
 80026b8:	6062      	str	r2, [r4, #4]
  do {
    pqp = pqp->next;
  } while (pqp->prio >= p->prio);

  /* Insertion on prev.*/
  p->next       = pqp;
 80026ba:	6023      	str	r3, [r4, #0]

  /* Insertion in the priority queue.*/
  return (thread_t *)ch_pqueue_insert_behind(&ch.rlist.pqueue,
                                             &tp->hdr.pqueue);
}
 80026bc:	4620      	mov	r0, r4
  p->prev       = pqp->prev;
  p->prev->next = p;
 80026be:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 80026c0:	605c      	str	r4, [r3, #4]
 80026c2:	bd10      	pop	{r4, pc}
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 80026c4:	4802      	ldr	r0, [pc, #8]	; (80026d0 <chSchReadyI+0x40>)
 80026c6:	f002 fb5b 	bl	8004d80 <chSysHalt>
 80026ca:	bf00      	nop
 80026cc:	2000b68c 	.word	0x2000b68c
 80026d0:	0800cdac 	.word	0x0800cdac
	...

080026e0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80026e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80026e4:	4606      	mov	r6, r0
 80026e6:	4688      	mov	r8, r1
  event_listener_t *elp;

  chDbgCheckClassI();
 80026e8:	f7ff fe32 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 80026ec:	2e00      	cmp	r6, #0
 80026ee:	d03a      	beq.n	8002766 <chEvtBroadcastFlagsI+0x86>

  elp = esp->next;
 80026f0:	6834      	ldr	r4, [r6, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80026f2:	42a6      	cmp	r6, r4
 80026f4:	d02a      	beq.n	800274c <chEvtBroadcastFlagsI+0x6c>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80026f6:	2700      	movs	r7, #0
 80026f8:	e002      	b.n	8002700 <chEvtBroadcastFlagsI+0x20>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80026fa:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80026fc:	42a6      	cmp	r6, r4
 80026fe:	d025      	beq.n	800274c <chEvtBroadcastFlagsI+0x6c>
  /*lint -restore*/
    elp->flags |= flags;
 8002700:	68e3      	ldr	r3, [r4, #12]
 8002702:	ea43 0308 	orr.w	r3, r3, r8
 8002706:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8002708:	f1b8 0f00 	cmp.w	r8, #0
 800270c:	d003      	beq.n	8002716 <chEvtBroadcastFlagsI+0x36>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 800270e:	6923      	ldr	r3, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8002710:	ea18 0f03 	tst.w	r8, r3
 8002714:	d0f1      	beq.n	80026fa <chEvtBroadcastFlagsI+0x1a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8002716:	6865      	ldr	r5, [r4, #4]
 8002718:	f8d4 9008 	ldr.w	r9, [r4, #8]
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 800271c:	f7ff fe18 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8002720:	b1f5      	cbz	r5, 8002760 <chEvtBroadcastFlagsI+0x80>

  tp->epending |= events;
 8002722:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002724:	f895 2020 	ldrb.w	r2, [r5, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8002728:	ea49 0303 	orr.w	r3, r9, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800272c:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 800272e:	636b      	str	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002730:	d00e      	beq.n	8002750 <chEvtBroadcastFlagsI+0x70>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002732:	2a0b      	cmp	r2, #11
 8002734:	d1e1      	bne.n	80026fa <chEvtBroadcastFlagsI+0x1a>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8002736:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8002738:	4013      	ands	r3, r2

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 800273a:	429a      	cmp	r2, r3
 800273c:	d1dd      	bne.n	80026fa <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800273e:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002740:	4628      	mov	r0, r5
 8002742:	f7ff ffa5 	bl	8002690 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8002746:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002748:	42a6      	cmp	r6, r4
 800274a:	d1d9      	bne.n	8002700 <chEvtBroadcastFlagsI+0x20>
 800274c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002750:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002752:	4213      	tst	r3, r2
 8002754:	d0d1      	beq.n	80026fa <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8002756:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002758:	4628      	mov	r0, r5
 800275a:	f7ff ff99 	bl	8002690 <chSchReadyI>
 800275e:	e7f2      	b.n	8002746 <chEvtBroadcastFlagsI+0x66>
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8002760:	4802      	ldr	r0, [pc, #8]	; (800276c <chEvtBroadcastFlagsI+0x8c>)
 8002762:	f002 fb0d 	bl	8004d80 <chSysHalt>
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);
 8002766:	4802      	ldr	r0, [pc, #8]	; (8002770 <chEvtBroadcastFlagsI+0x90>)
 8002768:	f002 fb0a 	bl	8004d80 <chSysHalt>
 800276c:	0800cd58 	.word	0x0800cd58
 8002770:	0800cd34 	.word	0x0800cd34
	...

08002780 <wakeup>:
/*===========================================================================*/

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8002780:	b538      	push	{r3, r4, r5, lr}
 8002782:	4604      	mov	r4, r0
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002784:	2320      	movs	r3, #32
 8002786:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800278a:	f002 fb49 	bl	8004e20 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 800278e:	f894 3020 	ldrb.w	r3, [r4, #32]
 8002792:	2b07      	cmp	r3, #7
 8002794:	d810      	bhi.n	80027b8 <wakeup+0x38>
 8002796:	e8df f003 	tbb	[pc, r3]
 800279a:	0f15      	.short	0x0f15
 800279c:	040a1b0f 	.word	0x040a1b0f
 80027a0:	0a0f      	.short	0x0a0f
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80027a2:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 80027a4:	f7ff fdd4 	bl	8002350 <chDbgCheckClassI>

  sp->cnt++;
 80027a8:	68ab      	ldr	r3, [r5, #8]
 80027aa:	3301      	adds	r3, #1
 80027ac:	60ab      	str	r3, [r5, #8]
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
 80027ae:	e894 000c 	ldmia.w	r4, {r2, r3}
 80027b2:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 80027b4:	6822      	ldr	r2, [r4, #0]
 80027b6:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80027b8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80027bc:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 80027be:	4620      	mov	r0, r4
 80027c0:	f7ff ff66 	bl	8002690 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80027c4:	f002 fb14 	bl	8004df0 <_dbg_check_unlock_from_isr>
 80027c8:	2300      	movs	r3, #0
 80027ca:	f383 8811 	msr	BASEPRI, r3
 80027ce:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80027d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80027d2:	2200      	movs	r2, #0
 80027d4:	601a      	str	r2, [r3, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80027d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80027da:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 80027dc:	4620      	mov	r0, r4
 80027de:	f7ff ff57 	bl	8002690 <chSchReadyI>
 80027e2:	e7ef      	b.n	80027c4 <wakeup+0x44>
	...

080027f0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 80027f0:	b508      	push	{r3, lr}
 80027f2:	2320      	movs	r3, #32
 80027f4:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80027f8:	4a06      	ldr	r2, [pc, #24]	; (8002814 <_dbg_check_leave_isr+0x24>)
 80027fa:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80027fc:	2b00      	cmp	r3, #0
 80027fe:	dd01      	ble.n	8002804 <_dbg_check_leave_isr+0x14>
 8002800:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002802:	b111      	cbz	r1, 800280a <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 8002804:	4804      	ldr	r0, [pc, #16]	; (8002818 <_dbg_check_leave_isr+0x28>)
 8002806:	f002 fabb 	bl	8004d80 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800280a:	3b01      	subs	r3, #1
 800280c:	6313      	str	r3, [r2, #48]	; 0x30
 800280e:	f381 8811 	msr	BASEPRI, r1
 8002812:	bd08      	pop	{r3, pc}
 8002814:	2000b68c 	.word	0x2000b68c
 8002818:	0800cda4 	.word	0x0800cda4
 800281c:	00000000 	.word	0x00000000

08002820 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8002820:	b508      	push	{r3, lr}
 8002822:	4605      	mov	r5, r0
 8002824:	2320      	movs	r3, #32
 8002826:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800282a:	f002 fb21 	bl	8004e70 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 800282e:	4b10      	ldr	r3, [pc, #64]	; (8002870 <chThdExit+0x50>)
 8002830:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool ch_list_notempty(ch_list_t *lp) {

  return (bool)(lp->next != lp);
 8002832:	6aa0      	ldr	r0, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8002834:	6265      	str	r5, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (ch_list_notempty(&tp->waiting)) {
 8002836:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800283a:	42a8      	cmp	r0, r5
 800283c:	d006      	beq.n	800284c <chThdExit+0x2c>
 * @notapi
 */
static inline ch_list_t *ch_list_pop(ch_list_t *lp) {

  ch_list_t *p = lp->next;
  lp->next = p->next;
 800283e:	6803      	ldr	r3, [r0, #0]
 8002840:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI((thread_t *)ch_list_pop(&tp->waiting));
 8002842:	f7ff ff25 	bl	8002690 <chSchReadyI>
 *
 * @notapi
 */
static inline bool ch_list_notempty(ch_list_t *lp) {

  return (bool)(lp->next != lp);
 8002846:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (ch_list_notempty(&tp->waiting)) {
 8002848:	42a8      	cmp	r0, r5
 800284a:	d1f8      	bne.n	800283e <chThdExit+0x1e>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800284c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002850:	b943      	cbnz	r3, 8002864 <chThdExit+0x44>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8002852:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8002856:	079b      	lsls	r3, r3, #30
 8002858:	d104      	bne.n	8002864 <chThdExit+0x44>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800285a:	6963      	ldr	r3, [r4, #20]
 800285c:	6922      	ldr	r2, [r4, #16]
 800285e:	611a      	str	r2, [r3, #16]
 8002860:	6922      	ldr	r2, [r4, #16]
 8002862:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8002864:	200f      	movs	r0, #15
 8002866:	f7ff fd4b 	bl	8002300 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800286a:	4802      	ldr	r0, [pc, #8]	; (8002874 <chThdExit+0x54>)
 800286c:	f002 fa88 	bl	8004d80 <chSysHalt>
 8002870:	2000b68c 	.word	0x2000b68c
 8002874:	0800cdb8 	.word	0x0800cdb8
	...

08002880 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8002880:	b538      	push	{r3, r4, r5, lr}
 8002882:	4604      	mov	r4, r0
 8002884:	460d      	mov	r5, r1
 8002886:	2320      	movs	r3, #32
 8002888:	f383 8811 	msr	BASEPRI, r3
 800288c:	f002 faf0 	bl	8004e70 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8002890:	f7ff fd5e 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 8002894:	b124      	cbz	r4, 80028a0 <chPoolFree+0x20>
 8002896:	b11d      	cbz	r5, 80028a0 <chPoolFree+0x20>
 8002898:	68a3      	ldr	r3, [r4, #8]
 800289a:	3b01      	subs	r3, #1
 800289c:	421d      	tst	r5, r3
 800289e:	d002      	beq.n	80028a6 <chPoolFree+0x26>
 80028a0:	480b      	ldr	r0, [pc, #44]	; (80028d0 <chPoolFree+0x50>)
 80028a2:	f002 fa6d 	bl	8004d80 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80028a6:	6823      	ldr	r3, [r4, #0]
 80028a8:	602b      	str	r3, [r5, #0]
  mp->next = php;
 80028aa:	6025      	str	r5, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80028ac:	f002 fad0 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80028b0:	4b08      	ldr	r3, [pc, #32]	; (80028d4 <chPoolFree+0x54>)
 80028b2:	681a      	ldr	r2, [r3, #0]
 80028b4:	429a      	cmp	r2, r3
 80028b6:	d004      	beq.n	80028c2 <chPoolFree+0x42>
 80028b8:	6999      	ldr	r1, [r3, #24]
 80028ba:	6893      	ldr	r3, [r2, #8]
 80028bc:	688a      	ldr	r2, [r1, #8]
 80028be:	429a      	cmp	r2, r3
 80028c0:	d303      	bcc.n	80028ca <chPoolFree+0x4a>
 80028c2:	2300      	movs	r3, #0
 80028c4:	f383 8811 	msr	BASEPRI, r3
 80028c8:	bd38      	pop	{r3, r4, r5, pc}
 80028ca:	4803      	ldr	r0, [pc, #12]	; (80028d8 <chPoolFree+0x58>)
 80028cc:	f002 fa58 	bl	8004d80 <chSysHalt>
 80028d0:	0800cd00 	.word	0x0800cd00
 80028d4:	2000b68c 	.word	0x2000b68c
 80028d8:	0800ce20 	.word	0x0800ce20
 80028dc:	00000000 	.word	0x00000000

080028e0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80028e0:	b570      	push	{r4, r5, r6, lr}
 80028e2:	2320      	movs	r3, #32
 80028e4:	4606      	mov	r6, r0
 80028e6:	460d      	mov	r5, r1
 80028e8:	4614      	mov	r4, r2
 80028ea:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80028ee:	f002 fabf 	bl	8004e70 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
 80028f2:	4622      	mov	r2, r4
 80028f4:	4629      	mov	r1, r5
 80028f6:	4630      	mov	r0, r6
 80028f8:	f7ff fd3a 	bl	8002370 <chCoreAllocFromTopI>
 80028fc:	4604      	mov	r4, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80028fe:	f002 faa7 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8002902:	4b08      	ldr	r3, [pc, #32]	; (8002924 <chCoreAllocFromTop+0x44>)
 8002904:	681a      	ldr	r2, [r3, #0]
 8002906:	429a      	cmp	r2, r3
 8002908:	d004      	beq.n	8002914 <chCoreAllocFromTop+0x34>
 800290a:	6999      	ldr	r1, [r3, #24]
 800290c:	6893      	ldr	r3, [r2, #8]
 800290e:	688a      	ldr	r2, [r1, #8]
 8002910:	429a      	cmp	r2, r3
 8002912:	d304      	bcc.n	800291e <chCoreAllocFromTop+0x3e>
 8002914:	2300      	movs	r3, #0
 8002916:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 800291a:	4620      	mov	r0, r4
 800291c:	bd70      	pop	{r4, r5, r6, pc}
 800291e:	4802      	ldr	r0, [pc, #8]	; (8002928 <chCoreAllocFromTop+0x48>)
 8002920:	f002 fa2e 	bl	8004d80 <chSysHalt>
 8002924:	2000b68c 	.word	0x2000b68c
 8002928:	0800d4f4 	.word	0x0800d4f4
 800292c:	00000000 	.word	0x00000000

08002930 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8002930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002934:	2320      	movs	r3, #32
 8002936:	b085      	sub	sp, #20
 8002938:	4607      	mov	r7, r0
 800293a:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 800293e:	4db2      	ldr	r5, [pc, #712]	; (8002c08 <chRegFindThreadByWorkingArea+0x2d8>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002940:	f002 fa96 	bl	8004e70 <_dbg_check_lock>
 8002944:	f8d5 9010 	ldr.w	r9, [r5, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8002948:	f899 3022 	ldrb.w	r3, [r9, #34]	; 0x22
 800294c:	3301      	adds	r3, #1
 800294e:	f889 3022 	strb.w	r3, [r9, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002952:	f002 fa7d 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8002956:	682b      	ldr	r3, [r5, #0]
 8002958:	42ab      	cmp	r3, r5
 800295a:	d004      	beq.n	8002966 <chRegFindThreadByWorkingArea+0x36>
 800295c:	69aa      	ldr	r2, [r5, #24]
 800295e:	689b      	ldr	r3, [r3, #8]
 8002960:	6892      	ldr	r2, [r2, #8]
 8002962:	429a      	cmp	r2, r3
 8002964:	d34a      	bcc.n	80029fc <chRegFindThreadByWorkingArea+0xcc>
 8002966:	f04f 0a00 	mov.w	sl, #0
 800296a:	f38a 8811 	msr	BASEPRI, sl
 800296e:	f8df 8298 	ldr.w	r8, [pc, #664]	; 8002c08 <chRegFindThreadByWorkingArea+0x2d8>
 8002972:	2620      	movs	r6, #32
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8002974:	f8d9 301c 	ldr.w	r3, [r9, #28]
 8002978:	42bb      	cmp	r3, r7
 800297a:	f000 80ca 	beq.w	8002b12 <chRegFindThreadByWorkingArea+0x1e2>
 800297e:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002982:	f002 fa75 	bl	8004e70 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8002986:	f8d9 4010 	ldr.w	r4, [r9, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800298a:	42ac      	cmp	r4, r5
 800298c:	f000 80c5 	beq.w	8002b1a <chRegFindThreadByWorkingArea+0x1ea>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002990:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002994:	2bff      	cmp	r3, #255	; 0xff
 8002996:	d04d      	beq.n	8002a34 <chRegFindThreadByWorkingArea+0x104>
    ntp->refs++;
 8002998:	3301      	adds	r3, #1
 800299a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800299e:	f002 fa57 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80029a2:	682b      	ldr	r3, [r5, #0]
 80029a4:	42ab      	cmp	r3, r5
 80029a6:	d005      	beq.n	80029b4 <chRegFindThreadByWorkingArea+0x84>
 80029a8:	f8d8 2018 	ldr.w	r2, [r8, #24]
 80029ac:	689b      	ldr	r3, [r3, #8]
 80029ae:	6892      	ldr	r2, [r2, #8]
 80029b0:	429a      	cmp	r2, r3
 80029b2:	d323      	bcc.n	80029fc <chRegFindThreadByWorkingArea+0xcc>
 80029b4:	f38a 8811 	msr	BASEPRI, sl
 80029b8:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80029bc:	f002 fa58 	bl	8004e70 <_dbg_check_lock>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80029c0:	f899 3022 	ldrb.w	r3, [r9, #34]	; 0x22
 80029c4:	b39b      	cbz	r3, 8002a2e <chRegFindThreadByWorkingArea+0xfe>
  tp->refs--;
 80029c6:	3b01      	subs	r3, #1
 80029c8:	f889 3022 	strb.w	r3, [r9, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80029cc:	f8d9 3020 	ldr.w	r3, [r9, #32]
 80029d0:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 80029d4:	2b0f      	cmp	r3, #15
 80029d6:	d014      	beq.n	8002a02 <chRegFindThreadByWorkingArea+0xd2>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80029d8:	f002 fa3a 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80029dc:	682b      	ldr	r3, [r5, #0]
 80029de:	42ab      	cmp	r3, r5
 80029e0:	d005      	beq.n	80029ee <chRegFindThreadByWorkingArea+0xbe>
 80029e2:	f8d8 2018 	ldr.w	r2, [r8, #24]
 80029e6:	689b      	ldr	r3, [r3, #8]
 80029e8:	6892      	ldr	r2, [r2, #8]
 80029ea:	429a      	cmp	r2, r3
 80029ec:	d31c      	bcc.n	8002a28 <chRegFindThreadByWorkingArea+0xf8>
 80029ee:	f38a 8811 	msr	BASEPRI, sl
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 80029f2:	2c00      	cmp	r4, #0
 80029f4:	f000 8096 	beq.w	8002b24 <chRegFindThreadByWorkingArea+0x1f4>
 80029f8:	46a1      	mov	r9, r4
 80029fa:	e7bb      	b.n	8002974 <chRegFindThreadByWorkingArea+0x44>
 80029fc:	4883      	ldr	r0, [pc, #524]	; (8002c0c <chRegFindThreadByWorkingArea+0x2dc>)
 80029fe:	f002 f9bf 	bl	8004d80 <chSysHalt>
    REG_REMOVE(tp);
 8002a02:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8002a06:	f8d9 2010 	ldr.w	r2, [r9, #16]
 8002a0a:	611a      	str	r2, [r3, #16]
 8002a0c:	f8d9 2010 	ldr.w	r2, [r9, #16]
 8002a10:	6153      	str	r3, [r2, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002a12:	f002 fa1d 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8002a16:	682b      	ldr	r3, [r5, #0]
 8002a18:	42ab      	cmp	r3, r5
 8002a1a:	d00e      	beq.n	8002a3a <chRegFindThreadByWorkingArea+0x10a>
 8002a1c:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8002a20:	689b      	ldr	r3, [r3, #8]
 8002a22:	6892      	ldr	r2, [r2, #8]
 8002a24:	429a      	cmp	r2, r3
 8002a26:	d208      	bcs.n	8002a3a <chRegFindThreadByWorkingArea+0x10a>
 8002a28:	4879      	ldr	r0, [pc, #484]	; (8002c10 <chRegFindThreadByWorkingArea+0x2e0>)
 8002a2a:	f002 f9a9 	bl	8004d80 <chSysHalt>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8002a2e:	4879      	ldr	r0, [pc, #484]	; (8002c14 <chRegFindThreadByWorkingArea+0x2e4>)
 8002a30:	f002 f9a6 	bl	8004d80 <chSysHalt>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002a34:	4878      	ldr	r0, [pc, #480]	; (8002c18 <chRegFindThreadByWorkingArea+0x2e8>)
 8002a36:	f002 f9a3 	bl	8004d80 <chSysHalt>
 8002a3a:	f38a 8811 	msr	BASEPRI, sl
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8002a3e:	f899 3021 	ldrb.w	r3, [r9, #33]	; 0x21
 8002a42:	f003 0303 	and.w	r3, r3, #3
 8002a46:	2b01      	cmp	r3, #1
 8002a48:	d008      	beq.n	8002a5c <chRegFindThreadByWorkingArea+0x12c>
 8002a4a:	2b02      	cmp	r3, #2
 8002a4c:	d1d1      	bne.n	80029f2 <chRegFindThreadByWorkingArea+0xc2>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8002a4e:	f8d9 0040 	ldr.w	r0, [r9, #64]	; 0x40
 8002a52:	f8d9 101c 	ldr.w	r1, [r9, #28]
 8002a56:	f7ff ff13 	bl	8002880 <chPoolFree>
 8002a5a:	e7ca      	b.n	80029f2 <chRegFindThreadByWorkingArea+0xc2>
 8002a5c:	f8d9 101c 	ldr.w	r1, [r9, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8002a60:	2900      	cmp	r1, #0
 8002a62:	d05c      	beq.n	8002b1e <chRegFindThreadByWorkingArea+0x1ee>
 8002a64:	074b      	lsls	r3, r1, #29
 8002a66:	d15a      	bne.n	8002b1e <chRegFindThreadByWorkingArea+0x1ee>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8002a68:	e911 000c 	ldmdb	r1, {r2, r3}
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002a6c:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002a6e:	08db      	lsrs	r3, r3, #3
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8002a70:	9201      	str	r2, [sp, #4]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002a72:	f841 3c04 	str.w	r3, [r1, #-4]
 8002a76:	9102      	str	r1, [sp, #8]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8002a78:	f102 0b0c 	add.w	fp, r2, #12
 8002a7c:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002a80:	f002 f9f6 	bl	8004e70 <_dbg_check_lock>
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *currtp = chThdGetSelfX();

  chDbgCheckClassS();
 8002a84:	f7ff fc2c 	bl	80022e0 <chDbgCheckClassS>
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002a88:	f8d5 9018 	ldr.w	r9, [r5, #24]
  chDbgCheck(mp != NULL);
 8002a8c:	9902      	ldr	r1, [sp, #8]
 8002a8e:	f1bb 0f00 	cmp.w	fp, #0
 8002a92:	d02d      	beq.n	8002af0 <chRegFindThreadByWorkingArea+0x1c0>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8002a94:	9b01      	ldr	r3, [sp, #4]
 8002a96:	6958      	ldr	r0, [r3, #20]
 8002a98:	2800      	cmp	r0, #0
 8002a9a:	f000 80ac 	beq.w	8002bf6 <chRegFindThreadByWorkingArea+0x2c6>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8002a9e:	f8d9 2008 	ldr.w	r2, [r9, #8]
 8002aa2:	6883      	ldr	r3, [r0, #8]
 8002aa4:	4293      	cmp	r3, r2
 8002aa6:	d207      	bcs.n	8002ab8 <chRegFindThreadByWorkingArea+0x188>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8002aa8:	f890 3020 	ldrb.w	r3, [r0, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 8002aac:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8002aae:	2b06      	cmp	r3, #6
 8002ab0:	d052      	beq.n	8002b58 <chRegFindThreadByWorkingArea+0x228>
 8002ab2:	2b07      	cmp	r3, #7
 8002ab4:	d038      	beq.n	8002b28 <chRegFindThreadByWorkingArea+0x1f8>
 8002ab6:	b1f3      	cbz	r3, 8002af6 <chRegFindThreadByWorkingArea+0x1c6>
        }
        break;
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&currtp->hdr.queue, &mp->queue);
 8002ab8:	465a      	mov	r2, fp
 8002aba:	e004      	b.n	8002ac6 <chRegFindThreadByWorkingArea+0x196>
static inline void ch_sch_prio_insert(ch_queue_t *tp, ch_queue_t *qp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 8002abc:	6890      	ldr	r0, [r2, #8]
 8002abe:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8002ac2:	4298      	cmp	r0, r3
 8002ac4:	d302      	bcc.n	8002acc <chRegFindThreadByWorkingArea+0x19c>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *tp, ch_queue_t *qp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
 8002ac6:	6812      	ldr	r2, [r2, #0]
  } while ((cp != qp) &&
           (((thread_t *)cp)->hdr.pqueue.prio >= ((thread_t *)tp)->hdr.pqueue.prio));
 8002ac8:	4593      	cmp	fp, r2
 8002aca:	d1f7      	bne.n	8002abc <chRegFindThreadByWorkingArea+0x18c>
  tp->next       = cp;
  tp->prev       = cp->prev;
 8002acc:	6853      	ldr	r3, [r2, #4]
 8002ace:	9102      	str	r1, [sp, #8]
 8002ad0:	e889 000c 	stmia.w	r9, {r2, r3}
      currtp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8002ad4:	2006      	movs	r0, #6
  tp->prev->next = tp;
 8002ad6:	f8c3 9000 	str.w	r9, [r3]
  cp->prev       = tp;
 8002ada:	f8c2 9004 	str.w	r9, [r2, #4]
        break;
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&currtp->hdr.queue, &mp->queue);
      currtp->u.wtmtxp = mp;
 8002ade:	f8c9 b024 	str.w	fp, [r9, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8002ae2:	f7ff fc0d 	bl	8002300 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
 8002ae6:	9b01      	ldr	r3, [sp, #4]
 8002ae8:	9902      	ldr	r1, [sp, #8]
 8002aea:	695b      	ldr	r3, [r3, #20]
 8002aec:	4599      	cmp	r9, r3
 8002aee:	d052      	beq.n	8002b96 <chRegFindThreadByWorkingArea+0x266>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *currtp = chThdGetSelfX();

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 8002af0:	484a      	ldr	r0, [pc, #296]	; (8002c1c <chRegFindThreadByWorkingArea+0x2ec>)
 8002af2:	f002 f945 	bl	8004d80 <chSysHalt>
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
 8002af6:	6842      	ldr	r2, [r0, #4]
 8002af8:	6803      	ldr	r3, [r0, #0]
 8002afa:	9102      	str	r1, [sp, #8]
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 8002afc:	f04f 0e01 	mov.w	lr, #1
 8002b00:	f880 e020 	strb.w	lr, [r0, #32]
 8002b04:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002b06:	6803      	ldr	r3, [r0, #0]
 8002b08:	605a      	str	r2, [r3, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI((thread_t *)ch_queue_dequeue(&tp->hdr.queue));
 8002b0a:	f7ff fdc1 	bl	8002690 <chSchReadyI>
 8002b0e:	9902      	ldr	r1, [sp, #8]
 8002b10:	e7d2      	b.n	8002ab8 <chRegFindThreadByWorkingArea+0x188>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8002b12:	4648      	mov	r0, r9
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
}
 8002b14:	b005      	add	sp, #20
 8002b16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8002b1a:	2400      	movs	r4, #0
 8002b1c:	e73f      	b.n	800299e <chRegFindThreadByWorkingArea+0x6e>
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8002b1e:	4840      	ldr	r0, [pc, #256]	; (8002c20 <chRegFindThreadByWorkingArea+0x2f0>)
 8002b20:	f002 f92e 	bl	8004d80 <chSysHalt>
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
 8002b24:	4620      	mov	r0, r4
 8002b26:	e7f5      	b.n	8002b14 <chRegFindThreadByWorkingArea+0x1e4>
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
 8002b28:	6842      	ldr	r2, [r0, #4]
 8002b2a:	6803      	ldr	r3, [r0, #0]
 8002b2c:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002b2e:	6803      	ldr	r3, [r0, #0]
 8002b30:	605a      	str	r2, [r3, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          ch_sch_prio_insert(ch_queue_dequeue(&tp->hdr.queue),
 8002b32:	6a43      	ldr	r3, [r0, #36]	; 0x24
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *tp, ch_queue_t *qp) {

  ch_queue_t *cp = qp;
 8002b34:	468c      	mov	ip, r1
 8002b36:	461a      	mov	r2, r3
 8002b38:	e004      	b.n	8002b44 <chRegFindThreadByWorkingArea+0x214>
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 8002b3a:	6891      	ldr	r1, [r2, #8]
 8002b3c:	468e      	mov	lr, r1
 8002b3e:	6881      	ldr	r1, [r0, #8]
 8002b40:	458e      	cmp	lr, r1
 8002b42:	d302      	bcc.n	8002b4a <chRegFindThreadByWorkingArea+0x21a>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *tp, ch_queue_t *qp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
 8002b44:	6812      	ldr	r2, [r2, #0]
  } while ((cp != qp) &&
           (((thread_t *)cp)->hdr.pqueue.prio >= ((thread_t *)tp)->hdr.pqueue.prio));
 8002b46:	4293      	cmp	r3, r2
 8002b48:	d1f7      	bne.n	8002b3a <chRegFindThreadByWorkingArea+0x20a>
  tp->next       = cp;
  tp->prev       = cp->prev;
 8002b4a:	6853      	ldr	r3, [r2, #4]
 8002b4c:	4661      	mov	r1, ip
 8002b4e:	e880 000c 	stmia.w	r0, {r2, r3}
  tp->prev->next = tp;
 8002b52:	6018      	str	r0, [r3, #0]
  cp->prev       = tp;
 8002b54:	6050      	str	r0, [r2, #4]
 8002b56:	e7af      	b.n	8002ab8 <chRegFindThreadByWorkingArea+0x188>
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
 8002b58:	6842      	ldr	r2, [r0, #4]
 8002b5a:	6803      	ldr	r3, [r0, #0]
 8002b5c:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002b5e:	6803      	ldr	r3, [r0, #0]
 8002b60:	605a      	str	r2, [r3, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(ch_queue_dequeue(&tp->hdr.queue),
 8002b62:	6a43      	ldr	r3, [r0, #36]	; 0x24
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *tp, ch_queue_t *qp) {

  ch_queue_t *cp = qp;
 8002b64:	468c      	mov	ip, r1
 8002b66:	461a      	mov	r2, r3
 8002b68:	e004      	b.n	8002b74 <chRegFindThreadByWorkingArea+0x244>
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 8002b6a:	6891      	ldr	r1, [r2, #8]
 8002b6c:	468e      	mov	lr, r1
 8002b6e:	6881      	ldr	r1, [r0, #8]
 8002b70:	458e      	cmp	lr, r1
 8002b72:	d302      	bcc.n	8002b7a <chRegFindThreadByWorkingArea+0x24a>
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *tp, ch_queue_t *qp) {

  ch_queue_t *cp = qp;
  do {
    cp = cp->next;
 8002b74:	6812      	ldr	r2, [r2, #0]
  } while ((cp != qp) &&
           (((thread_t *)cp)->hdr.pqueue.prio >= ((thread_t *)tp)->hdr.pqueue.prio));
 8002b76:	4293      	cmp	r3, r2
 8002b78:	d1f7      	bne.n	8002b6a <chRegFindThreadByWorkingArea+0x23a>
  tp->next       = cp;
  tp->prev       = cp->prev;
 8002b7a:	6853      	ldr	r3, [r2, #4]
 8002b7c:	e880 000c 	stmia.w	r0, {r2, r3}
  tp->prev->next = tp;
 8002b80:	6018      	str	r0, [r3, #0]
  cp->prev       = tp;
 8002b82:	6050      	str	r0, [r2, #4]
                             &tp->u.wtmtxp->queue);
          tp = tp->u.wtmtxp->owner;
 8002b84:	6a43      	ldr	r3, [r0, #36]	; 0x24
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8002b86:	f8d9 2008 	ldr.w	r2, [r9, #8]
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          ch_sch_prio_insert(ch_queue_dequeue(&tp->hdr.queue),
                             &tp->u.wtmtxp->queue);
          tp = tp->u.wtmtxp->owner;
 8002b8a:	6898      	ldr	r0, [r3, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8002b8c:	6883      	ldr	r3, [r0, #8]
 8002b8e:	429a      	cmp	r2, r3
 8002b90:	4661      	mov	r1, ip
 8002b92:	d889      	bhi.n	8002aa8 <chRegFindThreadByWorkingArea+0x178>
 8002b94:	e790      	b.n	8002ab8 <chRegFindThreadByWorkingArea+0x188>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == currtp, "not owner");
      chDbgAssert(currtp->mtxlist == mp, "not owned");
 8002b96:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38
 8002b9a:	459b      	cmp	fp, r3
 8002b9c:	d1a8      	bne.n	8002af0 <chRegFindThreadByWorkingArea+0x1c0>
 8002b9e:	9102      	str	r1, [sp, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002ba0:	f002 f956 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8002ba4:	682a      	ldr	r2, [r5, #0]
 8002ba6:	9902      	ldr	r1, [sp, #8]
 8002ba8:	42aa      	cmp	r2, r5
 8002baa:	d005      	beq.n	8002bb8 <chRegFindThreadByWorkingArea+0x288>
 8002bac:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8002bb0:	6892      	ldr	r2, [r2, #8]
 8002bb2:	689b      	ldr	r3, [r3, #8]
 8002bb4:	4293      	cmp	r3, r2
 8002bb6:	d35a      	bcc.n	8002c6e <chRegFindThreadByWorkingArea+0x33e>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8002bb8:	9b01      	ldr	r3, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8002bba:	f1a1 0008 	sub.w	r0, r1, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8002bbe:	f103 0e04 	add.w	lr, r3, #4
 8002bc2:	f38a 8811 	msr	BASEPRI, sl
 8002bc6:	4672      	mov	r2, lr

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8002bc8:	4290      	cmp	r0, r2
 8002bca:	d305      	bcc.n	8002bd8 <chRegFindThreadByWorkingArea+0x2a8>
 8002bcc:	6853      	ldr	r3, [r2, #4]
 8002bce:	3301      	adds	r3, #1
 8002bd0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002bd4:	4298      	cmp	r0, r3
 8002bd6:	d3a2      	bcc.n	8002b1e <chRegFindThreadByWorkingArea+0x1ee>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8002bd8:	4596      	cmp	lr, r2
 8002bda:	d005      	beq.n	8002be8 <chRegFindThreadByWorkingArea+0x2b8>
 8002bdc:	4290      	cmp	r0, r2
 8002bde:	d803      	bhi.n	8002be8 <chRegFindThreadByWorkingArea+0x2b8>
 8002be0:	6812      	ldr	r2, [r2, #0]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8002be2:	4290      	cmp	r0, r2
 8002be4:	d3f8      	bcc.n	8002bd8 <chRegFindThreadByWorkingArea+0x2a8>
 8002be6:	e7f1      	b.n	8002bcc <chRegFindThreadByWorkingArea+0x29c>

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002be8:	6813      	ldr	r3, [r2, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8002bea:	2b00      	cmp	r3, #0
 8002bec:	d042      	beq.n	8002c74 <chRegFindThreadByWorkingArea+0x344>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002bee:	4298      	cmp	r0, r3
 8002bf0:	d340      	bcc.n	8002c74 <chRegFindThreadByWorkingArea+0x344>
 8002bf2:	461a      	mov	r2, r3
 8002bf4:	e7e8      	b.n	8002bc8 <chRegFindThreadByWorkingArea+0x298>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
 8002bf6:	9801      	ldr	r0, [sp, #4]
    mp->next = currtp->mtxlist;
 8002bf8:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38
 8002bfc:	6183      	str	r3, [r0, #24]
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
 8002bfe:	f8c0 9014 	str.w	r9, [r0, #20]
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
 8002c02:	f8c9 b038 	str.w	fp, [r9, #56]	; 0x38
 8002c06:	e7ca      	b.n	8002b9e <chRegFindThreadByWorkingArea+0x26e>
 8002c08:	2000b68c 	.word	0x2000b68c
 8002c0c:	0800cd0c 	.word	0x0800cd0c
 8002c10:	0800c7ac 	.word	0x0800c7ac
 8002c14:	0800cd68 	.word	0x0800cd68
 8002c18:	0800cd18 	.word	0x0800cd18
 8002c1c:	0800cd78 	.word	0x0800cd78
 8002c20:	0800cd4c 	.word	0x0800cd4c
 8002c24:	464c      	mov	r4, r9
 8002c26:	f8dd 9008 	ldr.w	r9, [sp, #8]
 * @return              The removed element pointer.
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;
 8002c2a:	9801      	ldr	r0, [sp, #4]
 8002c2c:	463b      	mov	r3, r7
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 8002c2e:	f8c9 3008 	str.w	r3, [r9, #8]
 8002c32:	68c3      	ldr	r3, [r0, #12]
 8002c34:	9f03      	ldr	r7, [sp, #12]

  qp->next       = p->next;
 8002c36:	681a      	ldr	r2, [r3, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = (thread_t *)ch_queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8002c38:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8002c3a:	60c2      	str	r2, [r0, #12]
  qp->next->prev = qp;
 8002c3c:	f8c2 b004 	str.w	fp, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = (thread_t *)ch_queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8002c40:	9a01      	ldr	r2, [sp, #4]

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002c42:	4618      	mov	r0, r3
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = (thread_t *)ch_queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8002c44:	6153      	str	r3, [r2, #20]
      mp->next = tp->mtxlist;
 8002c46:	6191      	str	r1, [r2, #24]
      tp->mtxlist = mp;
 8002c48:	f8c3 b038 	str.w	fp, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002c4c:	f7ff fd20 	bl	8002690 <chSchReadyI>
      chSchRescheduleS();
 8002c50:	f7ff fcee 	bl	8002630 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002c54:	f002 f8fc 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8002c58:	682b      	ldr	r3, [r5, #0]
 8002c5a:	42ab      	cmp	r3, r5
 8002c5c:	f43f aec7 	beq.w	80029ee <chRegFindThreadByWorkingArea+0xbe>
 8002c60:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8002c64:	689b      	ldr	r3, [r3, #8]
 8002c66:	6892      	ldr	r2, [r2, #8]
 8002c68:	429a      	cmp	r2, r3
 8002c6a:	f4bf aec0 	bcs.w	80029ee <chRegFindThreadByWorkingArea+0xbe>
 8002c6e:	4831      	ldr	r0, [pc, #196]	; (8002d34 <chRegFindThreadByWorkingArea+0x404>)
 8002c70:	f002 f886 	bl	8004d80 <chSysHalt>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002c74:	f851 9c04 	ldr.w	r9, [r1, #-4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8002c78:	f841 3c08 	str.w	r3, [r1, #-8]
      H_NEXT(qp) = hp;
 8002c7c:	6010      	str	r0, [r2, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002c7e:	f109 0e01 	add.w	lr, r9, #1
 8002c82:	f851 3c08 	ldr.w	r3, [r1, #-8]
 8002c86:	eb00 0cce 	add.w	ip, r0, lr, lsl #3
 8002c8a:	459c      	cmp	ip, r3
 8002c8c:	d046      	beq.n	8002d1c <chRegFindThreadByWorkingArea+0x3ec>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 8002c8e:	f8d2 e004 	ldr.w	lr, [r2, #4]
 8002c92:	f10e 0301 	add.w	r3, lr, #1
 8002c96:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8002c9a:	4298      	cmp	r0, r3
 8002c9c:	d035      	beq.n	8002d0a <chRegFindThreadByWorkingArea+0x3da>
 8002c9e:	f8d5 9018 	ldr.w	r9, [r5, #24]
 8002ca2:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002ca6:	f002 f8e3 	bl	8004e70 <_dbg_check_lock>

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8002caa:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
 8002cae:	b112      	cbz	r2, 8002cb6 <chRegFindThreadByWorkingArea+0x386>
  chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 8002cb0:	6893      	ldr	r3, [r2, #8]
 8002cb2:	4599      	cmp	r9, r3
 8002cb4:	d002      	beq.n	8002cbc <chRegFindThreadByWorkingArea+0x38c>

  chDbgCheck(mp != NULL);

  chSysLock();

  chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 8002cb6:	4820      	ldr	r0, [pc, #128]	; (8002d38 <chRegFindThreadByWorkingArea+0x408>)
 8002cb8:	f002 f862 	bl	8004d80 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(currtp->mtxlist == mp, "not next in list");
 8002cbc:	4593      	cmp	fp, r2
 8002cbe:	d1fa      	bne.n	8002cb6 <chRegFindThreadByWorkingArea+0x386>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
 8002cc0:	9b01      	ldr	r3, [sp, #4]
 8002cc2:	699a      	ldr	r2, [r3, #24]
 8002cc4:	f8c9 2038 	str.w	r2, [r9, #56]	; 0x38
 8002cc8:	9203      	str	r2, [sp, #12]
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8002cca:	f7ff fb09 	bl	80022e0 <chDbgCheckClassS>

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002cce:	9b01      	ldr	r3, [sp, #4]
 8002cd0:	68db      	ldr	r3, [r3, #12]
 8002cd2:	459b      	cmp	fp, r3
 8002cd4:	d015      	beq.n	8002d02 <chRegFindThreadByWorkingArea+0x3d2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 8002cd6:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 8002cda:	9a03      	ldr	r2, [sp, #12]
 8002cdc:	f8cd 9008 	str.w	r9, [sp, #8]
 8002ce0:	9703      	str	r7, [sp, #12]
 8002ce2:	46a1      	mov	r9, r4
 8002ce4:	461f      	mov	r7, r3
 8002ce6:	4614      	mov	r4, r2
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
 8002ce8:	2c00      	cmp	r4, #0
 8002cea:	d09b      	beq.n	8002c24 <chRegFindThreadByWorkingArea+0x2f4>
 8002cec:	f7ff faf8 	bl	80022e0 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
 8002cf0:	6822      	ldr	r2, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002cf2:	4294      	cmp	r4, r2
 8002cf4:	d003      	beq.n	8002cfe <chRegFindThreadByWorkingArea+0x3ce>
            (((thread_t *)lmp->queue.next)->hdr.pqueue.prio > newprio)) {
 8002cf6:	6893      	ldr	r3, [r2, #8]
 8002cf8:	429f      	cmp	r7, r3
 8002cfa:	bf38      	it	cc
 8002cfc:	461f      	movcc	r7, r3
          newprio = ((thread_t *)lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
 8002cfe:	68e4      	ldr	r4, [r4, #12]
 8002d00:	e7f2      	b.n	8002ce8 <chRegFindThreadByWorkingArea+0x3b8>
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 8002d02:	9b01      	ldr	r3, [sp, #4]
 8002d04:	f8c3 a014 	str.w	sl, [r3, #20]
 8002d08:	e7a4      	b.n	8002c54 <chRegFindThreadByWorkingArea+0x324>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
 8002d0a:	e911 000a 	ldmdb	r1, {r1, r3}
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002d0e:	4473      	add	r3, lr
 8002d10:	3301      	adds	r3, #1
        H_NEXT(qp) = H_NEXT(hp);
 8002d12:	6011      	str	r1, [r2, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002d14:	6053      	str	r3, [r2, #4]
 8002d16:	f8d5 9018 	ldr.w	r9, [r5, #24]
 8002d1a:	e7c2      	b.n	8002ca2 <chRegFindThreadByWorkingArea+0x372>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002d1c:	f8dc c004 	ldr.w	ip, [ip, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002d20:	f850 303e 	ldr.w	r3, [r0, lr, lsl #3]
 8002d24:	f841 3c08 	str.w	r3, [r1, #-8]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002d28:	eb0c 0309 	add.w	r3, ip, r9
 8002d2c:	3301      	adds	r3, #1
 8002d2e:	f841 3c04 	str.w	r3, [r1, #-4]
 8002d32:	e7ac      	b.n	8002c8e <chRegFindThreadByWorkingArea+0x35e>
 8002d34:	0800ce08 	.word	0x0800ce08
 8002d38:	0800cd28 	.word	0x0800cd28
 8002d3c:	00000000 	.word	0x00000000

08002d40 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8002d40:	b510      	push	{r4, lr}
 8002d42:	2320      	movs	r3, #32
 8002d44:	4604      	mov	r4, r0
 8002d46:	f383 8811 	msr	BASEPRI, r3
 8002d4a:	f002 f891 	bl	8004e70 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8002d4e:	b1ac      	cbz	r4, 8002d7c <chThdSleep+0x3c>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8002d50:	4621      	mov	r1, r4
 8002d52:	2008      	movs	r0, #8
 8002d54:	f7ff fb3c 	bl	80023d0 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002d58:	f002 f87a 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8002d5c:	4b09      	ldr	r3, [pc, #36]	; (8002d84 <chThdSleep+0x44>)
 8002d5e:	681a      	ldr	r2, [r3, #0]
 8002d60:	429a      	cmp	r2, r3
 8002d62:	d004      	beq.n	8002d6e <chThdSleep+0x2e>
 8002d64:	6999      	ldr	r1, [r3, #24]
 8002d66:	6893      	ldr	r3, [r2, #8]
 8002d68:	688a      	ldr	r2, [r1, #8]
 8002d6a:	429a      	cmp	r2, r3
 8002d6c:	d303      	bcc.n	8002d76 <chThdSleep+0x36>
 8002d6e:	2300      	movs	r3, #0
 8002d70:	f383 8811 	msr	BASEPRI, r3
 8002d74:	bd10      	pop	{r4, pc}
 8002d76:	4804      	ldr	r0, [pc, #16]	; (8002d88 <chThdSleep+0x48>)
 8002d78:	f002 f802 	bl	8004d80 <chSysHalt>
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8002d7c:	4803      	ldr	r0, [pc, #12]	; (8002d8c <chThdSleep+0x4c>)
 8002d7e:	f001 ffff 	bl	8004d80 <chSysHalt>
 8002d82:	bf00      	nop
 8002d84:	2000b68c 	.word	0x2000b68c
 8002d88:	0800c7ac 	.word	0x0800c7ac
 8002d8c:	0800ce14 	.word	0x0800ce14

08002d90 <eval_dec>:
  (*pc_idx)++;

}

void eval_dec(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002d90:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8002d94:	3301      	adds	r3, #1
 8002d96:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002d9a:	011b      	lsls	r3, r3, #4
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;

}

void eval_dec(vmc_t *vmc, INT *pc_idx) {
 8002d9c:	b430      	push	{r4, r5}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002d9e:	18c4      	adds	r4, r0, r3
  UINT i = e.value;
  INT j = i - 1; // XXX: casting might cause issues for uint when outside int range
                 // dec should work with signed ints
  cam_value_t v = { .value = (UINT)j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002da0:	2500      	movs	r5, #0
}

void eval_dec(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  UINT i = e.value;
  INT j = i - 1; // XXX: casting might cause issues for uint when outside int range
 8002da2:	6862      	ldr	r2, [r4, #4]
                 // dec should work with signed ints
  cam_value_t v = { .value = (UINT)j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002da4:	52c5      	strh	r5, [r0, r3]
}

void eval_dec(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  UINT i = e.value;
  INT j = i - 1; // XXX: casting might cause issues for uint when outside int range
 8002da6:	1e53      	subs	r3, r2, #1
                 // dec should work with signed ints
  cam_value_t v = { .value = (UINT)j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002da8:	6063      	str	r3, [r4, #4]
  (*pc_idx)++;
 8002daa:	680b      	ldr	r3, [r1, #0]
 8002dac:	3301      	adds	r3, #1
 8002dae:	600b      	str	r3, [r1, #0]

}
 8002db0:	bc30      	pop	{r4, r5}
 8002db2:	4770      	bx	lr
	...

08002dc0 <eval_not>:
  (*pc_idx)++;

}

void eval_not(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002dc0:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8002dc4:	3301      	adds	r3, #1
 8002dc6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002dca:	011b      	lsls	r3, r3, #4
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;

}

void eval_not(vmc_t *vmc, INT *pc_idx) {
 8002dcc:	b430      	push	{r4, r5}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002dce:	18c4      	adds	r4, r0, r3
  UINT i = e.value;
  UINT j = i ^ 1;
  cam_value_t v = { .value = j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002dd0:	2500      	movs	r5, #0
}

void eval_not(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  UINT i = e.value;
  UINT j = i ^ 1;
 8002dd2:	6862      	ldr	r2, [r4, #4]
  cam_value_t v = { .value = j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002dd4:	52c5      	strh	r5, [r0, r3]
}

void eval_not(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  UINT i = e.value;
  UINT j = i ^ 1;
 8002dd6:	f082 0301 	eor.w	r3, r2, #1
  cam_value_t v = { .value = j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002dda:	6063      	str	r3, [r4, #4]
  (*pc_idx)++;
 8002ddc:	680b      	ldr	r3, [r1, #0]
 8002dde:	3301      	adds	r3, #1
 8002de0:	600b      	str	r3, [r1, #0]

}
 8002de2:	bc30      	pop	{r4, r5}
 8002de4:	4770      	bx	lr
 8002de6:	bf00      	nop
	...

08002df0 <eval_neg>:
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;
}

void eval_neg(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002df0:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8002df4:	3301      	adds	r3, #1
 8002df6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002dfa:	011b      	lsls	r3, r3, #4
  cam_value_t v = { .value = (UINT)abs_i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;
}

void eval_neg(vmc_t *vmc, INT *pc_idx) {
 8002dfc:	b430      	push	{r4, r5}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002dfe:	18c4      	adds	r4, r0, r3
  UINT i = e.value;
  INT j = -i; // XXX: might cause underflow for large uints
  cam_value_t v = { .value = (UINT)j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002e00:	2500      	movs	r5, #0
}

void eval_neg(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  UINT i = e.value;
  INT j = -i; // XXX: might cause underflow for large uints
 8002e02:	6862      	ldr	r2, [r4, #4]
  cam_value_t v = { .value = (UINT)j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002e04:	52c5      	strh	r5, [r0, r3]
}

void eval_neg(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  UINT i = e.value;
  INT j = -i; // XXX: might cause underflow for large uints
 8002e06:	4253      	negs	r3, r2
  cam_value_t v = { .value = (UINT)j, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002e08:	6063      	str	r3, [r4, #4]
  (*pc_idx)++;
 8002e0a:	680b      	ldr	r3, [r1, #0]
 8002e0c:	3301      	adds	r3, #1
 8002e0e:	600b      	str	r3, [r1, #0]

}
 8002e10:	bc30      	pop	{r4, r5}
 8002e12:	4770      	bx	lr
	...

08002e20 <eval_abs>:
  //goto label
  *pc_idx = (INT)label_to_jump;
}

void eval_abs(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002e20:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8002e24:	3301      	adds	r3, #1
 8002e26:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002e2a:	011b      	lsls	r3, r3, #4

  //goto label
  *pc_idx = (INT)label_to_jump;
}

void eval_abs(vmc_t *vmc, INT *pc_idx) {
 8002e2c:	b430      	push	{r4, r5}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002e2e:	18c4      	adds	r4, r0, r3
  INT signed_i = (INT)e.value;
  INT abs_i = abs(signed_i);
  cam_value_t v = { .value = (UINT)abs_i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002e30:	2500      	movs	r5, #0
}

void eval_abs(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  INT signed_i = (INT)e.value;
  INT abs_i = abs(signed_i);
 8002e32:	6862      	ldr	r2, [r4, #4]
  cam_value_t v = { .value = (UINT)abs_i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002e34:	52c5      	strh	r5, [r0, r3]
}

void eval_abs(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  INT signed_i = (INT)e.value;
  INT abs_i = abs(signed_i);
 8002e36:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 8002e3a:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
  cam_value_t v = { .value = (UINT)abs_i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002e3e:	6063      	str	r3, [r4, #4]
  (*pc_idx)++;
 8002e40:	680b      	ldr	r3, [r1, #0]
 8002e42:	3301      	adds	r3, #1
 8002e44:	600b      	str	r3, [r1, #0]
}
 8002e46:	bc30      	pop	{r4, r5}
 8002e48:	4770      	bx	lr
 8002e4a:	bf00      	nop
 8002e4c:	0000      	movs	r0, r0
	...

08002e50 <eval_goto>:

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8002e50:	6a42      	ldr	r2, [r0, #36]	; 0x24
    eval_callrts  // 0x37 : 55
  };


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
 8002e52:	680b      	ldr	r3, [r1, #0]
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8002e54:	4413      	add	r3, r2
 8002e56:	785a      	ldrb	r2, [r3, #1]


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
 8002e58:	789b      	ldrb	r3, [r3, #2]
}

void eval_goto(vmc_t *vmc, INT *pc_idx) {
  uint16_t label = get_label(vmc, pc_idx);
  // GOTO doesn't store jump address on stack
  *pc_idx = (INT)label;
 8002e5a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002e5e:	600b      	str	r3, [r1, #0]
 8002e60:	4770      	bx	lr
 8002e62:	bf00      	nop
	...

08002e70 <eval_skip>:
  }
}

void eval_skip(vmc_t *vmc, INT *pc_idx) {
  (void)vmc;
  (*pc_idx)++;
 8002e70:	680b      	ldr	r3, [r1, #0]
 8002e72:	3301      	adds	r3, #1
 8002e74:	600b      	str	r3, [r1, #0]
 8002e76:	4770      	bx	lr
	...

08002e80 <eval_clear>:
  vmc->contexts[vmc->current_running_context_id].env = v;
  *pc_idx = (*pc_idx) + 2;
}

void eval_clear(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
 8002e80:	680b      	ldr	r3, [r1, #0]
 8002e82:	3301      	adds	r3, #1
 8002e84:	600b      	str	r3, [r1, #0]
  cam_value_t empty_tuple = { .value = 0, .flags = 0 };
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
 8002e86:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8002e8a:	3301      	adds	r3, #1
 8002e8c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002e90:	011b      	lsls	r3, r3, #4
 8002e92:	18c1      	adds	r1, r0, r3
 8002e94:	2200      	movs	r2, #0
 8002e96:	52c2      	strh	r2, [r0, r3]
 8002e98:	604a      	str	r2, [r1, #4]
 8002e9a:	4770      	bx	lr
 8002e9c:	0000      	movs	r0, r0
	...

08002ea0 <eval_loadb>:

void eval_loadb(vmc_t *vmc, INT *pc_idx) {
  INT bool_idx = (*pc_idx) + 1;
  uint8_t bool_val = vmc->code_memory[bool_idx];
  cam_value_t v = { .value = (UINT)bool_val, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002ea0:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
  *pc_idx = (*pc_idx) + 3;
}

void eval_loadb(vmc_t *vmc, INT *pc_idx) {
  INT bool_idx = (*pc_idx) + 1;
  uint8_t bool_val = vmc->code_memory[bool_idx];
 8002ea4:	680a      	ldr	r2, [r1, #0]
  cam_value_t v = { .value = (UINT)i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
  *pc_idx = (*pc_idx) + 3;
}

void eval_loadb(vmc_t *vmc, INT *pc_idx) {
 8002ea6:	b430      	push	{r4, r5}
  INT bool_idx = (*pc_idx) + 1;
  uint8_t bool_val = vmc->code_memory[bool_idx];
  cam_value_t v = { .value = (UINT)bool_val, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002ea8:	3301      	adds	r3, #1
  *pc_idx = (*pc_idx) + 3;
}

void eval_loadb(vmc_t *vmc, INT *pc_idx) {
  INT bool_idx = (*pc_idx) + 1;
  uint8_t bool_val = vmc->code_memory[bool_idx];
 8002eaa:	6a44      	ldr	r4, [r0, #36]	; 0x24
  cam_value_t v = { .value = (UINT)bool_val, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002eac:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002eb0:	011b      	lsls	r3, r3, #4
  *pc_idx = (*pc_idx) + 3;
}

void eval_loadb(vmc_t *vmc, INT *pc_idx) {
  INT bool_idx = (*pc_idx) + 1;
  uint8_t bool_val = vmc->code_memory[bool_idx];
 8002eb2:	4422      	add	r2, r4
  cam_value_t v = { .value = (UINT)bool_val, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002eb4:	2500      	movs	r5, #0
 8002eb6:	18c4      	adds	r4, r0, r3
}

void eval_loadb(vmc_t *vmc, INT *pc_idx) {
  INT bool_idx = (*pc_idx) + 1;
  uint8_t bool_val = vmc->code_memory[bool_idx];
  cam_value_t v = { .value = (UINT)bool_val, .flags = 0};
 8002eb8:	7852      	ldrb	r2, [r2, #1]
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002eba:	52c5      	strh	r5, [r0, r3]
 8002ebc:	6062      	str	r2, [r4, #4]
  *pc_idx = (*pc_idx) + 2;
 8002ebe:	680b      	ldr	r3, [r1, #0]
 8002ec0:	3302      	adds	r3, #2
 8002ec2:	600b      	str	r3, [r1, #0]
}
 8002ec4:	bc30      	pop	{r4, r5}
 8002ec6:	4770      	bx	lr
	...

08002ed0 <eval_loadi>:
  }
  vmc->contexts[vmc->current_running_context_id].env = hold_reg;
  (*pc_idx)++;
}

void eval_loadi(vmc_t *vmc, INT *pc_idx) {
 8002ed0:	b4f0      	push	{r4, r5, r6, r7}
  INT int_idx1 = (*pc_idx) + 1;
 8002ed2:	680a      	ldr	r2, [r1, #0]
  INT int_idx2 = (*pc_idx) + 2;
  uint16_t int_idx =
    (vmc->code_memory[int_idx1] << 8) | vmc->code_memory[int_idx2]; // merge 2 bytes
 8002ed4:	6a46      	ldr	r6, [r0, #36]	; 0x24
  uint8_t byte1 = vmc->code_memory[i_idx + 1];
  uint8_t byte2 = vmc->code_memory[i_idx + 2];
  uint8_t byte3 = vmc->code_memory[i_idx + 3];
  INT i = (byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
  cam_value_t v = { .value = (UINT)i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002ed6:	f890 402c 	ldrb.w	r4, [r0, #44]	; 0x2c

void eval_loadi(vmc_t *vmc, INT *pc_idx) {
  INT int_idx1 = (*pc_idx) + 1;
  INT int_idx2 = (*pc_idx) + 2;
  uint16_t int_idx =
    (vmc->code_memory[int_idx1] << 8) | vmc->code_memory[int_idx2]; // merge 2 bytes
 8002eda:	4432      	add	r2, r6
  uint8_t byte1 = vmc->code_memory[i_idx + 1];
  uint8_t byte2 = vmc->code_memory[i_idx + 2];
  uint8_t byte3 = vmc->code_memory[i_idx + 3];
  INT i = (byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
  cam_value_t v = { .value = (UINT)i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002edc:	3401      	adds	r4, #1

void eval_loadi(vmc_t *vmc, INT *pc_idx) {
  INT int_idx1 = (*pc_idx) + 1;
  INT int_idx2 = (*pc_idx) + 2;
  uint16_t int_idx =
    (vmc->code_memory[int_idx1] << 8) | vmc->code_memory[int_idx2]; // merge 2 bytes
 8002ede:	7855      	ldrb	r5, [r2, #1]
}

void eval_loadi(vmc_t *vmc, INT *pc_idx) {
  INT int_idx1 = (*pc_idx) + 1;
  INT int_idx2 = (*pc_idx) + 2;
  uint16_t int_idx =
 8002ee0:	7893      	ldrb	r3, [r2, #2]
    (vmc->code_memory[int_idx1] << 8) | vmc->code_memory[int_idx2]; // merge 2 bytes
  INT int_pool_offset = 7; //TODO: Should we verify the int pool size here?
  INT i_idx = int_pool_offset + 4 * int_idx; // each int 4 bytes wide
 8002ee2:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8002ee6:	009b      	lsls	r3, r3, #2
 8002ee8:	3307      	adds	r3, #7
  uint8_t byte0 = vmc->code_memory[i_idx];
  uint8_t byte1 = vmc->code_memory[i_idx + 1];
  uint8_t byte2 = vmc->code_memory[i_idx + 2];
  uint8_t byte3 = vmc->code_memory[i_idx + 3];
 8002eea:	18f5      	adds	r5, r6, r3
  INT i = (byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
 8002eec:	5cf7      	ldrb	r7, [r6, r3]
 8002eee:	78ea      	ldrb	r2, [r5, #3]
 8002ef0:	786b      	ldrb	r3, [r5, #1]
 8002ef2:	78ae      	ldrb	r6, [r5, #2]
  cam_value_t v = { .value = (UINT)i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002ef4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8002ef8:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
 8002efc:	0124      	lsls	r4, r4, #4
 8002efe:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8002f02:	2500      	movs	r5, #0
 8002f04:	1902      	adds	r2, r0, r4
 8002f06:	5305      	strh	r5, [r0, r4]
  INT i_idx = int_pool_offset + 4 * int_idx; // each int 4 bytes wide
  uint8_t byte0 = vmc->code_memory[i_idx];
  uint8_t byte1 = vmc->code_memory[i_idx + 1];
  uint8_t byte2 = vmc->code_memory[i_idx + 2];
  uint8_t byte3 = vmc->code_memory[i_idx + 3];
  INT i = (byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
 8002f08:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
  cam_value_t v = { .value = (UINT)i, .flags = 0};
  vmc->contexts[vmc->current_running_context_id].env = v;
 8002f0c:	6053      	str	r3, [r2, #4]
  *pc_idx = (*pc_idx) + 3;
 8002f0e:	680b      	ldr	r3, [r1, #0]
 8002f10:	3303      	adds	r3, #3
 8002f12:	600b      	str	r3, [r1, #0]
}
 8002f14:	bcf0      	pop	{r4, r5, r6, r7}
 8002f16:	4770      	bx	lr
	...

08002f20 <eval_pack>:
    heap_set(&vmc->heap, hi, e, cam_label);
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
 8002f20:	b5f0      	push	{r4, r5, r6, r7, lr}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002f22:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
  return label;
}

uint16_t get_tag(vmc_t *vmc, INT *pc_idx){
  INT tag_idx1 = (*pc_idx) + 1;
 8002f26:	680a      	ldr	r2, [r1, #0]
    heap_set(&vmc->heap, hi, e, cam_label);
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
 8002f28:	460d      	mov	r5, r1
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002f2a:	3301      	adds	r3, #1

uint16_t get_tag(vmc_t *vmc, INT *pc_idx){
  INT tag_idx1 = (*pc_idx) + 1;
  INT tag_idx2 = (*pc_idx) + 2;
  uint16_t tag =
    (vmc->code_memory[tag_idx1] << 8) | vmc->code_memory[tag_idx2]; // merge 2 bytes
 8002f2c:	6a41      	ldr	r1, [r0, #36]	; 0x24
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002f2e:	eb03 0343 	add.w	r3, r3, r3, lsl #1

uint16_t get_tag(vmc_t *vmc, INT *pc_idx){
  INT tag_idx1 = (*pc_idx) + 1;
  INT tag_idx2 = (*pc_idx) + 2;
  uint16_t tag =
    (vmc->code_memory[tag_idx1] << 8) | vmc->code_memory[tag_idx2]; // merge 2 bytes
 8002f32:	440a      	add	r2, r1
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002f34:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    heap_set(&vmc->heap, hi, e, cam_label);
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
 8002f38:	4604      	mov	r4, r0
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002f3a:	e893 0003 	ldmia.w	r3, {r0, r1}
    heap_set(&vmc->heap, hi, e, cam_label);
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
 8002f3e:	b087      	sub	sp, #28

uint16_t get_tag(vmc_t *vmc, INT *pc_idx){
  INT tag_idx1 = (*pc_idx) + 1;
  INT tag_idx2 = (*pc_idx) + 2;
  uint16_t tag =
    (vmc->code_memory[tag_idx1] << 8) | vmc->code_memory[tag_idx2]; // merge 2 bytes
 8002f40:	7857      	ldrb	r7, [r2, #1]
}

uint16_t get_tag(vmc_t *vmc, INT *pc_idx){
  INT tag_idx1 = (*pc_idx) + 1;
  INT tag_idx2 = (*pc_idx) + 2;
  uint16_t tag =
 8002f42:	7893      	ldrb	r3, [r2, #2]
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002f44:	ae02      	add	r6, sp, #8
}

uint16_t get_tag(vmc_t *vmc, INT *pc_idx){
  INT tag_idx1 = (*pc_idx) + 1;
  INT tag_idx2 = (*pc_idx) + 2;
  uint16_t tag =
 8002f46:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t tag = get_tag(vmc, pc_idx);
  cam_value_t cam_tag =
 8002f4a:	2200      	movs	r2, #0
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002f4c:	e886 0003 	stmia.w	r6, {r0, r1}
  uint16_t tag = get_tag(vmc, pc_idx);
  cam_value_t cam_tag =
    { .value = (UINT)tag, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8002f50:	4620      	mov	r0, r4

void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t tag = get_tag(vmc, pc_idx);
  cam_value_t cam_tag =
    { .value = (UINT)tag, .flags = 0 };
 8002f52:	9305      	str	r3, [sp, #20]
}

void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t tag = get_tag(vmc, pc_idx);
  cam_value_t cam_tag =
 8002f54:	f8ad 2010 	strh.w	r2, [sp, #16]
    { .value = (UINT)tag, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8002f58:	f005 fd6a 	bl	8008a30 <vmc_heap_alloc_withGC>
  if(hi == HEAP_NULL){
 8002f5c:	1c43      	adds	r3, r0, #1
void eval_pack(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t tag = get_tag(vmc, pc_idx);
  cam_value_t cam_tag =
    { .value = (UINT)tag, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8002f5e:	4602      	mov	r2, r0
  if(hi == HEAP_NULL){
 8002f60:	d01a      	beq.n	8002f98 <eval_pack+0x78>
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8002f62:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8002f66:	3301      	adds	r3, #1
    heap_set(&vmc->heap, hi, cam_tag, e);
 8002f68:	e896 0003 	ldmia.w	r6, {r0, r1}
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8002f6c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002f70:	011b      	lsls	r3, r3, #4
 8002f72:	f44f 4700 	mov.w	r7, #32768	; 0x8000
 8002f76:	52e7      	strh	r7, [r4, r3]
    heap_set(&vmc->heap, hi, cam_tag, e);
 8002f78:	e88d 0003 	stmia.w	sp, {r0, r1}
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8002f7c:	18e6      	adds	r6, r4, r3
    heap_set(&vmc->heap, hi, cam_tag, e);
 8002f7e:	ab06      	add	r3, sp, #24
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8002f80:	6072      	str	r2, [r6, #4]
    heap_set(&vmc->heap, hi, cam_tag, e);
 8002f82:	4611      	mov	r1, r2
 8002f84:	4620      	mov	r0, r4
 8002f86:	e913 000c 	ldmdb	r3, {r2, r3}
 8002f8a:	f005 fd61 	bl	8008a50 <heap_set>
    *pc_idx = (*pc_idx) + 3;
 8002f8e:	682b      	ldr	r3, [r5, #0]
 8002f90:	3303      	adds	r3, #3
 8002f92:	602b      	str	r3, [r5, #0]
  }
}
 8002f94:	b007      	add	sp, #28
 8002f96:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_value_t cam_tag =
    { .value = (UINT)tag, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
  if(hi == HEAP_NULL){
    DEBUG_PRINT(("Heap allocation has failed"));
    *pc_idx = -1;
 8002f98:	6028      	str	r0, [r5, #0]
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, cam_tag, e);
    *pc_idx = (*pc_idx) + 3;
  }
}
 8002f9a:	b007      	add	sp, #28
 8002f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002f9e:	bf00      	nop

08002fa0 <eval_cur>:
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
 8002fa0:	b5f0      	push	{r4, r5, r6, r7, lr}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002fa2:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
    eval_callrts  // 0x37 : 55
  };


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
 8002fa6:	680a      	ldr	r2, [r1, #0]
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
 8002fa8:	460d      	mov	r5, r1
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002faa:	3301      	adds	r3, #1

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8002fac:	6a41      	ldr	r1, [r0, #36]	; 0x24
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002fae:	eb03 0343 	add.w	r3, r3, r3, lsl #1

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8002fb2:	440a      	add	r2, r1
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002fb4:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
 8002fb8:	4604      	mov	r4, r0
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002fba:	e893 0003 	ldmia.w	r3, {r0, r1}
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
 8002fbe:	b087      	sub	sp, #28

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8002fc0:	7857      	ldrb	r7, [r2, #1]


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
 8002fc2:	7893      	ldrb	r3, [r2, #2]
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002fc4:	ae02      	add	r6, sp, #8


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
 8002fc6:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
 8002fca:	2200      	movs	r2, #0
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8002fcc:	e886 0003 	stmia.w	r6, {r0, r1}
  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
    { .value = (UINT)label, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8002fd0:	4620      	mov	r0, r4

void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
    { .value = (UINT)label, .flags = 0 };
 8002fd2:	9305      	str	r3, [sp, #20]
}

void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
 8002fd4:	f8ad 2010 	strh.w	r2, [sp, #16]
    { .value = (UINT)label, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8002fd8:	f005 fd2a 	bl	8008a30 <vmc_heap_alloc_withGC>
  if(hi == HEAP_NULL){
 8002fdc:	1c43      	adds	r3, r0, #1
void eval_cur(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
    { .value = (UINT)label, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8002fde:	4602      	mov	r2, r0
  if(hi == HEAP_NULL){
 8002fe0:	d01b      	beq.n	800301a <eval_cur+0x7a>
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8002fe2:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    heap_set(&vmc->heap, hi, e, cam_label);
 8002fe6:	a906      	add	r1, sp, #24
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8002fe8:	3301      	adds	r3, #1
    heap_set(&vmc->heap, hi, e, cam_label);
 8002fea:	e911 0003 	ldmdb	r1, {r0, r1}
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8002fee:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002ff2:	011b      	lsls	r3, r3, #4
 8002ff4:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
 8002ff8:	f824 e003 	strh.w	lr, [r4, r3]
    heap_set(&vmc->heap, hi, e, cam_label);
 8002ffc:	e88d 0003 	stmia.w	sp, {r0, r1}
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003000:	18e7      	adds	r7, r4, r3
    heap_set(&vmc->heap, hi, e, cam_label);
 8003002:	4611      	mov	r1, r2
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003004:	607a      	str	r2, [r7, #4]
    heap_set(&vmc->heap, hi, e, cam_label);
 8003006:	4620      	mov	r0, r4
 8003008:	e896 000c 	ldmia.w	r6, {r2, r3}
 800300c:	f005 fd20 	bl	8008a50 <heap_set>
    *pc_idx = (*pc_idx) + 3;
 8003010:	682b      	ldr	r3, [r5, #0]
 8003012:	3303      	adds	r3, #3
 8003014:	602b      	str	r3, [r5, #0]
  }
}
 8003016:	b007      	add	sp, #28
 8003018:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_value_t cam_label =
    { .value = (UINT)label, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
  if(hi == HEAP_NULL){
    DEBUG_PRINT(("Heap allocation has failed"));
    *pc_idx = -1;
 800301a:	6028      	str	r0, [r5, #0]
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, e, cam_label);
    *pc_idx = (*pc_idx) + 3;
  }
}
 800301c:	b007      	add	sp, #28
 800301e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003020 <eval_snoc>:
  }
  vmc->contexts[vmc->current_running_context_id].env = r;

  (*pc_idx)++;
}
void eval_snoc(vmc_t *vmc, INT *pc_idx){
 8003020:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003022:	680b      	ldr	r3, [r1, #0]
 8003024:	3301      	adds	r3, #1
 8003026:	600b      	str	r3, [r1, #0]
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003028:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800302c:	1c5a      	adds	r2, r3, #1
 800302e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8003032:	eb00 1202 	add.w	r2, r0, r2, lsl #4
  }
  vmc->contexts[vmc->current_running_context_id].env = r;

  (*pc_idx)++;
}
void eval_snoc(vmc_t *vmc, INT *pc_idx){
 8003036:	4604      	mov	r4, r0
 8003038:	460d      	mov	r5, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800303a:	e892 0003 	ldmia.w	r2, {r0, r1}
  }
  vmc->contexts[vmc->current_running_context_id].env = r;

  (*pc_idx)++;
}
void eval_snoc(vmc_t *vmc, INT *pc_idx){
 800303e:	b087      	sub	sp, #28
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003040:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003044:	eb04 1303 	add.w	r3, r4, r3, lsl #4

  (*pc_idx)++;
}
void eval_snoc(vmc_t *vmc, INT *pc_idx){
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003048:	ae02      	add	r6, sp, #8
  cam_register_t hold_reg;
  int i =
 800304a:	af04      	add	r7, sp, #16

  (*pc_idx)++;
}
void eval_snoc(vmc_t *vmc, INT *pc_idx){
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800304c:	e886 0003 	stmia.w	r6, {r0, r1}
  cam_register_t hold_reg;
  int i =
 8003050:	f103 003c 	add.w	r0, r3, #60	; 0x3c
 8003054:	4639      	mov	r1, r7
 8003056:	f005 fbeb 	bl	8008830 <stack_pop>
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
 800305a:	b920      	cbnz	r0, 8003066 <eval_snoc+0x46>
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800305c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003060:	602b      	str	r3, [r5, #0]
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, e, hold_reg);
  }

}
 8003062:	b007      	add	sp, #28
 8003064:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8003066:	4620      	mov	r0, r4
 8003068:	f005 fce2 	bl	8008a30 <vmc_heap_alloc_withGC>
  if(hi == HEAP_NULL){
 800306c:	1c43      	adds	r3, r0, #1
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 800306e:	4602      	mov	r2, r0
  if(hi == HEAP_NULL){
 8003070:	d0f4      	beq.n	800305c <eval_snoc+0x3c>
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003072:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8003076:	3301      	adds	r3, #1
    heap_set(&vmc->heap, hi, e, hold_reg);
 8003078:	e897 0003 	ldmia.w	r7, {r0, r1}
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 800307c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003080:	011b      	lsls	r3, r3, #4
 8003082:	f44f 4700 	mov.w	r7, #32768	; 0x8000
 8003086:	52e7      	strh	r7, [r4, r3]
    heap_set(&vmc->heap, hi, e, hold_reg);
 8003088:	e88d 0003 	stmia.w	sp, {r0, r1}
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 800308c:	18e5      	adds	r5, r4, r3
    heap_set(&vmc->heap, hi, e, hold_reg);
 800308e:	4611      	mov	r1, r2
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003090:	606a      	str	r2, [r5, #4]
    heap_set(&vmc->heap, hi, e, hold_reg);
 8003092:	4620      	mov	r0, r4
 8003094:	e896 000c 	ldmia.w	r6, {r2, r3}
 8003098:	f005 fcda 	bl	8008a50 <heap_set>
  }

}
 800309c:	b007      	add	sp, #28
 800309e:	bdf0      	pop	{r4, r5, r6, r7, pc}

080030a0 <eval_pop>:

  (*pc_idx)++;

}

void eval_pop (vmc_t *vmc, INT *pc_idx){
 80030a0:	b570      	push	{r4, r5, r6, lr}
 80030a2:	4604      	mov	r4, r0
  cam_register_t r;
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &r);
 80030a4:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80030a8:	eb00 0040 	add.w	r0, r0, r0, lsl #1

  (*pc_idx)++;

}

void eval_pop (vmc_t *vmc, INT *pc_idx){
 80030ac:	b082      	sub	sp, #8
  cam_register_t r;
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &r);
 80030ae:	eb04 1000 	add.w	r0, r4, r0, lsl #4

  (*pc_idx)++;

}

void eval_pop (vmc_t *vmc, INT *pc_idx){
 80030b2:	460e      	mov	r6, r1
  cam_register_t r;
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &r);
 80030b4:	303c      	adds	r0, #60	; 0x3c
 80030b6:	4669      	mov	r1, sp
 80030b8:	f005 fbba 	bl	8008830 <stack_pop>
  if(i == 0){
 80030bc:	b178      	cbz	r0, 80030de <eval_pop+0x3e>
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  vmc->contexts[vmc->current_running_context_id].env = r;
 80030be:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80030c2:	e89d 0003 	ldmia.w	sp, {r0, r1}
 80030c6:	3301      	adds	r3, #1
 80030c8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80030cc:	eb04 1403 	add.w	r4, r4, r3, lsl #4
 80030d0:	e884 0003 	stmia.w	r4, {r0, r1}

  (*pc_idx)++;
 80030d4:	6833      	ldr	r3, [r6, #0]
 80030d6:	3301      	adds	r3, #1
 80030d8:	6033      	str	r3, [r6, #0]
}
 80030da:	b002      	add	sp, #8
 80030dc:	bd70      	pop	{r4, r5, r6, pc}
void eval_pop (vmc_t *vmc, INT *pc_idx){
  cam_register_t r;
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &r);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80030de:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80030e2:	6033      	str	r3, [r6, #0]
    return;
  }
  vmc->contexts[vmc->current_running_context_id].env = r;

  (*pc_idx)++;
}
 80030e4:	b002      	add	sp, #8
 80030e6:	bd70      	pop	{r4, r5, r6, pc}
	...

080030f0 <eval_eq_bool>:
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_eq_bool(vmc_t *vmc, INT *pc_idx) {
 80030f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80030f2:	680b      	ldr	r3, [r1, #0]
 80030f4:	3301      	adds	r3, #1
 80030f6:	600b      	str	r3, [r1, #0]
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_eq_bool(vmc_t *vmc, INT *pc_idx) {
 80030f8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env; // bool represented using uint
 80030fa:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80030fe:	1c43      	adds	r3, r0, #1
 8003100:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003104:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_eq_bool(vmc_t *vmc, INT *pc_idx) {
 8003108:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env; // bool represented using uint
 800310a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800310e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_eq_bool(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env; // bool represented using uint
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 8003112:	2500      	movs	r5, #0
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_eq_bool(vmc_t *vmc, INT *pc_idx) {
 8003114:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env; // bool represented using uint
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003116:	303c      	adds	r0, #60	; 0x3c
 8003118:	4669      	mov	r1, sp

}

void eval_eq_bool(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env; // bool represented using uint
 800311a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 800311c:	f8ad 5000 	strh.w	r5, [sp]
 8003120:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003122:	f005 fb85 	bl	8008830 <stack_pop>
  if(i == 0){
 8003126:	b178      	cbz	r0, 8003148 <eval_eq_bool+0x58>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003128:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
 800312c:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800312e:	3301      	adds	r3, #1
 8003130:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003134:	011b      	lsls	r3, r3, #4
 8003136:	18e1      	adds	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
 8003138:	1bd7      	subs	r7, r2, r7
 800313a:	fab7 f787 	clz	r7, r7
 800313e:	097f      	lsrs	r7, r7, #5
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003140:	52e5      	strh	r5, [r4, r3]
 8003142:	604f      	str	r7, [r1, #4]
}
 8003144:	b003      	add	sp, #12
 8003146:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env; // bool represented using uint
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003148:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800314c:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 800314e:	b003      	add	sp, #12
 8003150:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003152:	bf00      	nop
	...

08003160 <eval_eqf>:
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eqf(vmc_t *vmc, INT *pc_idx) {
 8003160:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003162:	680b      	ldr	r3, [r1, #0]
 8003164:	3301      	adds	r3, #1
 8003166:	600b      	str	r3, [r1, #0]
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eqf(vmc_t *vmc, INT *pc_idx) {
 8003168:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800316a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800316e:	1c43      	adds	r3, r0, #1
 8003170:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003174:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eqf(vmc_t *vmc, INT *pc_idx) {
 8003178:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800317a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800317e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_eqf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003182:	2500      	movs	r5, #0
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eqf(vmc_t *vmc, INT *pc_idx) {
 8003184:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003186:	303c      	adds	r0, #60	; 0x3c
 8003188:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eqf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800318a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800318c:	f8ad 5000 	strh.w	r5, [sp]
 8003190:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003192:	f005 fb4d 	bl	8008830 <stack_pop>
  if(i == 0){
 8003196:	b1b8      	cbz	r0, 80031c8 <eval_eqf+0x68>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003198:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
 800319c:	ed9d 7a01 	vldr	s14, [sp, #4]
 80031a0:	ee07 7a90 	vmov	s15, r7
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80031a4:	3301      	adds	r3, #1
 80031a6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80031aa:	011b      	lsls	r3, r3, #4
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
 80031ac:	eef4 7a47 	vcmp.f32	s15, s14
 80031b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80031b4:	eb04 0203 	add.w	r2, r4, r3
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
 80031b8:	bf0c      	ite	eq
 80031ba:	f04f 517e 	moveq.w	r1, #1065353216	; 0x3f800000
 80031be:	2100      	movne	r1, #0
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80031c0:	52e5      	strh	r5, [r4, r3]
 80031c2:	6051      	str	r1, [r2, #4]

}
 80031c4:	b003      	add	sp, #12
 80031c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80031c8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80031cc:	6033      	str	r3, [r6, #0]
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}
 80031ce:	b003      	add	sp, #12
 80031d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80031d2:	bf00      	nop
	...

080031e0 <eval_eq_signedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eq_signedi(vmc_t *vmc, INT *pc_idx) {
 80031e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80031e2:	680b      	ldr	r3, [r1, #0]
 80031e4:	3301      	adds	r3, #1
 80031e6:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eq_signedi(vmc_t *vmc, INT *pc_idx) {
 80031e8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80031ea:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80031ee:	1c43      	adds	r3, r0, #1
 80031f0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80031f4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eq_signedi(vmc_t *vmc, INT *pc_idx) {
 80031f8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80031fa:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80031fe:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_eq_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003202:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eq_signedi(vmc_t *vmc, INT *pc_idx) {
 8003204:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003206:	303c      	adds	r0, #60	; 0x3c
 8003208:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_eq_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800320a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800320c:	f8ad 5000 	strh.w	r5, [sp]
 8003210:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003212:	f005 fb0d 	bl	8008830 <stack_pop>
  if(i == 0){
 8003216:	b178      	cbz	r0, 8003238 <eval_eq_signedi+0x58>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003218:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
 800321c:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800321e:	3301      	adds	r3, #1
 8003220:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003224:	011b      	lsls	r3, r3, #4
 8003226:	18e1      	adds	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
 8003228:	1bd7      	subs	r7, r2, r7
 800322a:	fab7 f787 	clz	r7, r7
 800322e:	097f      	lsrs	r7, r7, #5
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003230:	52e5      	strh	r5, [r4, r3]
 8003232:	604f      	str	r7, [r1, #4]
}
 8003234:	b003      	add	sp, #12
 8003236:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003238:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800323c:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 == temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 800323e:	b003      	add	sp, #12
 8003240:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003242:	bf00      	nop
	...

08003250 <eval_eq_unsignedi>:
}


// Equality on base types

void eval_eq_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003250:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003252:	680b      	ldr	r3, [r1, #0]
 8003254:	3301      	adds	r3, #1
 8003256:	600b      	str	r3, [r1, #0]
}


// Equality on base types

void eval_eq_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003258:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800325a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800325e:	1c43      	adds	r3, r0, #1
 8003260:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003264:	eb00 0040 	add.w	r0, r0, r0, lsl #1
}


// Equality on base types

void eval_eq_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003268:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800326a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800326e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
// Equality on base types

void eval_eq_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003272:	2500      	movs	r5, #0
}


// Equality on base types

void eval_eq_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003274:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003276:	303c      	adds	r0, #60	; 0x3c
 8003278:	4669      	mov	r1, sp

// Equality on base types

void eval_eq_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800327a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800327c:	f8ad 5000 	strh.w	r5, [sp]
 8003280:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003282:	f005 fad5 	bl	8008830 <stack_pop>
  if(i == 0){
 8003286:	b178      	cbz	r0, 80032a8 <eval_eq_unsignedi+0x58>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003288:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
 800328c:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800328e:	3301      	adds	r3, #1
 8003290:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003294:	011b      	lsls	r3, r3, #4
 8003296:	18e1      	adds	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
 8003298:	1bd7      	subs	r7, r2, r7
 800329a:	fab7 f787 	clz	r7, r7
 800329e:	097f      	lsrs	r7, r7, #5
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80032a0:	52e5      	strh	r5, [r4, r3]
 80032a2:	604f      	str	r7, [r1, #4]
}
 80032a4:	b003      	add	sp, #12
 80032a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80032a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80032ac:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 80032ae:	b003      	add	sp, #12
 80032b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80032b2:	bf00      	nop
	...

080032c0 <eval_lef>:
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lef(vmc_t *vmc, INT *pc_idx) {
 80032c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80032c2:	680b      	ldr	r3, [r1, #0]
 80032c4:	3301      	adds	r3, #1
 80032c6:	600b      	str	r3, [r1, #0]
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lef(vmc_t *vmc, INT *pc_idx) {
 80032c8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80032ca:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80032ce:	1c43      	adds	r3, r0, #1
 80032d0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80032d4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lef(vmc_t *vmc, INT *pc_idx) {
 80032d8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80032da:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80032de:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_lef(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80032e2:	2500      	movs	r5, #0
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lef(vmc_t *vmc, INT *pc_idx) {
 80032e4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80032e6:	303c      	adds	r0, #60	; 0x3c
 80032e8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lef(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80032ea:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80032ec:	f8ad 5000 	strh.w	r5, [sp]
 80032f0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80032f2:	f005 fa9d 	bl	8008830 <stack_pop>
  if(i == 0){
 80032f6:	b1b8      	cbz	r0, 8003328 <eval_lef+0x68>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80032f8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
 80032fc:	ed9d 7a01 	vldr	s14, [sp, #4]
 8003300:	ee07 7a90 	vmov	s15, r7
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003304:	3301      	adds	r3, #1
 8003306:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800330a:	011b      	lsls	r3, r3, #4
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
 800330c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003310:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003314:	eb04 0203 	add.w	r2, r4, r3
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
 8003318:	bfac      	ite	ge
 800331a:	f04f 517e 	movge.w	r1, #1065353216	; 0x3f800000
 800331e:	2100      	movlt	r1, #0
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003320:	52e5      	strh	r5, [r4, r3]
 8003322:	6051      	str	r1, [r2, #4]
}
 8003324:	b003      	add	sp, #12
 8003326:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003328:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800332c:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 800332e:	b003      	add	sp, #12
 8003330:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003332:	bf00      	nop
	...

08003340 <eval_gef>:
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gef(vmc_t *vmc, INT *pc_idx) {
 8003340:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003342:	680b      	ldr	r3, [r1, #0]
 8003344:	3301      	adds	r3, #1
 8003346:	600b      	str	r3, [r1, #0]
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gef(vmc_t *vmc, INT *pc_idx) {
 8003348:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800334a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800334e:	1c43      	adds	r3, r0, #1
 8003350:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003354:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gef(vmc_t *vmc, INT *pc_idx) {
 8003358:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800335a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800335e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_gef(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003362:	2500      	movs	r5, #0
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gef(vmc_t *vmc, INT *pc_idx) {
 8003364:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003366:	303c      	adds	r0, #60	; 0x3c
 8003368:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gef(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800336a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800336c:	f8ad 5000 	strh.w	r5, [sp]
 8003370:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003372:	f005 fa5d 	bl	8008830 <stack_pop>
  if(i == 0){
 8003376:	b1b8      	cbz	r0, 80033a8 <eval_gef+0x68>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003378:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
 800337c:	ed9d 7a01 	vldr	s14, [sp, #4]
 8003380:	ee07 7a90 	vmov	s15, r7
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003384:	3301      	adds	r3, #1
 8003386:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800338a:	011b      	lsls	r3, r3, #4
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
 800338c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003390:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003394:	eb04 0203 	add.w	r2, r4, r3
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
 8003398:	bf94      	ite	ls
 800339a:	f04f 517e 	movls.w	r1, #1065353216	; 0x3f800000
 800339e:	2100      	movhi	r1, #0
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80033a0:	52e5      	strh	r5, [r4, r3]
 80033a2:	6051      	str	r1, [r2, #4]
}
 80033a4:	b003      	add	sp, #12
 80033a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80033a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80033ac:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 80033ae:	b003      	add	sp, #12
 80033b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80033b2:	bf00      	nop
	...

080033c0 <eval_ltf>:
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ltf(vmc_t *vmc, INT *pc_idx) {
 80033c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80033c2:	680b      	ldr	r3, [r1, #0]
 80033c4:	3301      	adds	r3, #1
 80033c6:	600b      	str	r3, [r1, #0]
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ltf(vmc_t *vmc, INT *pc_idx) {
 80033c8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80033ca:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80033ce:	1c43      	adds	r3, r0, #1
 80033d0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80033d4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ltf(vmc_t *vmc, INT *pc_idx) {
 80033d8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80033da:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80033de:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_ltf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80033e2:	2500      	movs	r5, #0
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ltf(vmc_t *vmc, INT *pc_idx) {
 80033e4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80033e6:	303c      	adds	r0, #60	; 0x3c
 80033e8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ltf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80033ea:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80033ec:	f8ad 5000 	strh.w	r5, [sp]
 80033f0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80033f2:	f005 fa1d 	bl	8008830 <stack_pop>
  if(i == 0){
 80033f6:	b1b8      	cbz	r0, 8003428 <eval_ltf+0x68>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80033f8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
 80033fc:	ed9d 7a01 	vldr	s14, [sp, #4]
 8003400:	ee07 7a90 	vmov	s15, r7
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003404:	3301      	adds	r3, #1
 8003406:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800340a:	011b      	lsls	r3, r3, #4
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
 800340c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003410:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003414:	eb04 0203 	add.w	r2, r4, r3
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
 8003418:	bfcc      	ite	gt
 800341a:	f04f 517e 	movgt.w	r1, #1065353216	; 0x3f800000
 800341e:	2100      	movle	r1, #0
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003420:	52e5      	strh	r5, [r4, r3]
 8003422:	6051      	str	r1, [r2, #4]
}
 8003424:	b003      	add	sp, #12
 8003426:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003428:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800342c:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 800342e:	b003      	add	sp, #12
 8003430:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003432:	bf00      	nop
	...

08003440 <eval_gtf>:
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_gtf(vmc_t *vmc, INT *pc_idx) {
 8003440:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003442:	680b      	ldr	r3, [r1, #0]
 8003444:	3301      	adds	r3, #1
 8003446:	600b      	str	r3, [r1, #0]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_gtf(vmc_t *vmc, INT *pc_idx) {
 8003448:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800344a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800344e:	1c43      	adds	r3, r0, #1
 8003450:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003454:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_gtf(vmc_t *vmc, INT *pc_idx) {
 8003458:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800345a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800345e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_gtf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003462:	2500      	movs	r5, #0
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}

void eval_gtf(vmc_t *vmc, INT *pc_idx) {
 8003464:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003466:	303c      	adds	r0, #60	; 0x3c
 8003468:	4669      	mov	r1, sp

}

void eval_gtf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800346a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800346c:	f8ad 5000 	strh.w	r5, [sp]
 8003470:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003472:	f005 f9dd 	bl	8008830 <stack_pop>
  if(i == 0){
 8003476:	b1b8      	cbz	r0, 80034a8 <eval_gtf+0x68>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003478:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
 800347c:	ed9d 7a01 	vldr	s14, [sp, #4]
 8003480:	ee07 7a90 	vmov	s15, r7
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003484:	3301      	adds	r3, #1
 8003486:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800348a:	011b      	lsls	r3, r3, #4
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
 800348c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8003490:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003494:	eb04 0203 	add.w	r2, r4, r3
  float temp2;
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
 8003498:	bf4c      	ite	mi
 800349a:	f04f 517e 	movmi.w	r1, #1065353216	; 0x3f800000
 800349e:	2100      	movpl	r1, #0
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80034a0:	52e5      	strh	r5, [r4, r3]
 80034a2:	6051      	str	r1, [r2, #4]
}
 80034a4:	b003      	add	sp, #12
 80034a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80034a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80034ac:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 80034ae:	b003      	add	sp, #12
 80034b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80034b2:	bf00      	nop
	...

080034c0 <eval_le_signedi>:
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_signedi(vmc_t *vmc, INT *pc_idx) {
 80034c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80034c2:	680b      	ldr	r3, [r1, #0]
 80034c4:	3301      	adds	r3, #1
 80034c6:	600b      	str	r3, [r1, #0]
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_signedi(vmc_t *vmc, INT *pc_idx) {
 80034c8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80034ca:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80034ce:	1c43      	adds	r3, r0, #1
 80034d0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80034d4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_signedi(vmc_t *vmc, INT *pc_idx) {
 80034d8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80034da:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80034de:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_le_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80034e2:	2500      	movs	r5, #0
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_signedi(vmc_t *vmc, INT *pc_idx) {
 80034e4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80034e6:	303c      	adds	r0, #60	; 0x3c
 80034e8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80034ea:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80034ec:	f8ad 5000 	strh.w	r5, [sp]
 80034f0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80034f2:	f005 f99d 	bl	8008830 <stack_pop>
  if(i == 0){
 80034f6:	b180      	cbz	r0, 800351a <eval_le_signedi+0x5a>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80034f8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
 80034fc:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80034fe:	3301      	adds	r3, #1
 8003500:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003504:	011b      	lsls	r3, r3, #4
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
 8003506:	42ba      	cmp	r2, r7
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003508:	eb04 0103 	add.w	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
 800350c:	bfcc      	ite	gt
 800350e:	2700      	movgt	r7, #0
 8003510:	2701      	movle	r7, #1
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003512:	52e5      	strh	r5, [r4, r3]
 8003514:	604f      	str	r7, [r1, #4]

}
 8003516:	b003      	add	sp, #12
 8003518:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800351a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800351e:	6033      	str	r3, [r6, #0]
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 <= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;

}
 8003520:	b003      	add	sp, #12
 8003522:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003530 <eval_ge_signedi>:
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_signedi(vmc_t *vmc, INT *pc_idx) {
 8003530:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003532:	680b      	ldr	r3, [r1, #0]
 8003534:	3301      	adds	r3, #1
 8003536:	600b      	str	r3, [r1, #0]
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_signedi(vmc_t *vmc, INT *pc_idx) {
 8003538:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800353a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800353e:	1c43      	adds	r3, r0, #1
 8003540:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003544:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_signedi(vmc_t *vmc, INT *pc_idx) {
 8003548:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800354a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800354e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_ge_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003552:	2500      	movs	r5, #0
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_signedi(vmc_t *vmc, INT *pc_idx) {
 8003554:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003556:	303c      	adds	r0, #60	; 0x3c
 8003558:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800355a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800355c:	f8ad 5000 	strh.w	r5, [sp]
 8003560:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003562:	f005 f965 	bl	8008830 <stack_pop>
  if(i == 0){
 8003566:	b180      	cbz	r0, 800358a <eval_ge_signedi+0x5a>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003568:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
 800356c:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800356e:	3301      	adds	r3, #1
 8003570:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003574:	011b      	lsls	r3, r3, #4
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
 8003576:	42ba      	cmp	r2, r7
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003578:	eb04 0103 	add.w	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
 800357c:	bfb4      	ite	lt
 800357e:	2700      	movlt	r7, #0
 8003580:	2701      	movge	r7, #1
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003582:	52e5      	strh	r5, [r4, r3]
 8003584:	604f      	str	r7, [r1, #4]
}
 8003586:	b003      	add	sp, #12
 8003588:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800358a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800358e:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 >= temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003590:	b003      	add	sp, #12
 8003592:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080035a0 <eval_lt_signedi>:
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_signedi(vmc_t *vmc, INT *pc_idx) {
 80035a0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80035a2:	680b      	ldr	r3, [r1, #0]
 80035a4:	3301      	adds	r3, #1
 80035a6:	600b      	str	r3, [r1, #0]
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_signedi(vmc_t *vmc, INT *pc_idx) {
 80035a8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80035aa:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80035ae:	1c43      	adds	r3, r0, #1
 80035b0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80035b4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_signedi(vmc_t *vmc, INT *pc_idx) {
 80035b8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80035ba:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80035be:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_lt_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80035c2:	2500      	movs	r5, #0
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_signedi(vmc_t *vmc, INT *pc_idx) {
 80035c4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80035c6:	303c      	adds	r0, #60	; 0x3c
 80035c8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80035ca:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80035cc:	f8ad 5000 	strh.w	r5, [sp]
 80035d0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80035d2:	f005 f92d 	bl	8008830 <stack_pop>
  if(i == 0){
 80035d6:	b180      	cbz	r0, 80035fa <eval_lt_signedi+0x5a>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80035d8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
 80035dc:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80035de:	3301      	adds	r3, #1
 80035e0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80035e4:	011b      	lsls	r3, r3, #4
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
 80035e6:	42ba      	cmp	r2, r7
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80035e8:	eb04 0103 	add.w	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
 80035ec:	bfac      	ite	ge
 80035ee:	2700      	movge	r7, #0
 80035f0:	2701      	movlt	r7, #1
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80035f2:	52e5      	strh	r5, [r4, r3]
 80035f4:	604f      	str	r7, [r1, #4]
}
 80035f6:	b003      	add	sp, #12
 80035f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80035fa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80035fe:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 < temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003600:	b003      	add	sp, #12
 8003602:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003610 <eval_gt_signedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_signedi(vmc_t *vmc, INT *pc_idx) {
 8003610:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003612:	680b      	ldr	r3, [r1, #0]
 8003614:	3301      	adds	r3, #1
 8003616:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_signedi(vmc_t *vmc, INT *pc_idx) {
 8003618:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800361a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800361e:	1c43      	adds	r3, r0, #1
 8003620:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003624:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_signedi(vmc_t *vmc, INT *pc_idx) {
 8003628:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800362a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800362e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_gt_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003632:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_signedi(vmc_t *vmc, INT *pc_idx) {
 8003634:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003636:	303c      	adds	r0, #60	; 0x3c
 8003638:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800363a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800363c:	f8ad 5000 	strh.w	r5, [sp]
 8003640:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003642:	f005 f8f5 	bl	8008830 <stack_pop>
  if(i == 0){
 8003646:	b180      	cbz	r0, 800366a <eval_gt_signedi+0x5a>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003648:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
 800364c:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800364e:	3301      	adds	r3, #1
 8003650:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003654:	011b      	lsls	r3, r3, #4
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
 8003656:	42ba      	cmp	r2, r7
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003658:	eb04 0103 	add.w	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
 800365c:	bfd4      	ite	le
 800365e:	2700      	movle	r7, #0
 8003660:	2701      	movgt	r7, #1
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003662:	52e5      	strh	r5, [r4, r3]
 8003664:	604f      	str	r7, [r1, #4]
}
 8003666:	b003      	add	sp, #12
 8003668:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800366a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800366e:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 > temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003670:	b003      	add	sp, #12
 8003672:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003680 <eval_le_unsignedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003680:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003682:	680b      	ldr	r3, [r1, #0]
 8003684:	3301      	adds	r3, #1
 8003686:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003688:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800368a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800368e:	1c43      	adds	r3, r0, #1
 8003690:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003694:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003698:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800369a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800369e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_le_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 80036a2:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_unsignedi(vmc_t *vmc, INT *pc_idx) {
 80036a4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80036a6:	303c      	adds	r0, #60	; 0x3c
 80036a8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_le_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80036aa:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 80036ac:	f8ad 5000 	strh.w	r5, [sp]
 80036b0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80036b2:	f005 f8bd 	bl	8008830 <stack_pop>
  if(i == 0){
 80036b6:	b180      	cbz	r0, 80036da <eval_le_unsignedi+0x5a>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80036b8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
 80036bc:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80036be:	3301      	adds	r3, #1
 80036c0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80036c4:	011b      	lsls	r3, r3, #4
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
 80036c6:	42ba      	cmp	r2, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80036c8:	eb04 0103 	add.w	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
 80036cc:	bf8c      	ite	hi
 80036ce:	2700      	movhi	r7, #0
 80036d0:	2701      	movls	r7, #1
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80036d2:	52e5      	strh	r5, [r4, r3]
 80036d4:	604f      	str	r7, [r1, #4]
}
 80036d6:	b003      	add	sp, #12
 80036d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80036da:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80036de:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value <= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 80036e0:	b003      	add	sp, #12
 80036e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080036f0 <eval_ge_unsignedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_unsignedi(vmc_t *vmc, INT *pc_idx) {
 80036f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80036f2:	680b      	ldr	r3, [r1, #0]
 80036f4:	3301      	adds	r3, #1
 80036f6:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_unsignedi(vmc_t *vmc, INT *pc_idx) {
 80036f8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80036fa:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80036fe:	1c43      	adds	r3, r0, #1
 8003700:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003704:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003708:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800370a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800370e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_ge_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 8003712:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003714:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003716:	303c      	adds	r0, #60	; 0x3c
 8003718:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_ge_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800371a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 800371c:	f8ad 5000 	strh.w	r5, [sp]
 8003720:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003722:	f005 f885 	bl	8008830 <stack_pop>
  if(i == 0){
 8003726:	b180      	cbz	r0, 800374a <eval_ge_unsignedi+0x5a>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003728:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
 800372c:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800372e:	3301      	adds	r3, #1
 8003730:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003734:	011b      	lsls	r3, r3, #4
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
 8003736:	42ba      	cmp	r2, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003738:	eb04 0103 	add.w	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
 800373c:	bf34      	ite	cc
 800373e:	2700      	movcc	r7, #0
 8003740:	2701      	movcs	r7, #1
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003742:	52e5      	strh	r5, [r4, r3]
 8003744:	604f      	str	r7, [r1, #4]
}
 8003746:	b003      	add	sp, #12
 8003748:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800374a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800374e:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value >= e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003750:	b003      	add	sp, #12
 8003752:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003760 <eval_lt_unsignedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003760:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003762:	680b      	ldr	r3, [r1, #0]
 8003764:	3301      	adds	r3, #1
 8003766:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003768:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800376a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800376e:	1c43      	adds	r3, r0, #1
 8003770:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003774:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003778:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800377a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800377e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_lt_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 8003782:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003784:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003786:	303c      	adds	r0, #60	; 0x3c
 8003788:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_lt_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800378a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 800378c:	f8ad 5000 	strh.w	r5, [sp]
 8003790:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003792:	f005 f84d 	bl	8008830 <stack_pop>
  if(i == 0){
 8003796:	b180      	cbz	r0, 80037ba <eval_lt_unsignedi+0x5a>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003798:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
 800379c:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800379e:	3301      	adds	r3, #1
 80037a0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80037a4:	011b      	lsls	r3, r3, #4
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
 80037a6:	42ba      	cmp	r2, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80037a8:	eb04 0103 	add.w	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
 80037ac:	bf2c      	ite	cs
 80037ae:	2700      	movcs	r7, #0
 80037b0:	2701      	movcc	r7, #1
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80037b2:	52e5      	strh	r5, [r4, r3]
 80037b4:	604f      	str	r7, [r1, #4]
}
 80037b6:	b003      	add	sp, #12
 80037b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80037ba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80037be:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value < e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 80037c0:	b003      	add	sp, #12
 80037c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080037d0 <eval_gt_unsignedi>:
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 80037d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80037d2:	680b      	ldr	r3, [r1, #0]
 80037d4:	3301      	adds	r3, #1
 80037d6:	600b      	str	r3, [r1, #0]
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 80037d8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80037da:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80037de:	1c43      	adds	r3, r0, #1
 80037e0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80037e4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 80037e8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80037ea:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80037ee:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_gt_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 80037f2:	2500      	movs	r5, #0
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_unsignedi(vmc_t *vmc, INT *pc_idx) {
 80037f4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80037f6:	303c      	adds	r0, #60	; 0x3c
 80037f8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_gt_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80037fa:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
 80037fc:	f8ad 5000 	strh.w	r5, [sp]
 8003800:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003802:	f005 f815 	bl	8008830 <stack_pop>
  if(i == 0){
 8003806:	b180      	cbz	r0, 800382a <eval_gt_unsignedi+0x5a>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003808:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
 800380c:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 800380e:	3301      	adds	r3, #1
 8003810:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003814:	011b      	lsls	r3, r3, #4
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
 8003816:	42ba      	cmp	r2, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003818:	eb04 0103 	add.w	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
 800381c:	bf94      	ite	ls
 800381e:	2700      	movls	r7, #0
 8003820:	2701      	movhi	r7, #1
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003822:	52e5      	strh	r5, [r4, r3]
 8003824:	604f      	str	r7, [r1, #4]
}
 8003826:	b003      	add	sp, #12
 8003828:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 };
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800382a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800382e:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value > e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003830:	b003      	add	sp, #12
 8003832:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003840 <eval_minf>:
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_minf(vmc_t *vmc, INT *pc_idx) {
 8003840:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003842:	680b      	ldr	r3, [r1, #0]
 8003844:	3301      	adds	r3, #1
 8003846:	600b      	str	r3, [r1, #0]
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_minf(vmc_t *vmc, INT *pc_idx) {
 8003848:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800384a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800384e:	1c43      	adds	r3, r0, #1
 8003850:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003854:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_minf(vmc_t *vmc, INT *pc_idx) {
 8003858:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800385a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800385e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_minf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003862:	2500      	movs	r5, #0
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_minf(vmc_t *vmc, INT *pc_idx) {
 8003864:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003866:	303c      	adds	r0, #60	; 0x3c
 8003868:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_minf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800386a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800386c:	f8ad 5000 	strh.w	r5, [sp]
 8003870:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003872:	f004 ffdd 	bl	8008830 <stack_pop>
  if(i == 0){
 8003876:	b188      	cbz	r0, 800389c <eval_minf+0x5c>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003878:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
 800387c:	eddd 7a01 	vldr	s15, [sp, #4]
 8003880:	ee07 7a10 	vmov	s14, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003884:	3301      	adds	r3, #1
 8003886:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800388a:	011b      	lsls	r3, r3, #4
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
 800388c:	ee77 7ac7 	vsub.f32	s15, s15, s14
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003890:	18e1      	adds	r1, r4, r3
 8003892:	52e5      	strh	r5, [r4, r3]
 8003894:	edc1 7a01 	vstr	s15, [r1, #4]
}
 8003898:	b003      	add	sp, #12
 800389a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800389c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80038a0:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 80038a2:	b003      	add	sp, #12
 80038a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80038a6:	bf00      	nop
	...

080038b0 <eval_mulf>:
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mulf(vmc_t *vmc, INT *pc_idx) {
 80038b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80038b2:	680b      	ldr	r3, [r1, #0]
 80038b4:	3301      	adds	r3, #1
 80038b6:	600b      	str	r3, [r1, #0]
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mulf(vmc_t *vmc, INT *pc_idx) {
 80038b8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80038ba:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80038be:	1c43      	adds	r3, r0, #1
 80038c0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80038c4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mulf(vmc_t *vmc, INT *pc_idx) {
 80038c8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80038ca:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80038ce:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_mulf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80038d2:	2500      	movs	r5, #0
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mulf(vmc_t *vmc, INT *pc_idx) {
 80038d4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80038d6:	303c      	adds	r0, #60	; 0x3c
 80038d8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mulf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80038da:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80038dc:	f8ad 5000 	strh.w	r5, [sp]
 80038e0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80038e2:	f004 ffa5 	bl	8008830 <stack_pop>
  if(i == 0){
 80038e6:	b188      	cbz	r0, 800390c <eval_mulf+0x5c>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80038e8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
 80038ec:	ed9d 7a01 	vldr	s14, [sp, #4]
 80038f0:	ee07 7a90 	vmov	s15, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80038f4:	3301      	adds	r3, #1
 80038f6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80038fa:	011b      	lsls	r3, r3, #4
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
 80038fc:	ee67 7a87 	vmul.f32	s15, s15, s14
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003900:	18e2      	adds	r2, r4, r3
 8003902:	52e5      	strh	r5, [r4, r3]
 8003904:	edc2 7a01 	vstr	s15, [r2, #4]
}
 8003908:	b003      	add	sp, #12
 800390a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800390c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003910:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003912:	b003      	add	sp, #12
 8003914:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003916:	bf00      	nop
	...

08003920 <eval_addf>:
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}


void eval_addf(vmc_t *vmc, INT *pc_idx) {
 8003920:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003922:	680b      	ldr	r3, [r1, #0]
 8003924:	3301      	adds	r3, #1
 8003926:	600b      	str	r3, [r1, #0]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}


void eval_addf(vmc_t *vmc, INT *pc_idx) {
 8003928:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800392a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800392e:	1c43      	adds	r3, r0, #1
 8003930:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003934:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}


void eval_addf(vmc_t *vmc, INT *pc_idx) {
 8003938:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800393a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800393e:	eb04 1000 	add.w	r0, r4, r0, lsl #4


void eval_addf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003942:	2500      	movs	r5, #0
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}


void eval_addf(vmc_t *vmc, INT *pc_idx) {
 8003944:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003946:	303c      	adds	r0, #60	; 0x3c
 8003948:	4669      	mov	r1, sp
}


void eval_addf(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800394a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 800394c:	f8ad 5000 	strh.w	r5, [sp]
 8003950:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003952:	f004 ff6d 	bl	8008830 <stack_pop>
  if(i == 0){
 8003956:	b188      	cbz	r0, 800397c <eval_addf+0x5c>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003958:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
 800395c:	ed9d 7a01 	vldr	s14, [sp, #4]
 8003960:	ee07 7a90 	vmov	s15, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003964:	3301      	adds	r3, #1
 8003966:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800396a:	011b      	lsls	r3, r3, #4
  float temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
 800396c:	ee77 7a87 	vadd.f32	s15, s15, s14
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003970:	18e2      	adds	r2, r4, r3
 8003972:	52e5      	strh	r5, [r4, r3]
 8003974:	edc2 7a01 	vstr	s15, [r2, #4]
}
 8003978:	b003      	add	sp, #12
 800397a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 800397c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003980:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(float));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003982:	b003      	add	sp, #12
 8003984:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003986:	bf00      	nop
	...

08003990 <eval_min_signedi>:
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_signedi(vmc_t *vmc, INT *pc_idx) {
 8003990:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003992:	680b      	ldr	r3, [r1, #0]
 8003994:	3301      	adds	r3, #1
 8003996:	600b      	str	r3, [r1, #0]
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_signedi(vmc_t *vmc, INT *pc_idx) {
 8003998:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800399a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800399e:	1c43      	adds	r3, r0, #1
 80039a0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80039a4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_signedi(vmc_t *vmc, INT *pc_idx) {
 80039a8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80039aa:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80039ae:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_min_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80039b2:	2500      	movs	r5, #0
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_signedi(vmc_t *vmc, INT *pc_idx) {
 80039b4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80039b6:	303c      	adds	r0, #60	; 0x3c
 80039b8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80039ba:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 80039bc:	f8ad 5000 	strh.w	r5, [sp]
 80039c0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80039c2:	f004 ff35 	bl	8008830 <stack_pop>
  if(i == 0){
 80039c6:	b160      	cbz	r0, 80039e2 <eval_min_signedi+0x52>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80039c8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
 80039cc:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80039ce:	3301      	adds	r3, #1
 80039d0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80039d4:	011b      	lsls	r3, r3, #4
 80039d6:	18e1      	adds	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
 80039d8:	1bd7      	subs	r7, r2, r7
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 80039da:	52e5      	strh	r5, [r4, r3]
 80039dc:	604f      	str	r7, [r1, #4]
}
 80039de:	b003      	add	sp, #12
 80039e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 80039e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80039e6:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 - temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 80039e8:	b003      	add	sp, #12
 80039ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80039ec:	0000      	movs	r0, r0
	...

080039f0 <eval_mul_signedi>:
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_signedi(vmc_t *vmc, INT *pc_idx) {
 80039f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 80039f2:	680b      	ldr	r3, [r1, #0]
 80039f4:	3301      	adds	r3, #1
 80039f6:	600b      	str	r3, [r1, #0]
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_signedi(vmc_t *vmc, INT *pc_idx) {
 80039f8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80039fa:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80039fe:	1c43      	adds	r3, r0, #1
 8003a00:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a04:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_signedi(vmc_t *vmc, INT *pc_idx) {
 8003a08:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003a0a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a0e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_mul_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003a12:	2500      	movs	r5, #0
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_signedi(vmc_t *vmc, INT *pc_idx) {
 8003a14:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a16:	303c      	adds	r0, #60	; 0x3c
 8003a18:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003a1a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003a1c:	f8ad 5000 	strh.w	r5, [sp]
 8003a20:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a22:	f004 ff05 	bl	8008830 <stack_pop>
  if(i == 0){
 8003a26:	b168      	cbz	r0, 8003a44 <eval_mul_signedi+0x54>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003a28:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
 8003a2c:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003a2e:	3301      	adds	r3, #1
 8003a30:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003a34:	011b      	lsls	r3, r3, #4
 8003a36:	18e1      	adds	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
 8003a38:	fb02 f707 	mul.w	r7, r2, r7
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003a3c:	52e5      	strh	r5, [r4, r3]
 8003a3e:	604f      	str	r7, [r1, #4]
}
 8003a40:	b003      	add	sp, #12
 8003a42:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003a44:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003a48:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 * temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003a4a:	b003      	add	sp, #12
 8003a4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003a4e:	bf00      	nop

08003a50 <eval_add_signedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_add_signedi(vmc_t *vmc, INT *pc_idx) {
 8003a50:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003a52:	680b      	ldr	r3, [r1, #0]
 8003a54:	3301      	adds	r3, #1
 8003a56:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_add_signedi(vmc_t *vmc, INT *pc_idx) {
 8003a58:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003a5a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8003a5e:	1c43      	adds	r3, r0, #1
 8003a60:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a64:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_add_signedi(vmc_t *vmc, INT *pc_idx) {
 8003a68:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003a6a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a6e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_add_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003a72:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_add_signedi(vmc_t *vmc, INT *pc_idx) {
 8003a74:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a76:	303c      	adds	r0, #60	; 0x3c
 8003a78:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_add_signedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003a7a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003a7c:	f8ad 5000 	strh.w	r5, [sp]
 8003a80:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003a82:	f004 fed5 	bl	8008830 <stack_pop>
  if(i == 0){
 8003a86:	b160      	cbz	r0, 8003aa2 <eval_add_signedi+0x52>
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003a88:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
 8003a8c:	9a01      	ldr	r2, [sp, #4]
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003a8e:	3301      	adds	r3, #1
 8003a90:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003a94:	011b      	lsls	r3, r3, #4
 8003a96:	18e1      	adds	r1, r4, r3
  INT temp2;
  INT temp3;
  cam_register_t final_value = { .flags = 0, .value = 0 };
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
 8003a98:	4417      	add	r7, r2
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003a9a:	52e5      	strh	r5, [r4, r3]
 8003a9c:	604f      	str	r7, [r1, #4]
}
 8003a9e:	b003      	add	sp, #12
 8003aa0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003aa2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003aa6:	6033      	str	r3, [r6, #0]
  memcpy(&temp1, &hold_reg.value, sizeof(UINT));
  memcpy(&temp2, &e.value, sizeof(UINT));
  temp3 = temp1 + temp2;
  memcpy(&final_value.value, &temp3, sizeof(INT));
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003aa8:	b003      	add	sp, #12
 8003aaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003aac:	0000      	movs	r0, r0
	...

08003ab0 <eval_min_unsignedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003ab2:	680b      	ldr	r3, [r1, #0]
 8003ab4:	3301      	adds	r3, #1
 8003ab6:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003ab8:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003aba:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8003abe:	1c43      	adds	r3, r0, #1
 8003ac0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ac4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003ac8:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003aca:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ace:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_min_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003ad2:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003ad4:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ad6:	303c      	adds	r0, #60	; 0x3c
 8003ad8:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_min_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003ada:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003adc:	f8ad 5000 	strh.w	r5, [sp]
 8003ae0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ae2:	f004 fea5 	bl	8008830 <stack_pop>
  if(i == 0){
 8003ae6:	b160      	cbz	r0, 8003b02 <eval_min_unsignedi+0x52>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003ae8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
 8003aec:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003aee:	3301      	adds	r3, #1
 8003af0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003af4:	011b      	lsls	r3, r3, #4
 8003af6:	18e1      	adds	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
 8003af8:	1bd7      	subs	r7, r2, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003afa:	52e5      	strh	r5, [r4, r3]
 8003afc:	604f      	str	r7, [r1, #4]
}
 8003afe:	b003      	add	sp, #12
 8003b00:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003b02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003b06:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value - e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003b08:	b003      	add	sp, #12
 8003b0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b0c:	0000      	movs	r0, r0
	...

08003b10 <eval_mul_unsignedi>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b10:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003b12:	680b      	ldr	r3, [r1, #0]
 8003b14:	3301      	adds	r3, #1
 8003b16:	600b      	str	r3, [r1, #0]
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b18:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003b1a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8003b1e:	1c43      	adds	r3, r0, #1
 8003b20:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003b24:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b28:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003b2a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003b2e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_mul_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003b32:	2500      	movs	r5, #0
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b34:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003b36:	303c      	adds	r0, #60	; 0x3c
 8003b38:	4669      	mov	r1, sp
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_mul_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003b3a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003b3c:	f8ad 5000 	strh.w	r5, [sp]
 8003b40:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003b42:	f004 fe75 	bl	8008830 <stack_pop>
  if(i == 0){
 8003b46:	b168      	cbz	r0, 8003b64 <eval_mul_unsignedi+0x54>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003b48:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
 8003b4c:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003b4e:	3301      	adds	r3, #1
 8003b50:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003b54:	011b      	lsls	r3, r3, #4
 8003b56:	18e1      	adds	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
 8003b58:	fb02 f707 	mul.w	r7, r2, r7
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003b5c:	52e5      	strh	r5, [r4, r3]
 8003b5e:	604f      	str	r7, [r1, #4]
}
 8003b60:	b003      	add	sp, #12
 8003b62:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003b64:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003b68:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value * e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003b6a:	b003      	add	sp, #12
 8003b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b6e:	bf00      	nop

08003b70 <eval_add_unsignedi>:
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;

}

void eval_add_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b70:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003b72:	680b      	ldr	r3, [r1, #0]
 8003b74:	3301      	adds	r3, #1
 8003b76:	600b      	str	r3, [r1, #0]
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;

}

void eval_add_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b78:	4604      	mov	r4, r0
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003b7a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8003b7e:	1c43      	adds	r3, r0, #1
 8003b80:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003b84:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;

}

void eval_add_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b88:	b083      	sub	sp, #12
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003b8a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003b8e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_add_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003b92:	2500      	movs	r5, #0
  vmc->contexts[vmc->current_running_context_id].env = v;
  (*pc_idx)++;

}

void eval_add_unsignedi(vmc_t *vmc, INT *pc_idx) {
 8003b94:	460e      	mov	r6, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003b96:	303c      	adds	r0, #60	; 0x3c
 8003b98:	4669      	mov	r1, sp

}

void eval_add_unsignedi(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003b9a:	685f      	ldr	r7, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003b9c:	f8ad 5000 	strh.w	r5, [sp]
 8003ba0:	9501      	str	r5, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ba2:	f004 fe45 	bl	8008830 <stack_pop>
  if(i == 0){
 8003ba6:	b160      	cbz	r0, 8003bc2 <eval_add_unsignedi+0x52>
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003ba8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
 8003bac:	9a01      	ldr	r2, [sp, #4]
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003bae:	3301      	adds	r3, #1
 8003bb0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003bb4:	011b      	lsls	r3, r3, #4
 8003bb6:	18e1      	adds	r1, r4, r3
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
 8003bb8:	4417      	add	r7, r2
  vmc->contexts[vmc->current_running_context_id].env = final_value;
 8003bba:	52e5      	strh	r5, [r4, r3]
 8003bbc:	604f      	str	r7, [r1, #4]
}
 8003bbe:	b003      	add	sp, #12
 8003bc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003bc2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003bc6:	6033      	str	r3, [r6, #0]
    return;
  }
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value + e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}
 8003bc8:	b003      	add	sp, #12
 8003bca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003bcc:	0000      	movs	r0, r0
	...

08003bd0 <eval_gotofalse>:
  uint16_t label = get_label(vmc, pc_idx);
  // GOTO doesn't store jump address on stack
  *pc_idx = (INT)label;
}

void eval_gotofalse(vmc_t *vmc, INT *pc_idx) {
 8003bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003bd2:	4604      	mov	r4, r0
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003bd4:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8003bd8:	1c43      	adds	r3, r0, #1
 8003bda:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003bde:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  uint16_t label = get_label(vmc, pc_idx);
  // GOTO doesn't store jump address on stack
  *pc_idx = (INT)label;
}

void eval_gotofalse(vmc_t *vmc, INT *pc_idx) {
 8003be2:	b083      	sub	sp, #12
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003be4:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003be8:	eb04 1000 	add.w	r0, r4, r0, lsl #4
  *pc_idx = (INT)label;
}

void eval_gotofalse(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003bec:	2200      	movs	r2, #0
  uint16_t label = get_label(vmc, pc_idx);
  // GOTO doesn't store jump address on stack
  *pc_idx = (INT)label;
}

void eval_gotofalse(vmc_t *vmc, INT *pc_idx) {
 8003bee:	460f      	mov	r7, r1
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003bf0:	303c      	adds	r0, #60	; 0x3c
 8003bf2:	4669      	mov	r1, sp
  // GOTO doesn't store jump address on stack
  *pc_idx = (INT)label;
}

void eval_gotofalse(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003bf4:	685e      	ldr	r6, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003bf6:	f8ad 2000 	strh.w	r2, [sp]
 8003bfa:	9201      	str	r2, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003bfc:	f004 fe18 	bl	8008830 <stack_pop>
  if(i == 0){
 8003c00:	b1d8      	cbz	r0, 8003c3a <eval_gotofalse+0x6a>
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  vmc->contexts[vmc->current_running_context_id].env = hold_reg;
 8003c02:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8003c06:	e89d 0003 	ldmia.w	sp, {r0, r1}
 8003c0a:	3301      	adds	r3, #1
 8003c0c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003c10:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 8003c14:	e883 0003 	stmia.w	r3, {r0, r1}
  if ((e.value & 1) == 0){ // NOT SET; FALSE
 8003c18:	07f3      	lsls	r3, r6, #31
 8003c1a:	d504      	bpl.n	8003c26 <eval_gotofalse+0x56>
    eval_goto(vmc, pc_idx);
  } else { // TRUE
    *pc_idx = (*pc_idx) + 3;
 8003c1c:	683b      	ldr	r3, [r7, #0]
 8003c1e:	3303      	adds	r3, #3
 8003c20:	603b      	str	r3, [r7, #0]
  }
}
 8003c22:	b003      	add	sp, #12
 8003c24:	bdf0      	pop	{r4, r5, r6, r7, pc}

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8003c26:	6a62      	ldr	r2, [r4, #36]	; 0x24
    eval_callrts  // 0x37 : 55
  };


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
 8003c28:	683b      	ldr	r3, [r7, #0]
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8003c2a:	4413      	add	r3, r2
 8003c2c:	785a      	ldrb	r2, [r3, #1]


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
 8003c2e:	789b      	ldrb	r3, [r3, #2]
}

void eval_goto(vmc_t *vmc, INT *pc_idx) {
  uint16_t label = get_label(vmc, pc_idx);
  // GOTO doesn't store jump address on stack
  *pc_idx = (INT)label;
 8003c30:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003c34:	603b      	str	r3, [r7, #0]
  if ((e.value & 1) == 0){ // NOT SET; FALSE
    eval_goto(vmc, pc_idx);
  } else { // TRUE
    *pc_idx = (*pc_idx) + 3;
  }
}
 8003c36:	b003      	add	sp, #12
 8003c38:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003c3a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003c3e:	603b      	str	r3, [r7, #0]
  if ((e.value & 1) == 0){ // NOT SET; FALSE
    eval_goto(vmc, pc_idx);
  } else { // TRUE
    *pc_idx = (*pc_idx) + 3;
  }
}
 8003c40:	b003      	add	sp, #12
 8003c42:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003c50 <eval_return>:

  }

}

void eval_return(vmc_t *vmc, INT *pc_idx) {
 8003c50:	b510      	push	{r4, lr}
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003c52:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8003c56:	eb03 0343 	add.w	r3, r3, r3, lsl #1

  }

}

void eval_return(vmc_t *vmc, INT *pc_idx) {
 8003c5a:	b082      	sub	sp, #8
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003c5c:	eb00 1003 	add.w	r0, r0, r3, lsl #4

  }

}

void eval_return(vmc_t *vmc, INT *pc_idx) {
 8003c60:	460c      	mov	r4, r1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003c62:	2300      	movs	r3, #0
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003c64:	303c      	adds	r0, #60	; 0x3c
 8003c66:	4669      	mov	r1, sp
  }

}

void eval_return(vmc_t *vmc, INT *pc_idx) {
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003c68:	f8ad 3000 	strh.w	r3, [sp]
 8003c6c:	9301      	str	r3, [sp, #4]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003c6e:	f004 fddf 	bl	8008830 <stack_pop>
  if(i == 0){
 8003c72:	b118      	cbz	r0, 8003c7c <eval_return+0x2c>
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  *pc_idx = hold_reg.value;
 8003c74:	9b01      	ldr	r3, [sp, #4]
 8003c76:	6023      	str	r3, [r4, #0]
}
 8003c78:	b002      	add	sp, #8
 8003c7a:	bd10      	pop	{r4, pc}
void eval_return(vmc_t *vmc, INT *pc_idx) {
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003c7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003c80:	6023      	str	r3, [r4, #0]
    return;
  }
  *pc_idx = hold_reg.value;
}
 8003c82:	b002      	add	sp, #8
 8003c84:	bd10      	pop	{r4, pc}
 8003c86:	bf00      	nop
	...

08003c90 <eval_cons>:
  (*pc_idx)++;
  cam_value_t empty_tuple = { .value = 0, .flags = 0 };
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
}

void eval_cons(vmc_t *vmc, INT *pc_idx) {
 8003c90:	b5f0      	push	{r4, r5, r6, r7, lr}
  (*pc_idx)++;
 8003c92:	680b      	ldr	r3, [r1, #0]
 8003c94:	3301      	adds	r3, #1
 8003c96:	600b      	str	r3, [r1, #0]
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003c98:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8003c9c:	1c5a      	adds	r2, r3, #1
 8003c9e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8003ca2:	eb00 1202 	add.w	r2, r0, r2, lsl #4
  (*pc_idx)++;
  cam_value_t empty_tuple = { .value = 0, .flags = 0 };
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
}

void eval_cons(vmc_t *vmc, INT *pc_idx) {
 8003ca6:	4604      	mov	r4, r0
 8003ca8:	460d      	mov	r5, r1
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003caa:	e892 0003 	ldmia.w	r2, {r0, r1}
  (*pc_idx)++;
  cam_value_t empty_tuple = { .value = 0, .flags = 0 };
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
}

void eval_cons(vmc_t *vmc, INT *pc_idx) {
 8003cae:	b087      	sub	sp, #28
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003cb0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003cb4:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
}

void eval_cons(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003cb8:	ae02      	add	r6, sp, #8
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003cba:	af04      	add	r7, sp, #16
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
}

void eval_cons(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003cbc:	e886 0003 	stmia.w	r6, {r0, r1}
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003cc0:	2200      	movs	r2, #0
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003cc2:	f103 003c 	add.w	r0, r3, #60	; 0x3c
 8003cc6:	4639      	mov	r1, r7
}

void eval_cons(vmc_t *vmc, INT *pc_idx) {
  (*pc_idx)++;
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003cc8:	f8ad 2010 	strh.w	r2, [sp, #16]
 8003ccc:	9205      	str	r2, [sp, #20]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003cce:	f004 fdaf 	bl	8008830 <stack_pop>
  if(i == 0){
 8003cd2:	b920      	cbnz	r0, 8003cde <eval_cons+0x4e>
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003cd4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003cd8:	602b      	str	r3, [r5, #0]
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, hold_reg, e);
  }
}
 8003cda:	b007      	add	sp, #28
 8003cdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8003cde:	4620      	mov	r0, r4
 8003ce0:	f004 fea6 	bl	8008a30 <vmc_heap_alloc_withGC>
  if(hi == HEAP_NULL){
 8003ce4:	1c43      	adds	r3, r0, #1
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8003ce6:	4602      	mov	r2, r0
  if(hi == HEAP_NULL){
 8003ce8:	d0f4      	beq.n	8003cd4 <eval_cons+0x44>
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003cea:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8003cee:	3301      	adds	r3, #1
    heap_set(&vmc->heap, hi, hold_reg, e);
 8003cf0:	e896 0003 	ldmia.w	r6, {r0, r1}
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003cf4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003cf8:	011b      	lsls	r3, r3, #4
 8003cfa:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 8003cfe:	52e6      	strh	r6, [r4, r3]
    heap_set(&vmc->heap, hi, hold_reg, e);
 8003d00:	e88d 0003 	stmia.w	sp, {r0, r1}
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003d04:	18e5      	adds	r5, r4, r3
    heap_set(&vmc->heap, hi, hold_reg, e);
 8003d06:	4611      	mov	r1, r2
  } else {
    // Assuming we have space for atleast one tuple
    // Do we check this as well?
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003d08:	606a      	str	r2, [r5, #4]
    heap_set(&vmc->heap, hi, hold_reg, e);
 8003d0a:	4620      	mov	r0, r4
 8003d0c:	e897 000c 	ldmia.w	r7, {r2, r3}
 8003d10:	f004 fe9e 	bl	8008a50 <heap_set>
  }
}
 8003d14:	b007      	add	sp, #28
 8003d16:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003d20 <eval_move>:
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_move(vmc_t *vmc, INT *pc_idx){
 8003d20:	b530      	push	{r4, r5, lr}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003d22:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8003d26:	1c5a      	adds	r2, r3, #1
 8003d28:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8003d2c:	eb00 1202 	add.w	r2, r0, r2, lsl #4
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_move(vmc_t *vmc, INT *pc_idx){
 8003d30:	4604      	mov	r4, r0
 8003d32:	460d      	mov	r5, r1
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003d34:	e892 0003 	ldmia.w	r2, {r0, r1}
  cam_register_t final_value =
    { .flags = 0, .value = hold_reg.value == e.value };
  vmc->contexts[vmc->current_running_context_id].env = final_value;
}

void eval_move(vmc_t *vmc, INT *pc_idx){
 8003d38:	b083      	sub	sp, #12
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003d3a:	e88d 0003 	stmia.w	sp, {r0, r1}
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, e);
 8003d3e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003d42:	eb04 1003 	add.w	r0, r4, r3, lsl #4
 8003d46:	303c      	adds	r0, #60	; 0x3c
 8003d48:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8003d4c:	f004 fd88 	bl	8008860 <stack_push>
  if(i == 0){
 8003d50:	b170      	cbz	r0, 8003d70 <eval_move+0x50>
    *pc_idx = -1;
    return;
  }

  cam_value_t empty_tuple = { .value = 0, .flags = 0 };
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
 8003d52:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8003d56:	3301      	adds	r3, #1
 8003d58:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003d5c:	011b      	lsls	r3, r3, #4
 8003d5e:	18e1      	adds	r1, r4, r3
 8003d60:	2200      	movs	r2, #0
 8003d62:	52e2      	strh	r2, [r4, r3]
 8003d64:	604a      	str	r2, [r1, #4]

  (*pc_idx)++;
 8003d66:	682b      	ldr	r3, [r5, #0]
 8003d68:	3301      	adds	r3, #1
 8003d6a:	602b      	str	r3, [r5, #0]

}
 8003d6c:	b003      	add	sp, #12
 8003d6e:	bd30      	pop	{r4, r5, pc}
void eval_move(vmc_t *vmc, INT *pc_idx){
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, e);
  if(i == 0){
    DEBUG_PRINT(("Stack push has failed"));
    *pc_idx = -1;
 8003d70:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003d74:	602b      	str	r3, [r5, #0]
  cam_value_t empty_tuple = { .value = 0, .flags = 0 };
  vmc->contexts[vmc->current_running_context_id].env = empty_tuple;

  (*pc_idx)++;

}
 8003d76:	b003      	add	sp, #12
 8003d78:	bd30      	pop	{r4, r5, pc}
 8003d7a:	bf00      	nop
 8003d7c:	0000      	movs	r0, r0
	...

08003d80 <eval_call>:
    return;
  }
  *pc_idx = hold_reg.value;
}

void eval_call(vmc_t *vmc, INT *pc_idx) {
 8003d80:	b570      	push	{r4, r5, r6, lr}
    eval_callrts  // 0x37 : 55
  };


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
 8003d82:	680b      	ldr	r3, [r1, #0]

void eval_call(vmc_t *vmc, INT *pc_idx) {
  uint16_t label = get_label(vmc, pc_idx);
  INT jump_address = (*pc_idx) + 3; // see Jump convention at the top
  cam_value_t j_add = { .value = (UINT)jump_address };
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8003d84:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8003d88:	6a45      	ldr	r5, [r0, #36]	; 0x24
    return;
  }
  *pc_idx = hold_reg.value;
}

void eval_call(vmc_t *vmc, INT *pc_idx) {
 8003d8a:	b082      	sub	sp, #8
  uint16_t label = get_label(vmc, pc_idx);
  INT jump_address = (*pc_idx) + 3; // see Jump convention at the top
 8003d8c:	1cde      	adds	r6, r3, #3
  cam_value_t j_add = { .value = (UINT)jump_address };
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8003d8e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    return;
  }
  *pc_idx = hold_reg.value;
}

void eval_call(vmc_t *vmc, INT *pc_idx) {
 8003d92:	460c      	mov	r4, r1
  uint16_t label = get_label(vmc, pc_idx);
  INT jump_address = (*pc_idx) + 3; // see Jump convention at the top
  cam_value_t j_add = { .value = (UINT)jump_address };
 8003d94:	2100      	movs	r1, #0
 8003d96:	9601      	str	r6, [sp, #4]

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8003d98:	442b      	add	r3, r5

void eval_call(vmc_t *vmc, INT *pc_idx) {
  uint16_t label = get_label(vmc, pc_idx);
  INT jump_address = (*pc_idx) + 3; // see Jump convention at the top
  cam_value_t j_add = { .value = (UINT)jump_address };
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8003d9a:	eb00 1002 	add.w	r0, r0, r2, lsl #4
}

void eval_call(vmc_t *vmc, INT *pc_idx) {
  uint16_t label = get_label(vmc, pc_idx);
  INT jump_address = (*pc_idx) + 3; // see Jump convention at the top
  cam_value_t j_add = { .value = (UINT)jump_address };
 8003d9e:	9100      	str	r1, [sp, #0]
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8003da0:	aa02      	add	r2, sp, #8
 8003da2:	e912 0006 	ldmdb	r2, {r1, r2}
 8003da6:	303c      	adds	r0, #60	; 0x3c

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8003da8:	785e      	ldrb	r6, [r3, #1]
 8003daa:	789d      	ldrb	r5, [r3, #2]

void eval_call(vmc_t *vmc, INT *pc_idx) {
  uint16_t label = get_label(vmc, pc_idx);
  INT jump_address = (*pc_idx) + 3; // see Jump convention at the top
  cam_value_t j_add = { .value = (UINT)jump_address };
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8003dac:	f004 fd58 	bl	8008860 <stack_push>
  if(i == 0){
 8003db0:	b120      	cbz	r0, 8003dbc <eval_call+0x3c>
    DEBUG_PRINT(("Stack push has failed"));
    *pc_idx = -1;
    return;
  }
  *pc_idx = (INT)label;
 8003db2:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 8003db6:	6025      	str	r5, [r4, #0]
}
 8003db8:	b002      	add	sp, #8
 8003dba:	bd70      	pop	{r4, r5, r6, pc}
  INT jump_address = (*pc_idx) + 3; // see Jump convention at the top
  cam_value_t j_add = { .value = (UINT)jump_address };
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
  if(i == 0){
    DEBUG_PRINT(("Stack push has failed"));
    *pc_idx = -1;
 8003dbc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003dc0:	6023      	str	r3, [r4, #0]
    return;
  }
  *pc_idx = (INT)label;
}
 8003dc2:	b002      	add	sp, #8
 8003dc4:	bd70      	pop	{r4, r5, r6, pc}
 8003dc6:	bf00      	nop
	...

08003dd0 <eval_swap>:
    return;
  }
  (*pc_idx)++;
}

void eval_swap(vmc_t *vmc, INT *pc_idx) {
 8003dd0:	b5f0      	push	{r4, r5, r6, r7, lr}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003dd2:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8003dd6:	1c5a      	adds	r2, r3, #1
 8003dd8:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8003ddc:	eb00 1202 	add.w	r2, r0, r2, lsl #4
    return;
  }
  (*pc_idx)++;
}

void eval_swap(vmc_t *vmc, INT *pc_idx) {
 8003de0:	4604      	mov	r4, r0
 8003de2:	460d      	mov	r5, r1
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003de4:	e892 0003 	ldmia.w	r2, {r0, r1}
    return;
  }
  (*pc_idx)++;
}

void eval_swap(vmc_t *vmc, INT *pc_idx) {
 8003de8:	b085      	sub	sp, #20
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003dea:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003dee:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 8003df2:	af02      	add	r7, sp, #8
  }
  (*pc_idx)++;
}

void eval_swap(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003df4:	e88d 0003 	stmia.w	sp, {r0, r1}
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003df8:	2200      	movs	r2, #0
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003dfa:	f103 003c 	add.w	r0, r3, #60	; 0x3c
 8003dfe:	4639      	mov	r1, r7
  (*pc_idx)++;
}

void eval_swap(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003e00:	f8ad 2008 	strh.w	r2, [sp, #8]
 8003e04:	9203      	str	r2, [sp, #12]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003e06:	f004 fd13 	bl	8008830 <stack_pop>
  if(i == 0){
 8003e0a:	b920      	cbnz	r0, 8003e16 <eval_swap+0x46>
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003e0c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003e10:	602b      	str	r3, [r5, #0]
    *pc_idx = -1;
    return;
  }
  vmc->contexts[vmc->current_running_context_id].env = hold_reg;
  (*pc_idx)++;
}
 8003e12:	b005      	add	sp, #20
 8003e14:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  int j = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, e);
 8003e16:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 8003e1a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003e1e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
 8003e22:	303c      	adds	r0, #60	; 0x3c
 8003e24:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8003e28:	f004 fd1a 	bl	8008860 <stack_push>
  if(j == 0){
 8003e2c:	2800      	cmp	r0, #0
 8003e2e:	d0ed      	beq.n	8003e0c <eval_swap+0x3c>
    DEBUG_PRINT(("Stack push has failed"));
    *pc_idx = -1;
    return;
  }
  vmc->contexts[vmc->current_running_context_id].env = hold_reg;
 8003e30:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8003e34:	e897 0003 	ldmia.w	r7, {r0, r1}
 8003e38:	3301      	adds	r3, #1
 8003e3a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003e3e:	eb04 1403 	add.w	r4, r4, r3, lsl #4
 8003e42:	e884 0003 	stmia.w	r4, {r0, r1}
  (*pc_idx)++;
 8003e46:	682b      	ldr	r3, [r5, #0]
 8003e48:	3301      	adds	r3, #1
 8003e4a:	602b      	str	r3, [r5, #0]
}
 8003e4c:	b005      	add	sp, #20
 8003e4e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003e50 <eval_push>:
    vmc->contexts[vmc->current_running_context_id].env = v;
  }
  *pc_idx = (*pc_idx) + 2;
}

void eval_push(vmc_t *vmc, INT *pc_idx) {
 8003e50:	b530      	push	{r4, r5, lr}
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003e52:	f890 402c 	ldrb.w	r4, [r0, #44]	; 0x2c
 8003e56:	1c63      	adds	r3, r4, #1
 8003e58:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003e5c:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    vmc->contexts[vmc->current_running_context_id].env = v;
  }
  *pc_idx = (*pc_idx) + 2;
}

void eval_push(vmc_t *vmc, INT *pc_idx) {
 8003e60:	4602      	mov	r2, r0
 8003e62:	460d      	mov	r5, r1
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003e64:	e893 0003 	ldmia.w	r3, {r0, r1}
    vmc->contexts[vmc->current_running_context_id].env = v;
  }
  *pc_idx = (*pc_idx) + 2;
}

void eval_push(vmc_t *vmc, INT *pc_idx) {
 8003e68:	b083      	sub	sp, #12
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003e6a:	e88d 0003 	stmia.w	sp, {r0, r1}
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, e);
 8003e6e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8003e72:	eb02 1004 	add.w	r0, r2, r4, lsl #4
 8003e76:	303c      	adds	r0, #60	; 0x3c
 8003e78:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8003e7c:	f004 fcf0 	bl	8008860 <stack_push>
  if(i == 0){
 8003e80:	b120      	cbz	r0, 8003e8c <eval_push+0x3c>
    DEBUG_PRINT(("Stack push has failed"));
    *pc_idx = -1;
    return;
  }
  (*pc_idx)++;
 8003e82:	682b      	ldr	r3, [r5, #0]
 8003e84:	3301      	adds	r3, #1
 8003e86:	602b      	str	r3, [r5, #0]
}
 8003e88:	b003      	add	sp, #12
 8003e8a:	bd30      	pop	{r4, r5, pc}
void eval_push(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  int i = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, e);
  if(i == 0){
    DEBUG_PRINT(("Stack push has failed"));
    *pc_idx = -1;
 8003e8c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003e90:	602b      	str	r3, [r5, #0]
    return;
  }
  (*pc_idx)++;
}
 8003e92:	b003      	add	sp, #12
 8003e94:	bd30      	pop	{r4, r5, pc}
 8003e96:	bf00      	nop
	...

08003ea0 <eval_switch>:
  } else { // TRUE
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_switch(vmc_t *vmc, INT *pc_idx) {
 8003ea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003ea4:	4604      	mov	r4, r0
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003ea6:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8003eaa:	1c43      	adds	r3, r0, #1
  } else { // TRUE
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_switch(vmc_t *vmc, INT *pc_idx) {
 8003eac:	b088      	sub	sp, #32
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003eae:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003eb2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003eb6:	ae02      	add	r6, sp, #8
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_switch(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003eb8:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ebc:	eb04 1000 	add.w	r0, r4, r0, lsl #4
  }
}

void eval_switch(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003ec0:	2200      	movs	r2, #0
  } else { // TRUE
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_switch(vmc_t *vmc, INT *pc_idx) {
 8003ec2:	460d      	mov	r5, r1
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ec4:	303c      	adds	r0, #60	; 0x3c
 8003ec6:	4631      	mov	r1, r6
    *pc_idx = (*pc_idx) + 3;
  }
}

void eval_switch(vmc_t *vmc, INT *pc_idx) {
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003ec8:	f8d3 8004 	ldr.w	r8, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003ecc:	f8ad 2008 	strh.w	r2, [sp, #8]
 8003ed0:	9203      	str	r2, [sp, #12]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003ed2:	f004 fcad 	bl	8008830 <stack_pop>
  if(i == 0){
 8003ed6:	b928      	cbnz	r0, 8003ee4 <eval_switch+0x44>
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
 8003ed8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003edc:	602b      	str	r3, [r5, #0]
  vmc->contexts[vmc->current_running_context_id].env = env_pointer;
  heap_set(&vmc->heap, hi, hold_reg, val);

  //goto label
  *pc_idx = (INT)label_to_jump;
}
 8003ede:	b008      	add	sp, #32
 8003ee0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  heap_index closure_address = e.value; // TODO: should we do a pointer check here?
  cam_value_t tag_heap = heap_fst(&vmc->heap, closure_address);
 8003ee4:	a804      	add	r0, sp, #16
 8003ee6:	4621      	mov	r1, r4
 8003ee8:	4642      	mov	r2, r8
  cam_value_t val = heap_snd(&vmc->heap, closure_address);
 8003eea:	af06      	add	r7, sp, #24
    DEBUG_PRINT(("Stack pop has failed"));
    *pc_idx = -1;
    return;
  }
  heap_index closure_address = e.value; // TODO: should we do a pointer check here?
  cam_value_t tag_heap = heap_fst(&vmc->heap, closure_address);
 8003eec:	f004 fde0 	bl	8008ab0 <heap_fst>
  cam_value_t val = heap_snd(&vmc->heap, closure_address);
 8003ef0:	4642      	mov	r2, r8
 8003ef2:	4638      	mov	r0, r7
 8003ef4:	4621      	mov	r1, r4
 8003ef6:	f004 fdcb 	bl	8008a90 <heap_snd>
  INT switch_size_idx = (*pc_idx) + 1;
 8003efa:	682b      	ldr	r3, [r5, #0]
  uint8_t switch_size = vmc->code_memory[switch_size_idx];
 8003efc:	6a60      	ldr	r0, [r4, #36]	; 0x24
    return;
  }
  heap_index closure_address = e.value; // TODO: should we do a pointer check here?
  cam_value_t tag_heap = heap_fst(&vmc->heap, closure_address);
  cam_value_t val = heap_snd(&vmc->heap, closure_address);
  INT switch_size_idx = (*pc_idx) + 1;
 8003efe:	1c5a      	adds	r2, r3, #1
  uint8_t switch_size = vmc->code_memory[switch_size_idx];

  int label_to_jump = -1;

  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 8003f00:	1c99      	adds	r1, r3, #2
  }
  heap_index closure_address = e.value; // TODO: should we do a pointer check here?
  cam_value_t tag_heap = heap_fst(&vmc->heap, closure_address);
  cam_value_t val = heap_snd(&vmc->heap, closure_address);
  INT switch_size_idx = (*pc_idx) + 1;
  uint8_t switch_size = vmc->code_memory[switch_size_idx];
 8003f02:	f810 e002 	ldrb.w	lr, [r0, r2]

  int label_to_jump = -1;

  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 8003f06:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
 8003f0a:	4571      	cmp	r1, lr
 8003f0c:	d8e4      	bhi.n	8003ed8 <eval_switch+0x38>
 8003f0e:	f8dd c014 	ldr.w	ip, [sp, #20]
 8003f12:	4403      	add	r3, r0
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
 8003f14:	f64f 7aff 	movw	sl, #65535	; 0xffff
 8003f18:	e003      	b.n	8003f22 <eval_switch+0x82>
 8003f1a:	4552      	cmp	r2, sl
 8003f1c:	d00f      	beq.n	8003f3e <eval_switch+0x9e>
  INT switch_size_idx = (*pc_idx) + 1;
  uint8_t switch_size = vmc->code_memory[switch_size_idx];

  int label_to_jump = -1;

  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 8003f1e:	4571      	cmp	r1, lr
 8003f20:	d8da      	bhi.n	8003ed8 <eval_switch+0x38>
    INT tag_idx1 = i;
    INT tag_idx2 = i + 1;
    uint16_t tag =
      (vmc->code_memory[tag_idx1] << 8) | vmc->code_memory[tag_idx2]; // merge 2 bytes
 8003f22:	7898      	ldrb	r0, [r3, #2]
  int label_to_jump = -1;

  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
    INT tag_idx1 = i;
    INT tag_idx2 = i + 1;
    uint16_t tag =
 8003f24:	78da      	ldrb	r2, [r3, #3]
      (vmc->code_memory[tag_idx1] << 8) | vmc->code_memory[tag_idx2]; // merge 2 bytes

    INT lab_idx1 = i + 2;
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 8003f26:	f893 9004 	ldrb.w	r9, [r3, #4]
 8003f2a:	f893 8005 	ldrb.w	r8, [r3, #5]
  int label_to_jump = -1;

  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
    INT tag_idx1 = i;
    INT tag_idx2 = i + 1;
    uint16_t tag =
 8003f2e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
 8003f32:	4562      	cmp	r2, ip
  INT switch_size_idx = (*pc_idx) + 1;
  uint8_t switch_size = vmc->code_memory[switch_size_idx];

  int label_to_jump = -1;

  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 8003f34:	f101 0104 	add.w	r1, r1, #4
 8003f38:	f103 0304 	add.w	r3, r3, #4
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
 8003f3c:	d1ed      	bne.n	8003f1a <eval_switch+0x7a>
    DEBUG_PRINT(("Tag %u not found while switching", tag_heap.value));
    *pc_idx = -1;
    return;
  }

  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8003f3e:	4620      	mov	r0, r4
 8003f40:	f004 fd76 	bl	8008a30 <vmc_heap_alloc_withGC>
  if(hi == HEAP_NULL){
 8003f44:	1c43      	adds	r3, r0, #1
    DEBUG_PRINT(("Tag %u not found while switching", tag_heap.value));
    *pc_idx = -1;
    return;
  }

  heap_index hi = vmc_heap_alloc_withGC(vmc);
 8003f46:	4602      	mov	r2, r0
  if(hi == HEAP_NULL){
 8003f48:	d0c6      	beq.n	8003ed8 <eval_switch+0x38>
    *pc_idx = -1;
    return;
  }
  cam_value_t env_pointer =
    { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
  vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003f4a:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8003f4e:	3301      	adds	r3, #1
  heap_set(&vmc->heap, hi, hold_reg, val);
 8003f50:	e897 0003 	ldmia.w	r7, {r0, r1}
    *pc_idx = -1;
    return;
  }
  cam_value_t env_pointer =
    { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
  vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003f54:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003f58:	011b      	lsls	r3, r3, #4
 8003f5a:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
 8003f5e:	f824 e003 	strh.w	lr, [r4, r3]
  heap_set(&vmc->heap, hi, hold_reg, val);
 8003f62:	e88d 0003 	stmia.w	sp, {r0, r1}
    *pc_idx = -1;
    return;
  }
  cam_value_t env_pointer =
    { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
  vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003f66:	18e7      	adds	r7, r4, r3
  heap_set(&vmc->heap, hi, hold_reg, val);
 8003f68:	4611      	mov	r1, r2
    *pc_idx = -1;
    return;
  }
  cam_value_t env_pointer =
    { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
  vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 8003f6a:	607a      	str	r2, [r7, #4]
  heap_set(&vmc->heap, hi, hold_reg, val);
 8003f6c:	4620      	mov	r0, r4
 8003f6e:	e896 000c 	ldmia.w	r6, {r2, r3}
 8003f72:	f004 fd6d 	bl	8008a50 <heap_set>
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
       (UINT)tag == 65535){ //wildcard check; wildcard tag = max(uint16_t) = 65535
      label_to_jump = label;
 8003f76:	ea48 2309 	orr.w	r3, r8, r9, lsl #8
 8003f7a:	602b      	str	r3, [r5, #0]
 8003f7c:	e7af      	b.n	8003ede <eval_switch+0x3e>
 8003f7e:	bf00      	nop

08003f80 <eval_app>:
    vmc->all_contexts_stopped = true;
  }

}

void eval_app(vmc_t *vmc, INT *pc_idx) {
 8003f80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003f84:	4604      	mov	r4, r0

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003f86:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8003f8a:	1c43      	adds	r3, r0, #1
    vmc->all_contexts_stopped = true;
  }

}

void eval_app(vmc_t *vmc, INT *pc_idx) {
 8003f8c:	b08c      	sub	sp, #48	; 0x30

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003f8e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003f92:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003f96:	ad02      	add	r5, sp, #8

}

void eval_app(vmc_t *vmc, INT *pc_idx) {

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003f98:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003f9c:	eb04 1000 	add.w	r0, r4, r0, lsl #4
}

void eval_app(vmc_t *vmc, INT *pc_idx) {

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003fa0:	2600      	movs	r6, #0
    vmc->all_contexts_stopped = true;
  }

}

void eval_app(vmc_t *vmc, INT *pc_idx) {
 8003fa2:	460f      	mov	r7, r1

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003fa4:	303c      	adds	r0, #60	; 0x3c
 8003fa6:	4629      	mov	r1, r5

}

void eval_app(vmc_t *vmc, INT *pc_idx) {

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8003fa8:	f8d3 8004 	ldr.w	r8, [r3, #4]
  cam_register_t hold_reg = { .flags = 0, .value = 0 }; // init register
 8003fac:	f8ad 6008 	strh.w	r6, [sp, #8]
 8003fb0:	9603      	str	r6, [sp, #12]
  int i = stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8003fb2:	f004 fc3d 	bl	8008830 <stack_pop>
  if(i == 0){
 8003fb6:	b928      	cbnz	r0, 8003fc4 <eval_app+0x44>
    cam_value_t label = heap_s;

    heap_index hi = vmc_heap_alloc_withGC(vmc);
    if(hi == HEAP_NULL){
      DEBUG_PRINT(("Heap allocation has failed"));
      *pc_idx = -1;
 8003fb8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003fbc:	603b      	str	r3, [r7, #0]
    }
    *pc_idx = (INT)label.value;

  }

}
 8003fbe:	b00c      	add	sp, #48	; 0x30
 8003fc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }

  heap_index closure_address = e.value; // TODO: should we do a pointer check here?
                                        // closure or combinator, the if checks that

  cam_value_t heap_f = heap_fst(&vmc->heap, closure_address);
 8003fc4:	f10d 0910 	add.w	r9, sp, #16
 8003fc8:	4642      	mov	r2, r8
 8003fca:	4648      	mov	r0, r9
 8003fcc:	4621      	mov	r1, r4
 8003fce:	f004 fd6f 	bl	8008ab0 <heap_fst>
  cam_value_t heap_s = heap_snd(&vmc->heap, closure_address);
 8003fd2:	4642      	mov	r2, r8
 8003fd4:	a806      	add	r0, sp, #24
 8003fd6:	4621      	mov	r1, r4
  }

  heap_index closure_address = e.value; // TODO: should we do a pointer check here?
                                        // closure or combinator, the if checks that

  cam_value_t heap_f = heap_fst(&vmc->heap, closure_address);
 8003fd8:	f8dd a014 	ldr.w	sl, [sp, #20]
  cam_value_t heap_s = heap_snd(&vmc->heap, closure_address);
 8003fdc:	f004 fd58 	bl	8008a90 <heap_snd>
 8003fe0:	f8dd 801c 	ldr.w	r8, [sp, #28]

  if(heap_s.value == COMB){ // if combinator
 8003fe4:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 8003fe8:	d037      	beq.n	800405a <eval_app+0xda>
    }
    *pc_idx = (INT)label.value;

  } else { // not a combinator but a closure

    cam_value_t val = heap_f;
 8003fea:	e899 0003 	ldmia.w	r9, {r0, r1}
 8003fee:	f10d 0a20 	add.w	sl, sp, #32
 8003ff2:	e88a 0003 	stmia.w	sl, {r0, r1}
    cam_value_t label = heap_s;

    heap_index hi = vmc_heap_alloc_withGC(vmc);
 8003ff6:	4620      	mov	r0, r4
 8003ff8:	f004 fd1a 	bl	8008a30 <vmc_heap_alloc_withGC>
    if(hi == HEAP_NULL){
 8003ffc:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
  } else { // not a combinator but a closure

    cam_value_t val = heap_f;
    cam_value_t label = heap_s;

    heap_index hi = vmc_heap_alloc_withGC(vmc);
 8004000:	4681      	mov	r9, r0
    if(hi == HEAP_NULL){
 8004002:	d0d9      	beq.n	8003fb8 <eval_app+0x38>
      DEBUG_PRINT(("Heap allocation has failed"));
      *pc_idx = -1;
      return;
    }
    heap_set(&vmc->heap, hi, val, hold_reg);
 8004004:	e895 0003 	ldmia.w	r5, {r0, r1}
 8004008:	e89a 000c 	ldmia.w	sl, {r2, r3}
 800400c:	e88d 0003 	stmia.w	sp, {r0, r1}
 8004010:	4620      	mov	r0, r4
 8004012:	4649      	mov	r1, r9
 8004014:	f004 fd1c 	bl	8008a50 <heap_set>
    cam_value_t new_env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = new_env_pointer;
 8004018:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
    cam_value_t j_add = { .value = (UINT)jump_address };
 800401c:	960a      	str	r6, [sp, #40]	; 0x28
      return;
    }
    heap_set(&vmc->heap, hi, val, hold_reg);
    cam_value_t new_env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = new_env_pointer;
 800401e:	3301      	adds	r3, #1
 8004020:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004024:	011b      	lsls	r3, r3, #4
 8004026:	18e2      	adds	r2, r4, r3
 8004028:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800402c:	52e1      	strh	r1, [r4, r3]
 800402e:	f8c2 9004 	str.w	r9, [r2, #4]


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
 8004032:	683b      	ldr	r3, [r7, #0]
    cam_value_t j_add = { .value = (UINT)jump_address };
    int j = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8004034:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = new_env_pointer;


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
 8004038:	3301      	adds	r3, #1
    cam_value_t j_add = { .value = (UINT)jump_address };
    int j = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 800403a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    vmc->contexts[vmc->current_running_context_id].env = new_env_pointer;


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
    cam_value_t j_add = { .value = (UINT)jump_address };
 800403e:	930b      	str	r3, [sp, #44]	; 0x2c
    int j = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8004040:	eb04 1000 	add.w	r0, r4, r0, lsl #4
 8004044:	ab0c      	add	r3, sp, #48	; 0x30
 8004046:	e913 0006 	ldmdb	r3, {r1, r2}
 800404a:	303c      	adds	r0, #60	; 0x3c
 800404c:	f004 fc08 	bl	8008860 <stack_push>
    if(j == 0){
 8004050:	2800      	cmp	r0, #0
 8004052:	d0b1      	beq.n	8003fb8 <eval_app+0x38>
      DEBUG_PRINT(("Stack push has failed"));
      *pc_idx = -1;
      return;
    }
    *pc_idx = (INT)label.value;
 8004054:	f8c7 8000 	str.w	r8, [r7]
 8004058:	e7b1      	b.n	8003fbe <eval_app+0x3e>

  if(heap_s.value == COMB){ // if combinator

    cam_value_t label = heap_f;

    vmc->contexts[vmc->current_running_context_id].env = hold_reg;
 800405a:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
    cam_value_t j_add = { .value = (UINT)jump_address };
 800405e:	960a      	str	r6, [sp, #40]	; 0x28

  if(heap_s.value == COMB){ // if combinator

    cam_value_t label = heap_f;

    vmc->contexts[vmc->current_running_context_id].env = hold_reg;
 8004060:	e895 0003 	ldmia.w	r5, {r0, r1}
 8004064:	1c5a      	adds	r2, r3, #1
 8004066:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800406a:	eb04 1202 	add.w	r2, r4, r2, lsl #4
 800406e:	e882 0003 	stmia.w	r2, {r0, r1}


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
 8004072:	683a      	ldr	r2, [r7, #0]
    cam_value_t j_add = { .value = (UINT)jump_address };
    int j = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8004074:	eb03 0343 	add.w	r3, r3, r3, lsl #1

    vmc->contexts[vmc->current_running_context_id].env = hold_reg;


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
 8004078:	3201      	adds	r2, #1
    cam_value_t j_add = { .value = (UINT)jump_address };
    int j = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 800407a:	eb04 1003 	add.w	r0, r4, r3, lsl #4
    vmc->contexts[vmc->current_running_context_id].env = hold_reg;


    //jump to label
    INT jump_address = (*pc_idx) + 1; // see Jump convention at the top
    cam_value_t j_add = { .value = (UINT)jump_address };
 800407e:	920b      	str	r2, [sp, #44]	; 0x2c
    int j = stack_push(&vmc->contexts[vmc->current_running_context_id].stack, j_add);
 8004080:	ab0c      	add	r3, sp, #48	; 0x30
 8004082:	e913 0006 	ldmdb	r3, {r1, r2}
 8004086:	303c      	adds	r0, #60	; 0x3c
 8004088:	f004 fbea 	bl	8008860 <stack_push>
    if(j == 0){
      DEBUG_PRINT(("Stack push has failed"));
      *pc_idx = -1;
 800408c:	2800      	cmp	r0, #0
 800408e:	bf14      	ite	ne
 8004090:	4653      	movne	r3, sl
 8004092:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
 8004096:	603b      	str	r3, [r7, #0]
 8004098:	e791      	b.n	8003fbe <eval_app+0x3e>
 800409a:	bf00      	nop
 800409c:	0000      	movs	r0, r0
	...

080040a0 <eval_rest>:
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)vmc->contexts[vmc->current_running_context_id].env.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
  *pc_idx = (*pc_idx) + 2;
}

void eval_rest(vmc_t *vmc, INT *pc_idx)  {
 80040a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
 80040a4:	6a42      	ldr	r2, [r0, #36]	; 0x24
  vmc->contexts[vmc->current_running_context_id].env = v;
  *pc_idx = (*pc_idx) + 2;
}

void eval_rest(vmc_t *vmc, INT *pc_idx)  {
  INT n_idx = (*pc_idx) + 1;
 80040a6:	680b      	ldr	r3, [r1, #0]
  uint8_t acc_n = vmc->code_memory[n_idx];
 80040a8:	441a      	add	r2, r3
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)vmc->contexts[vmc->current_running_context_id].env.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
  *pc_idx = (*pc_idx) + 2;
}

void eval_rest(vmc_t *vmc, INT *pc_idx)  {
 80040aa:	b082      	sub	sp, #8
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 80040ac:	7855      	ldrb	r5, [r2, #1]
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)vmc->contexts[vmc->current_running_context_id].env.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
  *pc_idx = (*pc_idx) + 2;
}

void eval_rest(vmc_t *vmc, INT *pc_idx)  {
 80040ae:	4604      	mov	r4, r0
 80040b0:	460e      	mov	r6, r1
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 80040b2:	b1f5      	cbz	r5, 80040f2 <eval_rest+0x52>
 80040b4:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 80040b8:	f04f 0800 	mov.w	r8, #0
 80040bc:	3301      	adds	r3, #1
 80040be:	466f      	mov	r7, sp
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80040c0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80040c4:	eb04 1303 	add.w	r3, r4, r3, lsl #4
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
 80040c8:	4638      	mov	r0, r7
 80040ca:	685a      	ldr	r2, [r3, #4]
 80040cc:	4621      	mov	r1, r4
 80040ce:	f004 fcef 	bl	8008ab0 <heap_fst>
    vmc->contexts[vmc->current_running_context_id].env = v;
 80040d2:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80040d6:	e897 0003 	ldmia.w	r7, {r0, r1}
 80040da:	3301      	adds	r3, #1
 80040dc:	eb03 0243 	add.w	r2, r3, r3, lsl #1
}

void eval_rest(vmc_t *vmc, INT *pc_idx)  {
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 80040e0:	f108 0801 	add.w	r8, r8, #1
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
    vmc->contexts[vmc->current_running_context_id].env = v;
 80040e4:	eb04 1202 	add.w	r2, r4, r2, lsl #4
}

void eval_rest(vmc_t *vmc, INT *pc_idx)  {
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 80040e8:	45a8      	cmp	r8, r5
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
    vmc->contexts[vmc->current_running_context_id].env = v;
 80040ea:	e882 0003 	stmia.w	r2, {r0, r1}
}

void eval_rest(vmc_t *vmc, INT *pc_idx)  {
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 80040ee:	d1e7      	bne.n	80040c0 <eval_rest+0x20>
 80040f0:	6833      	ldr	r3, [r6, #0]
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
    vmc->contexts[vmc->current_running_context_id].env = v;
  }
  *pc_idx = (*pc_idx) + 2;
 80040f2:	3302      	adds	r3, #2
 80040f4:	6033      	str	r3, [r6, #0]
}
 80040f6:	b002      	add	sp, #8
 80040f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80040fc:	0000      	movs	r0, r0
	...

08004100 <eval_acc>:
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)e.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
}


void eval_acc(vmc_t *vmc, INT *pc_idx) {
 8004100:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
 8004104:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8004106:	680b      	ldr	r3, [r1, #0]
 8004108:	4413      	add	r3, r2
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)e.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
}


void eval_acc(vmc_t *vmc, INT *pc_idx) {
 800410a:	b082      	sub	sp, #8
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 800410c:	785c      	ldrb	r4, [r3, #1]
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)e.value);
  vmc->contexts[vmc->current_running_context_id].env = v;
}


void eval_acc(vmc_t *vmc, INT *pc_idx) {
 800410e:	4606      	mov	r6, r0
 8004110:	460d      	mov	r5, r1
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 8004112:	b3cc      	cbz	r4, 8004188 <eval_acc+0x88>
 8004114:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8004118:	2700      	movs	r7, #0
 800411a:	3301      	adds	r3, #1
 800411c:	46e8      	mov	r8, sp
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800411e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004122:	eb06 1303 	add.w	r3, r6, r3, lsl #4
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
 8004126:	4640      	mov	r0, r8
 8004128:	685a      	ldr	r2, [r3, #4]
 800412a:	4631      	mov	r1, r6
 800412c:	f004 fcc0 	bl	8008ab0 <heap_fst>
    vmc->contexts[vmc->current_running_context_id].env = v;
 8004130:	f896 e02c 	ldrb.w	lr, [r6, #44]	; 0x2c
 8004134:	e898 0003 	ldmia.w	r8, {r0, r1}
 8004138:	f10e 0301 	add.w	r3, lr, #1
 800413c:	eb03 0243 	add.w	r2, r3, r3, lsl #1


void eval_acc(vmc_t *vmc, INT *pc_idx) {
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 8004140:	3701      	adds	r7, #1
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
    vmc->contexts[vmc->current_running_context_id].env = v;
 8004142:	eb06 1202 	add.w	r2, r6, r2, lsl #4


void eval_acc(vmc_t *vmc, INT *pc_idx) {
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 8004146:	42a7      	cmp	r7, r4
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
    vmc->contexts[vmc->current_running_context_id].env = v;
 8004148:	e882 0003 	stmia.w	r2, {r0, r1}


void eval_acc(vmc_t *vmc, INT *pc_idx) {
  INT n_idx = (*pc_idx) + 1;
  uint8_t acc_n = vmc->code_memory[n_idx];
  for(unsigned int i = 0; i < acc_n; i++){
 800414c:	d1e7      	bne.n	800411e <eval_acc+0x1e>
    cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
    cam_value_t v = heap_fst(&vmc->heap, (heap_index)e.value);
    vmc->contexts[vmc->current_running_context_id].env = v;
  }
  cam_value_t v = heap_snd(&vmc->heap, (heap_index)vmc->contexts[vmc->current_running_context_id].env.value);
 800414e:	f10e 0e01 	add.w	lr, lr, #1
 8004152:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
 8004156:	eb06 1e0e 	add.w	lr, r6, lr, lsl #4
 800415a:	4640      	mov	r0, r8
 800415c:	4631      	mov	r1, r6
 800415e:	f8de 2004 	ldr.w	r2, [lr, #4]
 8004162:	f004 fc95 	bl	8008a90 <heap_snd>
  vmc->contexts[vmc->current_running_context_id].env = v;
 8004166:	f896 302c 	ldrb.w	r3, [r6, #44]	; 0x2c
 800416a:	e898 0003 	ldmia.w	r8, {r0, r1}
 800416e:	3301      	adds	r3, #1
 8004170:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004174:	eb06 1603 	add.w	r6, r6, r3, lsl #4
 8004178:	e886 0003 	stmia.w	r6, {r0, r1}
  *pc_idx = (*pc_idx) + 2;
 800417c:	682b      	ldr	r3, [r5, #0]
 800417e:	3302      	adds	r3, #2
 8004180:	602b      	str	r3, [r5, #0]
}
 8004182:	b002      	add	sp, #8
 8004184:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004188:	f890 e02c 	ldrb.w	lr, [r0, #44]	; 0x2c
 800418c:	46e8      	mov	r8, sp
 800418e:	e7de      	b.n	800414e <eval_acc+0x4e>

08004190 <eval_stop>:
void eval_skip(vmc_t *vmc, INT *pc_idx) {
  (void)vmc;
  (*pc_idx)++;
}

void eval_stop(vmc_t *vmc, INT *pc_idx) {
 8004190:	b510      	push	{r4, lr}
  (void)pc_idx;
  vmc->context_used[vmc->current_running_context_id] = false;
 8004192:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8004196:	4403      	add	r3, r0
void eval_skip(vmc_t *vmc, INT *pc_idx) {
  (void)vmc;
  (*pc_idx)++;
}

void eval_stop(vmc_t *vmc, INT *pc_idx) {
 8004198:	4604      	mov	r4, r0
  (void)pc_idx;
  vmc->context_used[vmc->current_running_context_id] = false;
 800419a:	2200      	movs	r2, #0
 800419c:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
  int i = dispatch(vmc);
 80041a0:	f004 fb96 	bl	80088d0 <dispatch>
}

static bool is_all_contexts_stopped(vmc_t *vmc){
  bool start = false;
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    start = start | vmc->context_used[i];
 80041a4:	f894 10f0 	ldrb.w	r1, [r4, #240]	; 0xf0
 80041a8:	f894 30f1 	ldrb.w	r3, [r4, #241]	; 0xf1
 80041ac:	f894 20f2 	ldrb.w	r2, [r4, #242]	; 0xf2
 80041b0:	430b      	orrs	r3, r1
  (void)pc_idx;
  vmc->context_used[vmc->current_running_context_id] = false;
  int i = dispatch(vmc);
  if(i == -1)
    DEBUG_PRINT(("Ready Queue is empty\n"));
  if(is_all_contexts_stopped(vmc)){
 80041b2:	4313      	orrs	r3, r2
 80041b4:	d106      	bne.n	80041c4 <eval_stop+0x34>
 80041b6:	f894 30f3 	ldrb.w	r3, [r4, #243]	; 0xf3
 80041ba:	b91b      	cbnz	r3, 80041c4 <eval_stop+0x34>
    vmc->all_contexts_stopped = true;
 80041bc:	f241 4348 	movw	r3, #5192	; 0x1448
 80041c0:	2201      	movs	r2, #1
 80041c2:	54e2      	strb	r2, [r4, r3]
 80041c4:	bd10      	pop	{r4, pc}
 80041c6:	bf00      	nop
	...

080041d0 <eval_gotoifalse>:
    *pc_idx = (*pc_idx) + 3;
  }

}
void eval_gotoifalse(vmc_t *vmc, INT *pc_idx){
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 80041d0:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 80041d4:	3301      	adds	r3, #1
 80041d6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80041da:	eb00 1303 	add.w	r3, r0, r3, lsl #4

  if ((e.value & 1) == 0){ // NOT SET; FALSE
 80041de:	685b      	ldr	r3, [r3, #4]
 80041e0:	07db      	lsls	r3, r3, #31
 80041e2:	d503      	bpl.n	80041ec <eval_gotoifalse+0x1c>
    eval_goto(vmc, pc_idx);
  } else { // TRUE
    *pc_idx = (*pc_idx) + 3;
 80041e4:	680b      	ldr	r3, [r1, #0]
 80041e6:	3303      	adds	r3, #3
 80041e8:	600b      	str	r3, [r1, #0]
 80041ea:	4770      	bx	lr

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 80041ec:	6a42      	ldr	r2, [r0, #36]	; 0x24
    eval_callrts  // 0x37 : 55
  };


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
 80041ee:	680b      	ldr	r3, [r1, #0]
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 80041f0:	4413      	add	r3, r2
 80041f2:	785a      	ldrb	r2, [r3, #1]


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
 80041f4:	789b      	ldrb	r3, [r3, #2]
}

void eval_goto(vmc_t *vmc, INT *pc_idx) {
  uint16_t label = get_label(vmc, pc_idx);
  // GOTO doesn't store jump address on stack
  *pc_idx = (INT)label;
 80041f6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80041fa:	600b      	str	r3, [r1, #0]
 80041fc:	4770      	bx	lr
 80041fe:	bf00      	nop

08004200 <eval_switchi>:
    *pc_idx = (*pc_idx) + 3;
  }

}

void eval_switchi(vmc_t *vmc, INT *pc_idx){
 8004200:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 8004204:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8004208:	3301      	adds	r3, #1
 800420a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800420e:	eb00 1303 	add.w	r3, r0, r3, lsl #4
    *pc_idx = (*pc_idx) + 3;
  }

}

void eval_switchi(vmc_t *vmc, INT *pc_idx){
 8004212:	b085      	sub	sp, #20

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;

  heap_index tag_val_pair = e.value;
 8004214:	685c      	ldr	r4, [r3, #4]
    *pc_idx = (*pc_idx) + 3;
  }

}

void eval_switchi(vmc_t *vmc, INT *pc_idx){
 8004216:	4606      	mov	r6, r0

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;

  heap_index tag_val_pair = e.value;
  cam_value_t tag_heap = heap_fst(&vmc->heap, tag_val_pair);
 8004218:	4622      	mov	r2, r4
    *pc_idx = (*pc_idx) + 3;
  }

}

void eval_switchi(vmc_t *vmc, INT *pc_idx){
 800421a:	460f      	mov	r7, r1

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;

  heap_index tag_val_pair = e.value;
  cam_value_t tag_heap = heap_fst(&vmc->heap, tag_val_pair);
  cam_value_t val      = heap_snd(&vmc->heap, tag_val_pair);
 800421c:	ad02      	add	r5, sp, #8
void eval_switchi(vmc_t *vmc, INT *pc_idx){

  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;

  heap_index tag_val_pair = e.value;
  cam_value_t tag_heap = heap_fst(&vmc->heap, tag_val_pair);
 800421e:	4601      	mov	r1, r0
 8004220:	4668      	mov	r0, sp
 8004222:	f004 fc45 	bl	8008ab0 <heap_fst>
  cam_value_t val      = heap_snd(&vmc->heap, tag_val_pair);
 8004226:	4622      	mov	r2, r4
 8004228:	4631      	mov	r1, r6
 800422a:	4628      	mov	r0, r5
 800422c:	f004 fc30 	bl	8008a90 <heap_snd>
  INT switch_size_idx = (*pc_idx) + 1;
 8004230:	683b      	ldr	r3, [r7, #0]
  uint8_t switch_size = vmc->code_memory[switch_size_idx];
 8004232:	6a70      	ldr	r0, [r6, #36]	; 0x24
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;

  heap_index tag_val_pair = e.value;
  cam_value_t tag_heap = heap_fst(&vmc->heap, tag_val_pair);
  cam_value_t val      = heap_snd(&vmc->heap, tag_val_pair);
  INT switch_size_idx = (*pc_idx) + 1;
 8004234:	1c5a      	adds	r2, r3, #1
  uint8_t switch_size = vmc->code_memory[switch_size_idx];

  int label_to_jump = -1;
  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 8004236:	1c99      	adds	r1, r3, #2

  heap_index tag_val_pair = e.value;
  cam_value_t tag_heap = heap_fst(&vmc->heap, tag_val_pair);
  cam_value_t val      = heap_snd(&vmc->heap, tag_val_pair);
  INT switch_size_idx = (*pc_idx) + 1;
  uint8_t switch_size = vmc->code_memory[switch_size_idx];
 8004238:	5c84      	ldrb	r4, [r0, r2]

  int label_to_jump = -1;
  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 800423a:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 800423e:	42a1      	cmp	r1, r4
 8004240:	d828      	bhi.n	8004294 <eval_switchi+0x94>
 8004242:	f8dd c004 	ldr.w	ip, [sp, #4]
 8004246:	4403      	add	r3, r0
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
 8004248:	f64f 79ff 	movw	r9, #65535	; 0xffff
 800424c:	e003      	b.n	8004256 <eval_switchi+0x56>
 800424e:	454a      	cmp	r2, r9
 8004250:	d00f      	beq.n	8004272 <eval_switchi+0x72>
  cam_value_t val      = heap_snd(&vmc->heap, tag_val_pair);
  INT switch_size_idx = (*pc_idx) + 1;
  uint8_t switch_size = vmc->code_memory[switch_size_idx];

  int label_to_jump = -1;
  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 8004252:	42a1      	cmp	r1, r4
 8004254:	d81e      	bhi.n	8004294 <eval_switchi+0x94>
    INT tag_idx1 = i;
    INT tag_idx2 = i + 1;
    uint16_t tag =
      (vmc->code_memory[tag_idx1] << 8) | vmc->code_memory[tag_idx2]; // merge 2 bytes
 8004256:	7898      	ldrb	r0, [r3, #2]

  int label_to_jump = -1;
  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
    INT tag_idx1 = i;
    INT tag_idx2 = i + 1;
    uint16_t tag =
 8004258:	78da      	ldrb	r2, [r3, #3]
      (vmc->code_memory[tag_idx1] << 8) | vmc->code_memory[tag_idx2]; // merge 2 bytes

    INT lab_idx1 = i + 2;
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 800425a:	f893 8004 	ldrb.w	r8, [r3, #4]
 800425e:	f893 e005 	ldrb.w	lr, [r3, #5]

  int label_to_jump = -1;
  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
    INT tag_idx1 = i;
    INT tag_idx2 = i + 1;
    uint16_t tag =
 8004262:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
 8004266:	4562      	cmp	r2, ip
  cam_value_t val      = heap_snd(&vmc->heap, tag_val_pair);
  INT switch_size_idx = (*pc_idx) + 1;
  uint8_t switch_size = vmc->code_memory[switch_size_idx];

  int label_to_jump = -1;
  for(uint32_t i = (switch_size_idx + 1); i <= (switch_size_idx + (switch_size * 4)); i+=4){
 8004268:	f101 0104 	add.w	r1, r1, #4
 800426c:	f103 0304 	add.w	r3, r3, #4
    INT lab_idx2 = i + 3;
    uint16_t label =
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
 8004270:	d1ed      	bne.n	800424e <eval_switchi+0x4e>
    DEBUG_PRINT(("Tag %u not found while switching", tag_heap.value));
    *pc_idx = -1;
    return;
  }

  vmc->contexts[vmc->current_running_context_id].env = val;
 8004272:	f896 302c 	ldrb.w	r3, [r6, #44]	; 0x2c
 8004276:	e895 0003 	ldmia.w	r5, {r0, r1}
 800427a:	3301      	adds	r3, #1
 800427c:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 8004280:	eb06 1602 	add.w	r6, r6, r2, lsl #4
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
       (UINT)tag == 65535){ //wildcard check; wildcard tag = max(uint16_t) = 65535
      label_to_jump = label;
 8004284:	ea4e 2308 	orr.w	r3, lr, r8, lsl #8
    DEBUG_PRINT(("Tag %u not found while switching", tag_heap.value));
    *pc_idx = -1;
    return;
  }

  vmc->contexts[vmc->current_running_context_id].env = val;
 8004288:	e886 0003 	stmia.w	r6, {r0, r1}
      (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes


    if(tag_heap.value == (UINT)tag ||
       (UINT)tag == 65535){ //wildcard check; wildcard tag = max(uint16_t) = 65535
      label_to_jump = label;
 800428c:	603b      	str	r3, [r7, #0]


  //goto label
  *pc_idx = (INT)label_to_jump;

}
 800428e:	b005      	add	sp, #20
 8004290:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      break;
    }
  }
  if(label_to_jump == -1){
    DEBUG_PRINT(("Tag %u not found while switching", tag_heap.value));
    *pc_idx = -1;
 8004294:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004298:	603b      	str	r3, [r7, #0]


  //goto label
  *pc_idx = (INT)label_to_jump;

}
 800429a:	b005      	add	sp, #20
 800429c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080042a0 <eval_comb>:
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, e, hold_reg);
  }

}
void eval_comb(vmc_t *vmc, INT *pc_idx){
 80042a0:	b5f0      	push	{r4, r5, r6, r7, lr}

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 80042a2:	6a42      	ldr	r2, [r0, #36]	; 0x24
    eval_callrts  // 0x37 : 55
  };


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
 80042a4:	680b      	ldr	r3, [r1, #0]
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 80042a6:	4413      	add	r3, r2
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, e, hold_reg);
  }

}
void eval_comb(vmc_t *vmc, INT *pc_idx){
 80042a8:	b087      	sub	sp, #28

uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
    (vmc->code_memory[lab_idx1] << 8) | vmc->code_memory[lab_idx2]; // merge 2 bytes
 80042aa:	785a      	ldrb	r2, [r3, #1]


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
 80042ac:	789b      	ldrb	r3, [r3, #2]

}
void eval_comb(vmc_t *vmc, INT *pc_idx){

  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
 80042ae:	2600      	movs	r6, #0


uint16_t get_label(vmc_t *vmc, INT *pc_idx){
  INT lab_idx1 = (*pc_idx) + 1;
  INT lab_idx2 = (*pc_idx) + 2;
  uint16_t label =
 80042b0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
}
void eval_comb(vmc_t *vmc, INT *pc_idx){

  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
    { .value = (UINT)label, .flags = 0 };
 80042b4:	9303      	str	r3, [sp, #12]
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
    heap_set(&vmc->heap, hi, e, hold_reg);
  }

}
void eval_comb(vmc_t *vmc, INT *pc_idx){
 80042b6:	460d      	mov	r5, r1
 80042b8:	4604      	mov	r4, r0

  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
 80042ba:	f8ad 6008 	strh.w	r6, [sp, #8]
    { .value = (UINT)label, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 80042be:	f004 fbb7 	bl	8008a30 <vmc_heap_alloc_withGC>
  if(hi == HEAP_NULL){
 80042c2:	1c43      	adds	r3, r0, #1
void eval_comb(vmc_t *vmc, INT *pc_idx){

  uint16_t label = get_label(vmc, pc_idx);
  cam_value_t cam_label =
    { .value = (UINT)label, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
 80042c4:	4602      	mov	r2, r0
  if(hi == HEAP_NULL){
 80042c6:	d020      	beq.n	800430a <eval_comb+0x6a>
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 80042c8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c


    // This value is used to demarcate a heap cell as
    // storing a combinator value rather than a closure
    cam_value_t dummy_val = { .value = COMB };
 80042cc:	9604      	str	r6, [sp, #16]
 80042ce:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80042d2:	9105      	str	r1, [sp, #20]
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 80042d4:	3301      	adds	r3, #1
    // This value is used to demarcate a heap cell as
    // storing a combinator value rather than a closure
    cam_value_t dummy_val = { .value = COMB };


    heap_set(&vmc->heap, hi, cam_label, dummy_val);
 80042d6:	a906      	add	r1, sp, #24
 80042d8:	e911 0003 	ldmdb	r1, {r0, r1}
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 80042dc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80042e0:	011b      	lsls	r3, r3, #4
 80042e2:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
 80042e6:	f824 e003 	strh.w	lr, [r4, r3]
    // This value is used to demarcate a heap cell as
    // storing a combinator value rather than a closure
    cam_value_t dummy_val = { .value = COMB };


    heap_set(&vmc->heap, hi, cam_label, dummy_val);
 80042ea:	e88d 0003 	stmia.w	sp, {r0, r1}
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 80042ee:	18e7      	adds	r7, r4, r3
    // This value is used to demarcate a heap cell as
    // storing a combinator value rather than a closure
    cam_value_t dummy_val = { .value = COMB };


    heap_set(&vmc->heap, hi, cam_label, dummy_val);
 80042f0:	ae02      	add	r6, sp, #8
    *pc_idx = -1;
    return;
  } else {
    cam_value_t env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    vmc->contexts[vmc->current_running_context_id].env = env_pointer;
 80042f2:	607a      	str	r2, [r7, #4]
    // This value is used to demarcate a heap cell as
    // storing a combinator value rather than a closure
    cam_value_t dummy_val = { .value = COMB };


    heap_set(&vmc->heap, hi, cam_label, dummy_val);
 80042f4:	4611      	mov	r1, r2
 80042f6:	4620      	mov	r0, r4
 80042f8:	e896 000c 	ldmia.w	r6, {r2, r3}
 80042fc:	f004 fba8 	bl	8008a50 <heap_set>

    *pc_idx = (*pc_idx) + 3;
 8004300:	682b      	ldr	r3, [r5, #0]
 8004302:	3303      	adds	r3, #3
 8004304:	602b      	str	r3, [r5, #0]
  }

}
 8004306:	b007      	add	sp, #28
 8004308:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cam_value_t cam_label =
    { .value = (UINT)label, .flags = 0 };
  heap_index hi = vmc_heap_alloc_withGC(vmc);
  if(hi == HEAP_NULL){
    DEBUG_PRINT(("Heap allocation has failed"));
    *pc_idx = -1;
 800430a:	6028      	str	r0, [r5, #0]
    heap_set(&vmc->heap, hi, cam_label, dummy_val);

    *pc_idx = (*pc_idx) + 3;
  }

}
 800430c:	b007      	add	sp, #28
 800430e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004310 <eval_callrts>:
  //TODO: hold_reg1 and hold_reg2 should contain indices to the int pool
  // find index of 64 bit int baseline and deadline from the int pool

}

void eval_callrts(vmc_t *vmc, INT *pc_idx){
 8004310:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  INT n_idx = (*pc_idx) + 1;
  uint8_t rts_op_no = vmc->code_memory[n_idx];
 8004314:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8004316:	680b      	ldr	r3, [r1, #0]
 8004318:	4413      	add	r3, r2
  //TODO: hold_reg1 and hold_reg2 should contain indices to the int pool
  // find index of 64 bit int baseline and deadline from the int pool

}

void eval_callrts(vmc_t *vmc, INT *pc_idx){
 800431a:	b0a9      	sub	sp, #164	; 0xa4
    /* spawnExternal - 6 */
    /* wrap      - 7 */
    /* time      - 8 */

  int ret_code = -1; 
  switch(rts_op_no){
 800431c:	785b      	ldrb	r3, [r3, #1]
  //TODO: hold_reg1 and hold_reg2 should contain indices to the int pool
  // find index of 64 bit int baseline and deadline from the int pool

}

void eval_callrts(vmc_t *vmc, INT *pc_idx){
 800431e:	4604      	mov	r4, r0
 8004320:	4688      	mov	r8, r1
    /* spawnExternal - 6 */
    /* wrap      - 7 */
    /* time      - 8 */

  int ret_code = -1; 
  switch(rts_op_no){
 8004322:	2b08      	cmp	r3, #8
 8004324:	d80c      	bhi.n	8004340 <eval_callrts+0x30>
 8004326:	e8df f013 	tbh	[pc, r3, lsl #1]
 800432a:	0098      	.short	0x0098
 800432c:	00fa00de 	.word	0x00fa00de
 8004330:	01ba016b 	.word	0x01ba016b
 8004334:	02cc0297 	.word	0x02cc0297
 8004338:	001202ee 	.word	0x001202ee
 800433c:	f8dd 801c 	ldr.w	r8, [sp, #28]
      *pc_idx = ret_code;
      return;
  }
  if(ret_code == -1){
    DEBUG_PRINT(("Error in RTS function"));
    *pc_idx = ret_code;
 8004340:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004344:	f8c8 3000 	str.w	r3, [r8]
  } else { 

    *pc_idx = (*pc_idx) + 2;
  }
}
 8004348:	b029      	add	sp, #164	; 0xa4
 800434a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

static int handle_time(vmc_t *vmc){

  //syncT : Time -> Time -> Event a -> a

  cam_value_t hold_reg1 = vmc->contexts[vmc->current_running_context_id].env;
 800434e:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8004352:	1c43      	adds	r3, r0, #1
 8004354:	eb03 0343 	add.w	r3, r3, r3, lsl #1

  cam_register_t hold_reg2;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg2);
 8004358:	eb00 0040 	add.w	r0, r0, r0, lsl #1

static int handle_time(vmc_t *vmc){

  //syncT : Time -> Time -> Event a -> a

  cam_value_t hold_reg1 = vmc->contexts[vmc->current_running_context_id].env;
 800435c:	eb04 1303 	add.w	r3, r4, r3, lsl #4

  cam_register_t hold_reg2;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg2);
 8004360:	eb04 1000 	add.w	r0, r4, r0, lsl #4
  //syncT : Time -> Time -> Event a -> a

  cam_value_t hold_reg1 = vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg2;
  int i =
 8004364:	303c      	adds	r0, #60	; 0x3c
 8004366:	a918      	add	r1, sp, #96	; 0x60

static int handle_time(vmc_t *vmc){

  //syncT : Time -> Time -> Event a -> a

  cam_value_t hold_reg1 = vmc->contexts[vmc->current_running_context_id].env;
 8004368:	685d      	ldr	r5, [r3, #4]

  cam_register_t hold_reg2;
  int i =
 800436a:	f004 fa61 	bl	8008830 <stack_pop>
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg2);
  if(i == 0){
 800436e:	2800      	cmp	r0, #0
 8004370:	d0e6      	beq.n	8004340 <eval_callrts+0x30>
    return -1;
  }

  cam_register_t hold_reg3;
  int j =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg3);
 8004372:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 8004376:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800437a:	eb04 1000 	add.w	r0, r4, r0, lsl #4
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }

  cam_register_t hold_reg3;
  int j =
 800437e:	af1d      	add	r7, sp, #116	; 0x74
 8004380:	303c      	adds	r0, #60	; 0x3c
 8004382:	4639      	mov	r1, r7
 8004384:	f004 fa54 	bl	8008830 <stack_pop>
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg3);
  if(j == 0){
 8004388:	2800      	cmp	r0, #0
 800438a:	d0d9      	beq.n	8004340 <eval_callrts+0x30>
  Time deadline = (Time)(hold_reg2.value * PLATFORM_TIME_FACTOR);

  // After calling the rts function `time` make sure the
  // env register points to `ev` so that we can `sync` next
  // because the sequence of bytecode will be - ..time; sync...
  vmc->contexts[vmc->current_running_context_id].env = hold_reg3;
 800438c:	f894 e02c 	ldrb.w	lr, [r4, #44]	; 0x2c
  }

  /* Is this a good place to multiply by PLATFORM_TIME_FACTOR? */
  Time baseline = (Time)(hold_reg1.value * PLATFORM_TIME_FACTOR);
  
  Time deadline = (Time)(hold_reg2.value * PLATFORM_TIME_FACTOR);
 8004390:	9a19      	ldr	r2, [sp, #100]	; 0x64
}

int time(vmc_t *container, Time baseline, Time deadline){

  // use the logical time of the current thread
  Time currentTime =
 8004392:	ea4f 034e 	mov.w	r3, lr, lsl #1
 8004396:	eb03 010e 	add.w	r1, r3, lr
 800439a:	eb04 1101 	add.w	r1, r4, r1, lsl #4
    container->contexts[container->current_running_context_id].logicalTime;
  Time wakeupTime  = currentTime + baseline;
 800439e:	e9d1 ab14 	ldrd	sl, fp, [r1, #80]	; 0x50

  // After calling the rts function `time` make sure the
  // env register points to `ev` so that we can `sync` next
  // because the sequence of bytecode will be - ..time; sync...
  vmc->contexts[vmc->current_running_context_id].env = hold_reg3;
 80043a2:	f10e 0601 	add.w	r6, lr, #1
 80043a6:	e897 0003 	ldmia.w	r7, {r0, r1}
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }

  /* Is this a good place to multiply by PLATFORM_TIME_FACTOR? */
  Time baseline = (Time)(hold_reg1.value * PLATFORM_TIME_FACTOR);
 80043aa:	2754      	movs	r7, #84	; 0x54
 80043ac:	fb07 f505 	mul.w	r5, r7, r5
  Time deadline = (Time)(hold_reg2.value * PLATFORM_TIME_FACTOR);

  // After calling the rts function `time` make sure the
  // env register points to `ev` so that we can `sync` next
  // because the sequence of bytecode will be - ..time; sync...
  vmc->contexts[vmc->current_running_context_id].env = hold_reg3;
 80043b0:	eb06 0646 	add.w	r6, r6, r6, lsl #1
  }

  /* Is this a good place to multiply by PLATFORM_TIME_FACTOR? */
  Time baseline = (Time)(hold_reg1.value * PLATFORM_TIME_FACTOR);
  
  Time deadline = (Time)(hold_reg2.value * PLATFORM_TIME_FACTOR);
 80043b4:	fb07 f202 	mul.w	r2, r7, r2

  // After calling the rts function `time` make sure the
  // env register points to `ev` so that we can `sync` next
  // because the sequence of bytecode will be - ..time; sync...
  vmc->contexts[vmc->current_running_context_id].env = hold_reg3;
 80043b8:	eb04 1606 	add.w	r6, r4, r6, lsl #4
 80043bc:	eb1a 0a05 	adds.w	sl, sl, r5
 80043c0:	f14b 0b00 	adc.w	fp, fp, #0
 80043c4:	e886 0003 	stmia.w	r6, {r0, r1}
  }

  /* Is this a good place to multiply by PLATFORM_TIME_FACTOR? */
  Time baseline = (Time)(hold_reg1.value * PLATFORM_TIME_FACTOR);
  
  Time deadline = (Time)(hold_reg2.value * PLATFORM_TIME_FACTOR);
 80043c8:	2700      	movs	r7, #0
  Time finishTime;

  if(deadline == 0) // XXX : No deadline
 80043ca:	2a00      	cmp	r2, #0
 80043cc:	f000 82d9 	beq.w	8004982 <eval_callrts+0x672>
    finishTime = TIME_MAX;
  else
    finishTime = wakeupTime + deadline;
 80043d0:	eb1a 0002 	adds.w	r0, sl, r2
 80043d4:	eb4b 0107 	adc.w	r1, fp, r7
 80043d8:	4606      	mov	r6, r0
 80043da:	460f      	mov	r7, r1
    {   .context_id = container->current_running_context_id
      , .baseline = wakeupTime
      , .deadline = finishTime };

  container->contexts[container->current_running_context_id].deadline
    = finishTime;
 80043dc:	4473      	add	r3, lr
 80043de:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 80043e2:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
  if(deadline == 0) // XXX : No deadline
    finishTime = TIME_MAX;
  else
    finishTime = wakeupTime + deadline;

  pq_data_t currentThread =
 80043e6:	f88d e088 	strb.w	lr, [sp, #136]	; 0x88
 80043ea:	e9cd ab24 	strd	sl, fp, [sp, #144]	; 0x90
 80043ee:	e9cd 0126 	strd	r0, r1, [sp, #152]	; 0x98
  container->contexts[container->current_running_context_id].deadline
    = finishTime;


  //EXPERIMENT
  Time actualTime = sys_time_get_current_ticks();
 80043f2:	f001 ffad 	bl	8006350 <sys_time_get_current_ticks>
  Time absoluteBaseline = currentTime + baseline;
  Time absoluteDeadline = currentTime + baseline + deadline;
  bool cond1 = actualTime > absoluteDeadline;
  bool cond2 = (actualTime >= absoluteBaseline) &&
 80043f6:	4559      	cmp	r1, fp
 80043f8:	bf08      	it	eq
 80043fa:	4550      	cmpeq	r0, sl
 80043fc:	f0c0 82db 	bcc.w	80049b6 <eval_callrts+0x6a6>
 8004400:	428f      	cmp	r7, r1
 8004402:	bf08      	it	eq
 8004404:	4286      	cmpeq	r6, r0
 8004406:	bf2c      	ite	cs
 8004408:	2201      	movcs	r2, #1
 800440a:	2200      	movcc	r2, #0
    (actualTime <= absoluteDeadline);
  bool cond3 = baseline < SET_ALARM_AFTER;
  if(baseline == 0 || cond1 || cond2 || cond3){
 800440c:	f247 532f 	movw	r3, #29999	; 0x752f
 8004410:	429d      	cmp	r5, r3
 8004412:	f240 82bf 	bls.w	8004994 <eval_callrts+0x684>
 8004416:	428f      	cmp	r7, r1
 8004418:	bf08      	it	eq
 800441a:	4286      	cmpeq	r6, r0
 800441c:	f0c0 82ba 	bcc.w	8004994 <eval_callrts+0x684>
 8004420:	2a00      	cmp	r2, #0
 8004422:	f040 82b7 	bne.w	8004994 <eval_callrts+0x684>
    return 1;

  }

  // baseline > 0 set alarm
  int i = setAlarm(wakeupTime);
 8004426:	4650      	mov	r0, sl
 8004428:	4659      	mov	r1, fp
 800442a:	f004 fa39 	bl	80088a0 <setAlarm.lto_priv.101>
  if(i == -1){
 800442e:	3001      	adds	r0, #1
 8004430:	d086      	beq.n	8004340 <eval_callrts+0x30>
    DEBUG_PRINT(("Setting wakeup time has failed \n"));
    return i;
  }


  int j = pq_insert(&container->waitQ, currentThread);
 8004432:	ab28      	add	r3, sp, #160	; 0xa0
 8004434:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 8004438:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 800443c:	ad22      	add	r5, sp, #136	; 0x88
 800443e:	f504 5091 	add.w	r0, r4, #4640	; 0x1220
 8004442:	e895 000c 	ldmia.w	r5, {r2, r3}
 8004446:	3014      	adds	r0, #20
 8004448:	f004 f912 	bl	8008670 <pq_insert>
  if(j == -1){
 800444c:	3001      	adds	r0, #1
 800444e:	f43f af77 	beq.w	8004340 <eval_callrts+0x30>
    if(k == -1){
      DEBUG_PRINT(("Cannot enqueue in rdyQ \n"));
      return k;
    }

    dispatch(container);
 8004452:	4620      	mov	r0, r4
 8004454:	f004 fa3c 	bl	80088d0 <dispatch>
 8004458:	e0ca      	b.n	80045f0 <eval_callrts+0x2e0>
   */
  cam_value_t empty_tuple = { .value = 0, .flags = 0 };



  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;
 800445a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800445e:	3301      	adds	r3, #1
 8004460:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004464:	eb00 1303 	add.w	r3, r0, r3, lsl #4

  heap_index closure_address = e.value;


  cam_value_t heap_f = heap_fst(&vmc->heap, closure_address);
 8004468:	ad18      	add	r5, sp, #96	; 0x60



  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;

  heap_index closure_address = e.value;
 800446a:	685e      	ldr	r6, [r3, #4]


  cam_value_t heap_f = heap_fst(&vmc->heap, closure_address);
 800446c:	4628      	mov	r0, r5
 800446e:	4632      	mov	r2, r6
 8004470:	4621      	mov	r1, r4
 8004472:	f004 fb1d 	bl	8008ab0 <heap_fst>
  cam_value_t heap_s = heap_snd(&vmc->heap, closure_address);
 8004476:	4632      	mov	r2, r6
 8004478:	a81d      	add	r0, sp, #116	; 0x74
 800447a:	4621      	mov	r1, r4
  cam_register_t e = vmc->contexts[vmc->current_running_context_id].env;

  heap_index closure_address = e.value;


  cam_value_t heap_f = heap_fst(&vmc->heap, closure_address);
 800447c:	9f19      	ldr	r7, [sp, #100]	; 0x64
  cam_value_t heap_s = heap_snd(&vmc->heap, closure_address);
 800447e:	f004 fb07 	bl	8008a90 <heap_snd>
 8004482:	9e1e      	ldr	r6, [sp, #120]	; 0x78

  if(heap_s.value == COMB){ // if combinator
 8004484:	1c73      	adds	r3, r6, #1
 8004486:	f000 83b8 	beq.w	8004bfa <eval_callrts+0x8ea>
    return spawn(vmc, (uint16_t)label.value); // will place PID in env


  } else { // not a combinator but a closure

    cam_value_t val = heap_f;
 800448a:	e895 0003 	ldmia.w	r5, {r0, r1}
 800448e:	ad22      	add	r5, sp, #136	; 0x88
 8004490:	e885 0003 	stmia.w	r5, {r0, r1}

    // Put (v, ()) of [v:l] on the env register; Read above why () comes;
    // spawn then copies the content of the env register to
    // the `env` register of the new context

    heap_index hi = vmc_heap_alloc_withGC(vmc);
 8004494:	4620      	mov	r0, r4
 8004496:	f004 facb 	bl	8008a30 <vmc_heap_alloc_withGC>
 800449a:	4607      	mov	r7, r0
    if(hi == HEAP_NULL){
 800449c:	3001      	adds	r0, #1
 800449e:	f43f af4f 	beq.w	8004340 <eval_callrts+0x30>
      DEBUG_PRINT(("Heap allocation has failed"));
      return -1;
    }
    heap_set(&vmc->heap, hi, val, empty_tuple);
 80044a2:	2300      	movs	r3, #0
 80044a4:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
 80044a8:	9314      	str	r3, [sp, #80]	; 0x50
 80044aa:	ab13      	add	r3, sp, #76	; 0x4c
 80044ac:	e893 0003 	ldmia.w	r3, {r0, r1}
 80044b0:	e895 000c 	ldmia.w	r5, {r2, r3}
 80044b4:	e88d 0003 	stmia.w	sp, {r0, r1}
 80044b8:	4620      	mov	r0, r4
 80044ba:	4639      	mov	r1, r7
 80044bc:	f004 fac8 	bl	8008a50 <heap_set>
    cam_value_t new_env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };

    vmc->contexts[vmc->current_running_context_id].env = new_env_pointer;
 80044c0:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80044c4:	3301      	adds	r3, #1
 80044c6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80044ca:	011b      	lsls	r3, r3, #4
 80044cc:	18e2      	adds	r2, r4, r3
 80044ce:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80044d2:	52e0      	strh	r0, [r4, r3]

    // Spawn will places the label graveyard address on the stack
    return spawn(vmc, (uint16_t)label.value); // will place PID in env
 80044d4:	b2b1      	uxth	r1, r6
 80044d6:	4620      	mov	r0, r4
    }
    heap_set(&vmc->heap, hi, val, empty_tuple);
    cam_value_t new_env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };

    vmc->contexts[vmc->current_running_context_id].env = new_env_pointer;
 80044d8:	6057      	str	r7, [r2, #4]

    // Spawn will places the label graveyard address on the stack
    return spawn(vmc, (uint16_t)label.value); // will place PID in env
 80044da:	f004 fa11 	bl	8008900 <spawn>
    default:
      DEBUG_PRINT(("Invalid RTS op number"));
      *pc_idx = ret_code;
      return;
  }
  if(ret_code == -1){
 80044de:	3001      	adds	r0, #1
 80044e0:	f040 8086 	bne.w	80045f0 <eval_callrts+0x2e0>
 80044e4:	e72c      	b.n	8004340 <eval_callrts+0x30>
 80044e6:	4603      	mov	r3, r0
    /* spawnExternal - 6 */
    /* wrap      - 7 */
    /* time      - 8 */

  int ret_code = -1; 
  switch(rts_op_no){
 80044e8:	2200      	movs	r2, #0
 80044ea:	e003      	b.n	80044f4 <eval_callrts+0x1e4>
  return 1;
}


int channel(vmc_t *container, UUID *chan_id){
  for(int i = 0; i < MAX_CHANNELS; i++){
 80044ec:	3201      	adds	r2, #1
 80044ee:	2a64      	cmp	r2, #100	; 0x64
 80044f0:	f43f af26 	beq.w	8004340 <eval_callrts+0x30>
     if(container->channels[i].in_use == false){
 80044f4:	f893 111c 	ldrb.w	r1, [r3, #284]	; 0x11c
 80044f8:	332c      	adds	r3, #44	; 0x2c
 80044fa:	2900      	cmp	r1, #0
 80044fc:	d1f6      	bne.n	80044ec <eval_callrts+0x1dc>
      container->channels[i].in_use = true;
 80044fe:	232c      	movs	r3, #44	; 0x2c
 8004500:	fb03 4302 	mla	r3, r3, r2, r4
 8004504:	2001      	movs	r0, #1
 8004506:	f883 011c 	strb.w	r0, [r3, #284]	; 0x11c
  if(j == -1){
    DEBUG_PRINT(("Error initializing a channel \n"));
    return j;
  }
  cam_value_t channel_cam = { .value = (UINT)chan_id, .flags = 0 };
  vmc->contexts[vmc->current_running_context_id].env = channel_cam;
 800450a:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 800450e:	4403      	add	r3, r0
 8004510:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004514:	011b      	lsls	r3, r3, #4
 8004516:	18e0      	adds	r0, r4, r3
 8004518:	52e1      	strh	r1, [r4, r3]
 800451a:	6042      	str	r2, [r0, #4]
 800451c:	e068      	b.n	80045f0 <eval_callrts+0x2e0>
  return 1;
}

static int handle_sendevt(vmc_t *vmc){
  cam_value_t message = vmc->contexts[vmc->current_running_context_id].env;
 800451e:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 8004522:	1c43      	adds	r3, r0, #1
 8004524:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004528:	011b      	lsls	r3, r3, #4

  cam_register_t hold_reg;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 800452a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800452e:	eb04 1000 	add.w	r0, r4, r0, lsl #4
  vmc->contexts[vmc->current_running_context_id].env = channel_cam;
  return 1;
}

static int handle_sendevt(vmc_t *vmc){
  cam_value_t message = vmc->contexts[vmc->current_running_context_id].env;
 8004532:	18e2      	adds	r2, r4, r3

  cam_register_t hold_reg;
  int i =
 8004534:	303c      	adds	r0, #60	; 0x3c
 8004536:	a911      	add	r1, sp, #68	; 0x44
  vmc->contexts[vmc->current_running_context_id].env = channel_cam;
  return 1;
}

static int handle_sendevt(vmc_t *vmc){
  cam_value_t message = vmc->contexts[vmc->current_running_context_id].env;
 8004538:	6855      	ldr	r5, [r2, #4]
 800453a:	5ae6      	ldrh	r6, [r4, r3]

  cam_register_t hold_reg;
  int i =
 800453c:	f004 f978 	bl	8008830 <stack_pop>
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
 8004540:	2800      	cmp	r0, #0
 8004542:	f43f aefd 	beq.w	8004340 <eval_callrts+0x30>
  return 1;
}

int sendEvt(vmc_t *container, UUID *chan_id, cam_value_t msg, event_t *sevt){

  cam_value_t null  = {.value = (UINT)HEAP_NULL, .flags = 0};
 8004546:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800454a:	2700      	movs	r7, #0
   *               -> snd = pointer to wrap_func - [v:l] or [l]
   *
   */

  /* Allocate all memory needed in one go */
  heap_index cells = vmc_heap_alloc_n(container,3);
 800454c:	4620      	mov	r0, r4
 800454e:	f8ad 6024 	strh.w	r6, [sp, #36]	; 0x24
 8004552:	950a      	str	r5, [sp, #40]	; 0x28
  return 1;
}

int sendEvt(vmc_t *container, UUID *chan_id, cam_value_t msg, event_t *sevt){

  cam_value_t null  = {.value = (UINT)HEAP_NULL, .flags = 0};
 8004554:	f8ad 704c 	strh.w	r7, [sp, #76]	; 0x4c
 8004558:	9314      	str	r3, [sp, #80]	; 0x50
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }
  UUID channel_id = (UUID)hold_reg.value;
 800455a:	9e12      	ldr	r6, [sp, #72]	; 0x48
   *               -> snd = pointer to wrap_func - [v:l] or [l]
   *
   */

  /* Allocate all memory needed in one go */
  heap_index cells = vmc_heap_alloc_n(container,3);
 800455c:	f003 fed8 	bl	8008310 <vmc_heap_alloc_n.constprop.21>
  if ((INT)cells == HEAP_NULL) {
 8004560:	1c41      	adds	r1, r0, #1
   *               -> snd = pointer to wrap_func - [v:l] or [l]
   *
   */

  /* Allocate all memory needed in one go */
  heap_index cells = vmc_heap_alloc_n(container,3);
 8004562:	4605      	mov	r5, r0
  if ((INT)cells == HEAP_NULL) {
 8004564:	f43f aeec 	beq.w	8004340 <eval_callrts+0x30>
    DEBUG_PRINT(("heap allocation of 3 cells for event has failed"));
    return -1;
  }

  heap_index base_evt_idx = cells;
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
 8004568:	a80d      	add	r0, sp, #52	; 0x34
 800456a:	4621      	mov	r1, r4
 800456c:	462a      	mov	r2, r5
 800456e:	f004 fa8f 	bl	8008a90 <heap_snd>
 8004572:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;
 8004576:	a80b      	add	r0, sp, #44	; 0x2c
 8004578:	4652      	mov	r2, sl
 800457a:	4621      	mov	r1, r4

  UINT data = set_bottom_16_bits(SEND, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 800457c:	f10d 094c 	add.w	r9, sp, #76	; 0x4c
    return -1;
  }

  heap_index base_evt_idx = cells;
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;
 8004580:	f004 fa86 	bl	8008a90 <heap_snd>

  UINT data = set_bottom_16_bits(SEND, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 8004584:	e899 0003 	ldmia.w	r9, {r0, r1}
 8004588:	e88d 0003 	stmia.w	sp, {r0, r1}

static inline UINT set_bottom_16_bits(uint8_t first8bits, uint8_t second8bits){

  UINT value = 0;
  value = value | (first8bits << 8);
  value = value | second8bits;
 800458c:	b2f6      	uxtb	r6, r6
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;

  UINT data = set_bottom_16_bits(SEND, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
 800458e:	9619      	str	r6, [sp, #100]	; 0x64
 8004590:	f8ad 7060 	strh.w	r7, [sp, #96]	; 0x60
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 8004594:	ab18      	add	r3, sp, #96	; 0x60
 8004596:	cb0c      	ldmia	r3, {r2, r3}
 8004598:	4620      	mov	r0, r4
 800459a:	4629      	mov	r1, r5
    return -1;
  }

  heap_index base_evt_idx = cells;
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;
 800459c:	9e0c      	ldr	r6, [sp, #48]	; 0x30

  UINT data = set_bottom_16_bits(SEND, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 800459e:	f004 fa57 	bl	8008a50 <heap_set>
   *  cam_event_t -> fst = pointer to base_event_t
   *              -> snd = message or pointer to message
   */

  cam_value_t event = {.value = (UINT)base_evt_idx, .flags = VALUE_PTR_BIT};
  heap_set(&container->heap, cev_idx, event, msg);
 80045a2:	ab09      	add	r3, sp, #36	; 0x24
 80045a4:	e893 0003 	ldmia.w	r3, {r0, r1}
 80045a8:	e88d 0003 	stmia.w	sp, {r0, r1}
  /*
   *  cam_event_t -> fst = pointer to base_event_t
   *              -> snd = message or pointer to message
   */

  cam_value_t event = {.value = (UINT)base_evt_idx, .flags = VALUE_PTR_BIT};
 80045ac:	f44f 4700 	mov.w	r7, #32768	; 0x8000
 80045b0:	951e      	str	r5, [sp, #120]	; 0x78
 80045b2:	f8ad 7074 	strh.w	r7, [sp, #116]	; 0x74
  heap_set(&container->heap, cev_idx, event, msg);
 80045b6:	ab1d      	add	r3, sp, #116	; 0x74
 80045b8:	4651      	mov	r1, sl
 80045ba:	4620      	mov	r0, r4
 80045bc:	cb0c      	ldmia	r3, {r2, r3}
 80045be:	f004 fa47 	bl	8008a50 <heap_set>
   *  heap_cell_list -> fst = pointer to cam_event_t
   *                 -> snd = pointer to next heap_cell_ev
   */

  cam_value_t heap_cell = {.value = (UINT)cev_idx, .flags = VALUE_PTR_BIT };
  heap_set(&container->heap, hi, heap_cell, null);
 80045c2:	e899 0003 	ldmia.w	r9, {r0, r1}
  /*
   *  heap_cell_list -> fst = pointer to cam_event_t
   *                 -> snd = pointer to next heap_cell_ev
   */

  cam_value_t heap_cell = {.value = (UINT)cev_idx, .flags = VALUE_PTR_BIT };
 80045c6:	f8ad 7088 	strh.w	r7, [sp, #136]	; 0x88
 80045ca:	f8cd a08c 	str.w	sl, [sp, #140]	; 0x8c
   *                 -> snd = pointer to next heap_cell_ev
   */

  cam_value_t heap_cell = {.value = (UINT)cev_idx, .flags = VALUE_PTR_BIT };

  heap_set(&container->heap, hi, heap_cell, null);
 80045ce:	e88d 0003 	stmia.w	sp, {r0, r1}
 80045d2:	ab22      	add	r3, sp, #136	; 0x88
 80045d4:	cb0c      	ldmia	r3, {r2, r3}
 80045d6:	4631      	mov	r1, r6
 80045d8:	4620      	mov	r0, r4
 80045da:	f004 fa39 	bl	8008a50 <heap_set>
    return j;
  }

  cam_value_t recv_evt_env =
    { .value = (UINT)recv_evt, .flags = VALUE_PTR_BIT };
  vmc->contexts[vmc->current_running_context_id].env = recv_evt_env;
 80045de:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80045e2:	3301      	adds	r3, #1
 80045e4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80045e8:	011b      	lsls	r3, r3, #4
 80045ea:	18e2      	adds	r2, r4, r3
 80045ec:	52e7      	strh	r7, [r4, r3]
 80045ee:	6056      	str	r6, [r2, #4]
  if(ret_code == -1){
    DEBUG_PRINT(("Error in RTS function"));
    *pc_idx = ret_code;
  } else { 

    *pc_idx = (*pc_idx) + 2;
 80045f0:	f8d8 3000 	ldr.w	r3, [r8]
 80045f4:	3302      	adds	r3, #2
 80045f6:	f8c8 3000 	str.w	r3, [r8]
  }
}
 80045fa:	b029      	add	sp, #164	; 0xa4
 80045fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  vmc->contexts[vmc->current_running_context_id].env = send_evt_env;
  return 1;
}

static int handle_recvevt(vmc_t *vmc){
  cam_value_t channel_cam = vmc->contexts[vmc->current_running_context_id].env;
 8004600:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8004604:	3301      	adds	r3, #1
 8004606:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800460a:	eb00 1303 	add.w	r3, r0, r3, lsl #4

}

int recvEvt(vmc_t *container, UUID *chan_id, event_t *revt){

  cam_value_t null  = {.value = (UINT)HEAP_NULL, .flags = 0};
 800460e:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
 8004612:	2700      	movs	r7, #0
 8004614:	685e      	ldr	r6, [r3, #4]
 8004616:	f8ad 7034 	strh.w	r7, [sp, #52]	; 0x34
 800461a:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
   *
   */


  /* Allocating all cells needed in one go */
  heap_index cells = vmc_heap_alloc_n(container,3);
 800461e:	f003 fe77 	bl	8008310 <vmc_heap_alloc_n.constprop.21>
  if (cells == HEAP_NULL) {
 8004622:	4550      	cmp	r0, sl
   *
   */


  /* Allocating all cells needed in one go */
  heap_index cells = vmc_heap_alloc_n(container,3);
 8004624:	4683      	mov	fp, r0
  if (cells == HEAP_NULL) {
 8004626:	f43f ae8b 	beq.w	8004340 <eval_callrts+0x30>
    DEBUG_PRINT(("heap allocation of 3 cells for event has failed"));
    return -1;
  }

  heap_index base_evt_idx = cells;
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
 800462a:	a811      	add	r0, sp, #68	; 0x44
 800462c:	4621      	mov	r1, r4
 800462e:	465a      	mov	r2, fp
 8004630:	f004 fa2e 	bl	8008a90 <heap_snd>
 8004634:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;
 8004638:	a80f      	add	r0, sp, #60	; 0x3c
 800463a:	464a      	mov	r2, r9
 800463c:	4621      	mov	r1, r4

  UINT data = set_bottom_16_bits(RECV, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 800463e:	ad0d      	add	r5, sp, #52	; 0x34
    return -1;
  }

  heap_index base_evt_idx = cells;
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;
 8004640:	f004 fa26 	bl	8008a90 <heap_snd>

static inline UINT set_bottom_16_bits(uint8_t first8bits, uint8_t second8bits){

  UINT value = 0;
  value = value | (first8bits << 8);
  value = value | second8bits;
 8004644:	b2f6      	uxtb	r6, r6
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;

  UINT data = set_bottom_16_bits(RECV, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 8004646:	e895 0003 	ldmia.w	r5, {r0, r1}

static inline UINT set_bottom_16_bits(uint8_t first8bits, uint8_t second8bits){

  UINT value = 0;
  value = value | (first8bits << 8);
  value = value | second8bits;
 800464a:	f446 7680 	orr.w	r6, r6, #256	; 0x100
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;

  UINT data = set_bottom_16_bits(RECV, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
 800464e:	9614      	str	r6, [sp, #80]	; 0x50
 8004650:	f8ad 704c 	strh.w	r7, [sp, #76]	; 0x4c
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 8004654:	ab13      	add	r3, sp, #76	; 0x4c
 8004656:	cb0c      	ldmia	r3, {r2, r3}
 8004658:	e88d 0003 	stmia.w	sp, {r0, r1}
 800465c:	4620      	mov	r0, r4
 800465e:	4659      	mov	r1, fp
    return -1;
  }

  heap_index base_evt_idx = cells;
  heap_index cev_idx = heap_snd(&container->heap, cells).value;
  heap_index hi      = heap_snd(&container->heap, cev_idx).value;
 8004660:	9e10      	ldr	r6, [sp, #64]	; 0x40

  UINT data = set_bottom_16_bits(RECV, *chan_id);

  cam_value_t base_evt_simple = { .value = data, .flags = 0};
  heap_set(&container->heap, base_evt_idx, base_evt_simple, null); // pointer to wrap func NULL
 8004662:	f004 f9f5 	bl	8008a50 <heap_set>
   *              -> snd = null for recv
   */


  cam_value_t event = {.value = (UINT)base_evt_idx, .flags = VALUE_PTR_BIT};
  cam_value_t null_msg  = {.value = (UINT)HEAP_NULL, .flags = 0};
 8004666:	f8ad 7074 	strh.w	r7, [sp, #116]	; 0x74
 800466a:	f8cd a078 	str.w	sl, [sp, #120]	; 0x78
  heap_set(&container->heap, cev_idx, event, null_msg);
 800466e:	ab1d      	add	r3, sp, #116	; 0x74
 8004670:	e893 0003 	ldmia.w	r3, {r0, r1}
 8004674:	e88d 0003 	stmia.w	sp, {r0, r1}
   *  cam_event_t -> fst = pointer to base_event_t
   *              -> snd = null for recv
   */


  cam_value_t event = {.value = (UINT)base_evt_idx, .flags = VALUE_PTR_BIT};
 8004678:	f44f 4700 	mov.w	r7, #32768	; 0x8000
 800467c:	f8cd b064 	str.w	fp, [sp, #100]	; 0x64
 8004680:	f8ad 7060 	strh.w	r7, [sp, #96]	; 0x60
  cam_value_t null_msg  = {.value = (UINT)HEAP_NULL, .flags = 0};
  heap_set(&container->heap, cev_idx, event, null_msg);
 8004684:	ab18      	add	r3, sp, #96	; 0x60
 8004686:	4649      	mov	r1, r9
 8004688:	4620      	mov	r0, r4
 800468a:	cb0c      	ldmia	r3, {r2, r3}
 800468c:	f004 f9e0 	bl	8008a50 <heap_set>
   *                 -> snd = pointer to next heap_cell_ev
   */

  cam_value_t heap_cell = {.value = (UINT)cev_idx, .flags = VALUE_PTR_BIT };

  heap_set(&container->heap, hi, heap_cell, null);
 8004690:	e895 0003 	ldmia.w	r5, {r0, r1}
  /*
   *  heap_cell_list -> fst = pointer to cam_event_t
   *                 -> snd = pointer to next heap_cell_ev
   */

  cam_value_t heap_cell = {.value = (UINT)cev_idx, .flags = VALUE_PTR_BIT };
 8004694:	f8ad 7088 	strh.w	r7, [sp, #136]	; 0x88
 8004698:	f8cd 908c 	str.w	r9, [sp, #140]	; 0x8c
 800469c:	e797      	b.n	80045ce <eval_callrts+0x2be>
  vmc->contexts[vmc->current_running_context_id].env = recv_evt_env;
  return 1;
}

static int handle_sync(vmc_t *vmc){
  cam_value_t event_env = vmc->contexts[vmc->current_running_context_id].env;
 800469e:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 80046a2:	3301      	adds	r3, #1
 80046a4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80046a8:	011b      	lsls	r3, r3, #4
 80046aa:	18c2      	adds	r2, r0, r3

  if(event_env.flags != VALUE_PTR_BIT){
 80046ac:	5ac3      	ldrh	r3, [r0, r3]
  vmc->contexts[vmc->current_running_context_id].env = recv_evt_env;
  return 1;
}

static int handle_sync(vmc_t *vmc){
  cam_value_t event_env = vmc->contexts[vmc->current_running_context_id].env;
 80046ae:	6857      	ldr	r7, [r2, #4]

  if(event_env.flags != VALUE_PTR_BIT){
 80046b0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80046b4:	f47f ae44 	bne.w	8004340 <eval_callrts+0x30>
 80046b8:	f10d 0b88 	add.w	fp, sp, #136	; 0x88
 80046bc:	f10d 0a34 	add.w	sl, sp, #52	; 0x34

    }

    // else continue the do-while loop

    cam_value_t pointer_to_next = heap_snd(&container->heap, index);
 80046c0:	463e      	mov	r6, r7
 80046c2:	e00c      	b.n	80046de <eval_callrts+0x3ce>
      if(poll_recvq(container, &container->channels[bevt_simple.channel_id].recvq)){
        *cev = cevt;
        return 1;
      } // else continue the do-while loop

    } else if (bevt_simple.e_type == RECV) { // recvEvt
 80046c4:	f1b9 0f01 	cmp.w	r9, #1
 80046c8:	f000 8151 	beq.w	800496e <eval_callrts+0x65e>

    }

    // else continue the do-while loop

    cam_value_t pointer_to_next = heap_snd(&container->heap, index);
 80046cc:	463a      	mov	r2, r7
 80046ce:	a818      	add	r0, sp, #96	; 0x60
 80046d0:	4621      	mov	r1, r4
 80046d2:	f004 f9dd 	bl	8008a90 <heap_snd>
    index = (heap_index)pointer_to_next.value;
 80046d6:	9f19      	ldr	r7, [sp, #100]	; 0x64

  } while(index != HEAP_NULL);
 80046d8:	1c7a      	adds	r2, r7, #1
 80046da:	f000 81c7 	beq.w	8004a6c <eval_callrts+0x75c>

static int findSynchronizable(vmc_t *container, event_t *evts, cam_event_t *cev){
  heap_index index = *evts;
  do{

    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);
 80046de:	a809      	add	r0, sp, #36	; 0x24
 80046e0:	4621      	mov	r1, r4
 80046e2:	463a      	mov	r2, r7
 80046e4:	f004 f9e4 	bl	8008ab0 <heap_fst>



    cam_value_t base_evt_ptr =
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);
 80046e8:	9d0a      	ldr	r5, [sp, #40]	; 0x28

    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);



    cam_value_t base_evt_ptr =
 80046ea:	a80b      	add	r0, sp, #44	; 0x2c
 80046ec:	462a      	mov	r2, r5
 80046ee:	4621      	mov	r1, r4
 80046f0:	f004 f9de 	bl	8008ab0 <heap_fst>
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);

    cam_value_t message =
 80046f4:	462a      	mov	r2, r5

    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);



    cam_value_t base_evt_ptr =
 80046f6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);

    cam_value_t message =
 80046f8:	4650      	mov	r0, sl
 80046fa:	4621      	mov	r1, r4
 80046fc:	f004 f9c8 	bl	8008a90 <heap_snd>
      heap_snd(&container->heap, (heap_index)cam_evt_pointer.value);



    cam_value_t base_evt_simple =
 8004700:	462a      	mov	r2, r5
 8004702:	a80f      	add	r0, sp, #60	; 0x3c
 8004704:	4621      	mov	r1, r4
 8004706:	f004 f9d3 	bl	8008ab0 <heap_fst>
      heap_fst(&container->heap, (heap_index)base_evt_ptr.value);

    cam_value_t wrap_fptr =
 800470a:	462a      	mov	r2, r5
 800470c:	a811      	add	r0, sp, #68	; 0x44
 800470e:	4621      	mov	r1, r4
    cam_value_t message =
      heap_snd(&container->heap, (heap_index)cam_evt_pointer.value);



    cam_value_t base_evt_simple =
 8004710:	9d10      	ldr	r5, [sp, #64]	; 0x40
      heap_fst(&container->heap, (heap_index)base_evt_ptr.value);

    cam_value_t wrap_fptr =
 8004712:	f004 f9bd 	bl	8008a90 <heap_snd>
    base_evt_simple_t bevt_simple =
      {   .e_type     = extract_bits(base_evt_simple.value,  8, 8)
        , .channel_id = extract_bits(base_evt_simple.value,  0, 8)
      };

    base_event_t bevt = {   .evt_details   = bevt_simple
 8004716:	ab11      	add	r3, sp, #68	; 0x44
 8004718:	e893 0003 	ldmia.w	r3, {r0, r1}
 800471c:	ab1e      	add	r3, sp, #120	; 0x78
 800471e:	e883 0003 	stmia.w	r3, {r0, r1}
    cam_value_t wrap_fptr =
      heap_snd(&container->heap, (heap_index)base_evt_ptr.value);



    base_evt_simple_t bevt_simple =
 8004722:	f3c5 2907 	ubfx	r9, r5, #8, #8
 8004726:	b2ed      	uxtb	r5, r5
      };

    base_event_t bevt = {   .evt_details   = bevt_simple
                          , .wrap_func_ptr = wrap_fptr };

    cam_event_t cevt = { .bev = bevt, .msg = message };
 8004728:	ab1d      	add	r3, sp, #116	; 0x74
 800472a:	f88d 9074 	strb.w	r9, [sp, #116]	; 0x74
 800472e:	f88d 5075 	strb.w	r5, [sp, #117]	; 0x75
 8004732:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

    /**** Dealing with synchronous drivers like LEDs *****/
    if(container->channels[bevt_simple.channel_id].sync_driver_no != DRIVER_NULL){
 8004736:	232c      	movs	r3, #44	; 0x2c
 8004738:	fb03 fc05 	mul.w	ip, r3, r5
 800473c:	eb04 0e0c 	add.w	lr, r4, ip
      };

    base_event_t bevt = {   .evt_details   = bevt_simple
                          , .wrap_func_ptr = wrap_fptr };

    cam_event_t cevt = { .bev = bevt, .msg = message };
 8004740:	e88b 0007 	stmia.w	fp, {r0, r1, r2}

    /**** Dealing with synchronous drivers like LEDs *****/
    if(container->channels[bevt_simple.channel_id].sync_driver_no != DRIVER_NULL){
 8004744:	f89e 211d 	ldrb.w	r2, [lr, #285]	; 0x11d
      };

    base_event_t bevt = {   .evt_details   = bevt_simple
                          , .wrap_func_ptr = wrap_fptr };

    cam_event_t cevt = { .bev = bevt, .msg = message };
 8004748:	e89a 0003 	ldmia.w	sl, {r0, r1}
 800474c:	ab25      	add	r3, sp, #148	; 0x94

    /**** Dealing with synchronous drivers like LEDs *****/
    if(container->channels[bevt_simple.channel_id].sync_driver_no != DRIVER_NULL){
 800474e:	2aff      	cmp	r2, #255	; 0xff
      };

    base_event_t bevt = {   .evt_details   = bevt_simple
                          , .wrap_func_ptr = wrap_fptr };

    cam_event_t cevt = { .bev = bevt, .msg = message };
 8004750:	e883 0003 	stmia.w	r3, {r0, r1}

    /**** Dealing with synchronous drivers like LEDs *****/
    if(container->channels[bevt_simple.channel_id].sync_driver_no != DRIVER_NULL){
 8004754:	f04f 0e2c 	mov.w	lr, #44	; 0x2c
 8004758:	f040 8136 	bne.w	80049c8 <eval_callrts+0x6b8>
      *cev = cevt;
      return SYNC_DRIVER;
    }
    /****************************************************/

    if(bevt_simple.e_type == SEND){
 800475c:	f1b9 0f00 	cmp.w	r9, #0
 8004760:	d1b0      	bne.n	80046c4 <eval_callrts+0x3b4>

      if(poll_recvq(container, &container->channels[bevt_simple.channel_id].recvq)){
 8004762:	eb04 010c 	add.w	r1, r4, ip
 8004766:	f501 7184 	add.w	r1, r1, #264	; 0x108
 800476a:	4620      	mov	r0, r4
 800476c:	f004 fa98 	bl	8008ca0 <poll_recvq>
 8004770:	2800      	cmp	r0, #0
 8004772:	d0ab      	beq.n	80046cc <eval_callrts+0x3bc>
      } // else continue the do-while loop

    } else if (bevt_simple.e_type == RECV) { // recvEvt

      if(poll_sendq(container, &container->channels[bevt_simple.channel_id].sendq)){
        *cev = cevt;
 8004774:	f88d 9088 	strb.w	r9, [sp, #136]	; 0x88
 8004778:	f88d 5089 	strb.w	r5, [sp, #137]	; 0x89
 800477c:	465d      	mov	r5, fp
 800477e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8004780:	ad13      	add	r5, sp, #76	; 0x4c
 8004782:	462f      	mov	r7, r5
 8004784:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8004786:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8004788:	9317      	str	r3, [sp, #92]	; 0x5c
 800478a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800478c:	af18      	add	r7, sp, #96	; 0x60
 800478e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8004790:	682b      	ldr	r3, [r5, #0]
 8004792:	603b      	str	r3, [r7, #0]
  /* difference. In both cases the receiving thread starts executing */
  /* when `sync` succeeds! Therefore the code is differnt if you */
  /* view it from the perspective of the sender or the receiver. */

  base_event_t bevt = cev.bev;
  cam_value_t  message = cev.msg; // NULL for recv
 8004794:	ab1b      	add	r3, sp, #108	; 0x6c
 8004796:	e893 0003 	ldmia.w	r3, {r0, r1}
  /* both the if and else blocks carefully to understand the */
  /* difference. In both cases the receiving thread starts executing */
  /* when `sync` succeeds! Therefore the code is differnt if you */
  /* view it from the perspective of the sender or the receiver. */

  base_event_t bevt = cev.bev;
 800479a:	f89d a060 	ldrb.w	sl, [sp, #96]	; 0x60
 800479e:	f89d 9061 	ldrb.w	r9, [sp, #97]	; 0x61
 80047a2:	9d1a      	ldr	r5, [sp, #104]	; 0x68
  cam_value_t  message = cev.msg; // NULL for recv
 80047a4:	ab0f      	add	r3, sp, #60	; 0x3c
 80047a6:	e883 0003 	stmia.w	r3, {r0, r1}

  base_evt_simple_t bevt_simple = bevt.evt_details;
  cam_value_t wrap_fptr = bevt.wrap_func_ptr;


  if(bevt_simple.e_type == SEND){
 80047aa:	f1ba 0f00 	cmp.w	sl, #0
 80047ae:	f000 8260 	beq.w	8004c72 <eval_callrts+0x962>
    container->current_running_context_id = recv_context_id;
    DEBUG_PRINT(("Context switch\n"));

    return 1;

  } else if(bevt_simple.e_type == RECV) {
 80047b2:	f1ba 0f01 	cmp.w	sl, #1
 80047b6:	f47f adc3 	bne.w	8004340 <eval_callrts+0x30>

    send_data_t sender_data;
    int deq_status =
      chan_send_q_dequeue(&container->channels[bevt_simple.channel_id].sendq, &sender_data);
 80047ba:	202c      	movs	r0, #44	; 0x2c
 80047bc:	fb00 4009 	mla	r0, r0, r9, r4
    return 1;

  } else if(bevt_simple.e_type == RECV) {

    send_data_t sender_data;
    int deq_status =
 80047c0:	a91d      	add	r1, sp, #116	; 0x74
 80047c2:	30f4      	adds	r0, #244	; 0xf4
 80047c4:	f004 fa04 	bl	8008bd0 <chan_send_q_dequeue>
      chan_send_q_dequeue(&container->channels[bevt_simple.channel_id].sendq, &sender_data);

    if(deq_status == -1){ //empty queue
 80047c8:	3001      	adds	r0, #1
 80047ca:	f43f adb9 	beq.w	8004340 <eval_callrts+0x30>
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 80047ce:	6823      	ldr	r3, [r4, #0]
      return -1;
    }

    cam_value_t true_flag = { .value = 1, .flags = 0 };
    heap_set_fst(  &container->heap
                 , (heap_index)sender_data.dirty_flag_pointer.value
 80047d0:	9a21      	ldr	r2, [sp, #132]	; 0x84
  heap->value_flags[i].fst = value.flags;
 80047d2:	6961      	ldr	r1, [r4, #20]
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 80047d4:	f843 a032 	str.w	sl, [r3, r2, lsl #3]
  heap->value_flags[i].fst = value.flags;
 80047d8:	2300      	movs	r3, #0
 80047da:	f821 3022 	strh.w	r3, [r1, r2, lsl #2]


    /* NOTE Message passing begins */


    cam_value_t empty_tuple = { .value = 0, .flags = 0 };
 80047de:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
 80047e2:	9312      	str	r3, [sp, #72]	; 0x48
    /* container->contexts[sender_data.context_id].env = empty_tuple; */
    int k = message_pass(  container
 80047e4:	9301      	str	r3, [sp, #4]
 80047e6:	f8cd 9000 	str.w	r9, [sp]
 80047ea:	ab11      	add	r3, sp, #68	; 0x44
 80047ec:	f89d 1074 	ldrb.w	r1, [sp, #116]	; 0x74
 80047f0:	cb0c      	ldmia	r3, {r2, r3}
 80047f2:	4620      	mov	r0, r4
 80047f4:	f003 fdbc 	bl	8008370 <message_pass.constprop.17>
                         , sender_data.context_id
                         , empty_tuple
                         , bevt_simple.channel_id
                         , SEND
                         , SCHEDULED_FIRST); // sender got scheduled first
    if(k == -1){
 80047f8:	3001      	adds	r0, #1
 80047fa:	f43f ada1 	beq.w	8004340 <eval_callrts+0x30>



    /* NOTE Message passing ends */

    pq_data_t sender_info_2 =
 80047fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004802:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004806:	e9cd 2324 	strd	r2, r3, [sp, #144]	; 0x90
 800480a:	e9cd 2326 	strd	r2, r3, [sp, #152]	; 0x98
      {   .context_id = sender_data.context_id
        , .baseline = TIME_MAX
        , .deadline = TIME_MAX
      };
    int enq_status =
 800480e:	ab28      	add	r3, sp, #160	; 0xa0
 8004810:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 8004814:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}



    /* NOTE Message passing ends */

    pq_data_t sender_info_2 =
 8004818:	f89d 6074 	ldrb.w	r6, [sp, #116]	; 0x74
 800481c:	f88d 6088 	strb.w	r6, [sp, #136]	; 0x88
      {   .context_id = sender_data.context_id
        , .baseline = TIME_MAX
        , .deadline = TIME_MAX
      };
    int enq_status =
 8004820:	f504 5091 	add.w	r0, r4, #4640	; 0x1220
 8004824:	e89b 000c 	ldmia.w	fp, {r2, r3}
 8004828:	3004      	adds	r0, #4
 800482a:	f003 ff21 	bl	8008670 <pq_insert>
      pq_insert(&container->rdyQ, sender_info_2); // queueing sender

    if (enq_status == -1){
 800482e:	3001      	adds	r0, #1
 8004830:	f43f ad86 	beq.w	8004340 <eval_callrts+0x30>
      return -1;
    }

    /* NOTE Post synchronization actions begins */

    if((heap_index)wrap_fptr.value != HEAP_NULL){
 8004834:	1c6e      	adds	r6, r5, #1
 8004836:	f000 8270 	beq.w	8004d1a <eval_callrts+0xa0a>

      DEBUG_PRINT(("WRAP from RECV \n"));

      int q = postSync( container
 800483a:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 800483e:	9300      	str	r3, [sp, #0]
 8004840:	f8cd a004 	str.w	sl, [sp, #4]
 8004844:	ab1e      	add	r3, sp, #120	; 0x78
 8004846:	4629      	mov	r1, r5
 8004848:	4620      	mov	r0, r4
 800484a:	cb0c      	ldmia	r3, {r2, r3}
 800484c:	f004 f940 	bl	8008ad0 <postSync.isra.2.lto_priv.62>
                      , wrap_fptr
                      , sender_data.message
                      , container->current_running_context_id
                      , SCHEDULED_SECOND); // receiver got scheduled second
      if(q == -1){
 8004850:	3001      	adds	r0, #1
 8004852:	f47f aecd 	bne.w	80045f0 <eval_callrts+0x2e0>
 8004856:	e573      	b.n	8004340 <eval_callrts+0x30>


}

static int handle_choose(vmc_t *vmc){
  cam_value_t e2 = vmc->contexts[vmc->current_running_context_id].env;
 8004858:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800485c:	1c43      	adds	r3, r0, #1
 800485e:	eb03 0343 	add.w	r3, r3, r3, lsl #1

  cam_register_t e1;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &e1);
 8004862:	eb00 0040 	add.w	r0, r0, r0, lsl #1


}

static int handle_choose(vmc_t *vmc){
  cam_value_t e2 = vmc->contexts[vmc->current_running_context_id].env;
 8004866:	eb04 1303 	add.w	r3, r4, r3, lsl #4

  cam_register_t e1;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &e1);
 800486a:	eb04 1000 	add.w	r0, r4, r0, lsl #4

static int handle_choose(vmc_t *vmc){
  cam_value_t e2 = vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t e1;
  int i =
 800486e:	303c      	adds	r0, #60	; 0x3c
 8004870:	a91d      	add	r1, sp, #116	; 0x74


}

static int handle_choose(vmc_t *vmc){
  cam_value_t e2 = vmc->contexts[vmc->current_running_context_id].env;
 8004872:	685f      	ldr	r7, [r3, #4]

  cam_register_t e1;
  int i =
 8004874:	f003 ffdc 	bl	8008830 <stack_pop>
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &e1);
  if(i == 0){
 8004878:	2800      	cmp	r0, #0
 800487a:	f43f ad61 	beq.w	8004340 <eval_callrts+0x30>
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }

  event_t evt1 = (event_t)e1.value;
 800487e:	9e1e      	ldr	r6, [sp, #120]	; 0x78
 8004880:	f10d 0b88 	add.w	fp, sp, #136	; 0x88
 8004884:	4635      	mov	r5, r6
 8004886:	e000      	b.n	800488a <eval_callrts+0x57a>
    cam_value_t pointer_to_next = heap_snd(&container->heap, index1);
    if((heap_index)pointer_to_next.value == HEAP_NULL){
      //reached the end of evt1 list
      break;
    }
    index1 = (heap_index)pointer_to_next.value;
 8004888:	461d      	mov	r5, r3

  while(true){

    /* cam_value_t cam_evt_pointer = heap_fst(&container->heap, index1); */

    cam_value_t pointer_to_next = heap_snd(&container->heap, index1);
 800488a:	462a      	mov	r2, r5
 800488c:	4658      	mov	r0, fp
 800488e:	4621      	mov	r1, r4
 8004890:	f004 f8fe 	bl	8008a90 <heap_snd>
 8004894:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    if((heap_index)pointer_to_next.value == HEAP_NULL){
 8004896:	1c5a      	adds	r2, r3, #1
 8004898:	d1f6      	bne.n	8004888 <eval_callrts+0x578>
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
  heap->value_flags[i].snd = value.flags;
 800489a:	6963      	ldr	r3, [r4, #20]
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 800489c:	6822      	ldr	r2, [r4, #0]
 800489e:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
  heap->value_flags[i].snd = value.flags;
 80048a2:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80048a6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 80048aa:	6057      	str	r7, [r2, #4]
  heap->value_flags[i].snd = value.flags;
 80048ac:	8069      	strh	r1, [r5, #2]
  choose(vmc, &evt1, &evt2, &final_evt);

  cam_value_t final_evt_cam =
    { .value = (UINT)final_evt, .flags = VALUE_PTR_BIT };

  vmc->contexts[vmc->current_running_context_id].env = final_evt_cam;
 80048ae:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80048b2:	3301      	adds	r3, #1
 80048b4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80048b8:	011b      	lsls	r3, r3, #4
 80048ba:	18e2      	adds	r2, r4, r3
 80048bc:	52e1      	strh	r1, [r4, r3]
 80048be:	6056      	str	r6, [r2, #4]
 80048c0:	e696      	b.n	80045f0 <eval_callrts+0x2e0>
static int handle_spawnExternal(vmc_t *vmc){

  //spawnExternal : Channel a -> Int -> ()

  cam_value_t driver_details =
    vmc->contexts[vmc->current_running_context_id].env;
 80048c2:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c

static int handle_spawnExternal(vmc_t *vmc){

  //spawnExternal : Channel a -> Int -> ()

  cam_value_t driver_details =
 80048c6:	1c43      	adds	r3, r0, #1
 80048c8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80048cc:	eb00 0040 	add.w	r0, r0, r0, lsl #1

static int handle_spawnExternal(vmc_t *vmc){

  //spawnExternal : Channel a -> Int -> ()

  cam_value_t driver_details =
 80048d0:	eb04 1303 	add.w	r3, r4, r3, lsl #4
    vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 80048d4:	eb04 1000 	add.w	r0, r4, r0, lsl #4

  cam_value_t driver_details =
    vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg;
  int i =
 80048d8:	303c      	adds	r0, #60	; 0x3c
 80048da:	a922      	add	r1, sp, #136	; 0x88

static int handle_spawnExternal(vmc_t *vmc){

  //spawnExternal : Channel a -> Int -> ()

  cam_value_t driver_details =
 80048dc:	685d      	ldr	r5, [r3, #4]
    vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg;
  int i =
 80048de:	f003 ffa7 	bl	8008830 <stack_pop>
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
 80048e2:	2800      	cmp	r0, #0
 80048e4:	f43f ad2c 	beq.w	8004340 <eval_callrts+0x30>
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }
  UUID chan_id = (UUID)hold_reg.value;

  if(vmc->drivers[driver_details.value].is_synchronous){
 80048e8:	f105 0392 	add.w	r3, r5, #146	; 0x92
 80048ec:	eb04 1343 	add.w	r3, r4, r3, lsl #5
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }
  UUID chan_id = (UUID)hold_reg.value;
 80048f0:	9a23      	ldr	r2, [sp, #140]	; 0x8c

  if(vmc->drivers[driver_details.value].is_synchronous){
 80048f2:	7a1b      	ldrb	r3, [r3, #8]
 80048f4:	2b00      	cmp	r3, #0
 80048f6:	d160      	bne.n	80049ba <eval_callrts+0x6aa>
    // synchronous driver like LEDs
    vmc->channels[chan_id].sync_driver_no = (UUID)driver_details.value;
  } else {
    // asynchronous drivers like buttons
    vmc->drivers[driver_details.value].channel_id = chan_id;
 80048f8:	eb04 1445 	add.w	r4, r4, r5, lsl #5
 80048fc:	f504 5492 	add.w	r4, r4, #4672	; 0x1240
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }
  UUID chan_id = (UUID)hold_reg.value;
 8004900:	f884 2020 	strb.w	r2, [r4, #32]
 8004904:	e674      	b.n	80045f0 <eval_callrts+0x2e0>
static int handle_wrap(vmc_t *vmc){

  //wrap : Event a -> (a -> b) -> Event b

  cam_value_t wrapf_ptr =
    vmc->contexts[vmc->current_running_context_id].env;
 8004906:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c

static int handle_wrap(vmc_t *vmc){

  //wrap : Event a -> (a -> b) -> Event b

  cam_value_t wrapf_ptr =
 800490a:	1c43      	adds	r3, r0, #1
 800490c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004910:	011b      	lsls	r3, r3, #4
    vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg;
  int i =
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
 8004912:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8004916:	eb04 1000 	add.w	r0, r4, r0, lsl #4

static int handle_wrap(vmc_t *vmc){

  //wrap : Event a -> (a -> b) -> Event b

  cam_value_t wrapf_ptr =
 800491a:	18e2      	adds	r2, r4, r3
    vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg;
  int i =
 800491c:	303c      	adds	r0, #60	; 0x3c
 800491e:	a918      	add	r1, sp, #96	; 0x60

static int handle_wrap(vmc_t *vmc){

  //wrap : Event a -> (a -> b) -> Event b

  cam_value_t wrapf_ptr =
 8004920:	6856      	ldr	r6, [r2, #4]
 8004922:	5ae7      	ldrh	r7, [r4, r3]
    vmc->contexts[vmc->current_running_context_id].env;

  cam_register_t hold_reg;
  int i =
 8004924:	f003 ff84 	bl	8008830 <stack_pop>
    stack_pop(&vmc->contexts[vmc->current_running_context_id].stack, &hold_reg);
  if(i == 0){
 8004928:	2800      	cmp	r0, #0
 800492a:	f43f ad09 	beq.w	8004340 <eval_callrts+0x30>
    DEBUG_PRINT(("Stack pop has failed"));
    return -1;
  }
  event_t current_evt = hold_reg.value;
 800492e:	9d19      	ldr	r5, [sp, #100]	; 0x64

  // IMP: we are guaranteed by the compiler tranformations that
  // current_evt is a base event; so traversal of event not needed

  // get pointer to cam_event_t
  cam_value_t cevt_ptr = heap_fst(&vmc->heap, (heap_index)current_evt);
 8004930:	a81d      	add	r0, sp, #116	; 0x74
 8004932:	462a      	mov	r2, r5
 8004934:	4621      	mov	r1, r4
 8004936:	f004 f8bb 	bl	8008ab0 <heap_fst>
  // get pointer to base_event_t
  cam_value_t bevt_ptr = heap_fst(&vmc->heap, (heap_index)cevt_ptr.value);
 800493a:	4621      	mov	r1, r4
 800493c:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 800493e:	a822      	add	r0, sp, #136	; 0x88
 8004940:	f004 f8b6 	bl	8008ab0 <heap_fst>
  // set the second of the cell that bevt_ptr is pointing to wrapf_ptr
  heap_set_snd(&vmc->heap, (heap_index)bevt_ptr.value, wrapf_ptr);
 8004944:	9923      	ldr	r1, [sp, #140]	; 0x8c
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 8004946:	6822      	ldr	r2, [r4, #0]
  heap->value_flags[i].snd = value.flags;
 8004948:	6963      	ldr	r3, [r4, #20]
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 800494a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
  heap->value_flags[i].snd = value.flags;
 800494e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 8004952:	6056      	str	r6, [r2, #4]
  heap->value_flags[i].snd = value.flags;
 8004954:	805f      	strh	r7, [r3, #2]

  //Place the modified event on the environment
  cam_value_t new_env = { .value = (UINT)current_evt, .flags = VALUE_PTR_BIT };
  vmc->contexts[vmc->current_running_context_id].env = new_env;
 8004956:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 800495a:	3301      	adds	r3, #1
 800495c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004960:	011b      	lsls	r3, r3, #4
 8004962:	18e2      	adds	r2, r4, r3
 8004964:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8004968:	52e1      	strh	r1, [r4, r3]
 800496a:	6055      	str	r5, [r2, #4]
 800496c:	e640      	b.n	80045f0 <eval_callrts+0x2e0>
        return 1;
      } // else continue the do-while loop

    } else if (bevt_simple.e_type == RECV) { // recvEvt

      if(poll_sendq(container, &container->channels[bevt_simple.channel_id].sendq)){
 800496e:	eb04 010c 	add.w	r1, r4, ip
 8004972:	31f4      	adds	r1, #244	; 0xf4
 8004974:	4620      	mov	r0, r4
 8004976:	f004 f94b 	bl	8008c10 <poll_sendq>
 800497a:	2800      	cmp	r0, #0
 800497c:	f43f aea6 	beq.w	80046cc <eval_callrts+0x3bc>
 8004980:	e6f8      	b.n	8004774 <eval_callrts+0x464>
 8004982:	eb12 060a 	adds.w	r6, r2, sl
 8004986:	eb47 070b 	adc.w	r7, r7, fp
    container->contexts[container->current_running_context_id].logicalTime;
  Time wakeupTime  = currentTime + baseline;
  Time finishTime;

  if(deadline == 0) // XXX : No deadline
    finishTime = TIME_MAX;
 800498a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800498e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004992:	e523      	b.n	80043dc <eval_callrts+0xcc>
    // It cannot simply be elements organized by deadlines,
    // sometimes an untimed thread (with a short lifetime)
    // might unblock an important blocked thread, while
    // meeting other deadlines.

    int k = pq_insert(&container->rdyQ, currentThread);
 8004994:	ab28      	add	r3, sp, #160	; 0xa0
 8004996:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 800499a:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 800499e:	ad22      	add	r5, sp, #136	; 0x88
 80049a0:	f504 5091 	add.w	r0, r4, #4640	; 0x1220
 80049a4:	e895 000c 	ldmia.w	r5, {r2, r3}
 80049a8:	3004      	adds	r0, #4
 80049aa:	f003 fe61 	bl	8008670 <pq_insert>
    if(k == -1){
 80049ae:	3001      	adds	r0, #1
 80049b0:	f47f ad4f 	bne.w	8004452 <eval_callrts+0x142>
 80049b4:	e4c4      	b.n	8004340 <eval_callrts+0x30>
  //EXPERIMENT
  Time actualTime = sys_time_get_current_ticks();
  Time absoluteBaseline = currentTime + baseline;
  Time absoluteDeadline = currentTime + baseline + deadline;
  bool cond1 = actualTime > absoluteDeadline;
  bool cond2 = (actualTime >= absoluteBaseline) &&
 80049b6:	2200      	movs	r2, #0
 80049b8:	e528      	b.n	800440c <eval_callrts+0xfc>
 80049ba:	b2d2      	uxtb	r2, r2
  }
  UUID chan_id = (UUID)hold_reg.value;

  if(vmc->drivers[driver_details.value].is_synchronous){
    // synchronous driver like LEDs
    vmc->channels[chan_id].sync_driver_no = (UUID)driver_details.value;
 80049bc:	232c      	movs	r3, #44	; 0x2c
 80049be:	fb03 4402 	mla	r4, r3, r2, r4
 80049c2:	f884 511d 	strb.w	r5, [r4, #285]	; 0x11d
 80049c6:	e613      	b.n	80045f0 <eval_callrts+0x2e0>
    cam_event_t cevt = { .bev = bevt, .msg = message };

    /**** Dealing with synchronous drivers like LEDs *****/
    if(container->channels[bevt_simple.channel_id].sync_driver_no != DRIVER_NULL){
      // should use ll_data_readable/ ll_data_writeable depending on the event_type here
      *cev = cevt;
 80049c8:	f88d 5089 	strb.w	r5, [sp, #137]	; 0x89
 80049cc:	f88d 9088 	strb.w	r9, [sp, #136]	; 0x88
 80049d0:	465e      	mov	r6, fp
 80049d2:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80049d4:	ad13      	add	r5, sp, #76	; 0x4c
 80049d6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80049d8:	6833      	ldr	r3, [r6, #0]
 80049da:	602b      	str	r3, [r5, #0]
 80049dc:	ab1d      	add	r3, sp, #116	; 0x74
 80049de:	e883 0007 	stmia.w	r3, {r0, r1, r2}



/********** IO operation **********/
static int synchronizeSyncDriver(vmc_t *container, cam_event_t cev){
  base_event_t bevt = cev.bev;
 80049e2:	f89d 5074 	ldrb.w	r5, [sp, #116]	; 0x74
 80049e6:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 80049ea:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
    cam_event_t cevt = { .bev = bevt, .msg = message };

    /**** Dealing with synchronous drivers like LEDs *****/
    if(container->channels[bevt_simple.channel_id].sync_driver_no != DRIVER_NULL){
      // should use ll_data_readable/ ll_data_writeable depending on the event_type here
      *cev = cevt;
 80049ec:	9a26      	ldr	r2, [sp, #152]	; 0x98
  base_evt_simple_t bevt_simple = bevt.evt_details;
  cam_value_t wrap_fptr = bevt.wrap_func_ptr;


  cam_value_t val_before_post_sync; // this will be initialised inside the contionals
  if(bevt_simple.e_type == SEND){
 80049ee:	2d00      	cmp	r5, #0
 80049f0:	f000 811d 	beq.w	8004c2e <eval_callrts+0x91e>

    val_before_post_sync = empty_tuple;



  } else if(bevt_simple.e_type == RECV) {
 80049f4:	2d01      	cmp	r5, #1
 80049f6:	f47f aca3 	bne.w	8004340 <eval_callrts+0x30>
    UUID sync_driver_number =
 80049fa:	fb0e 4303 	mla	r3, lr, r3, r4
bool ll_driver_init(void) {
  return true; /* maybe something will need a status indicator in the future */
}

uint32_t ll_read(ll_driver_t *drv, uint8_t *data, uint32_t data_size) {
  return drv->ll_read_fun((struct ll_driver_s*)drv, data, data_size);
 80049fe:	462a      	mov	r2, r5
      container->channels[bevt_simple.channel_id].sync_driver_no;
    uint8_t data_arr[4];
    //TODO: How many bytes do we read ? its not always1 byte
    int k =
      ll_read(&container->drivers[sync_driver_number], data_arr, 1); //reading 1 byte
 8004a00:	f893 111d 	ldrb.w	r1, [r3, #285]	; 0x11d
 8004a04:	eb04 1341 	add.w	r3, r4, r1, lsl #5
 8004a08:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
 8004a0c:	eb04 1041 	add.w	r0, r4, r1, lsl #5
 8004a10:	3308      	adds	r3, #8
 8004a12:	f500 5092 	add.w	r0, r0, #4672	; 0x1240
 8004a16:	685b      	ldr	r3, [r3, #4]
 8004a18:	3004      	adds	r0, #4
 8004a1a:	4659      	mov	r1, fp
 8004a1c:	4798      	blx	r3
    if(k != 1){
 8004a1e:	2801      	cmp	r0, #1
 8004a20:	f47f ac8e 	bne.w	8004340 <eval_callrts+0x30>
      return -1;
    }

    UINT data = 0;
    data = data | (data_arr[3] << 24);
    data = data | (data_arr[2] << 16);
 8004a24:	f89d 208a 	ldrb.w	r2, [sp, #138]	; 0x8a
      DEBUG_PRINT(("Failed to read from sync driver!"));
      return -1;
    }

    UINT data = 0;
    data = data | (data_arr[3] << 24);
 8004a28:	f89d 108b 	ldrb.w	r1, [sp, #139]	; 0x8b
    data = data | (data_arr[2] << 16);
    data = data | (data_arr[1] <<  8);
    data = data | data_arr[0];
 8004a2c:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
    }

    UINT data = 0;
    data = data | (data_arr[3] << 24);
    data = data | (data_arr[2] << 16);
    data = data | (data_arr[1] <<  8);
 8004a30:	f89d 5089 	ldrb.w	r5, [sp, #137]	; 0x89
      return -1;
    }

    UINT data = 0;
    data = data | (data_arr[3] << 24);
    data = data | (data_arr[2] << 16);
 8004a34:	0412      	lsls	r2, r2, #16
 8004a36:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 8004a3a:	4313      	orrs	r3, r2
    data = data | (data_arr[1] <<  8);
    data = data | data_arr[0];
 8004a3c:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
    return -1;
  }


  //Post synchronization
  if((heap_index)wrap_fptr.value != HEAP_NULL){
 8004a40:	1c70      	adds	r0, r6, #1
 8004a42:	f000 80e9 	beq.w	8004c18 <eval_callrts+0x908>

    int q = postSync( container
 8004a46:	2300      	movs	r3, #0
 8004a48:	f8ad 3088 	strh.w	r3, [sp, #136]	; 0x88
 8004a4c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8004a50:	9523      	str	r5, [sp, #140]	; 0x8c
 8004a52:	9300      	str	r3, [sp, #0]
 8004a54:	2501      	movs	r5, #1
 8004a56:	e89b 000c 	ldmia.w	fp, {r2, r3}
 8004a5a:	4631      	mov	r1, r6
 8004a5c:	4620      	mov	r0, r4
 8004a5e:	9501      	str	r5, [sp, #4]
 8004a60:	f004 f836 	bl	8008ad0 <postSync.isra.2.lto_priv.62>
                    , wrap_fptr
                    , val_before_post_sync
                    , container->current_running_context_id
                    , SCHEDULED_SECOND); // a synchronised driver like LED is always ready with the message
                                         // so the receiving software thread is scheduled second
    if(q == -1){
 8004a64:	3001      	adds	r0, #1
 8004a66:	f47f adc3 	bne.w	80045f0 <eval_callrts+0x2e0>
 8004a6a:	e469      	b.n	8004340 <eval_callrts+0x30>
  if(b)
    dirty_flag = (cam_value_t){ .value = 1, .flags = 0 }; // true
  else
    dirty_flag = (cam_value_t){ .value = 0, .flags = 0 }; // false

  heap_index dirty_flag_idx = vmc_heap_alloc_withGC(container);
 8004a6c:	4620      	mov	r0, r4
 8004a6e:	f003 ffdf 	bl	8008a30 <vmc_heap_alloc_withGC>
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 8004a72:	6821      	ldr	r1, [r4, #0]
  heap->value_flags[i].fst = value.flags;
 8004a74:	6962      	ldr	r2, [r4, #20]
 8004a76:	9005      	str	r0, [sp, #20]
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 8004a78:	2300      	movs	r3, #0
 8004a7a:	f841 3030 	str.w	r3, [r1, r0, lsl #3]
 8004a7e:	4637      	mov	r7, r6
  heap->value_flags[i].fst = value.flags;
 8004a80:	f822 3020 	strh.w	r3, [r2, r0, lsl #2]
 8004a84:	f8cd 801c 	str.w	r8, [sp, #28]
 8004a88:	f8cd b018 	str.w	fp, [sp, #24]
 8004a8c:	e00a      	b.n	8004aa4 <eval_callrts+0x794>
        DEBUG_PRINT(( "Cannot enqueue in channel %u 's send queue \n"
                     , bevt_simple.channel_id));
        return -1;
      }

    } else if (bevt_simple.e_type == RECV){ // recvEvt
 8004a8e:	2b01      	cmp	r3, #1
 8004a90:	d073      	beq.n	8004b7a <eval_callrts+0x86a>
        return -1;
      }

    }

    cam_value_t pointer_to_next = heap_snd(&container->heap, index);
 8004a92:	463a      	mov	r2, r7
 8004a94:	4621      	mov	r1, r4
 8004a96:	a81d      	add	r0, sp, #116	; 0x74
 8004a98:	f003 fffa 	bl	8008a90 <heap_snd>
    index = (heap_index)pointer_to_next.value;
 8004a9c:	9f1e      	ldr	r7, [sp, #120]	; 0x78

  } while(index != HEAP_NULL);
 8004a9e:	1c79      	adds	r1, r7, #1
 8004aa0:	f000 80a5 	beq.w	8004bee <eval_callrts+0x8de>
  //Create dirty flag = false
  cam_value_t df_pointer = create_dirty_flag(container, false);

  do{

    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);
 8004aa4:	a80b      	add	r0, sp, #44	; 0x2c
 8004aa6:	4621      	mov	r1, r4
 8004aa8:	463a      	mov	r2, r7
 8004aaa:	f004 f801 	bl	8008ab0 <heap_fst>


    cam_value_t base_evt_ptr =
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);
 8004aae:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  do{

    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);


    cam_value_t base_evt_ptr =
 8004ab0:	4650      	mov	r0, sl
 8004ab2:	462a      	mov	r2, r5
 8004ab4:	4621      	mov	r1, r4
 8004ab6:	f003 fffb 	bl	8008ab0 <heap_fst>
 8004aba:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);

    cam_value_t msg =
 8004abe:	462a      	mov	r2, r5
 8004ac0:	a80f      	add	r0, sp, #60	; 0x3c
 8004ac2:	4621      	mov	r1, r4
 8004ac4:	f003 ffe4 	bl	8008a90 <heap_snd>
      heap_snd(&container->heap, (heap_index)cam_evt_pointer.value);



    cam_value_t base_evt_simple =
 8004ac8:	a811      	add	r0, sp, #68	; 0x44
 8004aca:	4621      	mov	r1, r4
 8004acc:	4642      	mov	r2, r8
 8004ace:	f003 ffef 	bl	8008ab0 <heap_fst>
 8004ad2:	9d12      	ldr	r5, [sp, #72]	; 0x48
      heap_fst(&container->heap, (heap_index)base_evt_ptr.value);

    cam_value_t wrap_fptr =
 8004ad4:	4642      	mov	r2, r8
 8004ad6:	a818      	add	r0, sp, #96	; 0x60
 8004ad8:	4621      	mov	r1, r4
 8004ada:	f003 ffd9 	bl	8008a90 <heap_snd>
      heap_snd(&container->heap, (heap_index)base_evt_ptr.value);



    base_evt_simple_t bevt_simple =
 8004ade:	f3c5 2307 	ubfx	r3, r5, #8, #8
        , .wrap_func_ptr = wrap_fptr
      };

    (void)bevt;// unused

    if(bevt_simple.e_type == SEND){
 8004ae2:	2b00      	cmp	r3, #0
 8004ae4:	d1d3      	bne.n	8004a8e <eval_callrts+0x77e>


      //XXX: Instead of copying the whole message send its reference.
      // send_data_t should have the field cam_value_t *message
      send_data_t sender_data =
 8004ae6:	ab0f      	add	r3, sp, #60	; 0x3c
 8004ae8:	e893 0003 	ldmia.w	r3, {r0, r1}
 8004aec:	ab1e      	add	r3, sp, #120	; 0x78
 8004aee:	e883 0003 	stmia.w	r3, {r0, r1}
 8004af2:	f248 0300 	movw	r3, #32768	; 0x8000
 8004af6:	f8ad 3080 	strh.w	r3, [sp, #128]	; 0x80
 8004afa:	aa1d      	add	r2, sp, #116	; 0x74
 8004afc:	9b05      	ldr	r3, [sp, #20]
        {   .context_id = container->current_running_context_id
 8004afe:	f894 902c 	ldrb.w	r9, [r4, #44]	; 0x2c
 8004b02:	9321      	str	r3, [sp, #132]	; 0x84
 8004b04:	f88d 9074 	strb.w	r9, [sp, #116]	; 0x74
 8004b08:	4696      	mov	lr, r2
 8004b0a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
  if (is_full(q)){
    DEBUG_PRINT(("Chan send queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
  q->data[q->rear] = send_data;
 8004b0e:	f8dd c018 	ldr.w	ip, [sp, #24]
 8004b12:	b2ed      	uxtb	r5, r5
          , .message = msg
          , .dirty_flag_pointer = df_pointer };

      int j =
        chan_send_q_enqueue(&container->channels[bevt_simple.channel_id].sendq, sender_data);
 8004b14:	262c      	movs	r6, #44	; 0x2c
 8004b16:	fb06 f505 	mul.w	r5, r6, r5

  if (is_full(q)){
    DEBUG_PRINT(("Chan send queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004b1a:	eb04 0805 	add.w	r8, r4, r5
 8004b1e:	46e6      	mov	lr, ip
 8004b20:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8004b24:	f108 03f4 	add.w	r3, r8, #244	; 0xf4
 8004b28:	685a      	ldr	r2, [r3, #4]
static inline bool is_empty(chan_send_queue_t *q)
{  return (q->size == 0); }

int chan_send_q_enqueue(chan_send_queue_t *q, send_data_t send_data){

  if (is_full(q)){
 8004b2a:	691b      	ldr	r3, [r3, #16]
 8004b2c:	9905      	ldr	r1, [sp, #20]
 8004b2e:	f8ce 1000 	str.w	r1, [lr]
 8004b32:	429a      	cmp	r2, r3
    DEBUG_PRINT(("Chan send queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004b34:	f108 0bf8 	add.w	fp, r8, #248	; 0xf8
  q->data[q->rear] = send_data;
  q->size = q->size + 1;
 8004b38:	f508 7580 	add.w	r5, r8, #256	; 0x100
static inline bool is_empty(chan_send_queue_t *q)
{  return (q->size == 0); }

int chan_send_q_enqueue(chan_send_queue_t *q, send_data_t send_data){

  if (is_full(q)){
 8004b3c:	f43f abfe 	beq.w	800433c <eval_callrts+0x2c>
    DEBUG_PRINT(("Chan send queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004b40:	f8d8 3100 	ldr.w	r3, [r8, #256]	; 0x100
  q->data[q->rear] = send_data;
 8004b44:	f88d 9088 	strb.w	r9, [sp, #136]	; 0x88

  if (is_full(q)){
    DEBUG_PRINT(("Chan send queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004b48:	3301      	adds	r3, #1
 8004b4a:	fb93 fef2 	sdiv	lr, r3, r2
 8004b4e:	fb02 3e1e 	mls	lr, r2, lr, r3
  q->data[q->rear] = send_data;
 8004b52:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004b56:	f8d8 80f4 	ldr.w	r8, [r8, #244]	; 0xf4

  if (is_full(q)){
    DEBUG_PRINT(("Chan send queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004b5a:	f8cb e008 	str.w	lr, [fp, #8]
  q->data[q->rear] = send_data;
 8004b5e:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
 8004b62:	eb08 0e8e 	add.w	lr, r8, lr, lsl #2
 8004b66:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8004b6a:	f8dc 3000 	ldr.w	r3, [ip]
 8004b6e:	f8ce 3000 	str.w	r3, [lr]
  q->size = q->size + 1;
 8004b72:	686b      	ldr	r3, [r5, #4]
 8004b74:	3301      	adds	r3, #1
 8004b76:	606b      	str	r3, [r5, #4]
 8004b78:	e78b      	b.n	8004a92 <eval_callrts+0x782>
 8004b7a:	b2ed      	uxtb	r5, r5
      recv_data_t recv_data =
        {   .context_id = container->current_running_context_id
          , .dirty_flag_pointer = df_pointer };

      int j =
        chan_recv_q_enqueue(  &container->channels[bevt_simple.channel_id].recvq
 8004b7c:	232c      	movs	r3, #44	; 0x2c
 8004b7e:	fb03 f305 	mul.w	r3, r3, r5
 8004b82:	f248 0200 	movw	r2, #32768	; 0x8000

  if (is_full(q)){
    DEBUG_PRINT(("Chan recv queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004b86:	18e5      	adds	r5, r4, r3
 8004b88:	f8ad 2078 	strh.w	r2, [sp, #120]	; 0x78
      }

    } else if (bevt_simple.e_type == RECV){ // recvEvt

      recv_data_t recv_data =
        {   .context_id = container->current_running_context_id
 8004b8c:	f894 c02c 	ldrb.w	ip, [r4, #44]	; 0x2c
 8004b90:	9a05      	ldr	r2, [sp, #20]
 8004b92:	921f      	str	r2, [sp, #124]	; 0x7c
 8004b94:	f505 7984 	add.w	r9, r5, #264	; 0x108
 8004b98:	f88d c074 	strb.w	ip, [sp, #116]	; 0x74
 8004b9c:	aa1d      	add	r2, sp, #116	; 0x74
 8004b9e:	ca07      	ldmia	r2, {r0, r1, r2}
 8004ba0:	f8d9 e004 	ldr.w	lr, [r9, #4]
static inline bool is_empty(chan_recv_queue_t *q)
{  return (q->size == 0); }

int chan_recv_q_enqueue(chan_recv_queue_t *q, recv_data_t chan_data){

  if (is_full(q)){
 8004ba4:	f8d9 b010 	ldr.w	fp, [r9, #16]
 8004ba8:	ab13      	add	r3, sp, #76	; 0x4c
 8004baa:	45de      	cmp	lr, fp
    DEBUG_PRINT(("Chan recv queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
  q->data[q->rear] = chan_data;
  q->size = q->size + 1;
 8004bac:	f505 7888 	add.w	r8, r5, #272	; 0x110
 8004bb0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
static inline bool is_empty(chan_recv_queue_t *q)
{  return (q->size == 0); }

int chan_recv_q_enqueue(chan_recv_queue_t *q, recv_data_t chan_data){

  if (is_full(q)){
 8004bb4:	f43f abc2 	beq.w	800433c <eval_callrts+0x2c>
    DEBUG_PRINT(("Chan recv queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004bb8:	f8d5 2114 	ldr.w	r2, [r5, #276]	; 0x114
  q->data[q->rear] = chan_data;
 8004bbc:	f88d c04c 	strb.w	ip, [sp, #76]	; 0x4c

  if (is_full(q)){
    DEBUG_PRINT(("Chan recv queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004bc0:	3201      	adds	r2, #1
 8004bc2:	fb92 f1fe 	sdiv	r1, r2, lr
 8004bc6:	fb0e 2e11 	mls	lr, lr, r1, r2
  q->data[q->rear] = chan_data;
 8004bca:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8004bce:	f8d5 5108 	ldr.w	r5, [r5, #264]	; 0x108

  if (is_full(q)){
    DEBUG_PRINT(("Chan recv queue is full\n"));
    return -1;
  }
  q->rear = (q->rear + 1)%q->capacity;
 8004bd2:	f8c9 e00c 	str.w	lr, [r9, #12]
  q->data[q->rear] = chan_data;
 8004bd6:	eb0e 034e 	add.w	r3, lr, lr, lsl #1
 8004bda:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8004bde:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  q->size = q->size + 1;
 8004be2:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8004be6:	3301      	adds	r3, #1
 8004be8:	f8c8 3008 	str.w	r3, [r8, #8]
 8004bec:	e751      	b.n	8004a92 <eval_callrts+0x782>
      DEBUG_PRINT(("Block events failed! \n"));
      return -1;
    }
    /* Return value not checked?
       It can be 1 or -1. neither case looks like an error though */
    dispatch(container);
 8004bee:	4620      	mov	r0, r4
 8004bf0:	f8dd 801c 	ldr.w	r8, [sp, #28]
 8004bf4:	f003 fe6c 	bl	80088d0 <dispatch>
 8004bf8:	e4fa      	b.n	80045f0 <eval_callrts+0x2e0>

  if(heap_s.value == COMB){ // if combinator

    cam_value_t label = heap_f;

    vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
 8004bfa:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8004bfe:	3301      	adds	r3, #1
 8004c00:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004c04:	011b      	lsls	r3, r3, #4
 8004c06:	18e5      	adds	r5, r4, r3
 8004c08:	2200      	movs	r2, #0
 8004c0a:	52e2      	strh	r2, [r4, r3]

    return spawn(vmc, (uint16_t)label.value); // will place PID in env
 8004c0c:	b2b9      	uxth	r1, r7
 8004c0e:	4620      	mov	r0, r4

  if(heap_s.value == COMB){ // if combinator

    cam_value_t label = heap_f;

    vmc->contexts[vmc->current_running_context_id].env = empty_tuple;
 8004c10:	606a      	str	r2, [r5, #4]

    return spawn(vmc, (uint16_t)label.value); // will place PID in env
 8004c12:	f003 fe75 	bl	8008900 <spawn>
 8004c16:	e462      	b.n	80044de <eval_callrts+0x1ce>
      return q;
    }


  } else {
    container->contexts[container->current_running_context_id].env
 8004c18:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
      = val_before_post_sync;
 8004c1c:	3301      	adds	r3, #1
 8004c1e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004c22:	011b      	lsls	r3, r3, #4
 8004c24:	18e2      	adds	r2, r4, r3
 8004c26:	2100      	movs	r1, #0
 8004c28:	52e1      	strh	r1, [r4, r3]
 8004c2a:	6055      	str	r5, [r2, #4]
 8004c2c:	e4e0      	b.n	80045f0 <eval_callrts+0x2e0>
    data_arr[3] = extract_bits(message.value, 24, 8);
    data_arr[2] = extract_bits(message.value, 16, 8);
    data_arr[1] = extract_bits(message.value,  8, 8);
    data_arr[0] = extract_bits(message.value,  0, 8);

    UUID sync_driver_number =
 8004c2e:	fb0e 4303 	mla	r3, lr, r3, r4
  // counting begins with 0
  //  Bit pattern -> 0 1 0 0 1 1
  //  Index       -> 5 4 3 2 1 0
  // counting always moves towards left
  UINT mask = (1 << numbits) - 1;
  return ( mask & (value >> lsbstart));
 8004c32:	0e17      	lsrs	r7, r2, #24
      container->channels[bevt_simple.channel_id].sync_driver_no;

    // TODO: how many bytes should we write ?
    //       its not always one. 
    int k =
      ll_write(&container->drivers[sync_driver_number], data_arr, 4); //writing 4 bytes
 8004c34:	f893 111d 	ldrb.w	r1, [r3, #285]	; 0x11d

    uint8_t data_arr[4];
    data_arr[3] = extract_bits(message.value, 24, 8);
    data_arr[2] = extract_bits(message.value, 16, 8);
    data_arr[1] = extract_bits(message.value,  8, 8);
    data_arr[0] = extract_bits(message.value,  0, 8);
 8004c38:	f88d 2088 	strb.w	r2, [sp, #136]	; 0x88
}

uint32_t ll_write(ll_driver_t *drv, uint8_t *data, uint32_t data_size) {
  return drv->ll_write_fun((struct ll_driver_s*)drv, data, data_size);
 8004c3c:	eb04 1341 	add.w	r3, r4, r1, lsl #5
 8004c40:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
      container->channels[bevt_simple.channel_id].sync_driver_no;

    // TODO: how many bytes should we write ?
    //       its not always one. 
    int k =
      ll_write(&container->drivers[sync_driver_number], data_arr, 4); //writing 4 bytes
 8004c44:	eb04 1041 	add.w	r0, r4, r1, lsl #5
 8004c48:	3308      	adds	r3, #8
  // counting begins with 0
  //  Bit pattern -> 0 1 0 0 1 1
  //  Index       -> 5 4 3 2 1 0
  // counting always moves towards left
  UINT mask = (1 << numbits) - 1;
  return ( mask & (value >> lsbstart));
 8004c4a:	0c11      	lsrs	r1, r2, #16
 8004c4c:	f500 5092 	add.w	r0, r0, #4672	; 0x1240
 8004c50:	0a12      	lsrs	r2, r2, #8
    //XXX: Assuming the message is a simple value and not a pointer for
    //     now; We should make such checks here and serialize accordingly

    uint8_t data_arr[4];
    data_arr[3] = extract_bits(message.value, 24, 8);
    data_arr[2] = extract_bits(message.value, 16, 8);
 8004c52:	f88d 108a 	strb.w	r1, [sp, #138]	; 0x8a
    data_arr[1] = extract_bits(message.value,  8, 8);
 8004c56:	f88d 2089 	strb.w	r2, [sp, #137]	; 0x89
 8004c5a:	689b      	ldr	r3, [r3, #8]

    //XXX: Assuming the message is a simple value and not a pointer for
    //     now; We should make such checks here and serialize accordingly

    uint8_t data_arr[4];
    data_arr[3] = extract_bits(message.value, 24, 8);
 8004c5c:	f88d 708b 	strb.w	r7, [sp, #139]	; 0x8b
 8004c60:	3004      	adds	r0, #4
 8004c62:	4659      	mov	r1, fp
 8004c64:	2204      	movs	r2, #4
 8004c66:	4798      	blx	r3

    // TODO: how many bytes should we write ?
    //       its not always one. 
    int k =
      ll_write(&container->drivers[sync_driver_number], data_arr, 4); //writing 4 bytes
    if(k != 4){
 8004c68:	2804      	cmp	r0, #4
 8004c6a:	f43f aee9 	beq.w	8004a40 <eval_callrts+0x730>
 8004c6e:	f7ff bb67 	b.w	8004340 <eval_callrts+0x30>

  if(bevt_simple.e_type == SEND){

    recv_data_t recv_data;//recv_context_id;
    int deq_status =
      chan_recv_q_dequeue(&container->channels[bevt_simple.channel_id].recvq, &recv_data);
 8004c72:	202c      	movs	r0, #44	; 0x2c
 8004c74:	fb00 4009 	mla	r0, r0, r9, r4


  if(bevt_simple.e_type == SEND){

    recv_data_t recv_data;//recv_context_id;
    int deq_status =
 8004c78:	a91d      	add	r1, sp, #116	; 0x74
 8004c7a:	f500 7084 	add.w	r0, r0, #264	; 0x108
 8004c7e:	f003 ffef 	bl	8008c60 <chan_recv_q_dequeue>
      chan_recv_q_dequeue(&container->channels[bevt_simple.channel_id].recvq, &recv_data);
    if(deq_status == -1){ //empty queue
 8004c82:	3001      	adds	r0, #1
 8004c84:	f43f ab5c 	beq.w	8004340 <eval_callrts+0x30>
      DEBUG_PRINT(( "Recv Queue of %u empty for syncing send \n"
                   , bevt_simple.channel_id));
      return -1;
    }

    UUID recv_context_id = recv_data.context_id;
 8004c88:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 8004c8c:	6821      	ldr	r1, [r4, #0]
  heap->value_flags[i].fst = value.flags;
 8004c8e:	6962      	ldr	r2, [r4, #20]
 8004c90:	4618      	mov	r0, r3
 8004c92:	461e      	mov	r6, r3

    cam_value_t true_flag = { .value = 1, .flags = 0 };
    heap_set_fst(  &container->heap
                 , (heap_index)recv_data.dirty_flag_pointer.value
 8004c94:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 8004c96:	2701      	movs	r7, #1
 8004c98:	f841 7033 	str.w	r7, [r1, r3, lsl #3]
  heap->value_flags[i].fst = value.flags;
 8004c9c:	f822 a023 	strh.w	sl, [r2, r3, lsl #2]
    /* NOTE Message passing begins */
    /*
     */


    int k = message_pass( container
 8004ca0:	9701      	str	r7, [sp, #4]
 8004ca2:	f8cd 9000 	str.w	r9, [sp]
 8004ca6:	ab0f      	add	r3, sp, #60	; 0x3c
 8004ca8:	4601      	mov	r1, r0
 8004caa:	cb0c      	ldmia	r3, {r2, r3}
 8004cac:	4620      	mov	r0, r4
 8004cae:	f003 fb5f 	bl	8008370 <message_pass.constprop.17>
                        , recv_context_id
                        , message
                        , bevt_simple.channel_id
                        , RECV
                        , SCHEDULED_FIRST); // receiver got scheduled first
    if(k == -1){
 8004cb2:	3001      	adds	r0, #1
 8004cb4:	f43f ab44 	beq.w	8004340 <eval_callrts+0x30>
    }


    /* NOTE Message passing ends */

    pq_data_t sender_info =
 8004cb8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8004cbc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004cc0:	e9cd 2324 	strd	r2, r3, [sp, #144]	; 0x90
 8004cc4:	e9cd 2326 	strd	r2, r3, [sp, #152]	; 0x98
      {   .context_id = container->current_running_context_id
        , .baseline = TIME_MAX
        , .deadline = TIME_MAX
      };
    int enq_status =
 8004cc8:	ab28      	add	r3, sp, #160	; 0xa0
 8004cca:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
    }


    /* NOTE Message passing ends */

    pq_data_t sender_info =
 8004cce:	f894 e02c 	ldrb.w	lr, [r4, #44]	; 0x2c
 8004cd2:	f88d e088 	strb.w	lr, [sp, #136]	; 0x88
      {   .context_id = container->current_running_context_id
        , .baseline = TIME_MAX
        , .deadline = TIME_MAX
      };
    int enq_status =
 8004cd6:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 8004cda:	f504 5091 	add.w	r0, r4, #4640	; 0x1220
 8004cde:	e89b 000c 	ldmia.w	fp, {r2, r3}
 8004ce2:	3004      	adds	r0, #4
 8004ce4:	f003 fcc4 	bl	8008670 <pq_insert>
      pq_insert(&container->rdyQ, sender_info); // queueing sender

    if (enq_status == -1){
 8004ce8:	3001      	adds	r0, #1
 8004cea:	f43f ab29 	beq.w	8004340 <eval_callrts+0x30>
    /* NOTE Post synchronization actions begins */
    // place the () on sender's env because sync (send) succeeded

    cam_value_t empty_tuple = { .value = 0, .flags = 0 };

    if((heap_index)wrap_fptr.value != HEAP_NULL){
 8004cee:	1c6b      	adds	r3, r5, #1
 8004cf0:	d01e      	beq.n	8004d30 <eval_callrts+0xa20>

      int q = postSync( container
 8004cf2:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 8004cf6:	f8ad a044 	strh.w	sl, [sp, #68]	; 0x44
 8004cfa:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
 8004cfe:	9701      	str	r7, [sp, #4]
 8004d00:	ab11      	add	r3, sp, #68	; 0x44
 8004d02:	cb0c      	ldmia	r3, {r2, r3}
 8004d04:	4629      	mov	r1, r5
 8004d06:	9000      	str	r0, [sp, #0]
 8004d08:	4620      	mov	r0, r4
 8004d0a:	f003 fee1 	bl	8008ad0 <postSync.isra.2.lto_priv.62>
                      , wrap_fptr
                      , empty_tuple
                      , container->current_running_context_id
                      , SCHEDULED_SECOND); // sender scheduled second
      if(q == -1){
 8004d0e:	3001      	adds	r0, #1
 8004d10:	f43f ab16 	beq.w	8004340 <eval_callrts+0x30>
        = empty_tuple;
    }
    /* NOTE Post synchronization actions ends */

    // the receiving thread will run now
    container->current_running_context_id = recv_context_id;
 8004d14:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
 8004d18:	e46a      	b.n	80045f0 <eval_callrts+0x2e0>
        return q;
      }


    } else {
      container->contexts[container->current_running_context_id].env
 8004d1a:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
        = sender_data.message;
 8004d1e:	a91e      	add	r1, sp, #120	; 0x78
 8004d20:	2330      	movs	r3, #48	; 0x30
 8004d22:	c903      	ldmia	r1, {r0, r1}
 8004d24:	fb02 3303 	mla	r3, r2, r3, r3
 8004d28:	441c      	add	r4, r3
 8004d2a:	e884 0003 	stmia.w	r4, {r0, r1}
 8004d2e:	e45f      	b.n	80045f0 <eval_callrts+0x2e0>
        return q;
      }


    } else {
      container->contexts[container->current_running_context_id].env
 8004d30:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
        = empty_tuple;
 8004d34:	2330      	movs	r3, #48	; 0x30
 8004d36:	fb02 3303 	mla	r3, r2, r3, r3
 8004d3a:	18e2      	adds	r2, r4, r3
 8004d3c:	f824 a003 	strh.w	sl, [r4, r3]
 8004d40:	f8c2 a004 	str.w	sl, [r2, #4]
 8004d44:	e7e6      	b.n	8004d14 <eval_callrts+0xa04>
 8004d46:	bf00      	nop
	...

08004d50 <_idle_thread.lto_priv.92>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8004d50:	e7fe      	b.n	8004d50 <_idle_thread.lto_priv.92>
 8004d52:	bf00      	nop
	...

08004d60 <chSysPolledDelayX>:
 8004d60:	4a03      	ldr	r2, [pc, #12]	; (8004d70 <chSysPolledDelayX+0x10>)
 8004d62:	6851      	ldr	r1, [r2, #4]
 8004d64:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8004d66:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8004d68:	4298      	cmp	r0, r3
 8004d6a:	d8fb      	bhi.n	8004d64 <chSysPolledDelayX+0x4>
  }
}
 8004d6c:	4770      	bx	lr
 8004d6e:	bf00      	nop
 8004d70:	e0001000 	.word	0xe0001000
	...

08004d80 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8004d80:	b508      	push	{r3, lr}
 8004d82:	4605      	mov	r5, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d84:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8004d86:	4c0a      	ldr	r4, [pc, #40]	; (8004db0 <chSysHalt+0x30>)
 8004d88:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8004d8a:	f003 0304 	and.w	r3, r3, #4
 8004d8e:	b29b      	uxth	r3, r3
 8004d90:	b10b      	cbz	r3, 8004d96 <chSysHalt+0x16>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8004d92:	62e5      	str	r5, [r4, #44]	; 0x2c
 8004d94:	e7fe      	b.n	8004d94 <chSysHalt+0x14>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8004d96:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8004d98:	780a      	ldrb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 8004d9a:	6088      	str	r0, [r1, #8]
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8004d9c:	2004      	movs	r0, #4
 8004d9e:	f360 0202 	bfi	r2, r0, #0, #3
    ch.dbg.trace_buffer.ptr->state         = 0;
 8004da2:	f363 02c7 	bfi	r2, r3, #3, #5
 8004da6:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
    trace_next();
 8004da8:	f7fd fa1a 	bl	80021e0 <trace_next.lto_priv.115>
 8004dac:	e7f1      	b.n	8004d92 <chSysHalt+0x12>
 8004dae:	bf00      	nop
 8004db0:	2000b68c 	.word	0x2000b68c
	...

08004dc0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 8004dc0:	b508      	push	{r3, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004dc2:	2320      	movs	r3, #32
 8004dc4:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004dc8:	4a06      	ldr	r2, [pc, #24]	; (8004de4 <_dbg_check_enter_isr+0x24>)
 8004dca:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004dcc:	2b00      	cmp	r3, #0
 8004dce:	db01      	blt.n	8004dd4 <_dbg_check_enter_isr+0x14>
 8004dd0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8004dd2:	b111      	cbz	r1, 8004dda <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 8004dd4:	4804      	ldr	r0, [pc, #16]	; (8004de8 <_dbg_check_enter_isr+0x28>)
 8004dd6:	f7ff ffd3 	bl	8004d80 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8004dda:	3301      	adds	r3, #1
 8004ddc:	6313      	str	r3, [r2, #48]	; 0x30
 8004dde:	f381 8811 	msr	BASEPRI, r1
 8004de2:	bd08      	pop	{r3, pc}
 8004de4:	2000b68c 	.word	0x2000b68c
 8004de8:	0800ce90 	.word	0x0800ce90
 8004dec:	00000000 	.word	0x00000000

08004df0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8004df0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004df2:	4b06      	ldr	r3, [pc, #24]	; (8004e0c <_dbg_check_unlock_from_isr+0x1c>)
 8004df4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004df6:	2a00      	cmp	r2, #0
 8004df8:	dd05      	ble.n	8004e06 <_dbg_check_unlock_from_isr+0x16>
 8004dfa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004dfc:	2a00      	cmp	r2, #0
 8004dfe:	dd02      	ble.n	8004e06 <_dbg_check_unlock_from_isr+0x16>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8004e00:	2200      	movs	r2, #0
 8004e02:	635a      	str	r2, [r3, #52]	; 0x34
 8004e04:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
 8004e06:	4802      	ldr	r0, [pc, #8]	; (8004e10 <_dbg_check_unlock_from_isr+0x20>)
 8004e08:	f7ff ffba 	bl	8004d80 <chSysHalt>
 8004e0c:	2000b68c 	.word	0x2000b68c
 8004e10:	0800ce98 	.word	0x0800ce98
	...

08004e20 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8004e20:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004e22:	4b06      	ldr	r3, [pc, #24]	; (8004e3c <_dbg_check_lock_from_isr+0x1c>)
 8004e24:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004e26:	2a00      	cmp	r2, #0
 8004e28:	dd01      	ble.n	8004e2e <_dbg_check_lock_from_isr+0xe>
 8004e2a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004e2c:	b112      	cbz	r2, 8004e34 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 8004e2e:	4804      	ldr	r0, [pc, #16]	; (8004e40 <_dbg_check_lock_from_isr+0x20>)
 8004e30:	f7ff ffa6 	bl	8004d80 <chSysHalt>
  }
  _dbg_enter_lock();
 8004e34:	2201      	movs	r2, #1
 8004e36:	635a      	str	r2, [r3, #52]	; 0x34
 8004e38:	bd08      	pop	{r3, pc}
 8004e3a:	bf00      	nop
 8004e3c:	2000b68c 	.word	0x2000b68c
 8004e40:	0800cea0 	.word	0x0800cea0
	...

08004e50 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 8004e50:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004e52:	4b05      	ldr	r3, [pc, #20]	; (8004e68 <_dbg_check_unlock+0x18>)
 8004e54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004e56:	b922      	cbnz	r2, 8004e62 <_dbg_check_unlock+0x12>
 8004e58:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8004e5a:	2900      	cmp	r1, #0
 8004e5c:	dd01      	ble.n	8004e62 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8004e5e:	635a      	str	r2, [r3, #52]	; 0x34
 8004e60:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8004e62:	4802      	ldr	r0, [pc, #8]	; (8004e6c <_dbg_check_unlock+0x1c>)
 8004e64:	f7ff ff8c 	bl	8004d80 <chSysHalt>
 8004e68:	2000b68c 	.word	0x2000b68c
 8004e6c:	0800cea8 	.word	0x0800cea8

08004e70 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8004e70:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004e72:	4b05      	ldr	r3, [pc, #20]	; (8004e88 <_dbg_check_lock+0x18>)
 8004e74:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004e76:	b90a      	cbnz	r2, 8004e7c <_dbg_check_lock+0xc>
 8004e78:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004e7a:	b112      	cbz	r2, 8004e82 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 8004e7c:	4803      	ldr	r0, [pc, #12]	; (8004e8c <_dbg_check_lock+0x1c>)
 8004e7e:	f7ff ff7f 	bl	8004d80 <chSysHalt>
  }
  _dbg_enter_lock();
 8004e82:	2201      	movs	r2, #1
 8004e84:	635a      	str	r2, [r3, #52]	; 0x34
 8004e86:	bd08      	pop	{r3, pc}
 8004e88:	2000b68c 	.word	0x2000b68c
 8004e8c:	0800ceb0 	.word	0x0800ceb0

08004e90 <otg_txfifo_handler>:
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8004e90:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8004e94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8004e98:	68da      	ldr	r2, [r3, #12]
 8004e9a:	f8d0 806c 	ldr.w	r8, [r0, #108]	; 0x6c
 8004e9e:	6956      	ldr	r6, [r2, #20]
 8004ea0:	e896 0028 	ldmia.w	r6, {r3, r5}
 8004ea4:	429d      	cmp	r5, r3
 8004ea6:	d235      	bcs.n	8004f14 <otg_txfifo_handler+0x84>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004ea8:	eb08 1e41 	add.w	lr, r8, r1, lsl #5
      return true;
    }

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 8004eac:	f8b2 c010 	ldrh.w	ip, [r2, #16]
#endif
      return true;
    }

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8004eb0:	1b5d      	subs	r5, r3, r5
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004eb2:	f8de 3918 	ldr.w	r3, [lr, #2328]	; 0x918
 8004eb6:	4565      	cmp	r5, ip
 8004eb8:	bf28      	it	cs
 8004eba:	4665      	movcs	r5, ip
 8004ebc:	b29b      	uxth	r3, r3
 8004ebe:	ebb5 0f83 	cmp.w	r5, r3, lsl #2
 8004ec2:	d832      	bhi.n	8004f2a <otg_txfifo_handler+0x9a>
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8004ec4:	68b7      	ldr	r7, [r6, #8]
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");
 8004ec6:	b315      	cbz	r5, 8004f0e <otg_txfifo_handler+0x7e>
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8004ec8:	1c4c      	adds	r4, r1, #1
 8004eca:	eb08 3404 	add.w	r4, r8, r4, lsl #12
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 8004ece:	683b      	ldr	r3, [r7, #0]
 8004ed0:	6023      	str	r3, [r4, #0]
    if (n <= 4) {
 8004ed2:	2d04      	cmp	r5, #4
 8004ed4:	d907      	bls.n	8004ee6 <otg_txfifo_handler+0x56>
 8004ed6:	462b      	mov	r3, r5
 8004ed8:	463a      	mov	r2, r7
      break;
    }
    n -= 4;
 8004eda:	3b04      	subs	r3, #4
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 8004edc:	f852 0f04 	ldr.w	r0, [r2, #4]!
 8004ee0:	6020      	str	r0, [r4, #0]
    if (n <= 4) {
 8004ee2:	2b04      	cmp	r3, #4
 8004ee4:	d8f9      	bhi.n	8004eda <otg_txfifo_handler+0x4a>
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8004ee6:	e896 000c 	ldmia.w	r6, {r2, r3}
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 8004eea:	442f      	add	r7, r5
    usbp->epc[ep]->in_state->txcnt += n;
 8004eec:	441d      	add	r5, r3
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8004eee:	42aa      	cmp	r2, r5
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 8004ef0:	60b7      	str	r7, [r6, #8]
    usbp->epc[ep]->in_state->txcnt += n;
 8004ef2:	6075      	str	r5, [r6, #4]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8004ef4:	d90e      	bls.n	8004f14 <otg_txfifo_handler+0x84>
#endif
      return true;
    }

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8004ef6:	1b55      	subs	r5, r2, r5
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004ef8:	f8de 3918 	ldr.w	r3, [lr, #2328]	; 0x918
 8004efc:	4565      	cmp	r5, ip
 8004efe:	bf28      	it	cs
 8004f00:	4665      	movcs	r5, ip
 8004f02:	b29b      	uxth	r3, r3
 8004f04:	ebb5 0f83 	cmp.w	r5, r3, lsl #2
 8004f08:	d80f      	bhi.n	8004f2a <otg_txfifo_handler+0x9a>
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");
 8004f0a:	2d00      	cmp	r5, #0
 8004f0c:	d1df      	bne.n	8004ece <otg_txfifo_handler+0x3e>
 8004f0e:	4808      	ldr	r0, [pc, #32]	; (8004f30 <otg_txfifo_handler+0xa0>)
 8004f10:	f7ff ff36 	bl	8004d80 <chSysHalt>
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
#if 1
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8004f14:	f8d8 3834 	ldr.w	r3, [r8, #2100]	; 0x834
 8004f18:	2001      	movs	r0, #1
 8004f1a:	fa00 f201 	lsl.w	r2, r0, r1
 8004f1e:	ea23 0302 	bic.w	r3, r3, r2
 8004f22:	f8c8 3834 	str.w	r3, [r8, #2100]	; 0x834
 8004f26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
      return false;
 8004f2a:	2000      	movs	r0, #0
    usbp->epc[ep]->in_state->txcnt += n;
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
  }
}
 8004f2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004f30:	0800ce38 	.word	0x0800ce38
	...

08004f40 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004f40:	4a98      	ldr	r2, [pc, #608]	; (80051a4 <__early_init+0x264>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004f42:	f8df c2a0 	ldr.w	ip, [pc, #672]	; 80051e4 <__early_init+0x2a4>

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004f46:	6913      	ldr	r3, [r2, #16]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004f48:	4897      	ldr	r0, [pc, #604]	; (80051a8 <__early_init+0x268>)

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004f4a:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8004f4e:	ea6f 2343 	mvn.w	r3, r3, lsl #9
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8004f52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004f56:	6113      	str	r3, [r2, #16]
 8004f58:	6913      	ldr	r3, [r2, #16]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004f5a:	f8df 828c 	ldr.w	r8, [pc, #652]	; 80051e8 <__early_init+0x2a8>
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8004f5e:	f8df 928c 	ldr.w	r9, [pc, #652]	; 80051ec <__early_init+0x2ac>
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8004f62:	f8df b28c 	ldr.w	fp, [pc, #652]	; 80051f0 <__early_init+0x2b0>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004f66:	f8df e28c 	ldr.w	lr, [pc, #652]	; 80051f4 <__early_init+0x2b4>
 8004f6a:	4f90      	ldr	r7, [pc, #576]	; (80051ac <__early_init+0x26c>)
 8004f6c:	4e90      	ldr	r6, [pc, #576]	; (80051b0 <__early_init+0x270>)
 8004f6e:	4d91      	ldr	r5, [pc, #580]	; (80051b4 <__early_init+0x274>)
 8004f70:	4c91      	ldr	r4, [pc, #580]	; (80051b8 <__early_init+0x278>)

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8004f72:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8004f76:	f023 0301 	bic.w	r3, r3, #1
 8004f7a:	6113      	str	r3, [r2, #16]
 8004f7c:	6913      	ldr	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8004f7e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004f80:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8004f84:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8004f88:	6313      	str	r3, [r2, #48]	; 0x30
 8004f8a:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8004f8c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8004f90:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8004f94:	6513      	str	r3, [r2, #80]	; 0x50
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8004f96:	f46f 4aa8 	mvn.w	sl, #21504	; 0x5400
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004f9a:	2300      	movs	r3, #0
static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8004f9c:	6d11      	ldr	r1, [r2, #80]	; 0x50
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004f9e:	f8c8 3004 	str.w	r3, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004fa2:	f8c8 a008 	str.w	sl, [r8, #8]
  gpiop->PUPDR   = config->pupdr;
 8004fa6:	f8c8 900c 	str.w	r9, [r8, #12]
  gpiop->ODR     = config->odr;
 8004faa:	f64f 7aff 	movw	sl, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8004fae:	f8df 9248 	ldr.w	r9, [pc, #584]	; 80051f8 <__early_init+0x2b8>
static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8004fb2:	f8c8 a014 	str.w	sl, [r8, #20]
  gpiop->AFRL    = config->afrl;
 8004fb6:	f8c8 b020 	str.w	fp, [r8, #32]
  gpiop->AFRH    = config->afrh;
 8004fba:	f8c8 9024 	str.w	r9, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8004fbe:	f8df b23c 	ldr.w	fp, [pc, #572]	; 80051fc <__early_init+0x2bc>
 8004fc2:	f8c8 b000 	str.w	fp, [r8]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8004fc6:	f44f 7910 	mov.w	r9, #576	; 0x240
 8004fca:	f8cc 9004 	str.w	r9, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004fce:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 8004fd2:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8005200 <__early_init+0x2c0>
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8004fd6:	f8cc 8008 	str.w	r8, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8004fda:	f04f 6980 	mov.w	r9, #67108864	; 0x4000000

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8004fde:	f8cc b00c 	str.w	fp, [ip, #12]
  gpiop->ODR     = config->odr;
 8004fe2:	f8cc a014 	str.w	sl, [ip, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8004fe6:	f04f 0b40 	mov.w	fp, #64	; 0x40

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8004fea:	f8cc 9020 	str.w	r9, [ip, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8004fee:	f8df 9214 	ldr.w	r9, [pc, #532]	; 8005204 <__early_init+0x2c4>
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8004ff2:	f8cc b024 	str.w	fp, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8004ff6:	f8cc 9000 	str.w	r9, [ip]

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8004ffa:	f10c 5ca2 	add.w	ip, ip, #339738624	; 0x14400000
 8004ffe:	f50c 3c44 	add.w	ip, ip, #200704	; 0x31000
 8005002:	f50c 7caa 	add.w	ip, ip, #340	; 0x154
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005006:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800500a:	f8ce 8008 	str.w	r8, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 800500e:	f8ce c00c 	str.w	ip, [lr, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8005012:	f04f 4cc0 	mov.w	ip, #1610612736	; 0x60000000
static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8005016:	f8ce a014 	str.w	sl, [lr, #20]
  gpiop->AFRL    = config->afrl;
 800501a:	f8ce c020 	str.w	ip, [lr, #32]
  gpiop->AFRH    = config->afrh;
 800501e:	f8df c1e8 	ldr.w	ip, [pc, #488]	; 8005208 <__early_init+0x2c8>
 8005022:	f8ce c024 	str.w	ip, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005026:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 800520c <__early_init+0x2cc>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800502a:	4964      	ldr	r1, [pc, #400]	; (80051bc <__early_init+0x27c>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800502c:	f8ce c000 	str.w	ip, [lr]

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8005030:	f8df e1dc 	ldr.w	lr, [pc, #476]	; 8005210 <__early_init+0x2d0>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005034:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8005036:	f8df c1dc 	ldr.w	ip, [pc, #476]	; 8005214 <__early_init+0x2d4>
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800503a:	f8c7 8008 	str.w	r8, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 800503e:	f8c7 e00c 	str.w	lr, [r7, #12]
  gpiop->ODR     = config->odr;
 8005042:	f640 7eff 	movw	lr, #4095	; 0xfff
 8005046:	f8c7 e014 	str.w	lr, [r7, #20]
  gpiop->AFRL    = config->afrl;
 800504a:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 800504c:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800504e:	f8c7 c000 	str.w	ip, [r7]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005052:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005054:	f8c6 8008 	str.w	r8, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8005058:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 800505a:	f8c6 a014 	str.w	sl, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800505e:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8005060:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005062:	f8c6 b000 	str.w	fp, [r6]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005066:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005068:	f8c5 8008 	str.w	r8, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 800506c:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 800506e:	f8c5 a014 	str.w	sl, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8005072:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8005074:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005076:	602b      	str	r3, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005078:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800507a:	f8c4 8008 	str.w	r8, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800507e:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 8005080:	f8c4 a014 	str.w	sl, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8005084:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8005086:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005088:	6023      	str	r3, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800508a:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800508c:	f8c0 8008 	str.w	r8, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8005090:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 8005092:	f8c0 a014 	str.w	sl, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8005096:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8005098:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800509a:	6003      	str	r3, [r0, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800509c:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800509e:	f8c1 8008 	str.w	r8, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80050a2:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 80050a4:	f8c1 a014 	str.w	sl, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80050a8:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80050aa:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80050ac:	600b      	str	r3, [r1, #0]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80050ae:	4b44      	ldr	r3, [pc, #272]	; (80051c0 <__early_init+0x280>)
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80050b0:	f04f 5e80 	mov.w	lr, #268435456	; 0x10000000
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80050b4:	f44f 4740 	mov.w	r7, #49152	; 0xc000
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80050b8:	f8c2 e040 	str.w	lr, [r2, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80050bc:	601f      	str	r7, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80050be:	6813      	ldr	r3, [r2, #0]
 80050c0:	f043 0301 	orr.w	r3, r3, #1
 80050c4:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80050c6:	6811      	ldr	r1, [r2, #0]
 80050c8:	4b36      	ldr	r3, [pc, #216]	; (80051a4 <__early_init+0x264>)
 80050ca:	078f      	lsls	r7, r1, #30
 80050cc:	d5fb      	bpl.n	80050c6 <__early_init+0x186>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 80050ce:	689a      	ldr	r2, [r3, #8]
 80050d0:	f022 0203 	bic.w	r2, r2, #3
 80050d4:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80050d6:	4619      	mov	r1, r3
 80050d8:	688b      	ldr	r3, [r1, #8]
 80050da:	4a32      	ldr	r2, [pc, #200]	; (80051a4 <__early_init+0x264>)
 80050dc:	f013 030c 	ands.w	r3, r3, #12
 80050e0:	d1fa      	bne.n	80050d8 <__early_init+0x198>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80050e2:	6811      	ldr	r1, [r2, #0]
 80050e4:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 80050e8:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80050ea:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 80050ec:	6813      	ldr	r3, [r2, #0]
 80050ee:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80050f2:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 80050f4:	6811      	ldr	r1, [r2, #0]
 80050f6:	4b2b      	ldr	r3, [pc, #172]	; (80051a4 <__early_init+0x264>)
 80050f8:	038e      	lsls	r6, r1, #14
 80050fa:	d5fb      	bpl.n	80050f4 <__early_init+0x1b4>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80050fc:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80050fe:	f042 0201 	orr.w	r2, r2, #1
 8005102:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8005104:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8005106:	4927      	ldr	r1, [pc, #156]	; (80051a4 <__early_init+0x264>)
 8005108:	0795      	lsls	r5, r2, #30
 800510a:	d5fb      	bpl.n	8005104 <__early_init+0x1c4>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800510c:	4b2d      	ldr	r3, [pc, #180]	; (80051c4 <__early_init+0x284>)
 800510e:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8005110:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8005112:	4a2b      	ldr	r2, [pc, #172]	; (80051c0 <__early_init+0x280>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8005114:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8005118:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800511a:	6853      	ldr	r3, [r2, #4]
 800511c:	045c      	lsls	r4, r3, #17
 800511e:	d5fc      	bpl.n	800511a <__early_init+0x1da>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8005120:	4920      	ldr	r1, [pc, #128]	; (80051a4 <__early_init+0x264>)
 8005122:	680a      	ldr	r2, [r1, #0]
 8005124:	4b1f      	ldr	r3, [pc, #124]	; (80051a4 <__early_init+0x264>)
 8005126:	0190      	lsls	r0, r2, #6
 8005128:	d5fb      	bpl.n	8005122 <__early_init+0x1e2>
    ;
#endif /* STM32_ACTIVATE_PLL */

#if STM32_ACTIVATE_PLLI2S
  /* PLLI2S activation.*/
  RCC->PLLI2SCFGR = STM32_PLLI2SR | STM32_PLLI2SN | STM32_PLLI2SP |
 800512a:	4a27      	ldr	r2, [pc, #156]	; (80051c8 <__early_init+0x288>)
 800512c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    STM32_PLLI2SSRC | STM32_PLLI2SQ | STM32_PLLI2SM;
  RCC->CR |= RCC_CR_PLLI2SON;
 8005130:	681a      	ldr	r2, [r3, #0]
 8005132:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8005136:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
 8005138:	681a      	ldr	r2, [r3, #0]
 800513a:	491a      	ldr	r1, [pc, #104]	; (80051a4 <__early_init+0x264>)
 800513c:	0112      	lsls	r2, r2, #4
 800513e:	d5fb      	bpl.n	8005138 <__early_init+0x1f8>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8005140:	4a22      	ldr	r2, [pc, #136]	; (80051cc <__early_init+0x28c>)

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8005142:	4b23      	ldr	r3, [pc, #140]	; (80051d0 <__early_init+0x290>)
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8005144:	608a      	str	r2, [r1, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8005146:	681a      	ldr	r2, [r3, #0]
 8005148:	4b22      	ldr	r3, [pc, #136]	; (80051d4 <__early_init+0x294>)
 800514a:	429a      	cmp	r2, r3
 800514c:	d01f      	beq.n	800518e <__early_init+0x24e>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800514e:	4b22      	ldr	r3, [pc, #136]	; (80051d8 <__early_init+0x298>)
 8005150:	f240 7205 	movw	r2, #1797	; 0x705
 8005154:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8005156:	4a20      	ldr	r2, [pc, #128]	; (80051d8 <__early_init+0x298>)
 8005158:	6813      	ldr	r3, [r2, #0]
 800515a:	f003 030f 	and.w	r3, r3, #15
 800515e:	2b05      	cmp	r3, #5
 8005160:	d1fa      	bne.n	8005158 <__early_init+0x218>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8005162:	4910      	ldr	r1, [pc, #64]	; (80051a4 <__early_init+0x264>)
 8005164:	688b      	ldr	r3, [r1, #8]
 8005166:	f043 0302 	orr.w	r3, r3, #2
 800516a:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800516c:	688b      	ldr	r3, [r1, #8]
 800516e:	4a0d      	ldr	r2, [pc, #52]	; (80051a4 <__early_init+0x264>)
 8005170:	f003 030c 	and.w	r3, r3, #12
 8005174:	2b08      	cmp	r3, #8
 8005176:	d1f9      	bne.n	800516c <__early_init+0x22c>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8005178:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800517a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800517e:	6453      	str	r3, [r2, #68]	; 0x44
 8005180:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8005182:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005186:	6653      	str	r3, [r2, #100]	; 0x64
 8005188:	6e53      	ldr	r3, [r2, #100]	; 0x64
 800518a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800518e:	4a13      	ldr	r2, [pc, #76]	; (80051dc <__early_init+0x29c>)
 8005190:	4b13      	ldr	r3, [pc, #76]	; (80051e0 <__early_init+0x2a0>)
 8005192:	6812      	ldr	r2, [r2, #0]
 8005194:	429a      	cmp	r2, r3
 8005196:	d1da      	bne.n	800514e <__early_init+0x20e>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8005198:	4b0f      	ldr	r3, [pc, #60]	; (80051d8 <__early_init+0x298>)
 800519a:	f240 1205 	movw	r2, #261	; 0x105
 800519e:	601a      	str	r2, [r3, #0]
 80051a0:	e7d9      	b.n	8005156 <__early_init+0x216>
 80051a2:	bf00      	nop
 80051a4:	40023800 	.word	0x40023800
 80051a8:	40021c00 	.word	0x40021c00
 80051ac:	40020c00 	.word	0x40020c00
 80051b0:	40021000 	.word	0x40021000
 80051b4:	40021400 	.word	0x40021400
 80051b8:	40021800 	.word	0x40021800
 80051bc:	40022000 	.word	0x40022000
 80051c0:	40007000 	.word	0x40007000
 80051c4:	07405408 	.word	0x07405408
 80051c8:	54413004 	.word	0x54413004
 80051cc:	38089400 	.word	0x38089400
 80051d0:	e0042000 	.word	0xe0042000
 80051d4:	20006411 	.word	0x20006411
 80051d8:	40023c00 	.word	0x40023c00
 80051dc:	e000ed00 	.word	0xe000ed00
 80051e0:	410fc241 	.word	0x410fc241
 80051e4:	40020400 	.word	0x40020400
 80051e8:	40020000 	.word	0x40020000
 80051ec:	40010054 	.word	0x40010054
 80051f0:	55560000 	.word	0x55560000
 80051f4:	40020800 	.word	0x40020800
 80051f8:	000aaa00 	.word	0x000aaa00
 80051fc:	2aa0aa00 	.word	0x2aa0aa00
 8005200:	55514515 	.word	0x55514515
 8005204:	00082080 	.word	0x00082080
 8005208:	00060600 	.word	0x00060600
 800520c:	02208001 	.word	0x02208001
 8005210:	00555055 	.word	0x00555055
 8005214:	55000100 	.word	0x55000100
	...

08005220 <VectorB0>:
/**
 * @brief   Interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8005220:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8005224:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8005228:	483c      	ldr	r0, [pc, #240]	; (800531c <VectorB0+0xfc>)
 800522a:	f7fd f819 	bl	8002260 <_trace_isr_enter>
 800522e:	f7ff fdc7 	bl	8004dc0 <_dbg_check_enter_isr>
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8005232:	f8d8 3010 	ldr.w	r3, [r8, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8005236:	f8d8 200c 	ldr.w	r2, [r8, #12]
 800523a:	4013      	ands	r3, r2
 800523c:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 800523e:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 8005240:	079b      	lsls	r3, r3, #30
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
  timp->SR = ~sr;
 8005242:	f8c8 2010 	str.w	r2, [r8, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8005246:	d408      	bmi.n	800525a <VectorB0+0x3a>

  OSAL_IRQ_PROLOGUE();

  st_lld_serve_interrupt();

  OSAL_IRQ_EPILOGUE();
 8005248:	f7fd fad2 	bl	80027f0 <_dbg_check_leave_isr>
 800524c:	4833      	ldr	r0, [pc, #204]	; (800531c <VectorB0+0xfc>)
 800524e:	f7fc ffe7 	bl	8002220 <_trace_isr_leave>
}
 8005252:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  OSAL_IRQ_PROLOGUE();

  st_lld_serve_interrupt();

  OSAL_IRQ_EPILOGUE();
 8005256:	f7fc bf53 	b.w	8002100 <_port_irq_epilogue>
 800525a:	2320      	movs	r3, #32
 800525c:	f383 8811 	msr	BASEPRI, r3
  delta_list_t *dlp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  dlp = vtlp->dlist.next;
 8005260:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 8005320 <VectorB0+0x100>
 8005264:	46ca      	mov	sl, r9
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8005266:	f7ff fddb 	bl	8004e20 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 800526a:	f7fd f871 	bl	8002350 <chDbgCheckClassI>
 * @iclass
 */
void chVTDoTickI(void) {
  virtual_timers_list_t *vtlp = &ch.vtlist;

  chDbgCheckClassI();
 800526e:	f7fd f86f 	bl	8002350 <chDbgCheckClassI>
  delta_list_t *dlp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  dlp = vtlp->dlist.next;
 8005272:	f85a 4f1c 	ldr.w	r4, [sl, #28]!
 8005276:	68a2      	ldr	r2, [r4, #8]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8005278:	464f      	mov	r7, r9
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800527a:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
 800527e:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
 8005282:	4827      	ldr	r0, [pc, #156]	; (8005320 <VectorB0+0x100>)
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8005284:	1acd      	subs	r5, r1, r3

    /* The list scan is limited by the timers header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < dlp->delta) {
 8005286:	4295      	cmp	r5, r2
 8005288:	d323      	bcc.n	80052d2 <VectorB0+0xb2>
      vtlp->dlist.next = dlp->next;

      /* Calling the associated function and then marking the timer as
         non active.*/
      fn = vtp->func;
      vtp->func = NULL;
 800528a:	2600      	movs	r6, #0
    do {
      vtfunc_t fn;
      virtual_timer_t *vtp = (virtual_timer_t *)dlp;

      /* The "last time" becomes this timer's expiration time.*/
      vtlp->lasttime += dlp->delta;
 800528c:	4413      	add	r3, r2
 800528e:	f8c9 3028 	str.w	r3, [r9, #40]	; 0x28
      nowdelta -= dlp->delta;

      /* Removing the timer from the list.*/
      dlp->next->prev = &vtlp->dlist;
 8005292:	6823      	ldr	r3, [r4, #0]
      vtfunc_t fn;
      virtual_timer_t *vtp = (virtual_timer_t *)dlp;

      /* The "last time" becomes this timer's expiration time.*/
      vtlp->lasttime += dlp->delta;
      nowdelta -= dlp->delta;
 8005294:	68a2      	ldr	r2, [r4, #8]
      dlp->next->prev = &vtlp->dlist;
      vtlp->dlist.next = dlp->next;

      /* Calling the associated function and then marking the timer as
         non active.*/
      fn = vtp->func;
 8005296:	f8d4 b00c 	ldr.w	fp, [r4, #12]
      /* The "last time" becomes this timer's expiration time.*/
      vtlp->lasttime += dlp->delta;
      nowdelta -= dlp->delta;

      /* Removing the timer from the list.*/
      dlp->next->prev = &vtlp->dlist;
 800529a:	f8c3 a004 	str.w	sl, [r3, #4]
         non active.*/
      fn = vtp->func;
      vtp->func = NULL;

      /* If the list becomes empty then the timer is stopped.*/
      if (is_vtlist_empty(&vtlp->dlist)) {
 800529e:	4553      	cmp	r3, sl
      vtlp->lasttime += dlp->delta;
      nowdelta -= dlp->delta;

      /* Removing the timer from the list.*/
      dlp->next->prev = &vtlp->dlist;
      vtlp->dlist.next = dlp->next;
 80052a0:	f8c9 301c 	str.w	r3, [r9, #28]

      /* Calling the associated function and then marking the timer as
         non active.*/
      fn = vtp->func;
      vtp->func = NULL;
 80052a4:	60e6      	str	r6, [r4, #12]
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 80052a6:	bf08      	it	eq
 80052a8:	f8c8 600c 	streq.w	r6, [r8, #12]
      vtfunc_t fn;
      virtual_timer_t *vtp = (virtual_timer_t *)dlp;

      /* The "last time" becomes this timer's expiration time.*/
      vtlp->lasttime += dlp->delta;
      nowdelta -= dlp->delta;
 80052ac:	1aad      	subs	r5, r5, r2
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80052ae:	f7ff fd9f 	bl	8004df0 <_dbg_check_unlock_from_isr>
 80052b2:	f386 8811 	msr	BASEPRI, r6
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 80052b6:	6920      	ldr	r0, [r4, #16]
 80052b8:	47d8      	blx	fp
 80052ba:	2320      	movs	r3, #32
 80052bc:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80052c0:	f7ff fdae 	bl	8004e20 <_dbg_check_lock_from_isr>
      chSysLockFromISR();

      /* Next element in the list.*/
      dlp = vtlp->dlist.next;
 80052c4:	f8d9 401c 	ldr.w	r4, [r9, #28]
    }
    while (dlp->delta <= nowdelta);
 80052c8:	68a2      	ldr	r2, [r4, #8]
 80052ca:	4295      	cmp	r5, r2
 80052cc:	d3d5      	bcc.n	800527a <VectorB0+0x5a>
 80052ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80052d0:	e7dc      	b.n	800528c <VectorB0+0x6c>
 *
 * @notapi
 */
static inline bool is_vtlist_empty(delta_list_t *dlhp) {

  return (bool)(dlhp == dlhp->next);
 80052d2:	69c2      	ldr	r2, [r0, #28]
    }
    while (dlp->delta <= nowdelta);
  }

  /* If the list is empty, nothing else to do.*/
  if (is_vtlist_empty(&vtlp->dlist)) {
 80052d4:	4552      	cmp	r2, sl
 80052d6:	d018      	beq.n	800530a <VectorB0+0xea>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 80052d8:	442b      	add	r3, r5
 80052da:	6283      	str	r3, [r0, #40]	; 0x28
  vtlp->dlist.next->delta -= nowdelta;
 80052dc:	6893      	ldr	r3, [r2, #8]
 80052de:	1b5b      	subs	r3, r3, r5
 80052e0:	6093      	str	r3, [r2, #8]
 80052e2:	6a82      	ldr	r2, [r0, #40]	; 0x28

  /* Recalculating the next alarm time.*/
  delta = dlp->delta - chTimeDiffX(vtlp->lasttime, now);
 80052e4:	68a3      	ldr	r3, [r4, #8]
 80052e6:	1a8c      	subs	r4, r1, r2
 80052e8:	1b1c      	subs	r4, r3, r4
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80052ea:	2c01      	cmp	r4, #1
 80052ec:	bf98      	it	ls
 80052ee:	2402      	movls	r4, #2

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 80052f0:	440c      	add	r4, r1
 80052f2:	4620      	mov	r0, r4
 80052f4:	f002 fb1c 	bl	8007930 <stSetAlarm>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80052f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX()) <=
 80052fc:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
 8005300:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8005302:	1aa1      	subs	r1, r4, r2
 8005304:	1a9b      	subs	r3, r3, r2
 8005306:	428b      	cmp	r3, r1
 8005308:	d805      	bhi.n	8005316 <VectorB0+0xf6>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800530a:	f7ff fd71 	bl	8004df0 <_dbg_check_unlock_from_isr>
 800530e:	2300      	movs	r3, #0
 8005310:	f383 8811 	msr	BASEPRI, r3
 8005314:	e798      	b.n	8005248 <VectorB0+0x28>
 8005316:	4803      	ldr	r0, [pc, #12]	; (8005324 <VectorB0+0x104>)
 8005318:	f7ff fd32 	bl	8004d80 <chSysHalt>
 800531c:	0800cef8 	.word	0x0800cef8
 8005320:	2000b68c 	.word	0x2000b68c
 8005324:	0800ceb8 	.word	0x0800ceb8
	...

08005330 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005330:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8005334:	b4f0      	push	{r4, r5, r6, r7}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005336:	68dc      	ldr	r4, [r3, #12]
 8005338:	6965      	ldr	r5, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800533a:	682b      	ldr	r3, [r5, #0]
 800533c:	60eb      	str	r3, [r5, #12]
  if (isp->txsize == 0) {
 800533e:	b9f3      	cbnz	r3, 800537e <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8005340:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8005342:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8005346:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800534a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800534e:	6823      	ldr	r3, [r4, #0]
 8005350:	f003 0303 	and.w	r3, r3, #3
 8005354:	2b01      	cmp	r3, #1
 8005356:	d026      	beq.n	80053a6 <usb_lld_start_in+0x76>
 8005358:	b20b      	sxth	r3, r1
 800535a:	eb00 1343 	add.w	r3, r0, r3, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800535e:	2401      	movs	r4, #1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8005360:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8005364:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8005368:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800536c:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 8005370:	fa04 f301 	lsl.w	r3, r4, r1
 8005374:	4313      	orrs	r3, r2
 8005376:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
}
 800537a:	bcf0      	pop	{r4, r5, r6, r7}
 800537c:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 800537e:	b319      	cbz	r1, 80053c8 <usb_lld_start_in+0x98>
 8005380:	1e5d      	subs	r5, r3, #1
 8005382:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* CHTODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8005386:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8005388:	8a26      	ldrh	r6, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    /* CHTODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 800538a:	eb00 1741 	add.w	r7, r0, r1, lsl #5
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800538e:	19ab      	adds	r3, r5, r6
 8005390:	fbb3 f3f6 	udiv	r3, r3, r6
                    usbp->epc[ep]->in_maxsize;
    /* CHTODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8005394:	ea42 43c3 	orr.w	r3, r2, r3, lsl #19
 8005398:	f8c7 3910 	str.w	r3, [r7, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800539c:	6823      	ldr	r3, [r4, #0]
 800539e:	f003 0303 	and.w	r3, r3, #3
 80053a2:	2b01      	cmp	r3, #1
 80053a4:	d1d8      	bne.n	8005358 <usb_lld_start_in+0x28>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80053a6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80053aa:	f413 7f80 	tst.w	r3, #256	; 0x100
 80053ae:	b20b      	sxth	r3, r1
 80053b0:	eb00 1443 	add.w	r4, r0, r3, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 80053b4:	f8d4 2900 	ldr.w	r2, [r4, #2304]	; 0x900
 80053b8:	bf14      	ite	ne
 80053ba:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 80053be:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
 80053c2:	f8c4 2900 	str.w	r2, [r4, #2304]	; 0x900
 80053c6:	e7c8      	b.n	800535a <usb_lld_start_in+0x2a>
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 80053c8:	2b40      	cmp	r3, #64	; 0x40
 80053ca:	d9d9      	bls.n	8005380 <usb_lld_start_in+0x50>
      isp->txsize = EP0_MAX_INSIZE;
 80053cc:	2340      	movs	r3, #64	; 0x40
 80053ce:	602b      	str	r3, [r5, #0]
 80053d0:	4a01      	ldr	r2, [pc, #4]	; (80053d8 <usb_lld_start_in+0xa8>)
 80053d2:	253f      	movs	r5, #63	; 0x3f
 80053d4:	e7d7      	b.n	8005386 <usb_lld_start_in+0x56>
 80053d6:	bf00      	nop
 80053d8:	20000040 	.word	0x20000040
 80053dc:	00000000 	.word	0x00000000

080053e0 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80053e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 80053e4:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80053e6:	eb06 1341 	add.w	r3, r6, r1, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80053ea:	4607      	mov	r7, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80053ec:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 80053f0:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 80053f4:	07e3      	lsls	r3, r4, #31
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80053f6:	460d      	mov	r5, r1
  otgp->ie[ep].DIEPINT = epint;

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 80053f8:	d503      	bpl.n	8005402 <otg_epin_handler+0x22>
 80053fa:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 80053fe:	07da      	lsls	r2, r3, #31
 8005400:	d409      	bmi.n	8005416 <otg_epin_handler+0x36>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8005402:	0623      	lsls	r3, r4, #24
 8005404:	d505      	bpl.n	8005412 <otg_epin_handler+0x32>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8005406:	f8d6 2834 	ldr.w	r2, [r6, #2100]	; 0x834
 800540a:	2301      	movs	r3, #1
 800540c:	40ab      	lsls	r3, r5
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800540e:	4213      	tst	r3, r2
 8005410:	d119      	bne.n	8005446 <otg_epin_handler+0x66>
 8005412:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005416:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 800541a:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 800541e:	f8de 3014 	ldr.w	r3, [lr, #20]

    if (isp->txsize < isp->totsize) {
 8005422:	f8d3 c000 	ldr.w	ip, [r3]
 8005426:	68da      	ldr	r2, [r3, #12]
 8005428:	4594      	cmp	ip, r2
 800542a:	d312      	bcc.n	8005452 <otg_epin_handler+0x72>
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800542c:	8902      	ldrh	r2, [r0, #8]
 800542e:	f8de c008 	ldr.w	ip, [lr, #8]
 8005432:	2301      	movs	r3, #1
 8005434:	408b      	lsls	r3, r1
 8005436:	ea22 0303 	bic.w	r3, r2, r3
 800543a:	8103      	strh	r3, [r0, #8]
 800543c:	f1bc 0f00 	cmp.w	ip, #0
 8005440:	d0df      	beq.n	8005402 <otg_epin_handler+0x22>
 8005442:	47e0      	blx	ip
 8005444:	e7dd      	b.n	8005402 <otg_epin_handler+0x22>
    }
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* TX FIFO empty or emptying.*/
    otg_txfifo_handler(usbp, ep);
 8005446:	4638      	mov	r0, r7
 8005448:	4629      	mov	r1, r5
  }
}
 800544a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    }
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* TX FIFO empty or emptying.*/
    otg_txfifo_handler(usbp, ep);
 800544e:	f7ff bd1f 	b.w	8004e90 <otg_txfifo_handler>

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 8005452:	ebcc 0202 	rsb	r2, ip, r2
      isp->txcnt  = 0;
 8005456:	f04f 0800 	mov.w	r8, #0
 800545a:	e883 0104 	stmia.w	r3, {r2, r8}
 800545e:	2320      	movs	r3, #32
 8005460:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8005464:	f7ff fcdc 	bl	8004e20 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usb_lld_start_in(usbp, ep);
 8005468:	4638      	mov	r0, r7
 800546a:	4629      	mov	r1, r5
 800546c:	f7ff ff60 	bl	8005330 <usb_lld_start_in>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8005470:	f7ff fcbe 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8005474:	f388 8811 	msr	BASEPRI, r8
 8005478:	e7c3      	b.n	8005402 <otg_epin_handler+0x22>
 800547a:	bf00      	nop
 800547c:	0000      	movs	r0, r0
	...

08005480 <usb_lld_start_out>:
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8005480:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8005484:	b430      	push	{r4, r5}
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8005486:	68dc      	ldr	r4, [r3, #12]
 8005488:	69a2      	ldr	r2, [r4, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800548a:	6813      	ldr	r3, [r2, #0]
 800548c:	60d3      	str	r3, [r2, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 800548e:	b909      	cbnz	r1, 8005494 <usb_lld_start_out+0x14>
 8005490:	2b40      	cmp	r3, #64	; 0x40
 8005492:	d822      	bhi.n	80054da <usb_lld_start_out+0x5a>
 8005494:	3b01      	subs	r3, #1
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8005496:	8a62      	ldrh	r2, [r4, #18]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8005498:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800549a:	6824      	ldr	r4, [r4, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800549c:	4413      	add	r3, r2
 800549e:	fbb3 f3f2 	udiv	r3, r3, r2
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 80054a2:	fb02 f203 	mul.w	r2, r2, r3
 80054a6:	3203      	adds	r2, #3

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80054a8:	04db      	lsls	r3, r3, #19
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 80054aa:	f022 0203 	bic.w	r2, r2, #3
 80054ae:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80054b2:	4313      	orrs	r3, r2
 80054b4:	eb00 1541 	add.w	r5, r0, r1, lsl #5
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80054b8:	f004 0203 	and.w	r2, r4, #3
 80054bc:	2a01      	cmp	r2, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 80054be:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80054c2:	d00e      	beq.n	80054e2 <usb_lld_start_out+0x62>
 80054c4:	b209      	sxth	r1, r1
 80054c6:	eb00 1141 	add.w	r1, r0, r1, lsl #5
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
}
 80054ca:	bc30      	pop	{r4, r5}
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80054cc:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 80054d0:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80054d4:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 80054d8:	4770      	bx	lr
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;
 80054da:	2340      	movs	r3, #64	; 0x40
 80054dc:	6013      	str	r3, [r2, #0]
 80054de:	233f      	movs	r3, #63	; 0x3f
 80054e0:	e7d9      	b.n	8005496 <usb_lld_start_out+0x16>
 80054e2:	b209      	sxth	r1, r1
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80054e4:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80054e8:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 80054ec:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80054f0:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80054f4:	bf14      	ite	ne
 80054f6:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80054fa:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 80054fe:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8005502:	e7e0      	b.n	80054c6 <usb_lld_start_out+0x46>
	...

08005510 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8005510:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8005514:	6ec7      	ldr	r7, [r0, #108]	; 0x6c
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8005516:	eb07 1341 	add.w	r3, r7, r1, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800551a:	4606      	mov	r6, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800551c:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8005520:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8005524:	0722      	lsls	r2, r4, #28
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8005526:	460d      	mov	r5, r1
  uint32_t epint = otgp->oe[ep].DOEPINT;

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8005528:	d503      	bpl.n	8005532 <otg_epout_handler+0x22>
 800552a:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800552e:	071b      	lsls	r3, r3, #28
 8005530:	d425      	bmi.n	800557e <otg_epout_handler+0x6e>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
  }

  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8005532:	07e2      	lsls	r2, r4, #31
 8005534:	d521      	bpl.n	800557a <otg_epout_handler+0x6a>
 8005536:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800553a:	07db      	lsls	r3, r3, #31
 800553c:	d51d      	bpl.n	800557a <otg_epout_handler+0x6a>
    USBOutEndpointState *osp;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 800553e:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 8005542:	68d9      	ldr	r1, [r3, #12]
 8005544:	698b      	ldr	r3, [r1, #24]

    /* EP0 requires special handling.*/
    if (ep == 0) {
 8005546:	b955      	cbnz	r5, 800555e <otg_epout_handler+0x4e>
#endif

      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8005548:	8a4a      	ldrh	r2, [r1, #18]
 800554a:	685c      	ldr	r4, [r3, #4]
 800554c:	fbb4 f0f2 	udiv	r0, r4, r2
 8005550:	fb02 4210 	mls	r2, r2, r0, r4
 8005554:	b91a      	cbnz	r2, 800555e <otg_epout_handler+0x4e>
          (osp->rxsize < osp->totsize)) {
 8005556:	6818      	ldr	r0, [r3, #0]
 8005558:	68da      	ldr	r2, [r3, #12]
#endif

      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800555a:	4290      	cmp	r0, r2
 800555c:	d315      	bcc.n	800558a <otg_epout_handler+0x7a>
        return;
      }
    }

    /* End on OUT transfer.*/
    _usb_isr_invoke_out_cb(usbp, ep);
 800555e:	8972      	ldrh	r2, [r6, #10]
 8005560:	68cc      	ldr	r4, [r1, #12]
 8005562:	2301      	movs	r3, #1
 8005564:	40ab      	lsls	r3, r5
 8005566:	ea22 0303 	bic.w	r3, r2, r3
 800556a:	8173      	strh	r3, [r6, #10]
 800556c:	b12c      	cbz	r4, 800557a <otg_epout_handler+0x6a>
 800556e:	4630      	mov	r0, r6
 8005570:	4629      	mov	r1, r5
 8005572:	4623      	mov	r3, r4
  }
}
 8005574:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        return;
      }
    }

    /* End on OUT transfer.*/
    _usb_isr_invoke_out_cb(usbp, ep);
 8005578:	4718      	bx	r3
 800557a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 800557e:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8005582:	68db      	ldr	r3, [r3, #12]
 8005584:	685b      	ldr	r3, [r3, #4]
 8005586:	4798      	blx	r3
 8005588:	e7d3      	b.n	8005532 <otg_epout_handler+0x22>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
          (osp->rxsize < osp->totsize)) {
        osp->rxsize = osp->totsize - osp->rxsize;
 800558a:	1a12      	subs	r2, r2, r0
        osp->rxcnt  = 0;
 800558c:	e883 0024 	stmia.w	r3, {r2, r5}
 8005590:	2320      	movs	r3, #32
 8005592:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8005596:	f7ff fc43 	bl	8004e20 <_dbg_check_lock_from_isr>
        osalSysLockFromISR();
        usb_lld_start_out(usbp, ep);
 800559a:	4630      	mov	r0, r6
 800559c:	4629      	mov	r1, r5
 800559e:	f7ff ff6f 	bl	8005480 <usb_lld_start_out>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80055a2:	f7ff fc25 	bl	8004df0 <_dbg_check_unlock_from_isr>
 80055a6:	f385 8811 	msr	BASEPRI, r5
 80055aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80055ae:	bf00      	nop

080055b0 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 80055b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  stm32_otg_t *otgp = usbp->otg;
 80055b4:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 80055b6:	6973      	ldr	r3, [r6, #20]
  sts &= otgp->GINTMSK;
 80055b8:	69b7      	ldr	r7, [r6, #24]
 80055ba:	401f      	ands	r7, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 80055bc:	f417 5880 	ands.w	r8, r7, #4096	; 0x1000
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 80055c0:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 80055c2:	6177      	str	r7, [r6, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 80055c4:	f040 814b 	bne.w	800585e <usb_lld_serve_interrupt+0x2ae>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 80055c8:	2f00      	cmp	r7, #0
 80055ca:	f2c0 812c 	blt.w	8005826 <usb_lld_serve_interrupt+0x276>

    _usb_wakeup(usbp);
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 80055ce:	053b      	lsls	r3, r7, #20
 80055d0:	d53f      	bpl.n	8005652 <usb_lld_serve_interrupt+0xa2>
 80055d2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80055d4:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
 80055d6:	f8d3 c008 	ldr.w	ip, [r3, #8]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80055da:	2100      	movs	r1, #0

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80055dc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80055e0:	e00c      	b.n	80055fc <usb_lld_serve_interrupt+0x4c>

    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
    }

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 80055e2:	f8d2 eb00 	ldr.w	lr, [r2, #2816]	; 0xb00
 80055e6:	f1be 0f00 	cmp.w	lr, #0
 80055ea:	db19      	blt.n	8005620 <usb_lld_serve_interrupt+0x70>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80055ec:	4403      	add	r3, r0

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80055ee:	3101      	adds	r1, #1
 80055f0:	458c      	cmp	ip, r1

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80055f2:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80055f6:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80055fa:	d318      	bcc.n	800562e <usb_lld_serve_interrupt+0x7e>
 80055fc:	014b      	lsls	r3, r1, #5
 80055fe:	18c2      	adds	r2, r0, r3

    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8005600:	f8d2 e900 	ldr.w	lr, [r2, #2304]	; 0x900
 8005604:	f1be 0f00 	cmp.w	lr, #0
 8005608:	daeb      	bge.n	80055e2 <usb_lld_serve_interrupt+0x32>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 800560a:	f8d2 e900 	ldr.w	lr, [r2, #2304]	; 0x900
 800560e:	f04e 4e80 	orr.w	lr, lr, #1073741824	; 0x40000000
 8005612:	f8c2 e900 	str.w	lr, [r2, #2304]	; 0x900
    }

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8005616:	f8d2 eb00 	ldr.w	lr, [r2, #2816]	; 0xb00
 800561a:	f1be 0f00 	cmp.w	lr, #0
 800561e:	dae5      	bge.n	80055ec <usb_lld_serve_interrupt+0x3c>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8005620:	f8d2 eb00 	ldr.w	lr, [r2, #2816]	; 0xb00
 8005624:	f04e 4e80 	orr.w	lr, lr, #1073741824	; 0x40000000
 8005628:	f8c2 eb00 	str.w	lr, [r2, #2816]	; 0xb00
 800562c:	e7de      	b.n	80055ec <usb_lld_serve_interrupt+0x3c>
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800562e:	686b      	ldr	r3, [r5, #4]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8005630:	7829      	ldrb	r1, [r5, #0]
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8005632:	681b      	ldr	r3, [r3, #0]
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8005634:	f04f 1401 	mov.w	r4, #65537	; 0x10001
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;
 8005638:	2205      	movs	r2, #5
 800563a:	f8c0 481c 	str.w	r4, [r0, #2076]	; 0x81c
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 800563e:	f885 1068 	strb.w	r1, [r5, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 8005642:	702a      	strb	r2, [r5, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8005644:	b113      	cbz	r3, 800564c <usb_lld_serve_interrupt+0x9c>
 8005646:	4628      	mov	r0, r5
 8005648:	2104      	movs	r1, #4
 800564a:	4798      	blx	r3

  /* Terminating all pending transactions.*/
  usbp->transmitting  = 0;
 800564c:	2300      	movs	r3, #0
 800564e:	812b      	strh	r3, [r5, #8]
  usbp->receiving     = 0;
 8005650:	816b      	strh	r3, [r5, #10]
    /* Default suspend action.*/
    _usb_suspend(usbp);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8005652:	04bc      	lsls	r4, r7, #18
 8005654:	d50c      	bpl.n	8005670 <usb_lld_serve_interrupt+0xc0>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8005656:	f8d6 3808 	ldr.w	r3, [r6, #2056]	; 0x808
 800565a:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800565e:	68f3      	ldr	r3, [r6, #12]
 8005660:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8005664:	bf0c      	ite	eq
 8005666:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 800566a:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 800566e:	60f3      	str	r3, [r6, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8005670:	0738      	lsls	r0, r7, #28
 8005672:	d432      	bmi.n	80056da <usb_lld_serve_interrupt+0x12a>
    _usb_isr_invoke_sof_cb(usbp);
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8005674:	02fa      	lsls	r2, r7, #11
 8005676:	d438      	bmi.n	80056ea <usb_lld_serve_interrupt+0x13a>
    otg_isoc_in_failed_handler(usbp);
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8005678:	02bb      	lsls	r3, r7, #10
 800567a:	f100 80a8 	bmi.w	80057ce <usb_lld_serve_interrupt+0x21e>
    otg_isoc_out_failed_handler(usbp);
  }

  /* Performing the whole FIFO emptying in the ISR, it is advised to keep
     this IRQ at a very low priority level.*/
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 800567e:	06fb      	lsls	r3, r7, #27
 8005680:	d479      	bmi.n	8005776 <usb_lld_serve_interrupt+0x1c6>
    otg_rxfifo_handler(usbp);
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8005682:	f8d6 4818 	ldr.w	r4, [r6, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8005686:	033e      	lsls	r6, r7, #12
 8005688:	d511      	bpl.n	80056ae <usb_lld_serve_interrupt+0xfe>
    if (src & (1 << 16))
 800568a:	03e0      	lsls	r0, r4, #15
 800568c:	f100 81b5 	bmi.w	80059fa <usb_lld_serve_interrupt+0x44a>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 8005690:	03a1      	lsls	r1, r4, #14
 8005692:	f100 81b9 	bmi.w	8005a08 <usb_lld_serve_interrupt+0x458>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 8005696:	0362      	lsls	r2, r4, #13
 8005698:	f100 81bd 	bmi.w	8005a16 <usb_lld_serve_interrupt+0x466>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 800569c:	0323      	lsls	r3, r4, #12
 800569e:	f100 81c1 	bmi.w	8005a24 <usb_lld_serve_interrupt+0x474>
      otg_epout_handler(usbp, 3);
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 20))
 80056a2:	02e6      	lsls	r6, r4, #11
 80056a4:	f100 81c5 	bmi.w	8005a32 <usb_lld_serve_interrupt+0x482>
      otg_epout_handler(usbp, 4);
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 21))
 80056a8:	02a0      	lsls	r0, r4, #10
 80056aa:	f100 815b 	bmi.w	8005964 <usb_lld_serve_interrupt+0x3b4>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 80056ae:	0379      	lsls	r1, r7, #13
 80056b0:	d511      	bpl.n	80056d6 <usb_lld_serve_interrupt+0x126>
    if (src & (1 << 0))
 80056b2:	07e2      	lsls	r2, r4, #31
 80056b4:	f100 819c 	bmi.w	80059f0 <usb_lld_serve_interrupt+0x440>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 80056b8:	07a3      	lsls	r3, r4, #30
 80056ba:	f100 8194 	bmi.w	80059e6 <usb_lld_serve_interrupt+0x436>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 80056be:	0767      	lsls	r7, r4, #29
 80056c0:	f100 817e 	bmi.w	80059c0 <usb_lld_serve_interrupt+0x410>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 80056c4:	0726      	lsls	r6, r4, #28
 80056c6:	f100 8182 	bmi.w	80059ce <usb_lld_serve_interrupt+0x41e>
      otg_epin_handler(usbp, 3);
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 4))
 80056ca:	06e0      	lsls	r0, r4, #27
 80056cc:	f100 8186 	bmi.w	80059dc <usb_lld_serve_interrupt+0x42c>
      otg_epin_handler(usbp, 4);
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 5))
 80056d0:	06a1      	lsls	r1, r4, #26
 80056d2:	f100 8141 	bmi.w	8005958 <usb_lld_serve_interrupt+0x3a8>
 80056d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
    _usb_isr_invoke_sof_cb(usbp);
 80056da:	686b      	ldr	r3, [r5, #4]
 80056dc:	68db      	ldr	r3, [r3, #12]
 80056de:	2b00      	cmp	r3, #0
 80056e0:	d0c8      	beq.n	8005674 <usb_lld_serve_interrupt+0xc4>
 80056e2:	4628      	mov	r0, r5
 80056e4:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 80056e6:	02fa      	lsls	r2, r7, #11
 80056e8:	d5c6      	bpl.n	8005678 <usb_lld_serve_interrupt+0xc8>
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 80056ea:	f8d5 a06c 	ldr.w	sl, [r5, #108]	; 0x6c
 80056ee:	2400      	movs	r4, #0

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 80056f0:	f04f 0901 	mov.w	r9, #1
 80056f4:	e006      	b.n	8005704 <usb_lld_serve_interrupt+0x154>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80056f6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80056f8:	3401      	adds	r4, #1
 80056fa:	689b      	ldr	r3, [r3, #8]
 80056fc:	b2e4      	uxtb	r4, r4
 80056fe:	429c      	cmp	r4, r3
 8005700:	46a0      	mov	r8, r4
 8005702:	d8b9      	bhi.n	8005678 <usb_lld_serve_interrupt+0xc8>
 8005704:	eb0a 1244 	add.w	r2, sl, r4, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8005708:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 800570c:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8005710:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8005714:	d1ef      	bne.n	80056f6 <usb_lld_serve_interrupt+0x146>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8005716:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800571a:	2b00      	cmp	r3, #0
 800571c:	daeb      	bge.n	80056f6 <usb_lld_serve_interrupt+0x146>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 800571e:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8005722:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 8005726:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 800572a:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 800572e:	2b00      	cmp	r3, #0
 8005730:	dbfb      	blt.n	800572a <usb_lld_serve_interrupt+0x17a>
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8005732:	ea4f 1888 	mov.w	r8, r8, lsl #6
 8005736:	6eea      	ldr	r2, [r5, #108]	; 0x6c
 8005738:	f048 0320 	orr.w	r3, r8, #32
 800573c:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800573e:	6913      	ldr	r3, [r2, #16]
 8005740:	0699      	lsls	r1, r3, #26
 8005742:	d4fc      	bmi.n	800573e <usb_lld_serve_interrupt+0x18e>
 8005744:	2012      	movs	r0, #18
 8005746:	f7ff fb0b 	bl	8004d60 <chSysPolledDelayX>

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 800574a:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 800574e:	892a      	ldrh	r2, [r5, #8]
 8005750:	68d9      	ldr	r1, [r3, #12]
 8005752:	fa09 f304 	lsl.w	r3, r9, r4
 8005756:	f8d1 c008 	ldr.w	ip, [r1, #8]
 800575a:	ea22 0303 	bic.w	r3, r2, r3
 800575e:	812b      	strh	r3, [r5, #8]
 8005760:	f1bc 0f00 	cmp.w	ip, #0
 8005764:	d002      	beq.n	800576c <usb_lld_serve_interrupt+0x1bc>
 8005766:	4628      	mov	r0, r5
 8005768:	4621      	mov	r1, r4
 800576a:	47e0      	blx	ip

      /* TX FIFO empty or emptying.*/
      otg_txfifo_handler(usbp, ep);
 800576c:	4628      	mov	r0, r5
 800576e:	4621      	mov	r1, r4
 8005770:	f7ff fb8e 	bl	8004e90 <otg_txfifo_handler>
 8005774:	e7bf      	b.n	80056f6 <usb_lld_serve_interrupt+0x146>
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
  uint32_t sts, cnt, ep;

  /* Popping the event word out of the RX FIFO.*/
  sts = usbp->otg->GRXSTSP;
 8005776:	f8d5 e06c 	ldr.w	lr, [r5, #108]	; 0x6c
 800577a:	f8de 3020 	ldr.w	r3, [lr, #32]

  /* Event details.*/
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;

  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800577e:	f403 11f0 	and.w	r1, r3, #1966080	; 0x1e0000
 8005782:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000

  /* Popping the event word out of the RX FIFO.*/
  sts = usbp->otg->GRXSTSP;

  /* Event details.*/
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8005786:	f3c3 120a 	ubfx	r2, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800578a:	f003 030f 	and.w	r3, r3, #15

  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800578e:	f000 80f1 	beq.w	8005974 <usb_lld_serve_interrupt+0x3c4>
 8005792:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 8005796:	f47f af74 	bne.w	8005682 <usb_lld_serve_interrupt+0xd2>
  case GRXSTSP_SETUP_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800579a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800579e:	68db      	ldr	r3, [r3, #12]
 80057a0:	6a18      	ldr	r0, [r3, #32]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80057a2:	2a00      	cmp	r2, #0
 80057a4:	f43f af6d 	beq.w	8005682 <usb_lld_serve_interrupt+0xd2>
 80057a8:	2100      	movs	r1, #0
    if ((i & 3) == 0) {
      w = *fifop;
 80057aa:	f50e 5e80 	add.w	lr, lr, #4096	; 0x1000
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80057ae:	460b      	mov	r3, r1
 80057b0:	e003      	b.n	80057ba <usb_lld_serve_interrupt+0x20a>
    }
    if (i < max) {
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
 80057b2:	3301      	adds	r3, #1
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80057b4:	4293      	cmp	r3, r2
 80057b6:	f43f af64 	beq.w	8005682 <usb_lld_serve_interrupt+0xd2>
    if ((i & 3) == 0) {
 80057ba:	079c      	lsls	r4, r3, #30
      w = *fifop;
 80057bc:	bf08      	it	eq
 80057be:	f8de 1000 	ldreq.w	r1, [lr]
    }
    if (i < max) {
 80057c2:	2b07      	cmp	r3, #7
 80057c4:	d8f5      	bhi.n	80057b2 <usb_lld_serve_interrupt+0x202>
      *buf++ = (uint8_t)w;
 80057c6:	7001      	strb	r1, [r0, #0]
      w >>= 8;
 80057c8:	0a09      	lsrs	r1, r1, #8
  while (i < n) {
    if ((i & 3) == 0) {
      w = *fifop;
    }
    if (i < max) {
      *buf++ = (uint8_t)w;
 80057ca:	3001      	adds	r0, #1
 80057cc:	e7f1      	b.n	80057b2 <usb_lld_serve_interrupt+0x202>
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 80057ce:	f8d5 806c 	ldr.w	r8, [r5, #108]	; 0x6c
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 80057d2:	2400      	movs	r4, #0
      /* CHTODO:: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 80057d4:	f04f 0901 	mov.w	r9, #1
 80057d8:	e006      	b.n	80057e8 <usb_lld_serve_interrupt+0x238>
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80057da:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80057dc:	3401      	adds	r4, #1
 80057de:	689b      	ldr	r3, [r3, #8]
 80057e0:	b2e4      	uxtb	r4, r4
 80057e2:	429c      	cmp	r4, r3
 80057e4:	f63f af4b 	bhi.w	800567e <usb_lld_serve_interrupt+0xce>
 80057e8:	eb08 1244 	add.w	r2, r8, r4, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 80057ec:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80057f0:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 80057f4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80057f8:	d1ef      	bne.n	80057da <usb_lld_serve_interrupt+0x22a>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 80057fa:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 80057fe:	2b00      	cmp	r3, #0
 8005800:	daeb      	bge.n	80057da <usb_lld_serve_interrupt+0x22a>
      /* CHTODO:: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8005802:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8005806:	896a      	ldrh	r2, [r5, #10]
 8005808:	68d9      	ldr	r1, [r3, #12]
 800580a:	fa09 f304 	lsl.w	r3, r9, r4
 800580e:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 8005812:	ea22 0303 	bic.w	r3, r2, r3
 8005816:	816b      	strh	r3, [r5, #10]
 8005818:	f1bc 0f00 	cmp.w	ip, #0
 800581c:	d0dd      	beq.n	80057da <usb_lld_serve_interrupt+0x22a>
 800581e:	4628      	mov	r0, r5
 8005820:	4621      	mov	r1, r4
 8005822:	47e0      	blx	ip
 8005824:	e7d9      	b.n	80057da <usb_lld_serve_interrupt+0x22a>

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8005826:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 800582a:	079a      	lsls	r2, r3, #30
 800582c:	d005      	beq.n	800583a <usb_lld_serve_interrupt+0x28a>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800582e:	f8d6 3e00 	ldr.w	r3, [r6, #3584]	; 0xe00
 8005832:	f023 0303 	bic.w	r3, r3, #3
 8005836:	f8c6 3e00 	str.w	r3, [r6, #3584]	; 0xe00

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800583a:	686a      	ldr	r2, [r5, #4]
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL &= ~DCTL_RWUSIG;
 800583c:	f8d6 3804 	ldr.w	r3, [r6, #2052]	; 0x804
 8005840:	6812      	ldr	r2, [r2, #0]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8005842:	f895 1068 	ldrb.w	r1, [r5, #104]	; 0x68
 8005846:	f023 0301 	bic.w	r3, r3, #1
 800584a:	f8c6 3804 	str.w	r3, [r6, #2052]	; 0x804
 800584e:	7029      	strb	r1, [r5, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8005850:	2a00      	cmp	r2, #0
 8005852:	f43f aebc 	beq.w	80055ce <usb_lld_serve_interrupt+0x1e>
 8005856:	4628      	mov	r0, r5
 8005858:	2105      	movs	r1, #5
 800585a:	4790      	blx	r2
 800585c:	e6b7      	b.n	80055ce <usb_lld_serve_interrupt+0x1e>

  /* State transition.*/
  usbp->state         = USB_READY;

  /* Resetting internal state.*/
  usbp->status        = 0;
 800585e:	2300      	movs	r3, #0
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8005860:	2102      	movs	r1, #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8005862:	2220      	movs	r2, #32
 8005864:	7001      	strb	r1, [r0, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8005866:	f8a0 3064 	strh.w	r3, [r0, #100]	; 0x64
  usbp->address       = 0;
 800586a:	f880 3066 	strb.w	r3, [r0, #102]	; 0x66
  usbp->configuration = 0;
 800586e:	f880 3067 	strb.w	r3, [r0, #103]	; 0x67
  usbp->transmitting  = 0;
 8005872:	8103      	strh	r3, [r0, #8]
  usbp->receiving     = 0;
 8005874:	8143      	strh	r3, [r0, #10]
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8005876:	60c3      	str	r3, [r0, #12]
 8005878:	6103      	str	r3, [r0, #16]
 800587a:	6143      	str	r3, [r0, #20]
 800587c:	6183      	str	r3, [r0, #24]
 800587e:	61c3      	str	r3, [r0, #28]
 8005880:	6203      	str	r3, [r0, #32]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_STP_WAITING;
 8005882:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
 8005886:	6132      	str	r2, [r6, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8005888:	6933      	ldr	r3, [r6, #16]
 800588a:	f013 0420 	ands.w	r4, r3, #32
 800588e:	d1fb      	bne.n	8005888 <usb_lld_serve_interrupt+0x2d8>
 8005890:	2012      	movs	r0, #18
 8005892:	f7ff fa65 	bl	8004d60 <chSysPolledDelayX>
 8005896:	f8d5 e070 	ldr.w	lr, [r5, #112]	; 0x70

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 800589a:	f8c6 4834 	str.w	r4, [r6, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800589e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80058a2:	f8de 7008 	ldr.w	r7, [lr, #8]
 80058a6:	f8c6 281c 	str.w	r2, [r6, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80058aa:	4623      	mov	r3, r4
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80058ac:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80058b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80058b4:	eb06 1243 	add.w	r2, r6, r3, lsl #5
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80058b8:	3301      	adds	r3, #1
 80058ba:	42bb      	cmp	r3, r7
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80058bc:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 80058c0:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80058c4:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80058c8:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80058cc:	d9f2      	bls.n	80058b4 <usb_lld_serve_interrupt+0x304>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80058ce:	f8de 3000 	ldr.w	r3, [lr]
 80058d2:	676b      	str	r3, [r5, #116]	; 0x74

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80058d4:	f8de 2000 	ldr.w	r2, [lr]
 80058d8:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 80058da:	6272      	str	r2, [r6, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80058dc:	2210      	movs	r2, #16
 80058de:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80058e0:	6919      	ldr	r1, [r3, #16]
 80058e2:	f011 0410 	ands.w	r4, r1, #16
 80058e6:	d1fb      	bne.n	80058e0 <usb_lld_serve_interrupt+0x330>
 80058e8:	2012      	movs	r0, #18
 80058ea:	f7ff fa39 	bl	8004d60 <chSysPolledDelayX>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80058ee:	f8d6 3800 	ldr.w	r3, [r6, #2048]	; 0x800
 80058f2:	6f28      	ldr	r0, [r5, #112]	; 0x70
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80058f4:	4a54      	ldr	r2, [pc, #336]	; (8005a48 <usb_lld_serve_interrupt+0x498>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 80058f6:	f8df e158 	ldr.w	lr, [pc, #344]	; 8005a50 <usb_lld_serve_interrupt+0x4a0>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80058fa:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80058fe:	f8c6 3800 	str.w	r3, [r6, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8005902:	69b3      	ldr	r3, [r6, #24]
 8005904:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8005908:	2109      	movs	r1, #9

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 800590a:	f043 0310 	orr.w	r3, r3, #16
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 800590e:	f04f 47c0 	mov.w	r7, #1610612736	; 0x60000000

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8005912:	61b3      	str	r3, [r6, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8005914:	f8c6 1810 	str.w	r1, [r6, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8005918:	f8c6 1814 	str.w	r1, [r6, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 800591c:	f8c5 e00c 	str.w	lr, [r5, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8005920:	f8c6 7b10 	str.w	r7, [r6, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8005924:	f8c6 2b00 	str.w	r2, [r6, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8005928:	f8c6 4910 	str.w	r4, [r6, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800592c:	f8c6 2900 	str.w	r2, [r6, #2304]	; 0x900
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8005930:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  usbp->pmnext += size;
 8005932:	f103 0210 	add.w	r2, r3, #16
 8005936:	676a      	str	r2, [r5, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8005938:	6841      	ldr	r1, [r0, #4]
 800593a:	428a      	cmp	r2, r1
 800593c:	d87e      	bhi.n	8005a3c <usb_lld_serve_interrupt+0x48c>

  /* Low level reset.*/
  usb_lld_reset(usbp);

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 800593e:	686a      	ldr	r2, [r5, #4]
 8005940:	6812      	ldr	r2, [r2, #0]
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8005942:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8005946:	62b3      	str	r3, [r6, #40]	; 0x28
 8005948:	2a00      	cmp	r2, #0
 800594a:	f43f aec4 	beq.w	80056d6 <usb_lld_serve_interrupt+0x126>
 800594e:	4628      	mov	r0, r5
 8005950:	4621      	mov	r1, r4
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 8))
      otg_epin_handler(usbp, 8);
#endif
  }
}
 8005952:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005956:	4710      	bx	r2
    if (src & (1 << 4))
      otg_epin_handler(usbp, 4);
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
 8005958:	4628      	mov	r0, r5
 800595a:	2105      	movs	r1, #5
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 8))
      otg_epin_handler(usbp, 8);
#endif
  }
}
 800595c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (src & (1 << 4))
      otg_epin_handler(usbp, 4);
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
 8005960:	f7ff bd3e 	b.w	80053e0 <otg_epin_handler>
    if (src & (1 << 20))
      otg_epout_handler(usbp, 4);
#endif
#if USB_MAX_ENDPOINTS >= 5
    if (src & (1 << 21))
      otg_epout_handler(usbp, 5);
 8005964:	2105      	movs	r1, #5
 8005966:	4628      	mov	r0, r5
 8005968:	f7ff fdd2 	bl	8005510 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 800596c:	0379      	lsls	r1, r7, #13
 800596e:	f57f aeb2 	bpl.w	80056d6 <usb_lld_serve_interrupt+0x126>
 8005972:	e69e      	b.n	80056b2 <usb_lld_serve_interrupt+0x102>
 8005974:	eb05 0483 	add.w	r4, r5, r3, lsl #2
    break;
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_OUT_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                            usbp->epc[ep]->out_state->rxbuf,
 8005978:	68e3      	ldr	r3, [r4, #12]
 800597a:	6999      	ldr	r1, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_OUT_DATA:
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800597c:	e891 0108 	ldmia.w	r1, {r3, r8}
 8005980:	6888      	ldr	r0, [r1, #8]
 8005982:	ebc8 0c03 	rsb	ip, r8, r3
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8005986:	2a00      	cmp	r2, #0
 8005988:	d05b      	beq.n	8005a42 <usb_lld_serve_interrupt+0x492>
 800598a:	2100      	movs	r1, #0
    if ((i & 3) == 0) {
      w = *fifop;
 800598c:	f50e 5e80 	add.w	lr, lr, #4096	; 0x1000
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8005990:	460b      	mov	r3, r1
    if ((i & 3) == 0) {
 8005992:	f013 0f03 	tst.w	r3, #3
      w = *fifop;
 8005996:	bf08      	it	eq
 8005998:	f8de 1000 	ldreq.w	r1, [lr]
    }
    if (i < max) {
 800599c:	459c      	cmp	ip, r3
 800599e:	d902      	bls.n	80059a6 <usb_lld_serve_interrupt+0x3f6>
      *buf++ = (uint8_t)w;
 80059a0:	7001      	strb	r1, [r0, #0]
      w >>= 8;
 80059a2:	0a09      	lsrs	r1, r1, #8
  while (i < n) {
    if ((i & 3) == 0) {
      w = *fifop;
    }
    if (i < max) {
      *buf++ = (uint8_t)w;
 80059a4:	3001      	adds	r0, #1
      w >>= 8;
    }
    i++;
 80059a6:	3301      	adds	r3, #1
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80059a8:	4293      	cmp	r3, r2
 80059aa:	d1f2      	bne.n	8005992 <usb_lld_serve_interrupt+0x3e2>
 80059ac:	68e3      	ldr	r3, [r4, #12]
 80059ae:	6999      	ldr	r1, [r3, #24]
 80059b0:	688b      	ldr	r3, [r1, #8]
 80059b2:	f8d1 8004 	ldr.w	r8, [r1, #4]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 80059b6:	4413      	add	r3, r2
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80059b8:	4442      	add	r2, r8
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 80059ba:	608b      	str	r3, [r1, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80059bc:	604a      	str	r2, [r1, #4]
 80059be:	e660      	b.n	8005682 <usb_lld_serve_interrupt+0xd2>
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
      otg_epin_handler(usbp, 2);
 80059c0:	4628      	mov	r0, r5
 80059c2:	2102      	movs	r1, #2
 80059c4:	f7ff fd0c 	bl	80053e0 <otg_epin_handler>
    if (src & (1 << 3))
 80059c8:	0726      	lsls	r6, r4, #28
 80059ca:	f57f ae7e 	bpl.w	80056ca <usb_lld_serve_interrupt+0x11a>
      otg_epin_handler(usbp, 3);
 80059ce:	4628      	mov	r0, r5
 80059d0:	2103      	movs	r1, #3
 80059d2:	f7ff fd05 	bl	80053e0 <otg_epin_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 4))
 80059d6:	06e0      	lsls	r0, r4, #27
 80059d8:	f57f ae7a 	bpl.w	80056d0 <usb_lld_serve_interrupt+0x120>
      otg_epin_handler(usbp, 4);
 80059dc:	4628      	mov	r0, r5
 80059de:	2104      	movs	r1, #4
 80059e0:	f7ff fcfe 	bl	80053e0 <otg_epin_handler>
 80059e4:	e674      	b.n	80056d0 <usb_lld_serve_interrupt+0x120>
  }
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
      otg_epin_handler(usbp, 1);
 80059e6:	4628      	mov	r0, r5
 80059e8:	2101      	movs	r1, #1
 80059ea:	f7ff fcf9 	bl	80053e0 <otg_epin_handler>
 80059ee:	e666      	b.n	80056be <usb_lld_serve_interrupt+0x10e>
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 80059f0:	4628      	mov	r0, r5
 80059f2:	2100      	movs	r1, #0
 80059f4:	f7ff fcf4 	bl	80053e0 <otg_epin_handler>
 80059f8:	e65e      	b.n	80056b8 <usb_lld_serve_interrupt+0x108>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 80059fa:	2100      	movs	r1, #0
 80059fc:	4628      	mov	r0, r5
 80059fe:	f7ff fd87 	bl	8005510 <otg_epout_handler>
    if (src & (1 << 17))
 8005a02:	03a1      	lsls	r1, r4, #14
 8005a04:	f57f ae47 	bpl.w	8005696 <usb_lld_serve_interrupt+0xe6>
      otg_epout_handler(usbp, 1);
 8005a08:	4628      	mov	r0, r5
 8005a0a:	2101      	movs	r1, #1
 8005a0c:	f7ff fd80 	bl	8005510 <otg_epout_handler>
    if (src & (1 << 18))
 8005a10:	0362      	lsls	r2, r4, #13
 8005a12:	f57f ae43 	bpl.w	800569c <usb_lld_serve_interrupt+0xec>
      otg_epout_handler(usbp, 2);
 8005a16:	4628      	mov	r0, r5
 8005a18:	2102      	movs	r1, #2
 8005a1a:	f7ff fd79 	bl	8005510 <otg_epout_handler>
    if (src & (1 << 19))
 8005a1e:	0323      	lsls	r3, r4, #12
 8005a20:	f57f ae3f 	bpl.w	80056a2 <usb_lld_serve_interrupt+0xf2>
      otg_epout_handler(usbp, 3);
 8005a24:	4628      	mov	r0, r5
 8005a26:	2103      	movs	r1, #3
 8005a28:	f7ff fd72 	bl	8005510 <otg_epout_handler>
#if USB_MAX_ENDPOINTS >= 4
    if (src & (1 << 20))
 8005a2c:	02e6      	lsls	r6, r4, #11
 8005a2e:	f57f ae3b 	bpl.w	80056a8 <usb_lld_serve_interrupt+0xf8>
      otg_epout_handler(usbp, 4);
 8005a32:	4628      	mov	r0, r5
 8005a34:	2104      	movs	r1, #4
 8005a36:	f7ff fd6b 	bl	8005510 <otg_epout_handler>
 8005a3a:	e635      	b.n	80056a8 <usb_lld_serve_interrupt+0xf8>
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8005a3c:	4803      	ldr	r0, [pc, #12]	; (8005a4c <usb_lld_serve_interrupt+0x49c>)
 8005a3e:	f7ff f99f 	bl	8004d80 <chSysHalt>
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8005a42:	4603      	mov	r3, r0
 8005a44:	e7b7      	b.n	80059b6 <usb_lld_serve_interrupt+0x406>
 8005a46:	bf00      	nop
 8005a48:	10008040 	.word	0x10008040
 8005a4c:	0800cee8 	.word	0x0800cee8
 8005a50:	0800cec4 	.word	0x0800cec4
	...

08005a60 <Vector174>:
/**
 * @brief   OTG2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8005a60:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8005a62:	4c09      	ldr	r4, [pc, #36]	; (8005a88 <Vector174+0x28>)
 8005a64:	4620      	mov	r0, r4
 8005a66:	f7fc fbfb 	bl	8002260 <_trace_isr_enter>
 8005a6a:	f7ff f9a9 	bl	8004dc0 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD2);
 8005a6e:	4807      	ldr	r0, [pc, #28]	; (8005a8c <Vector174+0x2c>)
 8005a70:	f7ff fd9e 	bl	80055b0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8005a74:	f7fc febc 	bl	80027f0 <_dbg_check_leave_isr>
 8005a78:	4620      	mov	r0, r4
 8005a7a:	f7fc fbd1 	bl	8002220 <_trace_isr_leave>
}
 8005a7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD2);

  OSAL_IRQ_EPILOGUE();
 8005a82:	f7fc bb3d 	b.w	8002100 <_port_irq_epilogue>
 8005a86:	bf00      	nop
 8005a88:	0800cf04 	.word	0x0800cf04
 8005a8c:	2000a444 	.word	0x2000a444

08005a90 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8005a90:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8005a92:	4c09      	ldr	r4, [pc, #36]	; (8005ab8 <Vector14C+0x28>)
 8005a94:	4620      	mov	r0, r4
 8005a96:	f7fc fbe3 	bl	8002260 <_trace_isr_enter>
 8005a9a:	f7ff f991 	bl	8004dc0 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD1);
 8005a9e:	4807      	ldr	r0, [pc, #28]	; (8005abc <Vector14C+0x2c>)
 8005aa0:	f7ff fd86 	bl	80055b0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8005aa4:	f7fc fea4 	bl	80027f0 <_dbg_check_leave_isr>
 8005aa8:	4620      	mov	r0, r4
 8005aaa:	f7fc fbb9 	bl	8002220 <_trace_isr_leave>
}
 8005aae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 8005ab2:	f7fc bb25 	b.w	8002100 <_port_irq_epilogue>
 8005ab6:	bf00      	nop
 8005ab8:	0800ce78 	.word	0x0800ce78
 8005abc:	2000a3cc 	.word	0x2000a3cc

08005ac0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8005ac0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005ac2:	480d      	ldr	r0, [pc, #52]	; (8005af8 <Vector158+0x38>)
 8005ac4:	f7fc fbcc 	bl	8002260 <_trace_isr_enter>
 8005ac8:	f7ff f97a 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8005acc:	4b0b      	ldr	r3, [pc, #44]	; (8005afc <Vector158+0x3c>)
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
 8005ace:	480c      	ldr	r0, [pc, #48]	; (8005b00 <Vector158+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8005ad0:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
 8005ad2:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8005ad4:	0d89      	lsrs	r1, r1, #22
 8005ad6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 8005ada:	058c      	lsls	r4, r1, #22
 8005adc:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
 8005ade:	b112      	cbz	r2, 8005ae6 <Vector158+0x26>
    dma.streams[15].func(dma.streams[15].param, flags);
 8005ae0:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8005ae4:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8005ae6:	f7fc fe83 	bl	80027f0 <_dbg_check_leave_isr>
 8005aea:	4803      	ldr	r0, [pc, #12]	; (8005af8 <Vector158+0x38>)
 8005aec:	f7fc fb98 	bl	8002220 <_trace_isr_leave>
}
 8005af0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
    dma.streams[15].func(dma.streams[15].param, flags);

  OSAL_IRQ_EPILOGUE();
 8005af4:	f7fc bb04 	b.w	8002100 <_port_irq_epilogue>
 8005af8:	0800ce2c 	.word	0x0800ce2c
 8005afc:	40026400 	.word	0x40026400
 8005b00:	2000a4d8 	.word	0x2000a4d8
	...

08005b10 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8005b10:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005b12:	480d      	ldr	r0, [pc, #52]	; (8005b48 <Vector154+0x38>)
 8005b14:	f7fc fba4 	bl	8002260 <_trace_isr_enter>
 8005b18:	f7ff f952 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8005b1c:	4b0b      	ldr	r3, [pc, #44]	; (8005b4c <Vector154+0x3c>)
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
 8005b1e:	480c      	ldr	r0, [pc, #48]	; (8005b50 <Vector154+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8005b20:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
 8005b22:	6f42      	ldr	r2, [r0, #116]	; 0x74
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8005b24:	0c09      	lsrs	r1, r1, #16
 8005b26:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 8005b2a:	040c      	lsls	r4, r1, #16
 8005b2c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
 8005b2e:	b10a      	cbz	r2, 8005b34 <Vector154+0x24>
    dma.streams[14].func(dma.streams[14].param, flags);
 8005b30:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8005b32:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8005b34:	f7fc fe5c 	bl	80027f0 <_dbg_check_leave_isr>
 8005b38:	4803      	ldr	r0, [pc, #12]	; (8005b48 <Vector154+0x38>)
 8005b3a:	f7fc fb71 	bl	8002220 <_trace_isr_leave>
}
 8005b3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
    dma.streams[14].func(dma.streams[14].param, flags);

  OSAL_IRQ_EPILOGUE();
 8005b42:	f7fc badd 	b.w	8002100 <_port_irq_epilogue>
 8005b46:	bf00      	nop
 8005b48:	0800ce54 	.word	0x0800ce54
 8005b4c:	40026400 	.word	0x40026400
 8005b50:	2000a4d8 	.word	0x2000a4d8
	...

08005b60 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8005b60:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005b62:	480d      	ldr	r0, [pc, #52]	; (8005b98 <Vector150+0x38>)
 8005b64:	f7fc fb7c 	bl	8002260 <_trace_isr_enter>
 8005b68:	f7ff f92a 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8005b6c:	4b0b      	ldr	r3, [pc, #44]	; (8005b9c <Vector150+0x3c>)
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
 8005b6e:	480c      	ldr	r0, [pc, #48]	; (8005ba0 <Vector150+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8005b70:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
 8005b72:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8005b74:	0989      	lsrs	r1, r1, #6
 8005b76:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 8005b7a:	018c      	lsls	r4, r1, #6
 8005b7c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
 8005b7e:	b10a      	cbz	r2, 8005b84 <Vector150+0x24>
    dma.streams[13].func(dma.streams[13].param, flags);
 8005b80:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8005b82:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8005b84:	f7fc fe34 	bl	80027f0 <_dbg_check_leave_isr>
 8005b88:	4803      	ldr	r0, [pc, #12]	; (8005b98 <Vector150+0x38>)
 8005b8a:	f7fc fb49 	bl	8002220 <_trace_isr_leave>
}
 8005b8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
    dma.streams[13].func(dma.streams[13].param, flags);

  OSAL_IRQ_EPILOGUE();
 8005b92:	f7fc bab5 	b.w	8002100 <_port_irq_epilogue>
 8005b96:	bf00      	nop
 8005b98:	0800cf10 	.word	0x0800cf10
 8005b9c:	40026400 	.word	0x40026400
 8005ba0:	2000a4d8 	.word	0x2000a4d8
	...

08005bb0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8005bb0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005bb2:	480c      	ldr	r0, [pc, #48]	; (8005be4 <Vector130+0x34>)
 8005bb4:	f7fc fb54 	bl	8002260 <_trace_isr_enter>
 8005bb8:	f7ff f902 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8005bbc:	4b0a      	ldr	r3, [pc, #40]	; (8005be8 <Vector130+0x38>)
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
 8005bbe:	480b      	ldr	r0, [pc, #44]	; (8005bec <Vector130+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8005bc0:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
 8005bc2:	6e42      	ldr	r2, [r0, #100]	; 0x64
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8005bc4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8005bc8:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 8005bca:	b10a      	cbz	r2, 8005bd0 <Vector130+0x20>
    dma.streams[12].func(dma.streams[12].param, flags);
 8005bcc:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8005bce:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8005bd0:	f7fc fe0e 	bl	80027f0 <_dbg_check_leave_isr>
 8005bd4:	4803      	ldr	r0, [pc, #12]	; (8005be4 <Vector130+0x34>)
 8005bd6:	f7fc fb23 	bl	8002220 <_trace_isr_leave>
}
 8005bda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
    dma.streams[12].func(dma.streams[12].param, flags);

  OSAL_IRQ_EPILOGUE();
 8005bde:	f7fc ba8f 	b.w	8002100 <_port_irq_epilogue>
 8005be2:	bf00      	nop
 8005be4:	0800ce84 	.word	0x0800ce84
 8005be8:	40026400 	.word	0x40026400
 8005bec:	2000a4d8 	.word	0x2000a4d8

08005bf0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8005bf0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005bf2:	480d      	ldr	r0, [pc, #52]	; (8005c28 <Vector12C+0x38>)
 8005bf4:	f7fc fb34 	bl	8002260 <_trace_isr_enter>
 8005bf8:	f7ff f8e2 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8005bfc:	4b0b      	ldr	r3, [pc, #44]	; (8005c2c <Vector12C+0x3c>)
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
 8005bfe:	480c      	ldr	r0, [pc, #48]	; (8005c30 <Vector12C+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8005c00:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
 8005c02:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8005c04:	0d89      	lsrs	r1, r1, #22
 8005c06:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 8005c0a:	058c      	lsls	r4, r1, #22
 8005c0c:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
 8005c0e:	b10a      	cbz	r2, 8005c14 <Vector12C+0x24>
    dma.streams[11].func(dma.streams[11].param, flags);
 8005c10:	6e00      	ldr	r0, [r0, #96]	; 0x60
 8005c12:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8005c14:	f7fc fdec 	bl	80027f0 <_dbg_check_leave_isr>
 8005c18:	4803      	ldr	r0, [pc, #12]	; (8005c28 <Vector12C+0x38>)
 8005c1a:	f7fc fb01 	bl	8002220 <_trace_isr_leave>
}
 8005c1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
    dma.streams[11].func(dma.streams[11].param, flags);

  OSAL_IRQ_EPILOGUE();
 8005c22:	f7fc ba6d 	b.w	8002100 <_port_irq_epilogue>
 8005c26:	bf00      	nop
 8005c28:	0800ce6c 	.word	0x0800ce6c
 8005c2c:	40026400 	.word	0x40026400
 8005c30:	2000a4d8 	.word	0x2000a4d8
	...

08005c40 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8005c40:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8005c42:	480d      	ldr	r0, [pc, #52]	; (8005c78 <Vector128+0x38>)
 8005c44:	f7fc fb0c 	bl	8002260 <_trace_isr_enter>
 8005c48:	f7ff f8ba 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8005c4c:	4b0b      	ldr	r3, [pc, #44]	; (8005c7c <Vector128+0x3c>)
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
 8005c4e:	480c      	ldr	r0, [pc, #48]	; (8005c80 <Vector128+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8005c50:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
 8005c52:	6d42      	ldr	r2, [r0, #84]	; 0x54
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8005c54:	0c09      	lsrs	r1, r1, #16
 8005c56:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 8005c5a:	040c      	lsls	r4, r1, #16
 8005c5c:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
 8005c5e:	b10a      	cbz	r2, 8005c64 <Vector128+0x24>
    dma.streams[10].func(dma.streams[10].param, flags);
 8005c60:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8005c62:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8005c64:	f7fc fdc4 	bl	80027f0 <_dbg_check_leave_isr>
 8005c68:	4803      	ldr	r0, [pc, #12]	; (8005c78 <Vector128+0x38>)
 8005c6a:	f7fc fad9 	bl	8002220 <_trace_isr_leave>
}
 8005c6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
    dma.streams[10].func(dma.streams[10].param, flags);

  OSAL_IRQ_EPILOGUE();
 8005c72:	f7fc ba45 	b.w	8002100 <_port_irq_epilogue>
 8005c76:	bf00      	nop
 8005c78:	0800ce60 	.word	0x0800ce60
 8005c7c:	40026400 	.word	0x40026400
 8005c80:	2000a4d8 	.word	0x2000a4d8
	...

08005c90 <get_descriptor.lto_priv.81>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8005c90:	2902      	cmp	r1, #2
 8005c92:	d006      	beq.n	8005ca2 <get_descriptor.lto_priv.81+0x12>
 8005c94:	2903      	cmp	r1, #3
 8005c96:	d006      	beq.n	8005ca6 <get_descriptor.lto_priv.81+0x16>
 8005c98:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 8005c9a:	4806      	ldr	r0, [pc, #24]	; (8005cb4 <get_descriptor.lto_priv.81+0x24>)
 8005c9c:	bf18      	it	ne
 8005c9e:	2000      	movne	r0, #0
 8005ca0:	4770      	bx	lr
  (void)lang;
  switch (dtype) {
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8005ca2:	4805      	ldr	r0, [pc, #20]	; (8005cb8 <get_descriptor.lto_priv.81+0x28>)
 8005ca4:	4770      	bx	lr
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8005ca6:	2a03      	cmp	r2, #3
      return &vcom_strings[dindex];
 8005ca8:	bf9a      	itte	ls
 8005caa:	4b04      	ldrls	r3, [pc, #16]	; (8005cbc <get_descriptor.lto_priv.81+0x2c>)
 8005cac:	eb03 00c2 	addls.w	r0, r3, r2, lsl #3
  }
  return NULL;
 8005cb0:	2000      	movhi	r0, #0
}
 8005cb2:	4770      	bx	lr
 8005cb4:	0800d014 	.word	0x0800d014
 8005cb8:	0800d03c 	.word	0x0800d03c
 8005cbc:	0800cfd8 	.word	0x0800cfd8

08005cc0 <ll_dac_read.lto_priv.73>:

/* sets bit 0 in the first byte of data to the value of the dac.
    The rest of data is cleared. */ 
static uint32_t ll_dac_read(struct ll_driver_s *this, uint8_t *data, uint32_t data_size) {
  ll_dac_driver_t *dac_driver = (ll_dac_driver_t*)this->driver_info;
  uint32_t state = dac_driver->internal.state;
 8005cc0:	6803      	ldr	r3, [r0, #0]
 8005cc2:	68db      	ldr	r3, [r3, #12]

  if (data_size >= 1) {
 8005cc4:	b172      	cbz	r2, 8005ce4 <ll_dac_read.lto_priv.73+0x24>
    data[0] = state;
  } 
  if (data_size >= 2) {
 8005cc6:	2a01      	cmp	r2, #1
static uint32_t ll_dac_read(struct ll_driver_s *this, uint8_t *data, uint32_t data_size) {
  ll_dac_driver_t *dac_driver = (ll_dac_driver_t*)this->driver_info;
  uint32_t state = dac_driver->internal.state;

  if (data_size >= 1) {
    data[0] = state;
 8005cc8:	700b      	strb	r3, [r1, #0]
  } 
  if (data_size >= 2) {
 8005cca:	d90b      	bls.n	8005ce4 <ll_dac_read.lto_priv.73+0x24>
    data[1] = state >>= 8;
 8005ccc:	0a18      	lsrs	r0, r3, #8
  }
  if (data_size >= 3) {
 8005cce:	2a02      	cmp	r2, #2

  if (data_size >= 1) {
    data[0] = state;
  } 
  if (data_size >= 2) {
    data[1] = state >>= 8;
 8005cd0:	7048      	strb	r0, [r1, #1]
  }
  if (data_size >= 3) {
 8005cd2:	d007      	beq.n	8005ce4 <ll_dac_read.lto_priv.73+0x24>
    data[2] = state >>= 8;
  }
  if (data_size >= 4) {
 8005cd4:	2a03      	cmp	r2, #3
  } 
  if (data_size >= 2) {
    data[1] = state >>= 8;
  }
  if (data_size >= 3) {
    data[2] = state >>= 8;
 8005cd6:	ea4f 4013 	mov.w	r0, r3, lsr #16
  }
  if (data_size >= 4) {
    data[3] = state >>= 8;
 8005cda:	bf18      	it	ne
 8005cdc:	0e1b      	lsrne	r3, r3, #24
  } 
  if (data_size >= 2) {
    data[1] = state >>= 8;
  }
  if (data_size >= 3) {
    data[2] = state >>= 8;
 8005cde:	7088      	strb	r0, [r1, #2]
  }
  if (data_size >= 4) {
    data[3] = state >>= 8;
 8005ce0:	bf18      	it	ne
 8005ce2:	70cb      	strbne	r3, [r1, #3]
  }

  return data_size;
}
 8005ce4:	4610      	mov	r0, r2
 8005ce6:	4770      	bx	lr
	...

08005cf0 <ll_dac_data_writeable.lto_priv.76>:
}

static uint32_t ll_dac_data_writeable(struct ll_driver_s *this) {
  (void) this;
  return 1;
}
 8005cf0:	2001      	movs	r0, #1
 8005cf2:	4770      	bx	lr
	...

08005d00 <ll_dac_data_available.lto_priv.75>:
}

static uint32_t ll_dac_data_available(struct ll_driver_s *this) {
  (void) this;
  return 1;
}
 8005d00:	2001      	movs	r0, #1
 8005d02:	4770      	bx	lr
	...

08005d10 <ll_dac_control.lto_priv.72>:
static uint32_t ll_dac_control(struct ll_driver_s *this, uint8_t *data, uint32_t data_size) {
  (void) this;
  (void) data;
  (void) data_size;
  return 0;
}
 8005d10:	2000      	movs	r0, #0
 8005d12:	4770      	bx	lr
	...

08005d20 <print_it>:
/**********************************/
/* Debug printing function        */

char buf[2048];

void print_it(const char *str, va_list args) {
 8005d20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  memset(buf,0,2048);
 8005d22:	4c0b      	ldr	r4, [pc, #44]	; (8005d50 <print_it+0x30>)
 8005d24:	f44f 6500 	mov.w	r5, #2048	; 0x800
/**********************************/
/* Debug printing function        */

char buf[2048];

void print_it(const char *str, va_list args) {
 8005d28:	4607      	mov	r7, r0
 8005d2a:	460e      	mov	r6, r1

  memset(buf,0,2048);
 8005d2c:	462a      	mov	r2, r5
 8005d2e:	4620      	mov	r0, r4
 8005d30:	2100      	movs	r1, #0
 8005d32:	f002 ffd9 	bl	8008ce8 <memset>

  vsnprintf(buf, 2048, str, args);
 8005d36:	4629      	mov	r1, r5
 8005d38:	463a      	mov	r2, r7
 8005d3a:	4620      	mov	r0, r4
 8005d3c:	4633      	mov	r3, r6
 8005d3e:	f003 f85b 	bl	8008df8 <vsnprintf>

  chprintf((BaseSequentialStream *)&SDU1,"%s", buf);
 8005d42:	4622      	mov	r2, r4
 8005d44:	4803      	ldr	r0, [pc, #12]	; (8005d54 <print_it+0x34>)
 8005d46:	4904      	ldr	r1, [pc, #16]	; (8005d58 <print_it+0x38>)
}
 8005d48:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  memset(buf,0,2048);

  vsnprintf(buf, 2048, str, args);

  chprintf((BaseSequentialStream *)&SDU1,"%s", buf);
 8005d4c:	f002 b8c8 	b.w	8007ee0 <chprintf.constprop.35>
 8005d50:	2000a9dc 	.word	0x2000a9dc
 8005d54:	2000b1fc 	.word	0x2000b1fc
 8005d58:	0800d044 	.word	0x0800d044
 8005d5c:	00000000 	.word	0x00000000

08005d60 <send_message.lto_priv.71>:
static MEMORYPOOL_DECL(msg_pool4, sizeof (svm_msg_t), PORT_NATURAL_ALIGN, NULL);
#endif

chibios_interop_t chibios_interop[VMC_NUM_CONTAINERS];

static int send_message(chibios_interop_t *this, svm_msg_t msg) {
 8005d60:	b082      	sub	sp, #8
 8005d62:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* Called from within an interrupt routine */

  int r = 0;
  svm_msg_t *m = (svm_msg_t *)chPoolAllocI(this->msg_pool);
 8005d66:	6804      	ldr	r4, [r0, #0]
static MEMORYPOOL_DECL(msg_pool4, sizeof (svm_msg_t), PORT_NATURAL_ALIGN, NULL);
#endif

chibios_interop_t chibios_interop[VMC_NUM_CONTAINERS];

static int send_message(chibios_interop_t *this, svm_msg_t msg) {
 8005d68:	a906      	add	r1, sp, #24
 8005d6a:	4607      	mov	r7, r0
 8005d6c:	e881 000c 	stmia.w	r1, {r2, r3}
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
  void *objp;

  chDbgCheckClassI();
 8005d70:	f7fc faee 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 8005d74:	2c00      	cmp	r4, #0
 8005d76:	d043      	beq.n	8005e00 <send_message.lto_priv.71+0xa0>

  objp = mp->next;
 8005d78:	6826      	ldr	r6, [r4, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8005d7a:	2e00      	cmp	r6, #0
 8005d7c:	d032      	beq.n	8005de4 <send_message.lto_priv.71+0x84>
    mp->next = mp->next->next;
 8005d7e:	6833      	ldr	r3, [r6, #0]
 8005d80:	6023      	str	r3, [r4, #0]

  int r = 0;
  svm_msg_t *m = (svm_msg_t *)chPoolAllocI(this->msg_pool);

  if (m) {
    *m = msg;
 8005d82:	ac06      	add	r4, sp, #24
 8005d84:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005d86:	4635      	mov	r5, r6
 8005d88:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005d8a:	e894 0003 	ldmia.w	r4, {r0, r1}
    msg_t msg_val = chMBPostI(this->mb, (uint32_t)m);
 8005d8e:	687c      	ldr	r4, [r7, #4]

  int r = 0;
  svm_msg_t *m = (svm_msg_t *)chPoolAllocI(this->msg_pool);

  if (m) {
    *m = msg;
 8005d90:	e885 0003 	stmia.w	r5, {r0, r1}
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
 8005d94:	f7fc fadc 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 8005d98:	2c00      	cmp	r4, #0
 8005d9a:	d03b      	beq.n	8005e14 <send_message.lto_priv.71+0xb4>

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8005d9c:	7d23      	ldrb	r3, [r4, #20]
 8005d9e:	2b00      	cmp	r3, #0
 8005da0:	d131      	bne.n	8005e06 <send_message.lto_priv.71+0xa6>
 *
 * @iclass
 */
static inline size_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
 8005da2:	f7fc fad5 	bl	8002350 <chDbgCheckClassI>
 8005da6:	f8d4 8000 	ldr.w	r8, [r4]
 8005daa:	6865      	ldr	r5, [r4, #4]
 *
 * @iclass
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
 8005dac:	f7fc fad0 	bl	8002350 <chDbgCheckClassI>
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8005db0:	6923      	ldr	r3, [r4, #16]
 */
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(mbp->top - mbp->buffer);
 8005db2:	ebc8 0205 	rsb	r2, r8, r5
 8005db6:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
 8005dba:	d024      	beq.n	8005e06 <send_message.lto_priv.71+0xa6>
    *mbp->wrptr++ = msg;
 8005dbc:	68a2      	ldr	r2, [r4, #8]
 8005dbe:	1d13      	adds	r3, r2, #4
 8005dc0:	60a3      	str	r3, [r4, #8]
 8005dc2:	6016      	str	r6, [r2, #0]
    if (mbp->wrptr >= mbp->top) {
 8005dc4:	42ab      	cmp	r3, r5
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
 8005dc6:	6923      	ldr	r3, [r4, #16]

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
    *mbp->wrptr++ = msg;
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
 8005dc8:	bf28      	it	cs
 8005dca:	f8c4 8008 	strcs.w	r8, [r4, #8]
    }
    mbp->cnt++;
 8005dce:	3301      	adds	r3, #1
 8005dd0:	6123      	str	r3, [r4, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8005dd2:	f104 0020 	add.w	r0, r4, #32
 8005dd6:	f002 f843 	bl	8007e60 <chThdDequeueNextI.constprop.55>
chibios_interop_t chibios_interop[VMC_NUM_CONTAINERS];

static int send_message(chibios_interop_t *this, svm_msg_t msg) {
  /* Called from within an interrupt routine */

  int r = 0;
 8005dda:	2000      	movs	r0, #0
    }
  }


  return r;
}
 8005ddc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005de0:	b002      	add	sp, #8
 8005de2:	4770      	bx	lr
  }
  else if (mp->provider != NULL) {
 8005de4:	68e3      	ldr	r3, [r4, #12]
 8005de6:	2b00      	cmp	r3, #0
 8005de8:	d0f7      	beq.n	8005dda <send_message.lto_priv.71+0x7a>
    objp = mp->provider(mp->object_size, mp->align);
 8005dea:	6860      	ldr	r0, [r4, #4]
 8005dec:	68a1      	ldr	r1, [r4, #8]
 8005dee:	4798      	blx	r3

    chDbgAssert(MEM_IS_ALIGNED(objp, mp->align),
 8005df0:	68a3      	ldr	r3, [r4, #8]
 8005df2:	3b01      	subs	r3, #1
 8005df4:	4218      	tst	r0, r3
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
    objp = mp->provider(mp->object_size, mp->align);
 8005df6:	4606      	mov	r6, r0

    chDbgAssert(MEM_IS_ALIGNED(objp, mp->align),
 8005df8:	d102      	bne.n	8005e00 <send_message.lto_priv.71+0xa0>
  /* Called from within an interrupt routine */

  int r = 0;
  svm_msg_t *m = (svm_msg_t *)chPoolAllocI(this->msg_pool);

  if (m) {
 8005dfa:	2800      	cmp	r0, #0
 8005dfc:	d0ed      	beq.n	8005dda <send_message.lto_priv.71+0x7a>
 8005dfe:	e7c0      	b.n	8005d82 <send_message.lto_priv.71+0x22>
 */
void *chPoolAllocI(memory_pool_t *mp) {
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);
 8005e00:	4806      	ldr	r0, [pc, #24]	; (8005e1c <send_message.lto_priv.71+0xbc>)
 8005e02:	f7fe ffbd 	bl	8004d80 <chSysHalt>
    *m = msg;
    msg_t msg_val = chMBPostI(this->mb, (uint32_t)m);
    if (msg_val != MSG_OK) {
      chPoolFree(this->msg_pool, (void*)m);
 8005e06:	6838      	ldr	r0, [r7, #0]
 8005e08:	4631      	mov	r1, r6
 8005e0a:	f7fc fd39 	bl	8002880 <chPoolFree>
      r = -1;
 8005e0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005e12:	e7e3      	b.n	8005ddc <send_message.lto_priv.71+0x7c>
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);
 8005e14:	4802      	ldr	r0, [pc, #8]	; (8005e20 <send_message.lto_priv.71+0xc0>)
 8005e16:	f7fe ffb3 	bl	8004d80 <chSysHalt>
 8005e1a:	bf00      	nop
 8005e1c:	0800cff8 	.word	0x0800cff8
 8005e20:	0800d1ec 	.word	0x0800d1ec
	...

08005e30 <dbg_print>:

void chibios_register_dbg_print(void (*f)(const char *str, va_list args)) {
  dbg_print_fun = f;
}

void dbg_print(const char *str, ...) {
 8005e30:	b40f      	push	{r0, r1, r2, r3}
 8005e32:	b500      	push	{lr}
  va_list args;

  if (dbg_print_fun != NULL) {
 8005e34:	4b06      	ldr	r3, [pc, #24]	; (8005e50 <dbg_print+0x20>)
 8005e36:	681b      	ldr	r3, [r3, #0]

void chibios_register_dbg_print(void (*f)(const char *str, va_list args)) {
  dbg_print_fun = f;
}

void dbg_print(const char *str, ...) {
 8005e38:	b083      	sub	sp, #12
  va_list args;

  if (dbg_print_fun != NULL) {
 8005e3a:	b123      	cbz	r3, 8005e46 <dbg_print+0x16>
    va_start(args, str);
 8005e3c:	aa05      	add	r2, sp, #20
    dbg_print_fun(str, args);
 8005e3e:	4611      	mov	r1, r2
 8005e40:	9804      	ldr	r0, [sp, #16]

void dbg_print(const char *str, ...) {
  va_list args;

  if (dbg_print_fun != NULL) {
    va_start(args, str);
 8005e42:	9201      	str	r2, [sp, #4]
    dbg_print_fun(str, args);
 8005e44:	4798      	blx	r3
    va_end(args);
  }
}
 8005e46:	b003      	add	sp, #12
 8005e48:	f85d eb04 	ldr.w	lr, [sp], #4
 8005e4c:	b004      	add	sp, #16
 8005e4e:	4770      	bx	lr
 8005e50:	2000a368 	.word	0x2000a368
	...

08005e60 <sof_handler.lto_priv.82>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8005e60:	b530      	push	{r4, r5, lr}
 8005e62:	2320      	movs	r3, #32
 8005e64:	b083      	sub	sp, #12
 8005e66:	f383 8811 	msr	BASEPRI, r3
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8005e6a:	4c25      	ldr	r4, [pc, #148]	; (8005f00 <sof_handler.lto_priv.82+0xa0>)
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8005e6c:	f7fe ffd8 	bl	8004e20 <_dbg_check_lock_from_isr>
 8005e70:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8005e74:	6813      	ldr	r3, [r2, #0]
 8005e76:	7819      	ldrb	r1, [r3, #0]
 8005e78:	2904      	cmp	r1, #4
 8005e7a:	d006      	beq.n	8005e8a <sof_handler.lto_priv.82+0x2a>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8005e7c:	f7fe ffb8 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8005e80:	2300      	movs	r3, #0
 8005e82:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
  osalSysUnlockFromISR();
}
 8005e86:	b003      	add	sp, #12
 8005e88:	bd30      	pop	{r4, r5, pc}
 8005e8a:	7a21      	ldrb	r1, [r4, #8]
 8005e8c:	2902      	cmp	r1, #2
 8005e8e:	d1f5      	bne.n	8005e7c <sof_handler.lto_priv.82+0x1c>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8005e90:	7911      	ldrb	r1, [r2, #4]
 8005e92:	891a      	ldrh	r2, [r3, #8]
 8005e94:	2301      	movs	r3, #1
 8005e96:	408b      	lsls	r3, r1
 8005e98:	4213      	tst	r3, r2
 8005e9a:	d1ef      	bne.n	8005e7c <sof_handler.lto_priv.82+0x1c>
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 8005e9c:	f7fc fa58 	bl	8002350 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8005ea0:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8005ea2:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8005ea4:	4293      	cmp	r3, r2
 8005ea6:	d1e9      	bne.n	8005e7c <sof_handler.lto_priv.82+0x1c>
 8005ea8:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8005eaa:	2a00      	cmp	r2, #0
 8005eac:	d0e6      	beq.n	8005e7c <sof_handler.lto_priv.82+0x1c>
 8005eae:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8005eb0:	2a00      	cmp	r2, #0
 8005eb2:	d0e3      	beq.n	8005e7c <sof_handler.lto_priv.82+0x1c>
 8005eb4:	3a04      	subs	r2, #4
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));

    if (size > 0U) {
 8005eb6:	1ad2      	subs	r2, r2, r3
 8005eb8:	d0e0      	beq.n	8005e7c <sof_handler.lto_priv.82+0x1c>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8005eba:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
 8005ebc:	6e22      	ldr	r2, [r4, #96]	; 0x60
      if (obqp->bwrptr >= obqp->btop) {
 8005ebe:	6de0      	ldr	r0, [r4, #92]	; 0x5c

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8005ec0:	6d21      	ldr	r1, [r4, #80]	; 0x50
      if (obqp->bwrptr >= obqp->btop) {
        obqp->bwrptr = obqp->buffers;
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8005ec2:	4d0f      	ldr	r5, [pc, #60]	; (8005f00 <sof_handler.lto_priv.82+0xa0>)
      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
 8005ec4:	4413      	add	r3, r2
      if (obqp->bwrptr >= obqp->btop) {
 8005ec6:	4283      	cmp	r3, r0
      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
 8005ec8:	6563      	str	r3, [r4, #84]	; 0x54

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8005eca:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
        obqp->bwrptr = obqp->buffers;
 8005ece:	bf28      	it	cs
 8005ed0:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8005ed2:	6521      	str	r1, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
        obqp->bwrptr = obqp->buffers;
 8005ed4:	bf28      	it	cs
 8005ed6:	6563      	strcs	r3, [r4, #84]	; 0x54

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8005ed8:	f105 0044 	add.w	r0, r5, #68	; 0x44
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8005edc:	2300      	movs	r3, #0
 8005ede:	a901      	add	r1, sp, #4
 8005ee0:	66e3      	str	r3, [r4, #108]	; 0x6c
 8005ee2:	f001 fc85 	bl	80077f0 <obqGetFullBufferI>

    osalDbgAssert(buf != NULL, "queue is empty");
 8005ee6:	4602      	mov	r2, r0
 8005ee8:	b138      	cbz	r0, 8005efa <sof_handler.lto_priv.82+0x9a>

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8005eea:	f8d5 148c 	ldr.w	r1, [r5, #1164]	; 0x48c
 8005eee:	9b01      	ldr	r3, [sp, #4]
 8005ef0:	6808      	ldr	r0, [r1, #0]
 8005ef2:	7909      	ldrb	r1, [r1, #4]
 8005ef4:	f000 ff3c 	bl	8006d70 <usbStartTransmitI>
 8005ef8:	e7c0      	b.n	8005e7c <sof_handler.lto_priv.82+0x1c>
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);

    osalDbgAssert(buf != NULL, "queue is empty");
 8005efa:	4802      	ldr	r0, [pc, #8]	; (8005f04 <sof_handler.lto_priv.82+0xa4>)
 8005efc:	f7fe ff40 	bl	8004d80 <chSysHalt>
 8005f00:	2000b1fc 	.word	0x2000b1fc
 8005f04:	0800d008 	.word	0x0800d008
	...

08005f10 <usb_event.lto_priv.80>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8005f10:	b538      	push	{r3, r4, r5, lr}
  extern SerialUSBDriver SDU1;

  switch (event) {
 8005f12:	2905      	cmp	r1, #5
 8005f14:	d816      	bhi.n	8005f44 <usb_event.lto_priv.80+0x34>
 8005f16:	e8df f001 	tbb	[pc, r1]
 8005f1a:	1550      	.short	0x1550
 8005f1c:	03505016 	.word	0x03505016
 8005f20:	2320      	movs	r3, #32
 8005f22:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8005f26:	f7fe ff7b 	bl	8004e20 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8005f2a:	4833      	ldr	r0, [pc, #204]	; (8005ff8 <usb_event.lto_priv.80+0xe8>)
 8005f2c:	2101      	movs	r1, #1
 8005f2e:	f7fc fbd7 	bl	80026e0 <chEvtBroadcastFlagsI>
 * @iclass
 */
void sduWakeupHookI(SerialUSBDriver *sdup) {

  chnAddFlagsI(sdup, CHN_CONNECTED);
  bqResumeX(&sdup->ibqueue);
 8005f32:	4b32      	ldr	r3, [pc, #200]	; (8005ffc <usb_event.lto_priv.80+0xec>)
 8005f34:	2400      	movs	r4, #0
 8005f36:	751c      	strb	r4, [r3, #20]
  bqResumeX(&sdup->obqueue);
 8005f38:	f883 404c 	strb.w	r4, [r3, #76]	; 0x4c
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8005f3c:	f7fe ff58 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8005f40:	f384 8811 	msr	BASEPRI, r4
 8005f44:	bd38      	pop	{r3, r4, r5, pc}
 8005f46:	4605      	mov	r5, r0
 8005f48:	2320      	movs	r3, #32
 8005f4a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8005f4e:	f7fe ff67 	bl	8004e20 <_dbg_check_lock_from_isr>
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter  = 0;
 8005f52:	4c2b      	ldr	r4, [pc, #172]	; (8006000 <usb_event.lto_priv.80+0xf0>)
    chSysLockFromISR();

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USB1_DATA_REQUEST_EP, &ep1config);
 8005f54:	4a2b      	ldr	r2, [pc, #172]	; (8006004 <usb_event.lto_priv.80+0xf4>)
 8005f56:	4628      	mov	r0, r5
 8005f58:	2101      	movs	r1, #1
 8005f5a:	f001 faf9 	bl	8007550 <usbInitEndpointI>
    usbInitEndpointI(usbp, USB1_INTERRUPT_REQUEST_EP, &ep2config);
 8005f5e:	2102      	movs	r1, #2
 8005f60:	4a29      	ldr	r2, [pc, #164]	; (8006008 <usb_event.lto_priv.80+0xf8>)
 8005f62:	4628      	mov	r0, r5
 8005f64:	f001 faf4 	bl	8007550 <usbInitEndpointI>
 8005f68:	2500      	movs	r5, #0
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();
 8005f6a:	f7fc f9f1 	bl	8002350 <chDbgCheckClassI>

  ibqp->bcounter  = 0;
  ibqp->brdptr    = ibqp->buffers;
 8005f6e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005f70:	6223      	str	r3, [r4, #32]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8005f72:	f104 000c 	add.w	r0, r4, #12
  ibqp->bwrptr    = ibqp->buffers;
 8005f76:	61e3      	str	r3, [r4, #28]
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter  = 0;
 8005f78:	61a5      	str	r5, [r4, #24]
  ibqp->brdptr    = ibqp->buffers;
  ibqp->bwrptr    = ibqp->buffers;
  ibqp->ptr       = NULL;
 8005f7a:	6365      	str	r5, [r4, #52]	; 0x34
  ibqp->top       = NULL;
 8005f7c:	63a5      	str	r5, [r4, #56]	; 0x38
 8005f7e:	f001 ff47 	bl	8007e10 <chThdDequeueAllI.constprop.57>
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {

  ibqResetI(&sdup->ibqueue);
  bqResumeX(&sdup->ibqueue);
 8005f82:	7525      	strb	r5, [r4, #20]
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 8005f84:	f7fc f9e4 	bl	8002350 <chDbgCheckClassI>

  obqp->bcounter  = bqSizeX(obqp);
  obqp->brdptr    = obqp->buffers;
 8005f88:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 */
void obqResetI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();

  obqp->bcounter  = bqSizeX(obqp);
 8005f8a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8005f8c:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->brdptr    = obqp->buffers;
 8005f8e:	65a3      	str	r3, [r4, #88]	; 0x58
  obqp->bwrptr    = obqp->buffers;
 8005f90:	6563      	str	r3, [r4, #84]	; 0x54
 8005f92:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->ptr       = NULL;
 8005f96:	66e5      	str	r5, [r4, #108]	; 0x6c
  obqp->top       = NULL;
 8005f98:	6725      	str	r5, [r4, #112]	; 0x70
 8005f9a:	f001 ff39 	bl	8007e10 <chThdDequeueAllI.constprop.57>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8005f9e:	2101      	movs	r1, #1
 8005fa0:	1d20      	adds	r0, r4, #4
  obqResetI(&sdup->obqueue);
  bqResumeX(&sdup->obqueue);
 8005fa2:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8005fa6:	f7fc fb9b 	bl	80026e0 <chEvtBroadcastFlagsI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
  (void) sdu_start_receive(sdup);
 8005faa:	4620      	mov	r0, r4
 8005fac:	f001 fba8 	bl	8007700 <sdu_start_receive.lto_priv.102>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8005fb0:	f7fe ff1e 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8005fb4:	f385 8811 	msr	BASEPRI, r5
 8005fb8:	bd38      	pop	{r3, r4, r5, pc}
 8005fba:	2320      	movs	r3, #32
 8005fbc:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
void sduSuspendHookI(SerialUSBDriver *sdup) {

  /* Avoiding events spam.*/
  if (bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
 8005fc0:	4c0f      	ldr	r4, [pc, #60]	; (8006000 <usb_event.lto_priv.80+0xf0>)
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8005fc2:	f7fe ff2d 	bl	8004e20 <_dbg_check_lock_from_isr>
 8005fc6:	7d23      	ldrb	r3, [r4, #20]
 8005fc8:	b113      	cbz	r3, 8005fd0 <usb_event.lto_priv.80+0xc0>
 8005fca:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 8005fce:	b96b      	cbnz	r3, 8005fec <usb_event.lto_priv.80+0xdc>
 8005fd0:	4809      	ldr	r0, [pc, #36]	; (8005ff8 <usb_event.lto_priv.80+0xe8>)
 8005fd2:	2102      	movs	r1, #2
 8005fd4:	f7fc fb84 	bl	80026e0 <chEvtBroadcastFlagsI>
    return;
  }
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
  bqSuspendI(&sdup->ibqueue);
 8005fd8:	2501      	movs	r5, #1
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8005fda:	480c      	ldr	r0, [pc, #48]	; (800600c <usb_event.lto_priv.80+0xfc>)
 8005fdc:	7525      	strb	r5, [r4, #20]
 8005fde:	f001 ff17 	bl	8007e10 <chThdDequeueAllI.constprop.57>
 8005fe2:	480b      	ldr	r0, [pc, #44]	; (8006010 <usb_event.lto_priv.80+0x100>)
  bqSuspendI(&sdup->obqueue);
 8005fe4:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8005fe8:	f001 ff12 	bl	8007e10 <chThdDequeueAllI.constprop.57>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8005fec:	f7fe ff00 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8005ff0:	2300      	movs	r3, #0
 8005ff2:	f383 8811 	msr	BASEPRI, r3
 8005ff6:	bd38      	pop	{r3, r4, r5, pc}
 8005ff8:	2000b200 	.word	0x2000b200
 8005ffc:	2000b1fc 	.word	0x2000b1fc
 8006000:	2000b1fc 	.word	0x2000b1fc
 8006004:	0800d1c8 	.word	0x0800d1c8
 8006008:	0800d180 	.word	0x0800d180
 800600c:	2000b208 	.word	0x2000b208
 8006010:	2000b240 	.word	0x2000b240
	...

08006020 <ll_dac_write.lto_priv.74>:
/* data[0] will be reinterpreted as a bool */
static uint32_t ll_dac_write(struct ll_driver_s *this, uint8_t *data, uint32_t data_size) {
  ll_dac_driver_t *dac_driver = (ll_dac_driver_t*)this->driver_info;

  //  dacPutChannelX(&dac_driver->internal.dacd, 0, 4095);
  if (data_size >= 2) { 
 8006020:	2a01      	cmp	r2, #1

  return data_size;
}

/* data[0] will be reinterpreted as a bool */
static uint32_t ll_dac_write(struct ll_driver_s *this, uint8_t *data, uint32_t data_size) {
 8006022:	b538      	push	{r3, r4, r5, lr}
  ll_dac_driver_t *dac_driver = (ll_dac_driver_t*)this->driver_info;
 8006024:	6803      	ldr	r3, [r0, #0]

  //  dacPutChannelX(&dac_driver->internal.dacd, 0, 4095);
  if (data_size >= 2) { 
 8006026:	d90f      	bls.n	8006048 <ll_dac_write.lto_priv.74+0x28>
    uint16_t val = 0;
    val = data[1];
    val = val << 8;
    val |= data[0];

    dacPutChannelX(dac_driver->internal.dacd, 0, val);
 8006028:	6918      	ldr	r0, [r3, #16]
  ll_dac_driver_t *dac_driver = (ll_dac_driver_t*)this->driver_info;

  //  dacPutChannelX(&dac_driver->internal.dacd, 0, 4095);
  if (data_size >= 2) { 
    uint16_t val = 0;
    val = data[1];
 800602a:	784d      	ldrb	r5, [r1, #1]
 * @xclass
 */
void dacPutChannelX(DACDriver *dacp, dacchannel_t channel, dacsample_t sample) {

  osalDbgCheck(channel < (dacchannel_t)DAC_MAX_CHANNELS);
  osalDbgAssert(dacp->state == DAC_READY, "invalid state");
 800602c:	7803      	ldrb	r3, [r0, #0]
    val = val << 8;
    val |= data[0];
 800602e:	7809      	ldrb	r1, [r1, #0]
 8006030:	2b02      	cmp	r3, #2
 8006032:	4614      	mov	r4, r2
 8006034:	d002      	beq.n	800603c <ll_dac_write.lto_priv.74+0x1c>
 8006036:	4805      	ldr	r0, [pc, #20]	; (800604c <ll_dac_write.lto_priv.74+0x2c>)
 8006038:	f7fe fea2 	bl	8004d80 <chSysHalt>

  dac_lld_put_channel(dacp, channel, sample);
 800603c:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
 8006040:	f001 ff26 	bl	8007e90 <dac_lld_put_channel.constprop.51>
 8006044:	4620      	mov	r0, r4
 8006046:	bd38      	pop	{r3, r4, r5, pc}

    dacPutChannelX(dac_driver->internal.dacd, 0, val);
    return data_size; 
  } 
  return 0;
 8006048:	2000      	movs	r0, #0
}
 800604a:	bd38      	pop	{r3, r4, r5, pc}
 800604c:	0800d1b8 	.word	0x0800d1b8

08006050 <Vector108>:

  return true;
}

OSAL_IRQ_HANDLER(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER, _HANDLER))) {
 8006050:	b5f0      	push	{r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();
 8006052:	4832      	ldr	r0, [pc, #200]	; (800611c <Vector108+0xcc>)
  tim->DIER |= 0x1; /* activate interrupt on "update event" (for example overflow) */

  return true;
}

OSAL_IRQ_HANDLER(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER, _HANDLER))) {
 8006054:	b08b      	sub	sp, #44	; 0x2c
  OSAL_IRQ_PROLOGUE();
 8006056:	f7fc f903 	bl	8002260 <_trace_isr_enter>
 800605a:	f7fe feb1 	bl	8004dc0 <_dbg_check_enter_isr>
  
  uint32_t hw = counter_high_word;
  
  if ((tim->SR & tim->DIER) & 0x1 ) { /* This indicates and update event (overflow?) */
 800605e:	4b30      	ldr	r3, [pc, #192]	; (8006120 <Vector108+0xd0>)
}

OSAL_IRQ_HANDLER(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER, _HANDLER))) {
  OSAL_IRQ_PROLOGUE();
  
  uint32_t hw = counter_high_word;
 8006060:	4930      	ldr	r1, [pc, #192]	; (8006124 <Vector108+0xd4>)
  
  if ((tim->SR & tim->DIER) & 0x1 ) { /* This indicates and update event (overflow?) */
 8006062:	681b      	ldr	r3, [r3, #0]
}

OSAL_IRQ_HANDLER(COMB_EXPAND(STM32_TIM,COMB_EXPAND(SYS_TIMER, _HANDLER))) {
  OSAL_IRQ_PROLOGUE();
  
  uint32_t hw = counter_high_word;
 8006064:	6808      	ldr	r0, [r1, #0]
  
  if ((tim->SR & tim->DIER) & 0x1 ) { /* This indicates and update event (overflow?) */
 8006066:	691c      	ldr	r4, [r3, #16]
 8006068:	68da      	ldr	r2, [r3, #12]
 800606a:	4022      	ands	r2, r4
 800606c:	07d4      	lsls	r4, r2, #31
 800606e:	d50b      	bpl.n	8006088 <Vector108+0x38>
    /* TODO: Not 100% certain this is definitely an overflow. Couldn't it
       be other "events"?  */
    uint32_t sr = tim->SR;
 8006070:	691a      	ldr	r2, [r3, #16]
    tim->SR = ~sr; /* clear update event flag */


    counter_high_word++;

    if (alarm.active) {
 8006072:	4c2d      	ldr	r4, [pc, #180]	; (8006128 <Vector108+0xd8>)
  
  if ((tim->SR & tim->DIER) & 0x1 ) { /* This indicates and update event (overflow?) */
    /* TODO: Not 100% certain this is definitely an overflow. Couldn't it
       be other "events"?  */
    uint32_t sr = tim->SR;
    sr &= 0x1 & STM32_TIM_DIER_IRQ_MASK;
 8006074:	f002 0201 	and.w	r2, r2, #1
    tim->SR = ~sr; /* clear update event flag */
 8006078:	43d2      	mvns	r2, r2
 800607a:	611a      	str	r2, [r3, #16]


    counter_high_word++;
 800607c:	680a      	ldr	r2, [r1, #0]

    if (alarm.active) {
 800607e:	7825      	ldrb	r5, [r4, #0]
    uint32_t sr = tim->SR;
    sr &= 0x1 & STM32_TIM_DIER_IRQ_MASK;
    tim->SR = ~sr; /* clear update event flag */


    counter_high_word++;
 8006080:	3201      	adds	r2, #1
 8006082:	600a      	str	r2, [r1, #0]

    if (alarm.active) {
 8006084:	2d00      	cmp	r5, #0
 8006086:	d13a      	bne.n	80060fe <Vector108+0xae>
    	tim->DIER |= 0x2; /* activate interrupt on ccr channel 1 */
      }
    }
  }

  if ((tim->SR & tim->DIER) & 0x2) {
 8006088:	6919      	ldr	r1, [r3, #16]
 800608a:	68da      	ldr	r2, [r3, #12]
 800608c:	400a      	ands	r2, r1
 800608e:	0792      	lsls	r2, r2, #30
 8006090:	d52b      	bpl.n	80060ea <Vector108+0x9a>
    uint32_t low_word;
    //uint32_t high_word;
    Time time;
    
    uint32_t sr = tim->SR;
 8006092:	691a      	ldr	r2, [r3, #16]
    time |= low_word;
    
    svm_msg_t msg;
    msg.sender_id = SYS_TIME_SENDER_ID;
    msg.timestamp = time; //sys_time_get_current_ticks();
    msg.data = 0xDEADBEEF;
 8006094:	4925      	ldr	r1, [pc, #148]	; (800612c <Vector108+0xdc>)
 8006096:	9106      	str	r1, [sp, #24]
    uint32_t low_word;
    //uint32_t high_word;
    Time time;
    
    uint32_t sr = tim->SR;
    sr &= 0x2 & STM32_TIM_DIER_IRQ_MASK;
 8006098:	f002 0202 	and.w	r2, r2, #2
    tim->SR = ~sr; /* clear ccr event flag */
 800609c:	43d2      	mvns	r2, r2
 800609e:	611a      	str	r2, [r3, #16]


    tim->DIER &= ~0x2; /* disable interrupt on ccr channel 1 */
 80060a0:	68da      	ldr	r2, [r3, #12]
 80060a2:	f022 0202 	bic.w	r2, r2, #2
 80060a6:	60da      	str	r2, [r3, #12]

    low_word = tim->CNT;
 80060a8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    time = hw;
    time <<= 32;
 80060aa:	2400      	movs	r4, #0
 80060ac:	4605      	mov	r5, r0
    time |= low_word;
 80060ae:	4629      	mov	r1, r5
 80060b0:	ea44 0003 	orr.w	r0, r4, r3
    
    svm_msg_t msg;
    msg.sender_id = SYS_TIME_SENDER_ID;
 80060b4:	23ff      	movs	r3, #255	; 0xff
 80060b6:	9304      	str	r3, [sp, #16]
    msg.timestamp = time; //sys_time_get_current_ticks();
    msg.data = 0xDEADBEEF;
    msg.msg_type = 0;
 80060b8:	9405      	str	r4, [sp, #20]
    time <<= 32;
    time |= low_word;
    
    svm_msg_t msg;
    msg.sender_id = SYS_TIME_SENDER_ID;
    msg.timestamp = time; //sys_time_get_current_ticks();
 80060ba:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80060be:	2320      	movs	r3, #32
 80060c0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80060c4:	f7fe feac 	bl	8004e20 <_dbg_check_lock_from_isr>
    msg.data = 0xDEADBEEF;
    msg.msg_type = 0;

    osalSysLockFromISR(); 
    interop->send_message(interop, msg); /* check for error */
 80060c8:	ab0a      	add	r3, sp, #40	; 0x28
 80060ca:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 80060ce:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 80060d2:	4b17      	ldr	r3, [pc, #92]	; (8006130 <Vector108+0xe0>)
 80060d4:	6818      	ldr	r0, [r3, #0]
 80060d6:	ab04      	add	r3, sp, #16
 80060d8:	6881      	ldr	r1, [r0, #8]
 80060da:	cb0c      	ldmia	r3, {r2, r3}
 80060dc:	4788      	blx	r1
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80060de:	f7fe fe87 	bl	8004df0 <_dbg_check_unlock_from_isr>
 80060e2:	f384 8811 	msr	BASEPRI, r4
    osalSysUnlockFromISR();  

    alarm.active = false;
 80060e6:	4b10      	ldr	r3, [pc, #64]	; (8006128 <Vector108+0xd8>)
 80060e8:	701c      	strb	r4, [r3, #0]
  }
  
  OSAL_IRQ_EPILOGUE();
 80060ea:	f7fc fb81 	bl	80027f0 <_dbg_check_leave_isr>
 80060ee:	480b      	ldr	r0, [pc, #44]	; (800611c <Vector108+0xcc>)
 80060f0:	f7fc f896 	bl	8002220 <_trace_isr_leave>
}
 80060f4:	b00b      	add	sp, #44	; 0x2c
 80060f6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    osalSysUnlockFromISR();  

    alarm.active = false;
  }
  
  OSAL_IRQ_EPILOGUE();
 80060fa:	f7fc b801 	b.w	8002100 <_port_irq_epilogue>


    counter_high_word++;

    if (alarm.active) {
      if (counter_high_word == alarm.alarm_time >> 32) {
 80060fe:	680a      	ldr	r2, [r1, #0]
 8006100:	68e6      	ldr	r6, [r4, #12]
 8006102:	68a1      	ldr	r1, [r4, #8]
 8006104:	2700      	movs	r7, #0
 8006106:	2500      	movs	r5, #0
 8006108:	42bd      	cmp	r5, r7
 800610a:	bf08      	it	eq
 800610c:	42b2      	cmpeq	r2, r6
 800610e:	d1bb      	bne.n	8006088 <Vector108+0x38>
     	tim->CCR[0] = (uint32_t)alarm.alarm_time;
 8006110:	6359      	str	r1, [r3, #52]	; 0x34
    	tim->DIER |= 0x2; /* activate interrupt on ccr channel 1 */
 8006112:	68da      	ldr	r2, [r3, #12]
 8006114:	f042 0202 	orr.w	r2, r2, #2
 8006118:	60da      	str	r2, [r3, #12]
 800611a:	e7b5      	b.n	8006088 <Vector108+0x38>
 800611c:	0800d01c 	.word	0x0800d01c
 8006120:	20000810 	.word	0x20000810
 8006124:	20004f50 	.word	0x20004f50
 8006128:	2000a300 	.word	0x2000a300
 800612c:	deadbeef 	.word	0xdeadbeef
 8006130:	2000a97c 	.word	0x2000a97c
	...

08006140 <pq_extractMin>:
    insertIdx = parentIdx(insertIdx);
  }
  return 1;
}

int pq_extractMin(PriorityQ_t *pq, pq_data_t *pq_data){
 8006140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  if(pq->size <= 0){
 8006144:	6885      	ldr	r5, [r0, #8]
 8006146:	2d00      	cmp	r5, #0
    insertIdx = parentIdx(insertIdx);
  }
  return 1;
}

int pq_extractMin(PriorityQ_t *pq, pq_data_t *pq_data){
 8006148:	b087      	sub	sp, #28
 800614a:	4684      	mov	ip, r0

  if(pq->size <= 0){
 800614c:	f340 80b4 	ble.w	80062b8 <pq_extractMin+0x178>
    DEBUG_PRINT(("Priority queue is empty\n"));
    return -1;
  }

  if(pq->size == 1){
 8006150:	2d01      	cmp	r5, #1
 8006152:	460c      	mov	r4, r1
 8006154:	f000 80a3 	beq.w	800629e <pq_extractMin+0x15e>
    pq->size--;
    *pq_data = pq->data[0];
    return 1;
  }

  *pq_data = pq->data[0]; // the root is returned
 8006158:	6805      	ldr	r5, [r0, #0]
 800615a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800615c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800615e:	e895 0003 	ldmia.w	r5, {r0, r1}
 8006162:	e884 0003 	stmia.w	r4, {r0, r1}

  // heapify the remaining tree
  pq->data[0] = pq->data[pq->size - 1];
 8006166:	f8dc 4008 	ldr.w	r4, [ip, #8]
 800616a:	f8dc 5000 	ldr.w	r5, [ip]
 800616e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8006172:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
 8006176:	3c18      	subs	r4, #24
 8006178:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800617a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800617c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8006180:	e885 0003 	stmia.w	r5, {r0, r1}
  pq->size--;
 8006184:	f8dc 6008 	ldr.w	r6, [ip, #8]
 8006188:	3e01      	subs	r6, #1
 800618a:	f8cc 6008 	str.w	r6, [ip, #8]
 800618e:	2300      	movs	r3, #0
  *y = temp;
}

static inline int parentIdx(int i) { return (i-1)/2; }

static inline int leftIdx(int i) { return (2*i + 1); }
 8006190:	005a      	lsls	r2, r3, #1
 8006192:	1c54      	adds	r4, r2, #1
{
  for(;;){
    int l = leftIdx(i);
    int r = rightIdx(i);
    int smallest = i;
    if (l < pq->size && lessThan(&pq->data[l], &pq->data[i], pq->cmp))
 8006194:	42a6      	cmp	r6, r4

static inline int parentIdx(int i) { return (i-1)/2; }

static inline int leftIdx(int i) { return (2*i + 1); }

static inline int rightIdx(int i) { return (2*i + 2); }
 8006196:	f102 0e02 	add.w	lr, r2, #2
{
  for(;;){
    int l = leftIdx(i);
    int r = rightIdx(i);
    int smallest = i;
    if (l < pq->size && lessThan(&pq->data[l], &pq->data[i], pq->cmp))
 800619a:	dd18      	ble.n	80061ce <pq_extractMin+0x8e>
 800619c:	f8dc 5000 	ldr.w	r5, [ip]
 80061a0:	f89c 700c 	ldrb.w	r7, [ip, #12]
 80061a4:	eb04 0844 	add.w	r8, r4, r4, lsl #1
 80061a8:	18d1      	adds	r1, r2, r3
 80061aa:	eb05 08c8 	add.w	r8, r5, r8, lsl #3
 80061ae:	eb05 01c1 	add.w	r1, r5, r1, lsl #3
static inline int leftIdx(int i) { return (2*i + 1); }

static inline int rightIdx(int i) { return (2*i + 2); }

static inline bool lessThan(pq_data_t *d1, pq_data_t *d2, Comparator_t c){
  if(c == BASELINE)
 80061b2:	2f00      	cmp	r7, #0
 80061b4:	d168      	bne.n	8006288 <pq_extractMin+0x148>
    return (d1->baseline < d2->baseline);
 80061b6:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
 80061ba:	e9d8 ab02 	ldrd	sl, fp, [r8, #8]
 80061be:	458b      	cmp	fp, r1
 80061c0:	bf08      	it	eq
 80061c2:	4582      	cmpeq	sl, r0
 80061c4:	bf34      	ite	cc
 80061c6:	2101      	movcc	r1, #1
 80061c8:	2100      	movcs	r1, #0
{
  for(;;){
    int l = leftIdx(i);
    int r = rightIdx(i);
    int smallest = i;
    if (l < pq->size && lessThan(&pq->data[l], &pq->data[i], pq->cmp))
 80061ca:	2900      	cmp	r1, #0
 80061cc:	d144      	bne.n	8006258 <pq_extractMin+0x118>
      smallest = l;
    if (r < pq->size && lessThan(&pq->data[r], &pq->data[smallest], pq->cmp))
 80061ce:	4576      	cmp	r6, lr
 80061d0:	dd55      	ble.n	800627e <pq_extractMin+0x13e>
 80061d2:	f8dc 5000 	ldr.w	r5, [ip]
 80061d6:	f89c 700c 	ldrb.w	r7, [ip, #12]
 80061da:	eb02 0803 	add.w	r8, r2, r3
 80061de:	eb0e 014e 	add.w	r1, lr, lr, lsl #1
 80061e2:	eb05 08c8 	add.w	r8, r5, r8, lsl #3
 80061e6:	461c      	mov	r4, r3
 80061e8:	eb05 01c1 	add.w	r1, r5, r1, lsl #3
static inline int leftIdx(int i) { return (2*i + 1); }

static inline int rightIdx(int i) { return (2*i + 2); }

static inline bool lessThan(pq_data_t *d1, pq_data_t *d2, Comparator_t c){
  if(c == BASELINE)
 80061ec:	2f00      	cmp	r7, #0
 80061ee:	d13b      	bne.n	8006268 <pq_extractMin+0x128>
    return (d1->baseline < d2->baseline);
 80061f0:	e9d1 6702 	ldrd	r6, r7, [r1, #8]
 80061f4:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
 80061f8:	428f      	cmp	r7, r1
 80061fa:	bf08      	it	eq
 80061fc:	4286      	cmpeq	r6, r0
 80061fe:	bf34      	ite	cc
 8006200:	2101      	movcc	r1, #1
 8006202:	2100      	movcs	r1, #0

static inline int parentIdx(int i) { return (i-1)/2; }

static inline int leftIdx(int i) { return (2*i + 1); }

static inline int rightIdx(int i) { return (2*i + 2); }
 8006204:	2900      	cmp	r1, #0
 8006206:	bf18      	it	ne
 8006208:	4674      	movne	r4, lr
    int smallest = i;
    if (l < pq->size && lessThan(&pq->data[l], &pq->data[i], pq->cmp))
      smallest = l;
    if (r < pq->size && lessThan(&pq->data[r], &pq->data[smallest], pq->cmp))
      smallest = r;
    if (smallest == i){
 800620a:	42a3      	cmp	r3, r4
 800620c:	d037      	beq.n	800627e <pq_extractMin+0x13e>
      break;
    } else {
        swapElems(&pq->data[i], &pq->data[smallest]);
 800620e:	4413      	add	r3, r2
 8006210:	eb05 07c3 	add.w	r7, r5, r3, lsl #3
#include<stdbool.h>


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
 8006214:	46b9      	mov	r9, r7
 8006216:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
 800621a:	46e8      	mov	r8, sp
 800621c:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
    if (r < pq->size && lessThan(&pq->data[r], &pq->data[smallest], pq->cmp))
      smallest = r;
    if (smallest == i){
      break;
    } else {
        swapElems(&pq->data[i], &pq->data[smallest]);
 8006220:	eb04 0644 	add.w	r6, r4, r4, lsl #1
#include<stdbool.h>


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
 8006224:	e899 0003 	ldmia.w	r9, {r0, r1}
    if (r < pq->size && lessThan(&pq->data[r], &pq->data[smallest], pq->cmp))
      smallest = r;
    if (smallest == i){
      break;
    } else {
        swapElems(&pq->data[i], &pq->data[smallest]);
 8006228:	eb05 05c6 	add.w	r5, r5, r6, lsl #3


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
  *x = *y;
 800622c:	46ae      	mov	lr, r5
#include<stdbool.h>


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
 800622e:	e888 0003 	stmia.w	r8, {r0, r1}
  *x = *y;
 8006232:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8006236:	463e      	mov	r6, r7
 8006238:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800623a:	e89e 0003 	ldmia.w	lr, {r0, r1}
  *y = temp;
 800623e:	466e      	mov	r6, sp


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
  *x = *y;
 8006240:	e889 0003 	stmia.w	r9, {r0, r1}
  *y = temp;
 8006244:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8006246:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8006248:	e898 0003 	ldmia.w	r8, {r0, r1}
 800624c:	e88e 0003 	stmia.w	lr, {r0, r1}
 8006250:	4623      	mov	r3, r4
 8006252:	f8dc 6008 	ldr.w	r6, [ip, #8]
 8006256:	e79b      	b.n	8006190 <pq_extractMin+0x50>
    int l = leftIdx(i);
    int r = rightIdx(i);
    int smallest = i;
    if (l < pq->size && lessThan(&pq->data[l], &pq->data[i], pq->cmp))
      smallest = l;
    if (r < pq->size && lessThan(&pq->data[r], &pq->data[smallest], pq->cmp))
 8006258:	4576      	cmp	r6, lr
 800625a:	ddd6      	ble.n	800620a <pq_extractMin+0xca>
 800625c:	eb0e 014e 	add.w	r1, lr, lr, lsl #1
 8006260:	eb05 01c1 	add.w	r1, r5, r1, lsl #3
static inline int leftIdx(int i) { return (2*i + 1); }

static inline int rightIdx(int i) { return (2*i + 2); }

static inline bool lessThan(pq_data_t *d1, pq_data_t *d2, Comparator_t c){
  if(c == BASELINE)
 8006264:	2f00      	cmp	r7, #0
 8006266:	d0c3      	beq.n	80061f0 <pq_extractMin+0xb0>
    return (d1->baseline < d2->baseline);
  else
    return (d1->deadline < d2->deadline);
 8006268:	e9d1 6704 	ldrd	r6, r7, [r1, #16]
 800626c:	e9d8 0104 	ldrd	r0, r1, [r8, #16]
 8006270:	428f      	cmp	r7, r1
 8006272:	bf08      	it	eq
 8006274:	4286      	cmpeq	r6, r0
 8006276:	bf34      	ite	cc
 8006278:	2101      	movcc	r1, #1
 800627a:	2100      	movcs	r1, #0
 800627c:	e7c2      	b.n	8006204 <pq_extractMin+0xc4>
    int l = leftIdx(i);
    int r = rightIdx(i);
    int smallest = i;
    if (l < pq->size && lessThan(&pq->data[l], &pq->data[i], pq->cmp))
      smallest = l;
    if (r < pq->size && lessThan(&pq->data[r], &pq->data[smallest], pq->cmp))
 800627e:	2501      	movs	r5, #1
  pq->data[0] = pq->data[pq->size - 1];
  pq->size--;
  minHeapify(pq, 0);

  return 1;
}
 8006280:	4628      	mov	r0, r5
 8006282:	b007      	add	sp, #28
 8006284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

static inline bool lessThan(pq_data_t *d1, pq_data_t *d2, Comparator_t c){
  if(c == BASELINE)
    return (d1->baseline < d2->baseline);
  else
    return (d1->deadline < d2->deadline);
 8006288:	e9d1 0104 	ldrd	r0, r1, [r1, #16]
 800628c:	e9d8 ab04 	ldrd	sl, fp, [r8, #16]
 8006290:	458b      	cmp	fp, r1
 8006292:	bf08      	it	eq
 8006294:	4582      	cmpeq	sl, r0
 8006296:	bf34      	ite	cc
 8006298:	2101      	movcc	r1, #1
 800629a:	2100      	movcs	r1, #0
 800629c:	e795      	b.n	80061ca <pq_extractMin+0x8a>
    return -1;
  }

  if(pq->size == 1){
    pq->size--;
    *pq_data = pq->data[0];
 800629e:	6806      	ldr	r6, [r0, #0]
    DEBUG_PRINT(("Priority queue is empty\n"));
    return -1;
  }

  if(pq->size == 1){
    pq->size--;
 80062a0:	2300      	movs	r3, #0
 80062a2:	6083      	str	r3, [r0, #8]
    *pq_data = pq->data[0];
 80062a4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80062a6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80062a8:	e896 0003 	ldmia.w	r6, {r0, r1}
 80062ac:	e884 0003 	stmia.w	r4, {r0, r1}
  pq->data[0] = pq->data[pq->size - 1];
  pq->size--;
  minHeapify(pq, 0);

  return 1;
}
 80062b0:	4628      	mov	r0, r5
 80062b2:	b007      	add	sp, #28
 80062b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

int pq_extractMin(PriorityQ_t *pq, pq_data_t *pq_data){

  if(pq->size <= 0){
    DEBUG_PRINT(("Priority queue is empty\n"));
    return -1;
 80062b8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 80062bc:	e7e0      	b.n	8006280 <pq_extractMin+0x140>
 80062be:	bf00      	nop

080062c0 <sys_time_set_wake_up>:
uint32_t sys_time_get_clock_freq(void) {

  return counter_freq;
}

bool sys_time_set_wake_up(Time absolute) {
 80062c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80062c2:	4607      	mov	r7, r0
 80062c4:	460d      	mov	r5, r1
 80062c6:	2320      	movs	r3, #32
 80062c8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80062cc:	f7fe fdd0 	bl	8004e70 <_dbg_check_lock>

  chSysLock();
  uint32_t high_word = 0;

  alarm.alarm_time = absolute;
 80062d0:	4e1a      	ldr	r6, [pc, #104]	; (800633c <sys_time_set_wake_up+0x7c>)
  alarm.active = true;

  high_word = counter_high_word;
 80062d2:	4b1b      	ldr	r3, [pc, #108]	; (8006340 <sys_time_set_wake_up+0x80>)
bool sys_time_set_wake_up(Time absolute) {

  chSysLock();
  uint32_t high_word = 0;

  alarm.alarm_time = absolute;
 80062d4:	60f5      	str	r5, [r6, #12]
  alarm.active = true;

  high_word = counter_high_word;
 80062d6:	681c      	ldr	r4, [r3, #0]
bool sys_time_set_wake_up(Time absolute) {

  chSysLock();
  uint32_t high_word = 0;

  alarm.alarm_time = absolute;
 80062d8:	60b7      	str	r7, [r6, #8]
  alarm.active = true;

  high_word = counter_high_word;
  if (high_word == alarm.alarm_time >> 32) {
 80062da:	462a      	mov	r2, r5
 80062dc:	2300      	movs	r3, #0
 80062de:	2500      	movs	r5, #0
 80062e0:	429d      	cmp	r5, r3

  chSysLock();
  uint32_t high_word = 0;

  alarm.alarm_time = absolute;
  alarm.active = true;
 80062e2:	f04f 0101 	mov.w	r1, #1

  high_word = counter_high_word;
  if (high_word == alarm.alarm_time >> 32) {
 80062e6:	bf08      	it	eq
 80062e8:	4294      	cmpeq	r4, r2

  chSysLock();
  uint32_t high_word = 0;

  alarm.alarm_time = absolute;
  alarm.active = true;
 80062ea:	7031      	strb	r1, [r6, #0]

  high_word = counter_high_word;
  if (high_word == alarm.alarm_time >> 32) {
    if ((uint32_t)absolute < tim->CNT) {
 80062ec:	4b15      	ldr	r3, [pc, #84]	; (8006344 <sys_time_set_wake_up+0x84>)

  alarm.alarm_time = absolute;
  alarm.active = true;

  high_word = counter_high_word;
  if (high_word == alarm.alarm_time >> 32) {
 80062ee:	d017      	beq.n	8006320 <sys_time_set_wake_up+0x60>
    } else {
      tim->CCR[0] = (uint32_t)absolute; /* low 32 bits */
    }
    tim->DIER |= 0x2; /* enable interrups on CCR[0] */
  } else {
    tim->DIER &= ~0x2;
 80062f0:	681a      	ldr	r2, [r3, #0]
 80062f2:	68d3      	ldr	r3, [r2, #12]
 80062f4:	f023 0302 	bic.w	r3, r3, #2
 80062f8:	60d3      	str	r3, [r2, #12]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80062fa:	f7fe fda9 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80062fe:	4b12      	ldr	r3, [pc, #72]	; (8006348 <sys_time_set_wake_up+0x88>)
 8006300:	681a      	ldr	r2, [r3, #0]
 8006302:	429a      	cmp	r2, r3
 8006304:	d004      	beq.n	8006310 <sys_time_set_wake_up+0x50>
 8006306:	6999      	ldr	r1, [r3, #24]
 8006308:	6893      	ldr	r3, [r2, #8]
 800630a:	688a      	ldr	r2, [r1, #8]
 800630c:	429a      	cmp	r2, r3
 800630e:	d304      	bcc.n	800631a <sys_time_set_wake_up+0x5a>
 8006310:	2300      	movs	r3, #0
 8006312:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  //chprintf((BaseSequentialStream *)&SDU1, "alarm set at high word: %u\r\n", high_word);
  //chprintf((BaseSequentialStream *)&SDU1, "Now low word         : %u\r\n", low_word_now);
  //chprintf((BaseSequentialStream *)&SDU1, "alarm set at low word: %u\r\n", tim->CCR[0]);
  return true;
}
 8006316:	2001      	movs	r0, #1
 8006318:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800631a:	480c      	ldr	r0, [pc, #48]	; (800634c <sys_time_set_wake_up+0x8c>)
 800631c:	f7fe fd30 	bl	8004d80 <chSysHalt>
  alarm.alarm_time = absolute;
  alarm.active = true;

  high_word = counter_high_word;
  if (high_word == alarm.alarm_time >> 32) {
    if ((uint32_t)absolute < tim->CNT) {
 8006320:	681b      	ldr	r3, [r3, #0]
 8006322:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006324:	4297      	cmp	r7, r2
      tim->CCR[0] = tim->CNT + 1000;
 8006326:	bf37      	itett	cc
 8006328:	6a5a      	ldrcc	r2, [r3, #36]	; 0x24
    } else {
      tim->CCR[0] = (uint32_t)absolute; /* low 32 bits */
 800632a:	635f      	strcs	r7, [r3, #52]	; 0x34
  alarm.active = true;

  high_word = counter_high_word;
  if (high_word == alarm.alarm_time >> 32) {
    if ((uint32_t)absolute < tim->CNT) {
      tim->CCR[0] = tim->CNT + 1000;
 800632c:	f502 727a 	addcc.w	r2, r2, #1000	; 0x3e8
 8006330:	635a      	strcc	r2, [r3, #52]	; 0x34
    } else {
      tim->CCR[0] = (uint32_t)absolute; /* low 32 bits */
    }
    tim->DIER |= 0x2; /* enable interrups on CCR[0] */
 8006332:	68da      	ldr	r2, [r3, #12]
 8006334:	f042 0202 	orr.w	r2, r2, #2
 8006338:	60da      	str	r2, [r3, #12]
 800633a:	e7de      	b.n	80062fa <sys_time_set_wake_up+0x3a>
 800633c:	2000a300 	.word	0x2000a300
 8006340:	20004f50 	.word	0x20004f50
 8006344:	20000810 	.word	0x20000810
 8006348:	2000b68c 	.word	0x2000b68c
 800634c:	0800cf60 	.word	0x0800cf60

08006350 <sys_time_get_current_ticks>:
  
  OSAL_IRQ_EPILOGUE();
}


Time sys_time_get_current_ticks(void) {
 8006350:	b538      	push	{r3, r4, r5, lr}
 8006352:	2320      	movs	r3, #32
 8006354:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006358:	f7fe fd8a 	bl	8004e70 <_dbg_check_lock>
  /*   low_word = tim->CNT; */
  /*   high_word2 = counter_high_word; */
  /* } while (high_word != high_word2); /\* todo execute body at most twice *\/ */

  high_word = counter_high_word;
  low_word = tim->CNT;
 800635c:	4b0c      	ldr	r3, [pc, #48]	; (8006390 <sys_time_get_current_ticks+0x40>)
  /*   high_word = counter_high_word; */
  /*   low_word = tim->CNT; */
  /*   high_word2 = counter_high_word; */
  /* } while (high_word != high_word2); /\* todo execute body at most twice *\/ */

  high_word = counter_high_word;
 800635e:	4a0d      	ldr	r2, [pc, #52]	; (8006394 <sys_time_get_current_ticks+0x44>)
  low_word = tim->CNT;
 8006360:	681b      	ldr	r3, [r3, #0]
  /*   high_word = counter_high_word; */
  /*   low_word = tim->CNT; */
  /*   high_word2 = counter_high_word; */
  /* } while (high_word != high_word2); /\* todo execute body at most twice *\/ */

  high_word = counter_high_word;
 8006362:	6814      	ldr	r4, [r2, #0]
  low_word = tim->CNT;
 8006364:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006366:	f7fe fd73 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 800636a:	4b0b      	ldr	r3, [pc, #44]	; (8006398 <sys_time_get_current_ticks+0x48>)
 800636c:	681a      	ldr	r2, [r3, #0]
 800636e:	429a      	cmp	r2, r3
 8006370:	d004      	beq.n	800637c <sys_time_get_current_ticks+0x2c>
 8006372:	6999      	ldr	r1, [r3, #24]
 8006374:	6893      	ldr	r3, [r2, #8]
 8006376:	688a      	ldr	r2, [r1, #8]
 8006378:	429a      	cmp	r2, r3
 800637a:	d306      	bcc.n	800638a <sys_time_get_current_ticks+0x3a>
 800637c:	2300      	movs	r3, #0
 800637e:	f383 8811 	msr	BASEPRI, r3
  
  time = high_word;
  time <<= 32;
 8006382:	4618      	mov	r0, r3
 8006384:	4621      	mov	r1, r4
  time |= low_word;
  chSysUnlock();
  return time;
}
 8006386:	4328      	orrs	r0, r5
 8006388:	bd38      	pop	{r3, r4, r5, pc}
 800638a:	4804      	ldr	r0, [pc, #16]	; (800639c <sys_time_get_current_ticks+0x4c>)
 800638c:	f7fe fcf8 	bl	8004d80 <chSysHalt>
 8006390:	20000810 	.word	0x20000810
 8006394:	20004f50 	.word	0x20004f50
 8006398:	2000b68c 	.word	0x2000b68c
 800639c:	0800cf60 	.word	0x0800cf60

080063a0 <chibios_container_thread.lto_priv.63>:


/****************************/
/* Chibios container thread */

static THD_FUNCTION(chibios_container_thread, arg) {
 80063a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 80063a4:	f8df 9298 	ldr.w	r9, [pc, #664]	; 8006640 <chibios_container_thread.lto_priv.63+0x2a0>

  chibios_svm_thread_data_t *data = (chibios_svm_thread_data_t*)arg;
  vmc_t *container = data->container;
 80063a8:	6804      	ldr	r4, [r0, #0]
 80063aa:	f8d9 3018 	ldr.w	r3, [r9, #24]
 80063ae:	6842      	ldr	r2, [r0, #4]
 80063b0:	619a      	str	r2, [r3, #24]


/****************************/
/* Chibios container thread */

static THD_FUNCTION(chibios_container_thread, arg) {
 80063b2:	b09b      	sub	sp, #108	; 0x6c
  return r;
}

int vmc_run(vmc_t *container,void (*dbg_print)(const char *str, ...)) {

  dbg_print("vmc_run container address: %u\r\n", (uint32_t)container);
 80063b4:	4621      	mov	r1, r4
 80063b6:	4897      	ldr	r0, [pc, #604]	; (8006614 <chibios_container_thread.lto_priv.63+0x274>)
 80063b8:	f7ff fd3a 	bl	8005e30 <dbg_print>

  for (int i = 0; i < VMC_MAX_CONTEXTS; i++) {
    container->context_used[i] = false; //XXX: should move to vmc_init
 80063bc:	2600      	movs	r6, #0
  }

  INT pc = 0;
  /* Check valid code */
  uint32_t magic = 0;
  magic |= ((uint32_t)container->code_memory[pc++]) << 24; /* not sure this shifting works out */
 80063be:	6a61      	ldr	r1, [r4, #36]	; 0x24
int vmc_run(vmc_t *container,void (*dbg_print)(const char *str, ...)) {

  dbg_print("vmc_run container address: %u\r\n", (uint32_t)container);

  for (int i = 0; i < VMC_MAX_CONTEXTS; i++) {
    container->context_used[i] = false; //XXX: should move to vmc_init
 80063c0:	f884 60f0 	strb.w	r6, [r4, #240]	; 0xf0
 80063c4:	f884 60f1 	strb.w	r6, [r4, #241]	; 0xf1
 80063c8:	f884 60f2 	strb.w	r6, [r4, #242]	; 0xf2
 80063cc:	f884 60f3 	strb.w	r6, [r4, #243]	; 0xf3

  INT pc = 0;
  /* Check valid code */
  uint32_t magic = 0;
  magic |= ((uint32_t)container->code_memory[pc++]) << 24; /* not sure this shifting works out */
  magic |= ((uint32_t)container->code_memory[pc++]) << 16;
 80063d0:	784b      	ldrb	r3, [r1, #1]
  }

  INT pc = 0;
  /* Check valid code */
  uint32_t magic = 0;
  magic |= ((uint32_t)container->code_memory[pc++]) << 24; /* not sure this shifting works out */
 80063d2:	780f      	ldrb	r7, [r1, #0]
  magic |= ((uint32_t)container->code_memory[pc++]) << 16;
  magic |= ((uint32_t)container->code_memory[pc++]) << 8;
  magic |= ((uint32_t)container->code_memory[pc++]);
 80063d4:	78ca      	ldrb	r2, [r1, #3]
  INT pc = 0;
  /* Check valid code */
  uint32_t magic = 0;
  magic |= ((uint32_t)container->code_memory[pc++]) << 24; /* not sure this shifting works out */
  magic |= ((uint32_t)container->code_memory[pc++]) << 16;
  magic |= ((uint32_t)container->code_memory[pc++]) << 8;
 80063d6:	788d      	ldrb	r5, [r1, #2]
  magic |= ((uint32_t)container->code_memory[pc++]);


  /* feedcafe: 4276996862 */
  dbg_print("magic: %u\r\n", magic);
 80063d8:	488f      	ldr	r0, [pc, #572]	; (8006618 <chibios_container_thread.lto_priv.63+0x278>)

  INT pc = 0;
  /* Check valid code */
  uint32_t magic = 0;
  magic |= ((uint32_t)container->code_memory[pc++]) << 24; /* not sure this shifting works out */
  magic |= ((uint32_t)container->code_memory[pc++]) << 16;
 80063da:	041b      	lsls	r3, r3, #16
 80063dc:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 80063e0:	4313      	orrs	r3, r2
  magic |= ((uint32_t)container->code_memory[pc++]) << 8;
  magic |= ((uint32_t)container->code_memory[pc++]);
 80063e2:	ea43 2505 	orr.w	r5, r3, r5, lsl #8


  /* feedcafe: 4276996862 */
  dbg_print("magic: %u\r\n", magic);
 80063e6:	4629      	mov	r1, r5
 80063e8:	f7ff fd22 	bl	8005e30 <dbg_print>
  if (magic != 0xFEEDCAFE) return 0;
 80063ec:	4b8b      	ldr	r3, [pc, #556]	; (800661c <chibios_container_thread.lto_priv.63+0x27c>)
 80063ee:	429d      	cmp	r5, r3
 80063f0:	d002      	beq.n	80063f8 <chibios_container_thread.lto_priv.63+0x58>
  /* TODO read_message_poll */
  scheduler(container, NULL, read_message_block, mailbox_num_used);

  /* If we return to here, do something in relation to the
     return value of the scheduler function.*/
}
 80063f2:	b01b      	add	sp, #108	; 0x6c
 80063f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* uint8_t version = container->code_memory[pc++]; */
  pc++;

  uint16_t pool_size_ints;
  pool_size_ints = container->code_memory[pc++] << 8;
 80063f8:	6a65      	ldr	r5, [r4, #36]	; 0x24
  container->context_used[0] = true;
  container->current_running_context_id = 0;
  container->all_contexts_stopped = false;


  dbg_print("vmc_run executing ctx: %d\r\n", container->current_running_context_id);
 80063fa:	4889      	ldr	r0, [pc, #548]	; (8006620 <chibios_container_thread.lto_priv.63+0x280>)

  /* uint8_t version = container->code_memory[pc++]; */
  pc++;

  uint16_t pool_size_ints;
  pool_size_ints = container->code_memory[pc++] << 8;
 80063fc:	796a      	ldrb	r2, [r5, #5]
  pool_size_ints |= container->code_memory[pc++];
 80063fe:	79ab      	ldrb	r3, [r5, #6]

  pc += (pool_size_ints * 4);
 8006400:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006404:	009b      	lsls	r3, r3, #2

  uint16_t pool_size_strings;
  pool_size_strings = container->code_memory[pc++] << 8;
 8006406:	18ea      	adds	r2, r5, r3
  pool_size_strings |= container->code_memory[pc++];
 8006408:	f103 0109 	add.w	r1, r3, #9
  pool_size_ints |= container->code_memory[pc++];

  pc += (pool_size_ints * 4);

  uint16_t pool_size_strings;
  pool_size_strings = container->code_memory[pc++] << 8;
 800640c:	79d3      	ldrb	r3, [r2, #7]
  pool_size_strings |= container->code_memory[pc++];
 800640e:	7a12      	ldrb	r2, [r2, #8]

  pc += pool_size_strings;
 8006410:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 8006414:	440b      	add	r3, r1

  uint16_t pool_size_native;
  pool_size_native = container->code_memory[pc++] << 8;
  pool_size_native |= container->code_memory[pc++];
 8006416:	18ea      	adds	r2, r5, r3
  pool_size_strings |= container->code_memory[pc++];

  pc += pool_size_strings;

  uint16_t pool_size_native;
  pool_size_native = container->code_memory[pc++] << 8;
 8006418:	5ced      	ldrb	r5, [r5, r3]
  pool_size_native |= container->code_memory[pc++];
 800641a:	7852      	ldrb	r2, [r2, #1]
  /* Experiments with the scheduler */
  cam_value_t v_empty = get_cam_val(0,0);


  /* Set up the parent context to be active */
  container->contexts[0].env = v_empty;
 800641c:	8626      	strh	r6, [r4, #48]	; 0x30

  uint16_t pool_size_native;
  pool_size_native = container->code_memory[pc++] << 8;
  pool_size_native |= container->code_memory[pc++];

  pc += (pool_size_native * 4);
 800641e:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
 8006422:	eb03 0385 	add.w	r3, r3, r5, lsl #2
  /* Set up the parent context to be active */
  container->contexts[0].env = v_empty;
  container->contexts[0].pc  = pc;
  container->context_used[0] = true;
  container->current_running_context_id = 0;
  container->all_contexts_stopped = false;
 8006426:	f241 4248 	movw	r2, #5192	; 0x1448

  uint32_t code_size;
  code_size = container->code_memory[pc++]  << 24;
  code_size |= container->code_memory[pc++] << 16;
  code_size |= container->code_memory[pc++] << 8;
  code_size |= container->code_memory[pc++];
 800642a:	1d9d      	adds	r5, r3, #6


  /* Set up the parent context to be active */
  container->contexts[0].env = v_empty;
  container->contexts[0].pc  = pc;
  container->context_used[0] = true;
 800642c:	2301      	movs	r3, #1
  cam_value_t v_empty = get_cam_val(0,0);


  /* Set up the parent context to be active */
  container->contexts[0].env = v_empty;
  container->contexts[0].pc  = pc;
 800642e:	63a5      	str	r5, [r4, #56]	; 0x38
  /* Experiments with the scheduler */
  cam_value_t v_empty = get_cam_val(0,0);


  /* Set up the parent context to be active */
  container->contexts[0].env = v_empty;
 8006430:	6366      	str	r6, [r4, #52]	; 0x34
  container->contexts[0].pc  = pc;
  container->context_used[0] = true;
  container->current_running_context_id = 0;
 8006432:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
  container->all_contexts_stopped = false;


  dbg_print("vmc_run executing ctx: %d\r\n", container->current_running_context_id);
 8006436:	4631      	mov	r1, r6
  /* Set up the parent context to be active */
  container->contexts[0].env = v_empty;
  container->contexts[0].pc  = pc;
  container->context_used[0] = true;
  container->current_running_context_id = 0;
  container->all_contexts_stopped = false;
 8006438:	54a6      	strb	r6, [r4, r2]


  /* Set up the parent context to be active */
  container->contexts[0].env = v_empty;
  container->contexts[0].pc  = pc;
  container->context_used[0] = true;
 800643a:	f884 30f0 	strb.w	r3, [r4, #240]	; 0xf0
  container->current_running_context_id = 0;
  container->all_contexts_stopped = false;


  dbg_print("vmc_run executing ctx: %d\r\n", container->current_running_context_id);
 800643e:	f7ff fcf7 	bl	8005e30 <dbg_print>
  dbg_print("vmc_run ctx pc: %d\r\n", container->contexts[container->current_running_context_id].pc);
 8006442:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8006446:	4877      	ldr	r0, [pc, #476]	; (8006624 <chibios_container_thread.lto_priv.63+0x284>)
 8006448:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800644c:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  //        }
  //     }

  // Step 1. Pick the top of the waitQ, time to schedule it.
  pq_data_t timedThread;
  int i = pq_extractMin(&vmc->waitQ, &timedThread);
 8006450:	f504 5b91 	add.w	fp, r4, #4640	; 0x1220
 8006454:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8006456:	f7ff fceb 	bl	8005e30 <dbg_print>
  dbg_print("vmc_run current env: %u\r\n", container->contexts[container->current_running_context_id].env.value);
 800645a:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 800645e:	4872      	ldr	r0, [pc, #456]	; (8006628 <chibios_container_thread.lto_priv.63+0x288>)
 8006460:	3301      	adds	r3, #1
 8006462:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8006466:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800646a:	f504 58a2 	add.w	r8, r4, #5184	; 0x1440
 800646e:	6859      	ldr	r1, [r3, #4]
 8006470:	f7ff fcde 	bl	8005e30 <dbg_print>
  dbg_print("vmc_run current instr: 0x%x\r\n", container->code_memory[pc]);
 8006474:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006476:	486d      	ldr	r0, [pc, #436]	; (800662c <chibios_container_thread.lto_priv.63+0x28c>)
 8006478:	5d59      	ldrb	r1, [r3, r5]
 800647a:	f7ff fcd9 	bl	8005e30 <dbg_print>

  (void)poll_msg;

  svm_msg_t msg;

  dbg_print("Entered Scheduler\r\n");
 800647e:	486c      	ldr	r0, [pc, #432]	; (8006630 <chibios_container_thread.lto_priv.63+0x290>)
 8006480:	f7ff fcd6 	bl	8005e30 <dbg_print>
  dbg_print("container address: %u\r\n", (uint32_t)container);
 8006484:	4621      	mov	r1, r4
 8006486:	486b      	ldr	r0, [pc, #428]	; (8006634 <chibios_container_thread.lto_priv.63+0x294>)
 8006488:	f7ff fcd2 	bl	8005e30 <dbg_print>
  }
}


static void initLogicalTime(vmc_t *vmc){
  Time currentTicks = sys_time_get_current_ticks();
 800648c:	f7ff ff60 	bl	8006350 <sys_time_get_current_ticks>
    } else {

      // Currently running thread's deadline is earlier or the same

      // Step 5.3 Put the timed thread in rdyQ
      int r = pq_insert(&vmc->rdyQ, timedThread);
 8006490:	465b      	mov	r3, fp
  for(int i = 0; i < VMC_MAX_CONTEXTS; i ++){
    vmc->contexts[i].logicalTime = currentTicks;
 8006492:	e9c4 0114 	strd	r0, r1, [r4, #80]	; 0x50
 8006496:	e9c4 0120 	strd	r0, r1, [r4, #128]	; 0x80
 800649a:	e9c4 012c 	strd	r0, r1, [r4, #176]	; 0xb0
 800649e:	e9c4 0138 	strd	r0, r1, [r4, #224]	; 0xe0

static int read_message_block(vmc_t* vmc, svm_msg_t *msg) {

  msg_t msg_value;

  chibios_interop_t* interop = (chibios_interop_t*)vmc->backend_custom;
 80064a2:	46c2      	mov	sl, r8
 80064a4:	3304      	adds	r3, #4
 80064a6:	f108 0808 	add.w	r8, r8, #8
 80064aa:	f10a 0a04 	add.w	sl, sl, #4
  //        }
  //     }

  // Step 1. Pick the top of the waitQ, time to schedule it.
  pq_data_t timedThread;
  int i = pq_extractMin(&vmc->waitQ, &timedThread);
 80064ae:	f10b 0b14 	add.w	fp, fp, #20
    } else {

      // Currently running thread's deadline is earlier or the same

      // Step 5.3 Put the timed thread in rdyQ
      int r = pq_insert(&vmc->rdyQ, timedThread);
 80064b2:	9307      	str	r3, [sp, #28]
    /* 		stack_get_sp(&container->contexts[container->current_running_context_id].stack)); */
    /* } */

    //dbg_print("CURRENT_ID: %u\r\n", container->current_running_context_id);

    if(container->all_contexts_stopped){
 80064b4:	f898 3000 	ldrb.w	r3, [r8]
 80064b8:	2b00      	cmp	r3, #0
 80064ba:	f040 808e 	bne.w	80065da <chibios_container_thread.lto_priv.63+0x23a>
    */

    //bool activation = false; 
    
    /* If we are doing nothing, block on the message queue */
    if (container->current_running_context_id == UUID_NONE) {
 80064be:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80064c2:	2bff      	cmp	r3, #255	; 0xff
 80064c4:	d018      	beq.n	80064f8 <chibios_container_thread.lto_priv.63+0x158>
    }

    /* If a context is running do this... */
    if (container->current_running_context_id != UUID_NONE) {

      INT *pc = (INT *)&container->contexts[container->current_running_context_id].pc;
 80064c6:	eb03 0543 	add.w	r5, r3, r3, lsl #1
 80064ca:	012d      	lsls	r5, r5, #4
 80064cc:	3538      	adds	r5, #56	; 0x38
      /* dbg_print("current instr: 0x%x  [Dec: %u]\r\n", container->code_memory[*pc], container->code_memory[*pc]); */
      /* dbg_print("sizeof(evaluators) = %d\r\n", sizeof(evaluators)); */

      /* Execute an instruction */

      uint8_t current_inst = container->code_memory[*pc];
 80064ce:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80064d0:	5962      	ldr	r2, [r4, r5]
 80064d2:	5c8e      	ldrb	r6, [r1, r2]
      /*   DEBUG_PRINT(("%u %u\n", current_inst, next_inst)); */
      /* } else { */
      /*   DEBUG_PRINT(("%u\n", current_inst)); */
      /* } */

      if (current_inst > (sizeof(evaluators) / 4)) {
 80064d4:	2e38      	cmp	r6, #56	; 0x38
    }

    /* If a context is running do this... */
    if (container->current_running_context_id != UUID_NONE) {

      INT *pc = (INT *)&container->contexts[container->current_running_context_id].pc;
 80064d6:	eb04 0105 	add.w	r1, r4, r5
      /*   DEBUG_PRINT(("%u %u\n", current_inst, next_inst)); */
      /* } else { */
      /*   DEBUG_PRINT(("%u\n", current_inst)); */
      /* } */

      if (current_inst > (sizeof(evaluators) / 4)) {
 80064da:	f200 8168 	bhi.w	80067ae <chibios_container_thread.lto_priv.63+0x40e>
#ifdef TRACE_ON
	trace_print(dbg_print, 25);
#endif
	return -1;
      } else {
        evaluators[current_inst](container, pc);
 80064de:	4b56      	ldr	r3, [pc, #344]	; (8006638 <chibios_container_thread.lto_priv.63+0x298>)
 80064e0:	4620      	mov	r0, r4
 80064e2:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 80064e6:	4798      	blx	r3
      }

      if(*pc  == -1){
 80064e8:	5963      	ldr	r3, [r4, r5]
 80064ea:	3301      	adds	r3, #1
 80064ec:	d1e2      	bne.n	80064b4 <chibios_container_thread.lto_priv.63+0x114>
        dbg_print("Instruction %u failed",current_inst);
 80064ee:	4631      	mov	r1, r6
 80064f0:	4852      	ldr	r0, [pc, #328]	; (800663c <chibios_container_thread.lto_priv.63+0x29c>)
 80064f2:	f7ff fc9d 	bl	8005e30 <dbg_print>
 80064f6:	e77c      	b.n	80063f2 <chibios_container_thread.lto_priv.63+0x52>
 80064f8:	f8da 7000 	ldr.w	r7, [sl]
 80064fc:	2320      	movs	r3, #32
  int r = chMBFetchTimeout(interop->mb, &msg_value, TIME_INFINITE);
 80064fe:	687d      	ldr	r5, [r7, #4]
 8006500:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006504:	f7fe fcb4 	bl	8004e70 <_dbg_check_lock>
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
 8006508:	f7fb feea 	bl	80022e0 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 800650c:	2d00      	cmp	r5, #0
 800650e:	f000 812f 	beq.w	8006770 <chibios_container_thread.lto_priv.63+0x3d0>

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8006512:	f105 0620 	add.w	r6, r5, #32
 8006516:	e00b      	b.n	8006530 <chibios_container_thread.lto_priv.63+0x190>
 *
 * @iclass
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();
 8006518:	f7fb ff1a 	bl	8002350 <chDbgCheckClassI>

  return mbp->cnt;
 800651c:	692b      	ldr	r3, [r5, #16]
    if (mbp->reset) {
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 800651e:	2b00      	cmp	r3, #0
 8006520:	d144      	bne.n	80065ac <chibios_container_thread.lto_priv.63+0x20c>

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8006522:	4630      	mov	r0, r6
 8006524:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8006528:	f7fc f81a 	bl	8002560 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 800652c:	2800      	cmp	r0, #0
 800652e:	d152      	bne.n	80065d6 <chibios_container_thread.lto_priv.63+0x236>
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8006530:	7d2b      	ldrb	r3, [r5, #20]
 8006532:	2b00      	cmp	r3, #0
 8006534:	d0f0      	beq.n	8006518 <chibios_container_thread.lto_priv.63+0x178>
      return MSG_RESET;
 8006536:	f06f 0501 	mvn.w	r5, #1
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800653a:	f7fe fc89 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 800653e:	f8d9 3000 	ldr.w	r3, [r9]
 8006542:	454b      	cmp	r3, r9
 8006544:	d005      	beq.n	8006552 <chibios_container_thread.lto_priv.63+0x1b2>
 8006546:	4a3e      	ldr	r2, [pc, #248]	; (8006640 <chibios_container_thread.lto_priv.63+0x2a0>)
 8006548:	689b      	ldr	r3, [r3, #8]
 800654a:	6992      	ldr	r2, [r2, #24]
 800654c:	6892      	ldr	r2, [r2, #8]
 800654e:	429a      	cmp	r2, r3
 8006550:	d329      	bcc.n	80065a6 <chibios_container_thread.lto_priv.63+0x206>
 8006552:	2300      	movs	r3, #0
 8006554:	f383 8811 	msr	BASEPRI, r3

  if (r == MSG_OK ) {
 8006558:	b93d      	cbnz	r5, 800656a <chibios_container_thread.lto_priv.63+0x1ca>

    *msg = *(svm_msg_t*)msg_value;
 800655a:	9906      	ldr	r1, [sp, #24]

    chPoolFree(interop->msg_pool, (void*)msg_value);
 800655c:	6838      	ldr	r0, [r7, #0]
  chibios_interop_t* interop = (chibios_interop_t*)vmc->backend_custom;
  int r = chMBFetchTimeout(interop->mb, &msg_value, TIME_INFINITE);

  if (r == MSG_OK ) {

    *msg = *(svm_msg_t*)msg_value;
 800655e:	680b      	ldr	r3, [r1, #0]
 8006560:	9304      	str	r3, [sp, #16]
 8006562:	688b      	ldr	r3, [r1, #8]
 8006564:	9305      	str	r3, [sp, #20]

    chPoolFree(interop->msg_pool, (void*)msg_value);
 8006566:	f7fc f98b 	bl	8002880 <chPoolFree>

}

int handle_msg(vmc_t *vmc, svm_msg_t *m){

  if (m->sender_id == 255) // Timer interrupt
 800656a:	9b04      	ldr	r3, [sp, #16]
 800656c:	2bff      	cmp	r3, #255	; 0xff
 800656e:	d06d      	beq.n	800664c <chibios_container_thread.lto_priv.63+0x2ac>
}


static int handle_driver_msg(vmc_t *vmc, svm_msg_t *m){

  UUID chan_id = vmc->drivers[m->sender_id].channel_id;
 8006570:	9b04      	ldr	r3, [sp, #16]
 8006572:	eb04 1343 	add.w	r3, r4, r3, lsl #5
 8006576:	f503 5392 	add.w	r3, r3, #4672	; 0x1240
  cam_value_t msg = { .value = m->data, .flags = 0 };

  // The following code is a barebones version of what `sync` does
  recv_data_t recv_data;//recv_context_id;
  int deq_status =
    chan_recv_q_dequeue(&vmc->channels[chan_id].recvq, &recv_data);
 800657a:	202c      	movs	r0, #44	; 0x2c
}


static int handle_driver_msg(vmc_t *vmc, svm_msg_t *m){

  UUID chan_id = vmc->drivers[m->sender_id].channel_id;
 800657c:	f893 5020 	ldrb.w	r5, [r3, #32]

  //XXX: Logic here to decide if the arrived message is
  //     the entire message or the pointer to a location to read
  cam_value_t msg = { .value = m->data, .flags = 0 };
 8006580:	9b05      	ldr	r3, [sp, #20]
 8006582:	930f      	str	r3, [sp, #60]	; 0x3c

  // The following code is a barebones version of what `sync` does
  recv_data_t recv_data;//recv_context_id;
  int deq_status =
    chan_recv_q_dequeue(&vmc->channels[chan_id].recvq, &recv_data);
 8006584:	fb00 4005 	mla	r0, r0, r5, r4
  //     the entire message or the pointer to a location to read
  cam_value_t msg = { .value = m->data, .flags = 0 };

  // The following code is a barebones version of what `sync` does
  recv_data_t recv_data;//recv_context_id;
  int deq_status =
 8006588:	f500 7084 	add.w	r0, r0, #264	; 0x108

  UUID chan_id = vmc->drivers[m->sender_id].channel_id;

  //XXX: Logic here to decide if the arrived message is
  //     the entire message or the pointer to a location to read
  cam_value_t msg = { .value = m->data, .flags = 0 };
 800658c:	2700      	movs	r7, #0

  // The following code is a barebones version of what `sync` does
  recv_data_t recv_data;//recv_context_id;
  int deq_status =
 800658e:	a914      	add	r1, sp, #80	; 0x50

  UUID chan_id = vmc->drivers[m->sender_id].channel_id;

  //XXX: Logic here to decide if the arrived message is
  //     the entire message or the pointer to a location to read
  cam_value_t msg = { .value = m->data, .flags = 0 };
 8006590:	f8ad 7038 	strh.w	r7, [sp, #56]	; 0x38

  // The following code is a barebones version of what `sync` does
  recv_data_t recv_data;//recv_context_id;
  int deq_status =
 8006594:	f002 fb64 	bl	8008c60 <chan_recv_q_dequeue>
    chan_recv_q_dequeue(&vmc->channels[chan_id].recvq, &recv_data);
  if(deq_status == -1){ //empty queue
 8006598:	3001      	adds	r0, #1
 800659a:	d122      	bne.n	80065e2 <chibios_container_thread.lto_priv.63+0x242>
      /*   /\* enqueue processes *\/ */
      /* } */
    }

    /* If a context is running do this... */
    if (container->current_running_context_id != UUID_NONE) {
 800659c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80065a0:	2bff      	cmp	r3, #255	; 0xff
 80065a2:	d087      	beq.n	80064b4 <chibios_container_thread.lto_priv.63+0x114>
 80065a4:	e78f      	b.n	80064c6 <chibios_container_thread.lto_priv.63+0x126>
 80065a6:	4827      	ldr	r0, [pc, #156]	; (8006644 <chibios_container_thread.lto_priv.63+0x2a4>)
 80065a8:	f7fe fbea 	bl	8004d80 <chSysHalt>
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
      *msgp = *mbp->rdptr++;
 80065ac:	68ea      	ldr	r2, [r5, #12]
      if (mbp->rdptr >= mbp->top) {
 80065ae:	6869      	ldr	r1, [r5, #4]
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
      *msgp = *mbp->rdptr++;
 80065b0:	6810      	ldr	r0, [r2, #0]
 80065b2:	9006      	str	r0, [sp, #24]
 80065b4:	3204      	adds	r2, #4
      if (mbp->rdptr >= mbp->top) {
 80065b6:	428a      	cmp	r2, r1
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
      *msgp = *mbp->rdptr++;
 80065b8:	60ea      	str	r2, [r5, #12]
      if (mbp->rdptr >= mbp->top) {
        mbp->rdptr = mbp->buffer;
      }
      mbp->cnt--;
 80065ba:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
      *msgp = *mbp->rdptr++;
      if (mbp->rdptr >= mbp->top) {
        mbp->rdptr = mbp->buffer;
 80065be:	bf24      	itt	cs
 80065c0:	682a      	ldrcs	r2, [r5, #0]
 80065c2:	60ea      	strcs	r2, [r5, #12]
      }
      mbp->cnt--;
 80065c4:	612b      	str	r3, [r5, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 80065c6:	f105 0018 	add.w	r0, r5, #24
 80065ca:	f001 fc49 	bl	8007e60 <chThdDequeueNextI.constprop.55>
      chSchRescheduleS();

      return MSG_OK;
 80065ce:	2500      	movs	r5, #0
      }
      mbp->cnt--;

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
      chSchRescheduleS();
 80065d0:	f7fc f82e 	bl	8002630 <chSchRescheduleS>
 80065d4:	e7b1      	b.n	800653a <chibios_container_thread.lto_priv.63+0x19a>
      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
  } while (rdymsg == MSG_OK);
 80065d6:	4605      	mov	r5, r0
 80065d8:	e7af      	b.n	800653a <chibios_container_thread.lto_priv.63+0x19a>
        return -1; // error
      }
    }
  }
  /* end */
  dbg_print("Closing down scheduler\r\n");
 80065da:	481b      	ldr	r0, [pc, #108]	; (8006648 <chibios_container_thread.lto_priv.63+0x2a8>)
 80065dc:	f7ff fc28 	bl	8005e30 <dbg_print>
 80065e0:	e707      	b.n	80063f2 <chibios_container_thread.lto_priv.63+0x52>
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 80065e2:	6823      	ldr	r3, [r4, #0]
  heap->value_flags[i].fst = value.flags;
 80065e4:	6960      	ldr	r0, [r4, #20]
  /*   return -(int)UUID_NONE; */
  /* } */

  cam_value_t true_flag = { .value = 1, .flags = 0 };
  heap_set_fst(  &vmc->heap
		 , (heap_index)recv_data.dirty_flag_pointer.value
 80065e6:	9916      	ldr	r1, [sp, #88]	; 0x58
    // we ignore the message and let the scheduler continue
    // blocking; See scheduler.c
    return 2;
  }

  UUID recv_context_id = recv_data.context_id;
 80065e8:	f89d 6050 	ldrb.w	r6, [sp, #80]	; 0x50
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 80065ec:	2201      	movs	r2, #1
 80065ee:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
  heap->value_flags[i].fst = value.flags;
 80065f2:	f820 7021 	strh.w	r7, [r0, r1, lsl #2]



  /* NOTE Message passing begins */

  int k = message_pass( vmc
 80065f6:	ab0e      	add	r3, sp, #56	; 0x38
 80065f8:	9201      	str	r2, [sp, #4]
 80065fa:	9500      	str	r5, [sp, #0]
 80065fc:	cb0c      	ldmia	r3, {r2, r3}
 80065fe:	4631      	mov	r1, r6
 8006600:	4620      	mov	r0, r4
 8006602:	f001 feb5 	bl	8008370 <message_pass.constprop.17>
                      , msg
                      , chan_id
                      , RECV
                      , SCHEDULED_FIRST);// the receiving thread was scheduled first but
                                         // the interrupt arrived later
  if(k == -1){
 8006606:	3001      	adds	r0, #1
 8006608:	f000 80df 	beq.w	80067ca <chibios_container_thread.lto_priv.63+0x42a>

  /* NOTE Message passing ends */


  // the receiving thread will run now
  vmc->current_running_context_id = recv_context_id;
 800660c:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
 8006610:	e7c4      	b.n	800659c <chibios_container_thread.lto_priv.63+0x1fc>
 8006612:	bf00      	nop
 8006614:	0800d048 	.word	0x0800d048
 8006618:	0800d068 	.word	0x0800d068
 800661c:	feedcafe 	.word	0xfeedcafe
 8006620:	0800d074 	.word	0x0800d074
 8006624:	0800d090 	.word	0x0800d090
 8006628:	0800d0a8 	.word	0x0800d0a8
 800662c:	0800d0c4 	.word	0x0800d0c4
 8006630:	0800d0e4 	.word	0x0800d0e4
 8006634:	0800d050 	.word	0x0800d050
 8006638:	20000814 	.word	0x20000814
 800663c:	0800d14c 	.word	0x0800d14c
 8006640:	2000b68c 	.word	0x2000b68c
 8006644:	0800d1f8 	.word	0x0800d1f8
 8006648:	0800d164 	.word	0x0800d164
  //        }
  //     }

  // Step 1. Pick the top of the waitQ, time to schedule it.
  pq_data_t timedThread;
  int i = pq_extractMin(&vmc->waitQ, &timedThread);
 800664c:	a90e      	add	r1, sp, #56	; 0x38
 800664e:	4658      	mov	r0, fp
 8006650:	f7ff fd76 	bl	8006140 <pq_extractMin>
  if (i == -1){
 8006654:	3001      	adds	r0, #1
 8006656:	f000 80af 	beq.w	80067b8 <chibios_container_thread.lto_priv.63+0x418>

  Time time_now = timedThread.baseline;

  //Step 2. Increment logical time of the thread for which the interrupt
  //        arrived
  vmc->contexts[timedThread.context_id].logicalTime = time_now;
 800665a:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38

  return 1;
}
int pq_getMin(PriorityQ_t *pq, pq_data_t *pq_data){

  if(pq_isEmpty(pq)){
 800665e:	f8db 2008 	ldr.w	r2, [fp, #8]
  if (i == -1){
    DEBUG_PRINT(("Cannot dequeue from wait queue \n"));
    return -3;
  }

  Time time_now = timedThread.baseline;
 8006662:	e9dd 6710 	ldrd	r6, r7, [sp, #64]	; 0x40

  //Step 2. Increment logical time of the thread for which the interrupt
  //        arrived
  vmc->contexts[timedThread.context_id].logicalTime = time_now;
 8006666:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800666a:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800666e:	e9c3 6714 	strd	r6, r7, [r3, #80]	; 0x50
 8006672:	2a00      	cmp	r2, #0
 8006674:	d04c      	beq.n	8006710 <chibios_container_thread.lto_priv.63+0x370>
    DEBUG_PRINT(("Priority queue is empty\n"));
    return -1;
  }

  *pq_data = pq->data[0];
 8006676:	f8db 3000 	ldr.w	r3, [fp]
 800667a:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800667e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8006682:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8006686:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28

    // if there are waiting threads then set alarm / put them in rdyQ

    //Step 3.1  If the following condition hold put timedThread2 in the rdyQ
    //          it is ready to run; no need to set alarm
    Time actualTime = sys_time_get_current_ticks();
 800668a:	f7ff fe61 	bl	8006350 <sys_time_get_current_ticks>
    bool cond1 = actualTime > timedThread2.deadline;
    bool cond2 = (actualTime >= timedThread2.baseline) &&
 800668e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8006692:	4299      	cmp	r1, r3
 8006694:	bf08      	it	eq
 8006696:	4290      	cmpeq	r0, r2
 8006698:	d215      	bcs.n	80066c6 <chibios_container_thread.lto_priv.63+0x326>
      (actualTime <= timedThread2.deadline);
    bool cond3 = (actualTime - timedThread2.baseline)  < SET_ALARM_AFTER;
 800669a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800669e:	1a82      	subs	r2, r0, r2
 80066a0:	eb61 0303 	sbc.w	r3, r1, r3
 80066a4:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    if(cond1 || cond2 || cond3){
 80066a8:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 80066ac:	428b      	cmp	r3, r1
 80066ae:	bf08      	it	eq
 80066b0:	4282      	cmpeq	r2, r0
 80066b2:	d308      	bcc.n	80066c6 <chibios_container_thread.lto_priv.63+0x326>
 80066b4:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80066b8:	2100      	movs	r1, #0
 80066ba:	f247 502f 	movw	r0, #29999	; 0x752f
 80066be:	4299      	cmp	r1, r3
 80066c0:	bf08      	it	eq
 80066c2:	4290      	cmpeq	r0, r2
 80066c4:	d37b      	bcc.n	80067be <chibios_container_thread.lto_priv.63+0x41e>

      // pop it from waitQ
      pq_data_t timedThread2Popped;
      int j = pq_extractMin(&vmc->waitQ, &timedThread2Popped);
 80066c6:	ad14      	add	r5, sp, #80	; 0x50
 80066c8:	4629      	mov	r1, r5
 80066ca:	4658      	mov	r0, fp
 80066cc:	f7ff fd38 	bl	8006140 <pq_extractMin>
      if (j == -1){
 80066d0:	3001      	adds	r0, #1
 80066d2:	d069      	beq.n	80067a8 <chibios_container_thread.lto_priv.63+0x408>
        DEBUG_PRINT(("Cannot dequeue from wait queue \n"));
        return -4;
      }

      int k = pq_insert(&vmc->rdyQ, timedThread2Popped);
 80066d4:	ab1a      	add	r3, sp, #104	; 0x68
 80066d6:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 80066da:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 80066de:	9807      	ldr	r0, [sp, #28]
 80066e0:	e895 000c 	ldmia.w	r5, {r2, r3}
 80066e4:	f001 ffc4 	bl	8008670 <pq_insert>
      if(k == -1){
 80066e8:	1c41      	adds	r1, r0, #1
 80066ea:	d058      	beq.n	800679e <chibios_container_thread.lto_priv.63+0x3fe>
      }
      time_now = timedThread2Popped.baseline;

      //Update clocks

      vmc->contexts[timedThread.context_id].logicalTime = time_now;
 80066ec:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
      int k = pq_insert(&vmc->rdyQ, timedThread2Popped);
      if(k == -1){
        DEBUG_PRINT(("Cannot enqueue in rdyQ \n"));
        return k;
      }
      time_now = timedThread2Popped.baseline;
 80066f0:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	; 0x58

      //Update clocks

      vmc->contexts[timedThread.context_id].logicalTime = time_now;
 80066f4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80066f8:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 80066fc:	e9c3 6714 	strd	r6, r7, [r3, #80]	; 0x50

      vmc->contexts[timedThread2Popped.context_id].logicalTime = time_now;
 8006700:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 8006704:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8006708:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800670c:	e9c3 6714 	strd	r6, r7, [r3, #80]	; 0x50
    // Proceed onwards
  }

  //Step 4. If no threads are running schedule the thread
  //        for which the interrupt arrived
  if(vmc->current_running_context_id == UUID_NONE){
 8006710:	f894 502c 	ldrb.w	r5, [r4, #44]	; 0x2c
 8006714:	2dff      	cmp	r5, #255	; 0xff
 8006716:	d01e      	beq.n	8006756 <chibios_container_thread.lto_priv.63+0x3b6>
    // Some thread is running

    //Step 5. Compare deadlines and accordingly schedule

    if(timedThread.deadline <
       vmc->contexts[vmc->current_running_context_id].deadline){
 8006718:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 800671c:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 8006720:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	; 0x58
  } else {
    // Some thread is running

    //Step 5. Compare deadlines and accordingly schedule

    if(timedThread.deadline <
 8006724:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8006728:	428b      	cmp	r3, r1
 800672a:	bf08      	it	eq
 800672c:	4282      	cmpeq	r2, r0
 800672e:	d222      	bcs.n	8006776 <chibios_container_thread.lto_priv.63+0x3d6>
       vmc->contexts[vmc->current_running_context_id].deadline){

      // Step 5.1. Put the current thread to rdyQ
      pq_data_t currentThreadInfo =
 8006730:	e9cd 6716 	strd	r6, r7, [sp, #88]	; 0x58
 8006734:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
        {   .context_id = vmc->current_running_context_id
          , .baseline = time_now // the current logical time
          , .deadline = vmc->contexts[vmc->current_running_context_id].deadline
        };
      int z = pq_insert(&vmc->rdyQ, currentThreadInfo);
 8006738:	ab1a      	add	r3, sp, #104	; 0x68
 800673a:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 800673e:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}

    if(timedThread.deadline <
       vmc->contexts[vmc->current_running_context_id].deadline){

      // Step 5.1. Put the current thread to rdyQ
      pq_data_t currentThreadInfo =
 8006742:	f88d 5050 	strb.w	r5, [sp, #80]	; 0x50
        {   .context_id = vmc->current_running_context_id
          , .baseline = time_now // the current logical time
          , .deadline = vmc->contexts[vmc->current_running_context_id].deadline
        };
      int z = pq_insert(&vmc->rdyQ, currentThreadInfo);
 8006746:	ad14      	add	r5, sp, #80	; 0x50
 8006748:	e895 000c 	ldmia.w	r5, {r2, r3}
 800674c:	9807      	ldr	r0, [sp, #28]
 800674e:	f001 ff8f 	bl	8008670 <pq_insert>
      if(z == -1){
 8006752:	1c42      	adds	r2, r0, #1
 8006754:	d023      	beq.n	800679e <chibios_container_thread.lto_priv.63+0x3fe>
        DEBUG_PRINT(("Cannot enqueue in ready queue \n"));
        return z;
      }

      // Step 5.2 Put the timed thread as currently running
      vmc->current_running_context_id = timedThread.context_id;
 8006756:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 800675a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c

      // Step 5.3 Update the correct deadline
      vmc->contexts[vmc->current_running_context_id].deadline
        = timedThread.deadline;
 800675e:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 8006762:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8006766:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800676a:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 800676e:	e715      	b.n	800659c <chibios_container_thread.lto_priv.63+0x1fc>
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8006770:	4817      	ldr	r0, [pc, #92]	; (80067d0 <chibios_container_thread.lto_priv.63+0x430>)
 8006772:	f7fe fb05 	bl	8004d80 <chSysHalt>
    } else {

      // Currently running thread's deadline is earlier or the same

      // Step 5.3 Put the timed thread in rdyQ
      int r = pq_insert(&vmc->rdyQ, timedThread);
 8006776:	ab10      	add	r3, sp, #64	; 0x40
 8006778:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800677a:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 800677e:	ab0e      	add	r3, sp, #56	; 0x38
 8006780:	cb0c      	ldmia	r3, {r2, r3}
 8006782:	9807      	ldr	r0, [sp, #28]
 8006784:	f001 ff74 	bl	8008670 <pq_insert>
      if(r == -1){
 8006788:	1c43      	adds	r3, r0, #1
 800678a:	d008      	beq.n	800679e <chibios_container_thread.lto_priv.63+0x3fe>
        return r;
      }


      // Step 5.4 Update clock of the currently running thread
      vmc->contexts[vmc->current_running_context_id].logicalTime
 800678c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
        = time_now;
 8006790:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8006794:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 8006798:	e9c3 6714 	strd	r6, r7, [r3, #80]	; 0x50
 800679c:	e6fe      	b.n	800659c <chibios_container_thread.lto_priv.63+0x1fc>

      // Currently running thread's deadline is earlier or the same

      // Step 5.3 Put the timed thread in rdyQ
      int r = pq_insert(&vmc->rdyQ, timedThread);
      if(r == -1){
 800679e:	4601      	mov	r1, r0
      /* dbg_print("  data: %u\r\n", msg.data); */
      //      dbg_print("  time: %llu\r\n", msg.timestamp);
      /*handle msg */
      int msg_r = handle_msg(container, &msg);
      if (msg_r  <= 0) {
	dbg_print("Error in handle_msg: %d\r\n",msg_r);
 80067a0:	480c      	ldr	r0, [pc, #48]	; (80067d4 <chibios_container_thread.lto_priv.63+0x434>)
 80067a2:	f7ff fb45 	bl	8005e30 <dbg_print>
 80067a6:	e624      	b.n	80063f2 <chibios_container_thread.lto_priv.63+0x52>
      // pop it from waitQ
      pq_data_t timedThread2Popped;
      int j = pq_extractMin(&vmc->waitQ, &timedThread2Popped);
      if (j == -1){
        DEBUG_PRINT(("Cannot dequeue from wait queue \n"));
        return -4;
 80067a8:	f06f 0103 	mvn.w	r1, #3
 80067ac:	e7f8      	b.n	80067a0 <chibios_container_thread.lto_priv.63+0x400>
      /*   DEBUG_PRINT(("%u\n", current_inst)); */
      /* } */

      if (current_inst > (sizeof(evaluators) / 4)) {
	
        dbg_print("current_inst = %u at pc = %d is invalid   (ctx = %u) \r\n", current_inst, *pc, container->current_running_context_id);
 80067ae:	4631      	mov	r1, r6
 80067b0:	4809      	ldr	r0, [pc, #36]	; (80067d8 <chibios_container_thread.lto_priv.63+0x438>)
 80067b2:	f7ff fb3d 	bl	8005e30 <dbg_print>
 80067b6:	e61c      	b.n	80063f2 <chibios_container_thread.lto_priv.63+0x52>
  // Step 1. Pick the top of the waitQ, time to schedule it.
  pq_data_t timedThread;
  int i = pq_extractMin(&vmc->waitQ, &timedThread);
  if (i == -1){
    DEBUG_PRINT(("Cannot dequeue from wait queue \n"));
    return -3;
 80067b8:	f06f 0102 	mvn.w	r1, #2
 80067bc:	e7f0      	b.n	80067a0 <chibios_container_thread.lto_priv.63+0x400>

      vmc->contexts[timedThread2Popped.context_id].logicalTime = time_now;
    } else {
      //Step 3.2  Above conditions not true; Set alarm for the baseline of timedThread2
      Time alarmTime = timedThread2.baseline;
      int q = setAlarm(alarmTime);
 80067be:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80067c2:	f002 f86d 	bl	80088a0 <setAlarm.lto_priv.101>
      if(q == -1){
 80067c6:	3001      	adds	r0, #1
 80067c8:	d1a2      	bne.n	8006710 <chibios_container_thread.lto_priv.63+0x370>
                      , RECV
                      , SCHEDULED_FIRST);// the receiving thread was scheduled first but
                                         // the interrupt arrived later
  if(k == -1){
    DEBUG_PRINT(("Error in message passing"));
    return -2;
 80067ca:	f06f 0101 	mvn.w	r1, #1
 80067ce:	e7e7      	b.n	80067a0 <chibios_container_thread.lto_priv.63+0x400>
 80067d0:	0800d1a4 	.word	0x0800d1a4
 80067d4:	0800d0f8 	.word	0x0800d0f8
 80067d8:	0800d114 	.word	0x0800d114
 80067dc:	00000000 	.word	0x00000000

080067e0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 80067e0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80067e2:	480d      	ldr	r0, [pc, #52]	; (8006818 <Vector124+0x38>)
 80067e4:	f7fb fd3c 	bl	8002260 <_trace_isr_enter>
 80067e8:	f7fe faea 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80067ec:	4b0b      	ldr	r3, [pc, #44]	; (800681c <Vector124+0x3c>)
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
 80067ee:	480c      	ldr	r0, [pc, #48]	; (8006820 <Vector124+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80067f0:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
 80067f2:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80067f4:	0989      	lsrs	r1, r1, #6
 80067f6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 80067fa:	018c      	lsls	r4, r1, #6
 80067fc:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
 80067fe:	b10a      	cbz	r2, 8006804 <Vector124+0x24>
    dma.streams[9].func(dma.streams[9].param, flags);
 8006800:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8006802:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006804:	f7fb fff4 	bl	80027f0 <_dbg_check_leave_isr>
 8006808:	4803      	ldr	r0, [pc, #12]	; (8006818 <Vector124+0x38>)
 800680a:	f7fb fd09 	bl	8002220 <_trace_isr_leave>
}
 800680e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
    dma.streams[9].func(dma.streams[9].param, flags);

  OSAL_IRQ_EPILOGUE();
 8006812:	f7fb bc75 	b.w	8002100 <_port_irq_epilogue>
 8006816:	bf00      	nop
 8006818:	0800d228 	.word	0x0800d228
 800681c:	40026400 	.word	0x40026400
 8006820:	2000a4d8 	.word	0x2000a4d8
	...

08006830 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8006830:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006832:	480c      	ldr	r0, [pc, #48]	; (8006864 <Vector120+0x34>)
 8006834:	f7fb fd14 	bl	8002260 <_trace_isr_enter>
 8006838:	f7fe fac2 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800683c:	4b0a      	ldr	r3, [pc, #40]	; (8006868 <Vector120+0x38>)
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
 800683e:	480b      	ldr	r0, [pc, #44]	; (800686c <Vector120+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8006840:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
 8006842:	6c42      	ldr	r2, [r0, #68]	; 0x44
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8006844:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8006848:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 800684a:	b10a      	cbz	r2, 8006850 <Vector120+0x20>
    dma.streams[8].func(dma.streams[8].param, flags);
 800684c:	6c80      	ldr	r0, [r0, #72]	; 0x48
 800684e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006850:	f7fb ffce 	bl	80027f0 <_dbg_check_leave_isr>
 8006854:	4803      	ldr	r0, [pc, #12]	; (8006864 <Vector120+0x34>)
 8006856:	f7fb fce3 	bl	8002220 <_trace_isr_leave>
}
 800685a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
    dma.streams[8].func(dma.streams[8].param, flags);

  OSAL_IRQ_EPILOGUE();
 800685e:	f7fb bc4f 	b.w	8002100 <_port_irq_epilogue>
 8006862:	bf00      	nop
 8006864:	0800d21c 	.word	0x0800d21c
 8006868:	40026400 	.word	0x40026400
 800686c:	2000a4d8 	.word	0x2000a4d8

08006870 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8006870:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006872:	480d      	ldr	r0, [pc, #52]	; (80068a8 <VectorFC+0x38>)
 8006874:	f7fb fcf4 	bl	8002260 <_trace_isr_enter>
 8006878:	f7fe faa2 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800687c:	4b0b      	ldr	r3, [pc, #44]	; (80068ac <VectorFC+0x3c>)
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
 800687e:	480c      	ldr	r0, [pc, #48]	; (80068b0 <VectorFC+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8006880:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
 8006882:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8006884:	0d89      	lsrs	r1, r1, #22
 8006886:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 800688a:	058c      	lsls	r4, r1, #22
 800688c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
 800688e:	b10a      	cbz	r2, 8006894 <VectorFC+0x24>
    dma.streams[7].func(dma.streams[7].param, flags);
 8006890:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8006892:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006894:	f7fb ffac 	bl	80027f0 <_dbg_check_leave_isr>
 8006898:	4803      	ldr	r0, [pc, #12]	; (80068a8 <VectorFC+0x38>)
 800689a:	f7fb fcc1 	bl	8002220 <_trace_isr_leave>
}
 800689e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
    dma.streams[7].func(dma.streams[7].param, flags);

  OSAL_IRQ_EPILOGUE();
 80068a2:	f7fb bc2d 	b.w	8002100 <_port_irq_epilogue>
 80068a6:	bf00      	nop
 80068a8:	0800d210 	.word	0x0800d210
 80068ac:	40026000 	.word	0x40026000
 80068b0:	2000a4d8 	.word	0x2000a4d8
	...

080068c0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80068c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80068c2:	480d      	ldr	r0, [pc, #52]	; (80068f8 <Vector84+0x38>)
 80068c4:	f7fb fccc 	bl	8002260 <_trace_isr_enter>
 80068c8:	f7fe fa7a 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80068cc:	4b0b      	ldr	r3, [pc, #44]	; (80068fc <Vector84+0x3c>)
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
 80068ce:	480c      	ldr	r0, [pc, #48]	; (8006900 <Vector84+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80068d0:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
 80068d2:	6b42      	ldr	r2, [r0, #52]	; 0x34
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80068d4:	0c09      	lsrs	r1, r1, #16
 80068d6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 80068da:	040c      	lsls	r4, r1, #16
 80068dc:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
 80068de:	b10a      	cbz	r2, 80068e4 <Vector84+0x24>
    dma.streams[6].func(dma.streams[6].param, flags);
 80068e0:	6b80      	ldr	r0, [r0, #56]	; 0x38
 80068e2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80068e4:	f7fb ff84 	bl	80027f0 <_dbg_check_leave_isr>
 80068e8:	4803      	ldr	r0, [pc, #12]	; (80068f8 <Vector84+0x38>)
 80068ea:	f7fb fc99 	bl	8002220 <_trace_isr_leave>
}
 80068ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
    dma.streams[6].func(dma.streams[6].param, flags);

  OSAL_IRQ_EPILOGUE();
 80068f2:	f7fb bc05 	b.w	8002100 <_port_irq_epilogue>
 80068f6:	bf00      	nop
 80068f8:	0800d204 	.word	0x0800d204
 80068fc:	40026000 	.word	0x40026000
 8006900:	2000a4d8 	.word	0x2000a4d8
	...

08006910 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8006910:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006912:	480d      	ldr	r0, [pc, #52]	; (8006948 <Vector80+0x38>)
 8006914:	f7fb fca4 	bl	8002260 <_trace_isr_enter>
 8006918:	f7fe fa52 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800691c:	4b0b      	ldr	r3, [pc, #44]	; (800694c <Vector80+0x3c>)
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
 800691e:	480c      	ldr	r0, [pc, #48]	; (8006950 <Vector80+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8006920:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
 8006922:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8006924:	0989      	lsrs	r1, r1, #6
 8006926:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 800692a:	018c      	lsls	r4, r1, #6
 800692c:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
 800692e:	b10a      	cbz	r2, 8006934 <Vector80+0x24>
    dma.streams[5].func(dma.streams[5].param, flags);
 8006930:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8006932:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006934:	f7fb ff5c 	bl	80027f0 <_dbg_check_leave_isr>
 8006938:	4803      	ldr	r0, [pc, #12]	; (8006948 <Vector80+0x38>)
 800693a:	f7fb fc71 	bl	8002220 <_trace_isr_leave>
}
 800693e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
    dma.streams[5].func(dma.streams[5].param, flags);

  OSAL_IRQ_EPILOGUE();
 8006942:	f7fb bbdd 	b.w	8002100 <_port_irq_epilogue>
 8006946:	bf00      	nop
 8006948:	0800d314 	.word	0x0800d314
 800694c:	40026000 	.word	0x40026000
 8006950:	2000a4d8 	.word	0x2000a4d8
	...

08006960 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8006960:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006962:	480c      	ldr	r0, [pc, #48]	; (8006994 <Vector7C+0x34>)
 8006964:	f7fb fc7c 	bl	8002260 <_trace_isr_enter>
 8006968:	f7fe fa2a 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800696c:	4b0a      	ldr	r3, [pc, #40]	; (8006998 <Vector7C+0x38>)
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
 800696e:	480b      	ldr	r0, [pc, #44]	; (800699c <Vector7C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8006970:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
 8006972:	6a42      	ldr	r2, [r0, #36]	; 0x24
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8006974:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8006978:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 800697a:	b10a      	cbz	r2, 8006980 <Vector7C+0x20>
    dma.streams[4].func(dma.streams[4].param, flags);
 800697c:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800697e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006980:	f7fb ff36 	bl	80027f0 <_dbg_check_leave_isr>
 8006984:	4803      	ldr	r0, [pc, #12]	; (8006994 <Vector7C+0x34>)
 8006986:	f7fb fc4b 	bl	8002220 <_trace_isr_leave>
}
 800698a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
    dma.streams[4].func(dma.streams[4].param, flags);

  OSAL_IRQ_EPILOGUE();
 800698e:	f7fb bbb7 	b.w	8002100 <_port_irq_epilogue>
 8006992:	bf00      	nop
 8006994:	0800d308 	.word	0x0800d308
 8006998:	40026000 	.word	0x40026000
 800699c:	2000a4d8 	.word	0x2000a4d8

080069a0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80069a0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80069a2:	480d      	ldr	r0, [pc, #52]	; (80069d8 <Vector78+0x38>)
 80069a4:	f7fb fc5c 	bl	8002260 <_trace_isr_enter>
 80069a8:	f7fe fa0a 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80069ac:	4b0b      	ldr	r3, [pc, #44]	; (80069dc <Vector78+0x3c>)
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
 80069ae:	480c      	ldr	r0, [pc, #48]	; (80069e0 <Vector78+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80069b0:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
 80069b2:	69c2      	ldr	r2, [r0, #28]
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80069b4:	0d89      	lsrs	r1, r1, #22
 80069b6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 80069ba:	058c      	lsls	r4, r1, #22
 80069bc:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
 80069be:	b10a      	cbz	r2, 80069c4 <Vector78+0x24>
    dma.streams[3].func(dma.streams[3].param, flags);
 80069c0:	6a00      	ldr	r0, [r0, #32]
 80069c2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80069c4:	f7fb ff14 	bl	80027f0 <_dbg_check_leave_isr>
 80069c8:	4803      	ldr	r0, [pc, #12]	; (80069d8 <Vector78+0x38>)
 80069ca:	f7fb fc29 	bl	8002220 <_trace_isr_leave>
}
 80069ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
    dma.streams[3].func(dma.streams[3].param, flags);

  OSAL_IRQ_EPILOGUE();
 80069d2:	f7fb bb95 	b.w	8002100 <_port_irq_epilogue>
 80069d6:	bf00      	nop
 80069d8:	0800d2e4 	.word	0x0800d2e4
 80069dc:	40026000 	.word	0x40026000
 80069e0:	2000a4d8 	.word	0x2000a4d8
	...

080069f0 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80069f0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80069f2:	480d      	ldr	r0, [pc, #52]	; (8006a28 <Vector74+0x38>)
 80069f4:	f7fb fc34 	bl	8002260 <_trace_isr_enter>
 80069f8:	f7fe f9e2 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80069fc:	4b0b      	ldr	r3, [pc, #44]	; (8006a2c <Vector74+0x3c>)
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
 80069fe:	480c      	ldr	r0, [pc, #48]	; (8006a30 <Vector74+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8006a00:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
 8006a02:	6942      	ldr	r2, [r0, #20]
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8006a04:	0c09      	lsrs	r1, r1, #16
 8006a06:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 8006a0a:	040c      	lsls	r4, r1, #16
 8006a0c:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
 8006a0e:	b10a      	cbz	r2, 8006a14 <Vector74+0x24>
    dma.streams[2].func(dma.streams[2].param, flags);
 8006a10:	6980      	ldr	r0, [r0, #24]
 8006a12:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006a14:	f7fb feec 	bl	80027f0 <_dbg_check_leave_isr>
 8006a18:	4803      	ldr	r0, [pc, #12]	; (8006a28 <Vector74+0x38>)
 8006a1a:	f7fb fc01 	bl	8002220 <_trace_isr_leave>
}
 8006a1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
    dma.streams[2].func(dma.streams[2].param, flags);

  OSAL_IRQ_EPILOGUE();
 8006a22:	f7fb bb6d 	b.w	8002100 <_port_irq_epilogue>
 8006a26:	bf00      	nop
 8006a28:	0800d2d8 	.word	0x0800d2d8
 8006a2c:	40026000 	.word	0x40026000
 8006a30:	2000a4d8 	.word	0x2000a4d8
	...

08006a40 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8006a40:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006a42:	480d      	ldr	r0, [pc, #52]	; (8006a78 <Vector70+0x38>)
 8006a44:	f7fb fc0c 	bl	8002260 <_trace_isr_enter>
 8006a48:	f7fe f9ba 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8006a4c:	4b0b      	ldr	r3, [pc, #44]	; (8006a7c <Vector70+0x3c>)
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
 8006a4e:	480c      	ldr	r0, [pc, #48]	; (8006a80 <Vector70+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8006a50:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
 8006a52:	68c2      	ldr	r2, [r0, #12]
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8006a54:	0989      	lsrs	r1, r1, #6
 8006a56:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 8006a5a:	018c      	lsls	r4, r1, #6
 8006a5c:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
 8006a5e:	b10a      	cbz	r2, 8006a64 <Vector70+0x24>
    dma.streams[1].func(dma.streams[1].param, flags);
 8006a60:	6900      	ldr	r0, [r0, #16]
 8006a62:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006a64:	f7fb fec4 	bl	80027f0 <_dbg_check_leave_isr>
 8006a68:	4803      	ldr	r0, [pc, #12]	; (8006a78 <Vector70+0x38>)
 8006a6a:	f7fb fbd9 	bl	8002220 <_trace_isr_leave>
}
 8006a6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
    dma.streams[1].func(dma.streams[1].param, flags);

  OSAL_IRQ_EPILOGUE();
 8006a72:	f7fb bb45 	b.w	8002100 <_port_irq_epilogue>
 8006a76:	bf00      	nop
 8006a78:	0800d2b0 	.word	0x0800d2b0
 8006a7c:	40026000 	.word	0x40026000
 8006a80:	2000a4d8 	.word	0x2000a4d8
	...

08006a90 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8006a90:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8006a92:	480c      	ldr	r0, [pc, #48]	; (8006ac4 <Vector6C+0x34>)
 8006a94:	f7fb fbe4 	bl	8002260 <_trace_isr_enter>
 8006a98:	f7fe f992 	bl	8004dc0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8006a9c:	4b0a      	ldr	r3, [pc, #40]	; (8006ac8 <Vector6C+0x38>)
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
 8006a9e:	480b      	ldr	r0, [pc, #44]	; (8006acc <Vector6C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8006aa0:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
 8006aa2:	6842      	ldr	r2, [r0, #4]
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8006aa4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8006aa8:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8006aaa:	b10a      	cbz	r2, 8006ab0 <Vector6C+0x20>
    dma.streams[0].func(dma.streams[0].param, flags);
 8006aac:	6880      	ldr	r0, [r0, #8]
 8006aae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8006ab0:	f7fb fe9e 	bl	80027f0 <_dbg_check_leave_isr>
 8006ab4:	4803      	ldr	r0, [pc, #12]	; (8006ac4 <Vector6C+0x34>)
 8006ab6:	f7fb fbb3 	bl	8002220 <_trace_isr_leave>
}
 8006aba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
    dma.streams[0].func(dma.streams[0].param, flags);

  OSAL_IRQ_EPILOGUE();
 8006abe:	f7fb bb1f 	b.w	8002100 <_port_irq_epilogue>
 8006ac2:	bf00      	nop
 8006ac4:	0800d2a4 	.word	0x0800d2a4
 8006ac8:	40026000 	.word	0x40026000
 8006acc:	2000a4d8 	.word	0x2000a4d8

08006ad0 <VectorE0>:
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 8006ad0:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8006ad2:	481f      	ldr	r0, [pc, #124]	; (8006b50 <VectorE0+0x80>)
 8006ad4:	f7fb fbc4 	bl	8002260 <_trace_isr_enter>
 8006ad8:	f7fe f972 	bl	8004dc0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8006adc:	4b1d      	ldr	r3, [pc, #116]	; (8006b54 <VectorE0+0x84>)
 8006ade:	695a      	ldr	r2, [r3, #20]
  pr &= EXTI->IMR & ((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
 8006ae0:	681c      	ldr	r4, [r3, #0]
 8006ae2:	4014      	ands	r4, r2
 8006ae4:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                     (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8006ae8:	615a      	str	r2, [r3, #20]

  exti_serve_irq(pr, 10);
 8006aea:	0562      	lsls	r2, r4, #21
 8006aec:	d504      	bpl.n	8006af8 <VectorE0+0x28>
 8006aee:	4a1a      	ldr	r2, [pc, #104]	; (8006b58 <VectorE0+0x88>)
 8006af0:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8006af2:	b10b      	cbz	r3, 8006af8 <VectorE0+0x28>
 8006af4:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8006af6:	4798      	blx	r3
  exti_serve_irq(pr, 11);
 8006af8:	0523      	lsls	r3, r4, #20
 8006afa:	d504      	bpl.n	8006b06 <VectorE0+0x36>
 8006afc:	4a16      	ldr	r2, [pc, #88]	; (8006b58 <VectorE0+0x88>)
 8006afe:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8006b00:	b10b      	cbz	r3, 8006b06 <VectorE0+0x36>
 8006b02:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 8006b04:	4798      	blx	r3
  exti_serve_irq(pr, 12);
 8006b06:	04e0      	lsls	r0, r4, #19
 8006b08:	d504      	bpl.n	8006b14 <VectorE0+0x44>
 8006b0a:	4a13      	ldr	r2, [pc, #76]	; (8006b58 <VectorE0+0x88>)
 8006b0c:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8006b0e:	b10b      	cbz	r3, 8006b14 <VectorE0+0x44>
 8006b10:	6e50      	ldr	r0, [r2, #100]	; 0x64
 8006b12:	4798      	blx	r3
  exti_serve_irq(pr, 13);
 8006b14:	04a1      	lsls	r1, r4, #18
 8006b16:	d504      	bpl.n	8006b22 <VectorE0+0x52>
 8006b18:	4a0f      	ldr	r2, [pc, #60]	; (8006b58 <VectorE0+0x88>)
 8006b1a:	6e93      	ldr	r3, [r2, #104]	; 0x68
 8006b1c:	b10b      	cbz	r3, 8006b22 <VectorE0+0x52>
 8006b1e:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8006b20:	4798      	blx	r3
  exti_serve_irq(pr, 14);
 8006b22:	0462      	lsls	r2, r4, #17
 8006b24:	d504      	bpl.n	8006b30 <VectorE0+0x60>
 8006b26:	4a0c      	ldr	r2, [pc, #48]	; (8006b58 <VectorE0+0x88>)
 8006b28:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8006b2a:	b10b      	cbz	r3, 8006b30 <VectorE0+0x60>
 8006b2c:	6f50      	ldr	r0, [r2, #116]	; 0x74
 8006b2e:	4798      	blx	r3
  exti_serve_irq(pr, 15);
 8006b30:	0423      	lsls	r3, r4, #16
 8006b32:	d504      	bpl.n	8006b3e <VectorE0+0x6e>
 8006b34:	4a08      	ldr	r2, [pc, #32]	; (8006b58 <VectorE0+0x88>)
 8006b36:	6f93      	ldr	r3, [r2, #120]	; 0x78
 8006b38:	b10b      	cbz	r3, 8006b3e <VectorE0+0x6e>
 8006b3a:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
 8006b3c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006b3e:	f7fb fe57 	bl	80027f0 <_dbg_check_leave_isr>
 8006b42:	4803      	ldr	r0, [pc, #12]	; (8006b50 <VectorE0+0x80>)
 8006b44:	f7fb fb6c 	bl	8002220 <_trace_isr_leave>
}
 8006b48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  exti_serve_irq(pr, 12);
  exti_serve_irq(pr, 13);
  exti_serve_irq(pr, 14);
  exti_serve_irq(pr, 15);

  OSAL_IRQ_EPILOGUE();
 8006b4c:	f7fb bad8 	b.w	8002100 <_port_irq_epilogue>
 8006b50:	0800d280 	.word	0x0800d280
 8006b54:	40013c00 	.word	0x40013c00
 8006b58:	2000a098 	.word	0x2000a098
 8006b5c:	00000000 	.word	0x00000000

08006b60 <Vector9C>:
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 8006b60:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8006b62:	481c      	ldr	r0, [pc, #112]	; (8006bd4 <Vector9C+0x74>)
 8006b64:	f7fb fb7c 	bl	8002260 <_trace_isr_enter>
 8006b68:	f7fe f92a 	bl	8004dc0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8006b6c:	4a1a      	ldr	r2, [pc, #104]	; (8006bd8 <Vector9C+0x78>)
 8006b6e:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & ((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
 8006b70:	6814      	ldr	r4, [r2, #0]
 8006b72:	401c      	ands	r4, r3
 8006b74:	f404 7378 	and.w	r3, r4, #992	; 0x3e0
                     (1U << 9));
  EXTI->PR = pr;
 8006b78:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 5);
 8006b7a:	06a3      	lsls	r3, r4, #26
 8006b7c:	d504      	bpl.n	8006b88 <Vector9C+0x28>
 8006b7e:	4a17      	ldr	r2, [pc, #92]	; (8006bdc <Vector9C+0x7c>)
 8006b80:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8006b82:	b10b      	cbz	r3, 8006b88 <Vector9C+0x28>
 8006b84:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8006b86:	4798      	blx	r3
  exti_serve_irq(pr, 6);
 8006b88:	0660      	lsls	r0, r4, #25
 8006b8a:	d504      	bpl.n	8006b96 <Vector9C+0x36>
 8006b8c:	4a13      	ldr	r2, [pc, #76]	; (8006bdc <Vector9C+0x7c>)
 8006b8e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8006b90:	b10b      	cbz	r3, 8006b96 <Vector9C+0x36>
 8006b92:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8006b94:	4798      	blx	r3
  exti_serve_irq(pr, 7);
 8006b96:	0621      	lsls	r1, r4, #24
 8006b98:	d504      	bpl.n	8006ba4 <Vector9C+0x44>
 8006b9a:	4a10      	ldr	r2, [pc, #64]	; (8006bdc <Vector9C+0x7c>)
 8006b9c:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8006b9e:	b10b      	cbz	r3, 8006ba4 <Vector9C+0x44>
 8006ba0:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8006ba2:	4798      	blx	r3
  exti_serve_irq(pr, 8);
 8006ba4:	05e2      	lsls	r2, r4, #23
 8006ba6:	d504      	bpl.n	8006bb2 <Vector9C+0x52>
 8006ba8:	4a0c      	ldr	r2, [pc, #48]	; (8006bdc <Vector9C+0x7c>)
 8006baa:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8006bac:	b10b      	cbz	r3, 8006bb2 <Vector9C+0x52>
 8006bae:	6c50      	ldr	r0, [r2, #68]	; 0x44
 8006bb0:	4798      	blx	r3
  exti_serve_irq(pr, 9);
 8006bb2:	05a3      	lsls	r3, r4, #22
 8006bb4:	d504      	bpl.n	8006bc0 <Vector9C+0x60>
 8006bb6:	4a09      	ldr	r2, [pc, #36]	; (8006bdc <Vector9C+0x7c>)
 8006bb8:	6c93      	ldr	r3, [r2, #72]	; 0x48
 8006bba:	b10b      	cbz	r3, 8006bc0 <Vector9C+0x60>
 8006bbc:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 8006bbe:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006bc0:	f7fb fe16 	bl	80027f0 <_dbg_check_leave_isr>
 8006bc4:	4803      	ldr	r0, [pc, #12]	; (8006bd4 <Vector9C+0x74>)
 8006bc6:	f7fb fb2b 	bl	8002220 <_trace_isr_leave>
}
 8006bca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  exti_serve_irq(pr, 6);
  exti_serve_irq(pr, 7);
  exti_serve_irq(pr, 8);
  exti_serve_irq(pr, 9);

  OSAL_IRQ_EPILOGUE();
 8006bce:	f7fb ba97 	b.w	8002100 <_port_irq_epilogue>
 8006bd2:	bf00      	nop
 8006bd4:	0800d2fc 	.word	0x0800d2fc
 8006bd8:	40013c00 	.word	0x40013c00
 8006bdc:	2000a098 	.word	0x2000a098

08006be0 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 8006be0:	b508      	push	{r3, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8006be2:	480d      	ldr	r0, [pc, #52]	; (8006c18 <Vector68+0x38>)
 8006be4:	f7fb fb3c 	bl	8002260 <_trace_isr_enter>
 8006be8:	f7fe f8ea 	bl	8004dc0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8006bec:	4a0b      	ldr	r2, [pc, #44]	; (8006c1c <Vector68+0x3c>)
 8006bee:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 4);
 8006bf0:	6813      	ldr	r3, [r2, #0]
 8006bf2:	400b      	ands	r3, r1
 8006bf4:	f003 0310 	and.w	r3, r3, #16
  EXTI->PR = pr;
 8006bf8:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 4);
 8006bfa:	b123      	cbz	r3, 8006c06 <Vector68+0x26>
 8006bfc:	4a08      	ldr	r2, [pc, #32]	; (8006c20 <Vector68+0x40>)
 8006bfe:	6a13      	ldr	r3, [r2, #32]
 8006c00:	b10b      	cbz	r3, 8006c06 <Vector68+0x26>
 8006c02:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8006c04:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006c06:	f7fb fdf3 	bl	80027f0 <_dbg_check_leave_isr>
 8006c0a:	4803      	ldr	r0, [pc, #12]	; (8006c18 <Vector68+0x38>)
 8006c0c:	f7fb fb08 	bl	8002220 <_trace_isr_leave>
}
 8006c10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  pr &= EXTI->IMR & (1U << 4);
  EXTI->PR = pr;

  exti_serve_irq(pr, 4);

  OSAL_IRQ_EPILOGUE();
 8006c14:	f7fb ba74 	b.w	8002100 <_port_irq_epilogue>
 8006c18:	0800d2f0 	.word	0x0800d2f0
 8006c1c:	40013c00 	.word	0x40013c00
 8006c20:	2000a098 	.word	0x2000a098
	...

08006c30 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 8006c30:	b508      	push	{r3, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8006c32:	480d      	ldr	r0, [pc, #52]	; (8006c68 <Vector64+0x38>)
 8006c34:	f7fb fb14 	bl	8002260 <_trace_isr_enter>
 8006c38:	f7fe f8c2 	bl	8004dc0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8006c3c:	4a0b      	ldr	r2, [pc, #44]	; (8006c6c <Vector64+0x3c>)
 8006c3e:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 3);
 8006c40:	6813      	ldr	r3, [r2, #0]
 8006c42:	400b      	ands	r3, r1
 8006c44:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
 8006c48:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 3);
 8006c4a:	b123      	cbz	r3, 8006c56 <Vector64+0x26>
 8006c4c:	4a08      	ldr	r2, [pc, #32]	; (8006c70 <Vector64+0x40>)
 8006c4e:	6993      	ldr	r3, [r2, #24]
 8006c50:	b10b      	cbz	r3, 8006c56 <Vector64+0x26>
 8006c52:	69d0      	ldr	r0, [r2, #28]
 8006c54:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006c56:	f7fb fdcb 	bl	80027f0 <_dbg_check_leave_isr>
 8006c5a:	4803      	ldr	r0, [pc, #12]	; (8006c68 <Vector64+0x38>)
 8006c5c:	f7fb fae0 	bl	8002220 <_trace_isr_leave>
}
 8006c60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  pr &= EXTI->IMR & (1U << 3);
  EXTI->PR = pr;

  exti_serve_irq(pr, 3);

  OSAL_IRQ_EPILOGUE();
 8006c64:	f7fb ba4c 	b.w	8002100 <_port_irq_epilogue>
 8006c68:	0800d2c8 	.word	0x0800d2c8
 8006c6c:	40013c00 	.word	0x40013c00
 8006c70:	2000a098 	.word	0x2000a098
	...

08006c80 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 8006c80:	b508      	push	{r3, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8006c82:	480d      	ldr	r0, [pc, #52]	; (8006cb8 <Vector60+0x38>)
 8006c84:	f7fb faec 	bl	8002260 <_trace_isr_enter>
 8006c88:	f7fe f89a 	bl	8004dc0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8006c8c:	4a0b      	ldr	r2, [pc, #44]	; (8006cbc <Vector60+0x3c>)
 8006c8e:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 2);
 8006c90:	6813      	ldr	r3, [r2, #0]
 8006c92:	400b      	ands	r3, r1
 8006c94:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
 8006c98:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 2);
 8006c9a:	b123      	cbz	r3, 8006ca6 <Vector60+0x26>
 8006c9c:	4a08      	ldr	r2, [pc, #32]	; (8006cc0 <Vector60+0x40>)
 8006c9e:	6913      	ldr	r3, [r2, #16]
 8006ca0:	b10b      	cbz	r3, 8006ca6 <Vector60+0x26>
 8006ca2:	6950      	ldr	r0, [r2, #20]
 8006ca4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006ca6:	f7fb fda3 	bl	80027f0 <_dbg_check_leave_isr>
 8006caa:	4803      	ldr	r0, [pc, #12]	; (8006cb8 <Vector60+0x38>)
 8006cac:	f7fb fab8 	bl	8002220 <_trace_isr_leave>
}
 8006cb0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  pr &= EXTI->IMR & (1U << 2);
  EXTI->PR = pr;

  exti_serve_irq(pr, 2);

  OSAL_IRQ_EPILOGUE();
 8006cb4:	f7fb ba24 	b.w	8002100 <_port_irq_epilogue>
 8006cb8:	0800d2bc 	.word	0x0800d2bc
 8006cbc:	40013c00 	.word	0x40013c00
 8006cc0:	2000a098 	.word	0x2000a098
	...

08006cd0 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8006cd0:	b508      	push	{r3, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8006cd2:	480d      	ldr	r0, [pc, #52]	; (8006d08 <Vector5C+0x38>)
 8006cd4:	f7fb fac4 	bl	8002260 <_trace_isr_enter>
 8006cd8:	f7fe f872 	bl	8004dc0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8006cdc:	4a0b      	ldr	r2, [pc, #44]	; (8006d0c <Vector5C+0x3c>)
 8006cde:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 1);
 8006ce0:	6813      	ldr	r3, [r2, #0]
 8006ce2:	400b      	ands	r3, r1
 8006ce4:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
 8006ce8:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 1);
 8006cea:	b123      	cbz	r3, 8006cf6 <Vector5C+0x26>
 8006cec:	4a08      	ldr	r2, [pc, #32]	; (8006d10 <Vector5C+0x40>)
 8006cee:	6893      	ldr	r3, [r2, #8]
 8006cf0:	b10b      	cbz	r3, 8006cf6 <Vector5C+0x26>
 8006cf2:	68d0      	ldr	r0, [r2, #12]
 8006cf4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006cf6:	f7fb fd7b 	bl	80027f0 <_dbg_check_leave_isr>
 8006cfa:	4803      	ldr	r0, [pc, #12]	; (8006d08 <Vector5C+0x38>)
 8006cfc:	f7fb fa90 	bl	8002220 <_trace_isr_leave>
}
 8006d00:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  pr &= EXTI->IMR & (1U << 1);
  EXTI->PR = pr;

  exti_serve_irq(pr, 1);

  OSAL_IRQ_EPILOGUE();
 8006d04:	f7fb b9fc 	b.w	8002100 <_port_irq_epilogue>
 8006d08:	0800d298 	.word	0x0800d298
 8006d0c:	40013c00 	.word	0x40013c00
 8006d10:	2000a098 	.word	0x2000a098
	...

08006d20 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 8006d20:	b508      	push	{r3, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8006d22:	480d      	ldr	r0, [pc, #52]	; (8006d58 <Vector58+0x38>)
 8006d24:	f7fb fa9c 	bl	8002260 <_trace_isr_enter>
 8006d28:	f7fe f84a 	bl	8004dc0 <_dbg_check_enter_isr>

  pr = EXTI->PR;
 8006d2c:	4a0b      	ldr	r2, [pc, #44]	; (8006d5c <Vector58+0x3c>)
 8006d2e:	6951      	ldr	r1, [r2, #20]
  pr &= EXTI->IMR & (1U << 0);
 8006d30:	6813      	ldr	r3, [r2, #0]
 8006d32:	400b      	ands	r3, r1
 8006d34:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR = pr;
 8006d38:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 0);
 8006d3a:	b123      	cbz	r3, 8006d46 <Vector58+0x26>
 8006d3c:	4a08      	ldr	r2, [pc, #32]	; (8006d60 <Vector58+0x40>)
 8006d3e:	6813      	ldr	r3, [r2, #0]
 8006d40:	b10b      	cbz	r3, 8006d46 <Vector58+0x26>
 8006d42:	6850      	ldr	r0, [r2, #4]
 8006d44:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8006d46:	f7fb fd53 	bl	80027f0 <_dbg_check_leave_isr>
 8006d4a:	4803      	ldr	r0, [pc, #12]	; (8006d58 <Vector58+0x38>)
 8006d4c:	f7fb fa68 	bl	8002220 <_trace_isr_leave>
}
 8006d50:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  pr &= EXTI->IMR & (1U << 0);
  EXTI->PR = pr;

  exti_serve_irq(pr, 0);

  OSAL_IRQ_EPILOGUE();
 8006d54:	f7fb b9d4 	b.w	8002100 <_port_irq_epilogue>
 8006d58:	0800d28c 	.word	0x0800d28c
 8006d5c:	40013c00 	.word	0x40013c00
 8006d60:	2000a098 	.word	0x2000a098
	...

08006d70 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8006d70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006d74:	4605      	mov	r5, r0
 8006d76:	460e      	mov	r6, r1
 8006d78:	4690      	mov	r8, r2
 8006d7a:	4699      	mov	r9, r3
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 8006d7c:	f7fb fae8 	bl	8002350 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006d80:	b1cd      	cbz	r5, 8006db6 <usbStartTransmitI+0x46>
 8006d82:	2e05      	cmp	r6, #5
 8006d84:	d817      	bhi.n	8006db6 <usbStartTransmitI+0x46>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8006d86:	2401      	movs	r4, #1
 8006d88:	40b4      	lsls	r4, r6
 8006d8a:	8928      	ldrh	r0, [r5, #8]
 8006d8c:	b2a4      	uxth	r4, r4
 8006d8e:	ea14 0700 	ands.w	r7, r4, r0
 8006d92:	d110      	bne.n	8006db6 <usbStartTransmitI+0x46>
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8006d94:	eb05 0386 	add.w	r3, r5, r6, lsl #2
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006d98:	4304      	orrs	r4, r0

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8006d9a:	68db      	ldr	r3, [r3, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006d9c:	812c      	strh	r4, [r5, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8006d9e:	6959      	ldr	r1, [r3, #20]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8006da0:	4628      	mov	r0, r5

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 8006da2:	f8c1 8008 	str.w	r8, [r1, #8]
  isp->txsize = n;
 8006da6:	f8c1 9000 	str.w	r9, [r1]
  isp->txcnt  = 0;
 8006daa:	604f      	str	r7, [r1, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8006dac:	4631      	mov	r1, r6
}
 8006dae:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8006db2:	f7fe babd 	b.w	8005330 <usb_lld_start_in>
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
  USBInEndpointState *isp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006db6:	4801      	ldr	r0, [pc, #4]	; (8006dbc <usbStartTransmitI+0x4c>)
 8006db8:	f7fd ffe2 	bl	8004d80 <chSysHalt>
 8006dbc:	0800d320 	.word	0x0800d320

08006dc0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8006dc0:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8006dc2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8006dc6:	4604      	mov	r4, r0

  (void)ep;
  switch (usbp->ep0state) {
 8006dc8:	2b15      	cmp	r3, #21
 8006dca:	d80c      	bhi.n	8006de6 <_usb_ep0out+0x26>
 8006dcc:	e8df f003 	tbb	[pc, r3]
 8006dd0:	0b0b0b0b 	.word	0x0b0b0b0b
 8006dd4:	0b190b0b 	.word	0x0b190b0b
 8006dd8:	0b0b0b0b 	.word	0x0b0b0b0b
 8006ddc:	0b0b0b0b 	.word	0x0b0b0b0b
 8006de0:	0b0b0b0b 	.word	0x0b0b0b0b
 8006de4:	2f0e      	.short	0x2f0e
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8006de6:	481c      	ldr	r0, [pc, #112]	; (8006e58 <_usb_ep0out+0x98>)
 8006de8:	f7fd ffca 	bl	8004d80 <chSysHalt>
    return;
  case USB_EP0_OUT_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8006dec:	68c3      	ldr	r3, [r0, #12]
 8006dee:	699b      	ldr	r3, [r3, #24]
 8006df0:	685b      	ldr	r3, [r3, #4]
 8006df2:	bb83      	cbnz	r3, 8006e56 <_usb_ep0out+0x96>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 8006df4:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8006df6:	b103      	cbz	r3, 8006dfa <_usb_ep0out+0x3a>
      usbp->ep0endcb(usbp);
 8006df8:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 8006dfa:	2300      	movs	r3, #0
 8006dfc:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006e00:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8006e02:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006e04:	6841      	ldr	r1, [r0, #4]
 8006e06:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8006e0a:	680d      	ldr	r5, [r1, #0]
 8006e0c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006e10:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8006e14:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8006e18:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006e1c:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8006e20:	b10d      	cbz	r5, 8006e26 <_usb_ep0out+0x66>
 8006e22:	2106      	movs	r1, #6
 8006e24:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8006e26:	2306      	movs	r3, #6
 8006e28:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006e2c:	bd38      	pop	{r3, r4, r5, pc}

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8006e2e:	230b      	movs	r3, #11
 8006e30:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
 8006e34:	2320      	movs	r3, #32
 8006e36:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006e3a:	f7fd fff1 	bl	8004e20 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 8006e3e:	2100      	movs	r1, #0
 8006e40:	460b      	mov	r3, r1
 8006e42:	4620      	mov	r0, r4
 8006e44:	460a      	mov	r2, r1
 8006e46:	f7ff ff93 	bl	8006d70 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006e4a:	f7fd ffd1 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8006e4e:	2300      	movs	r3, #0
 8006e50:	f383 8811 	msr	BASEPRI, r3
 8006e54:	bd38      	pop	{r3, r4, r5, pc}
 8006e56:	bd38      	pop	{r3, r4, r5, pc}
 8006e58:	0800d274 	.word	0x0800d274
 8006e5c:	00000000 	.word	0x00000000

08006e60 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8006e60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006e64:	4605      	mov	r5, r0
 8006e66:	460e      	mov	r6, r1
 8006e68:	4690      	mov	r8, r2
 8006e6a:	4699      	mov	r9, r3
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 8006e6c:	f7fb fa70 	bl	8002350 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006e70:	b1cd      	cbz	r5, 8006ea6 <usbStartReceiveI+0x46>
 8006e72:	2e05      	cmp	r6, #5
 8006e74:	d817      	bhi.n	8006ea6 <usbStartReceiveI+0x46>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8006e76:	2401      	movs	r4, #1
 8006e78:	40b4      	lsls	r4, r6
 8006e7a:	8968      	ldrh	r0, [r5, #10]
 8006e7c:	b2a4      	uxth	r4, r4
 8006e7e:	ea14 0700 	ands.w	r7, r4, r0
 8006e82:	d110      	bne.n	8006ea6 <usbStartReceiveI+0x46>
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8006e84:	eb05 0386 	add.w	r3, r5, r6, lsl #2
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006e88:	4304      	orrs	r4, r0

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8006e8a:	68db      	ldr	r3, [r3, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006e8c:	816c      	strh	r4, [r5, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8006e8e:	6999      	ldr	r1, [r3, #24]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8006e90:	4628      	mov	r0, r5

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
 8006e92:	f8c1 8008 	str.w	r8, [r1, #8]
  osp->rxsize = n;
 8006e96:	f8c1 9000 	str.w	r9, [r1]
  osp->rxcnt  = 0;
 8006e9a:	604f      	str	r7, [r1, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8006e9c:	4631      	mov	r1, r6
}
 8006e9e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8006ea2:	f7fe baed 	b.w	8005480 <usb_lld_start_out>
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8006ea6:	4801      	ldr	r0, [pc, #4]	; (8006eac <usbStartReceiveI+0x4c>)
 8006ea8:	f7fd ff6a 	bl	8004d80 <chSysHalt>
 8006eac:	0800d250 	.word	0x0800d250

08006eb0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8006eb0:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8006eb2:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8006eb6:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8006eb8:	2b15      	cmp	r3, #21
 8006eba:	d80c      	bhi.n	8006ed6 <_usb_ep0in+0x26>
 8006ebc:	e8df f003 	tbb	[pc, r3]
 8006ec0:	0b0b0b0b 	.word	0x0b0b0b0b
 8006ec4:	0b390b0b 	.word	0x0b390b0b
 8006ec8:	321e0e0b 	.word	0x321e0e0b
 8006ecc:	0b0b0b0b 	.word	0x0b0b0b0b
 8006ed0:	0b0b0b0b 	.word	0x0b0b0b0b
 8006ed4:	0b0b      	.short	0x0b0b
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8006ed6:	482b      	ldr	r0, [pc, #172]	; (8006f84 <_usb_ep0in+0xd4>)
 8006ed8:	f7fd ff52 	bl	8004d80 <chSysHalt>

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8006edc:	f890 1063 	ldrb.w	r1, [r0, #99]	; 0x63
 8006ee0:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8006ee4:	6d42      	ldr	r2, [r0, #84]	; 0x54
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8006ee6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8006eea:	4293      	cmp	r3, r2
 8006eec:	d906      	bls.n	8006efc <_usb_ep0in+0x4c>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8006eee:	68c3      	ldr	r3, [r0, #12]
 8006ef0:	8a1d      	ldrh	r5, [r3, #16]
 8006ef2:	fbb2 f3f5 	udiv	r3, r2, r5
 8006ef6:	fb05 2513 	mls	r5, r5, r3, r2
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8006efa:	b385      	cbz	r5, 8006f5e <_usb_ep0in+0xae>
      return;
    }
    /* Falls through.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8006efc:	2314      	movs	r3, #20
 8006efe:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f02:	2320      	movs	r3, #32
 8006f04:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006f08:	f7fd ff8a 	bl	8004e20 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0, NULL, 0);
 8006f0c:	2100      	movs	r1, #0
 8006f0e:	460b      	mov	r3, r1
 8006f10:	4620      	mov	r0, r4
 8006f12:	460a      	mov	r2, r1
 8006f14:	f7ff ffa4 	bl	8006e60 <usbStartReceiveI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006f18:	f7fd ff6a 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8006f1c:	2300      	movs	r3, #0
 8006f1e:	f383 8811 	msr	BASEPRI, r3
 8006f22:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_IN_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8006f24:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8006f26:	b103      	cbz	r3, 8006f2a <_usb_ep0in+0x7a>
      usbp->ep0endcb(usbp);
 8006f28:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_STP_WAITING;
 8006f2a:	2300      	movs	r3, #0
 8006f2c:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f30:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8006f32:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8006f34:	6841      	ldr	r1, [r0, #4]
 8006f36:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8006f3a:	680d      	ldr	r5, [r1, #0]
 8006f3c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006f40:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8006f44:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8006f48:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006f4c:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8006f50:	b10d      	cbz	r5, 8006f56 <_usb_ep0in+0xa6>
 8006f52:	2106      	movs	r1, #6
 8006f54:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8006f56:	2306      	movs	r3, #6
 8006f58:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f5c:	bd38      	pop	{r3, r4, r5, pc}
 8006f5e:	2320      	movs	r3, #32
 8006f60:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006f64:	f7fd ff5c 	bl	8004e20 <_dbg_check_lock_from_isr>
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 8006f68:	4620      	mov	r0, r4
 8006f6a:	4629      	mov	r1, r5
 8006f6c:	462a      	mov	r2, r5
 8006f6e:	462b      	mov	r3, r5
 8006f70:	f7ff fefe 	bl	8006d70 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006f74:	f7fd ff3c 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8006f78:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 8006f7c:	230a      	movs	r3, #10
 8006f7e:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006f82:	bd38      	pop	{r3, r4, r5, pc}
 8006f84:	0800d268 	.word	0x0800d268
	...

08006f90 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8006f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8006f92:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8006f96:	4604      	mov	r4, r0
  size_t max;

  /* Is the EP0 state machine in the correct state for handling setup
     packets?*/
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 8006f98:	b113      	cbz	r3, 8006fa0 <_usb_ep0setup+0x10>
    /* This is unexpected could require handling with a warning event.*/
    /* CHTODO: handling here.*/

    /* Resetting the EP0 state machine and going ahead.*/
    usbp->ep0state = USB_EP0_STP_WAITING;
 8006f9a:	2300      	movs	r3, #0
 8006f9c:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8006fa0:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006fa4:	6862      	ldr	r2, [r4, #4]
 8006fa6:	68cb      	ldr	r3, [r1, #12]
 8006fa8:	6a1b      	ldr	r3, [r3, #32]
 8006faa:	6819      	ldr	r1, [r3, #0]
 8006fac:	685b      	ldr	r3, [r3, #4]
 8006fae:	6623      	str	r3, [r4, #96]	; 0x60
 8006fb0:	65e1      	str	r1, [r4, #92]	; 0x5c
 8006fb2:	6893      	ldr	r3, [r2, #8]
 8006fb4:	b33b      	cbz	r3, 8007006 <_usb_ep0setup+0x76>
      !(usbp->config->requests_hook_cb(usbp))) {
 8006fb6:	4620      	mov	r0, r4
 8006fb8:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8006fba:	b320      	cbz	r0, 8007006 <_usb_ep0setup+0x76>
 8006fbc:	6d65      	ldr	r5, [r4, #84]	; 0x54
 8006fbe:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8006fc2:	f894 1063 	ldrb.w	r1, [r4, #99]	; 0x63
 8006fc6:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8006fca:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8006fce:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 8006fd0:	bf3c      	itt	cc
 8006fd2:	6562      	strcc	r2, [r4, #84]	; 0x54
 8006fd4:	4615      	movcc	r5, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8006fd6:	061b      	lsls	r3, r3, #24
 8006fd8:	f100 8085 	bmi.w	80070e6 <_usb_ep0setup+0x156>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8006fdc:	2d00      	cmp	r5, #0
 8006fde:	d16e      	bne.n	80070be <_usb_ep0setup+0x12e>
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8006fe0:	230b      	movs	r3, #11
 8006fe2:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8006fe6:	2320      	movs	r3, #32
 8006fe8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006fec:	f7fd ff18 	bl	8004e20 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 8006ff0:	4620      	mov	r0, r4
 8006ff2:	4629      	mov	r1, r5
 8006ff4:	462a      	mov	r2, r5
 8006ff6:	462b      	mov	r3, r5
 8006ff8:	f7ff feba 	bl	8006d70 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006ffc:	f7fd fef8 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8007000:	f385 8811 	msr	BASEPRI, r5
 8007004:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007006:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 800700a:	f013 0660 	ands.w	r6, r3, #96	; 0x60
 800700e:	d016      	beq.n	800703e <_usb_ep0setup+0xae>
 8007010:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8007012:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8007016:	6861      	ldr	r1, [r4, #4]
 8007018:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800701c:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8007020:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8007024:	680d      	ldr	r5, [r1, #0]
 8007026:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800702a:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 800702e:	b115      	cbz	r5, 8007036 <_usb_ep0setup+0xa6>
 8007030:	4620      	mov	r0, r4
 8007032:	2106      	movs	r1, #6
 8007034:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 8007036:	2306      	movs	r3, #6
 8007038:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 800703c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 800703e:	f894 505d 	ldrb.w	r5, [r4, #93]	; 0x5d
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8007042:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8007046:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800704a:	f240 3202 	movw	r2, #770	; 0x302
 800704e:	4295      	cmp	r5, r2
 8007050:	f000 80ed 	beq.w	800722e <_usb_ep0setup+0x29e>
 8007054:	d81d      	bhi.n	8007092 <_usb_ep0setup+0x102>
 8007056:	2d02      	cmp	r5, #2
 8007058:	f000 80d3 	beq.w	8007202 <_usb_ep0setup+0x272>
 800705c:	f240 80be 	bls.w	80071dc <_usb_ep0setup+0x24c>
 8007060:	f5b5 7f81 	cmp.w	r5, #258	; 0x102
 8007064:	f000 80fb 	beq.w	800725e <_usb_ep0setup+0x2ce>
 8007068:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 800706c:	d075      	beq.n	800715a <_usb_ep0setup+0x1ca>
 800706e:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8007072:	d1cd      	bne.n	8007010 <_usb_ep0setup+0x80>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8007074:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 8007078:	2a01      	cmp	r2, #1
 800707a:	d1c9      	bne.n	8007010 <_usb_ep0setup+0x80>
      usbp->status &= ~2U;
 800707c:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8007080:	6526      	str	r6, [r4, #80]	; 0x50
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8007082:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8007086:	6566      	str	r6, [r4, #84]	; 0x54
 8007088:	65a6      	str	r6, [r4, #88]	; 0x58
 800708a:	4635      	mov	r5, r6
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 800708c:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
 8007090:	e797      	b.n	8006fc2 <_usb_ep0setup+0x32>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8007092:	f240 6201 	movw	r2, #1537	; 0x601
 8007096:	4295      	cmp	r5, r2
 8007098:	d94d      	bls.n	8007136 <_usb_ep0setup+0x1a6>
 800709a:	f5b5 6f10 	cmp.w	r5, #2304	; 0x900
 800709e:	d06c      	beq.n	800717a <_usb_ep0setup+0x1ea>
 80070a0:	f640 4202 	movw	r2, #3074	; 0xc02
 80070a4:	4295      	cmp	r5, r2
 80070a6:	f000 80a5 	beq.w	80071f4 <_usb_ep0setup+0x264>
 80070aa:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 80070ae:	d1af      	bne.n	8007010 <_usb_ep0setup+0x80>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80070b0:	f104 0267 	add.w	r2, r4, #103	; 0x67
 80070b4:	2501      	movs	r5, #1
 80070b6:	65a6      	str	r6, [r4, #88]	; 0x58
 80070b8:	6522      	str	r2, [r4, #80]	; 0x50
 80070ba:	6565      	str	r5, [r4, #84]	; 0x54
 80070bc:	e781      	b.n	8006fc2 <_usb_ep0setup+0x32>
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_OUT_RX;
 80070be:	2315      	movs	r3, #21
 80070c0:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 80070c4:	2320      	movs	r3, #32
 80070c6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80070ca:	f7fd fea9 	bl	8004e20 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 80070ce:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80070d0:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80070d2:	4620      	mov	r0, r4
 80070d4:	2100      	movs	r1, #0
 80070d6:	f7ff fec3 	bl	8006e60 <usbStartReceiveI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80070da:	f7fd fe89 	bl	8004df0 <_dbg_check_unlock_from_isr>
 80070de:	2300      	movs	r3, #0
 80070e0:	f383 8811 	msr	BASEPRI, r3
 80070e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80070e6:	b19d      	cbz	r5, 8007110 <_usb_ep0setup+0x180>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_IN_TX;
 80070e8:	2309      	movs	r3, #9
 80070ea:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 80070ee:	2320      	movs	r3, #32
 80070f0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80070f4:	f7fd fe94 	bl	8004e20 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80070f8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80070fa:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80070fc:	4620      	mov	r0, r4
 80070fe:	2100      	movs	r1, #0
 8007100:	f7ff fe36 	bl	8006d70 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8007104:	f7fd fe74 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8007108:	2300      	movs	r3, #0
 800710a:	f383 8811 	msr	BASEPRI, r3
 800710e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8007110:	2314      	movs	r3, #20
 8007112:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
 8007116:	2320      	movs	r3, #32
 8007118:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800711c:	f7fd fe80 	bl	8004e20 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
 8007120:	4620      	mov	r0, r4
 8007122:	4629      	mov	r1, r5
 8007124:	462a      	mov	r2, r5
 8007126:	462b      	mov	r3, r5
 8007128:	f7ff fe9a 	bl	8006e60 <usbStartReceiveI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800712c:	f7fd fe60 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8007130:	f385 8811 	msr	BASEPRI, r5
 8007134:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8007136:	f5b5 6fc0 	cmp.w	r5, #1536	; 0x600
 800713a:	d236      	bcs.n	80071aa <_usb_ep0setup+0x21a>
 800713c:	f5b5 6fa0 	cmp.w	r5, #1280	; 0x500
 8007140:	f47f af66 	bne.w	8007010 <_usb_ep0setup+0x80>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8007144:	f8b4 205c 	ldrh.w	r2, [r4, #92]	; 0x5c
 8007148:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800714c:	f000 80a5 	beq.w	800729a <_usb_ep0setup+0x30a>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8007150:	2500      	movs	r5, #0
 8007152:	6525      	str	r5, [r4, #80]	; 0x50
 8007154:	6565      	str	r5, [r4, #84]	; 0x54
 8007156:	65a5      	str	r5, [r4, #88]	; 0x58
 8007158:	e733      	b.n	8006fc2 <_usb_ep0setup+0x32>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800715a:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 800715e:	2a01      	cmp	r2, #1
 8007160:	f47f af56 	bne.w	8007010 <_usb_ep0setup+0x80>
      usbp->status |= 2U;
 8007164:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8007168:	6526      	str	r6, [r4, #80]	; 0x50
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800716a:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800716e:	6566      	str	r6, [r4, #84]	; 0x54
 8007170:	65a6      	str	r6, [r4, #88]	; 0x58
 8007172:	4635      	mov	r5, r6
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8007174:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
 8007178:	e723      	b.n	8006fc2 <_usb_ep0setup+0x32>
    if (usbp->configuration != usbp->setup[2])
#endif
    {
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 800717a:	7823      	ldrb	r3, [r4, #0]
 800717c:	2b04      	cmp	r3, #4
 800717e:	f000 80a4 	beq.w	80072ca <_usb_ep0setup+0x33a>
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
 8007182:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
 8007186:	b14b      	cbz	r3, 800719c <_usb_ep0setup+0x20c>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8007188:	6862      	ldr	r2, [r4, #4]
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 800718a:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800718e:	6813      	ldr	r3, [r2, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
 8007190:	2204      	movs	r2, #4
 8007192:	7022      	strb	r2, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8007194:	b113      	cbz	r3, 800719c <_usb_ep0setup+0x20c>
 8007196:	4620      	mov	r0, r4
 8007198:	2102      	movs	r1, #2
 800719a:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800719c:	2500      	movs	r5, #0
 800719e:	6525      	str	r5, [r4, #80]	; 0x50
 80071a0:	6565      	str	r5, [r4, #84]	; 0x54
 80071a2:	65a5      	str	r5, [r4, #88]	; 0x58
 80071a4:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 80071a8:	e70b      	b.n	8006fc2 <_usb_ep0setup+0x32>
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80071aa:	6862      	ldr	r2, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 80071ac:	f894 0061 	ldrb.w	r0, [r4, #97]	; 0x61
 80071b0:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 80071b4:	6855      	ldr	r5, [r2, #4]
 80071b6:	f894 105f 	ldrb.w	r1, [r4, #95]	; 0x5f
 80071ba:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 80071be:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80071c2:	4620      	mov	r0, r4
 80071c4:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 80071c6:	2800      	cmp	r0, #0
 80071c8:	f43f af22 	beq.w	8007010 <_usb_ep0setup+0x80>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80071cc:	6843      	ldr	r3, [r0, #4]
 80071ce:	6805      	ldr	r5, [r0, #0]
 80071d0:	6565      	str	r5, [r4, #84]	; 0x54
 80071d2:	6523      	str	r3, [r4, #80]	; 0x50
 80071d4:	65a6      	str	r6, [r4, #88]	; 0x58
 80071d6:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 80071da:	e6f2      	b.n	8006fc2 <_usb_ep0setup+0x32>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80071dc:	b93d      	cbnz	r5, 80071ee <_usb_ep0setup+0x25e>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80071de:	2202      	movs	r2, #2
 80071e0:	f104 0164 	add.w	r1, r4, #100	; 0x64
 80071e4:	65a5      	str	r5, [r4, #88]	; 0x58
 80071e6:	6521      	str	r1, [r4, #80]	; 0x50
 80071e8:	6562      	str	r2, [r4, #84]	; 0x54
 80071ea:	4615      	mov	r5, r2
 80071ec:	e6e9      	b.n	8006fc2 <_usb_ep0setup+0x32>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80071ee:	2d01      	cmp	r5, #1
 80071f0:	f47f af0e 	bne.w	8007010 <_usb_ep0setup+0x80>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80071f4:	4a69      	ldr	r2, [pc, #420]	; (800739c <_usb_ep0setup+0x40c>)
 80071f6:	6522      	str	r2, [r4, #80]	; 0x50
 80071f8:	2502      	movs	r5, #2
 80071fa:	2200      	movs	r2, #0
 80071fc:	6565      	str	r5, [r4, #84]	; 0x54
 80071fe:	65a2      	str	r2, [r4, #88]	; 0x58
 8007200:	e6df      	b.n	8006fc2 <_usb_ep0setup+0x32>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8007202:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8007206:	f002 010f 	and.w	r1, r2, #15
 800720a:	0617      	lsls	r7, r2, #24
 800720c:	bf4c      	ite	mi
 800720e:	3148      	addmi	r1, #72	; 0x48
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8007210:	3158      	addpl	r1, #88	; 0x58
 8007212:	0149      	lsls	r1, r1, #5
 8007214:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8007216:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8007218:	0408      	lsls	r0, r1, #16
 800721a:	f57f aefa 	bpl.w	8007012 <_usb_ep0setup+0x82>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 800721e:	f411 1100 	ands.w	r1, r1, #2097152	; 0x200000
 8007222:	d135      	bne.n	8007290 <_usb_ep0setup+0x300>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8007224:	4a5e      	ldr	r2, [pc, #376]	; (80073a0 <_usb_ep0setup+0x410>)
 8007226:	6565      	str	r5, [r4, #84]	; 0x54
 8007228:	65a1      	str	r1, [r4, #88]	; 0x58
 800722a:	6522      	str	r2, [r4, #80]	; 0x50
 800722c:	e6c9      	b.n	8006fc2 <_usb_ep0setup+0x32>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800722e:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 8007232:	2a00      	cmp	r2, #0
 8007234:	f47f aeec 	bne.w	8007010 <_usb_ep0setup+0x80>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8007238:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 800723c:	f012 010f 	ands.w	r1, r2, #15
 8007240:	d086      	beq.n	8007150 <_usb_ep0setup+0x1c0>
 8007242:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8007244:	0612      	lsls	r2, r2, #24
 8007246:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 800724a:	d454      	bmi.n	80072f6 <_usb_ep0setup+0x366>
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800724c:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8007250:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8007254:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8007258:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 800725c:	e778      	b.n	8007150 <_usb_ep0setup+0x1c0>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800725e:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 8007262:	2a00      	cmp	r2, #0
 8007264:	f47f aed4 	bne.w	8007010 <_usb_ep0setup+0x80>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8007268:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
 800726c:	f012 010f 	ands.w	r1, r2, #15
 8007270:	f43f af6e 	beq.w	8007150 <_usb_ep0setup+0x1c0>
 8007274:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8007276:	eb03 1341 	add.w	r3, r3, r1, lsl #5
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800727a:	0611      	lsls	r1, r2, #24
 800727c:	d432      	bmi.n	80072e4 <_usb_ep0setup+0x354>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800727e:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8007282:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8007286:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800728a:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 800728e:	e75f      	b.n	8007150 <_usb_ep0setup+0x1c0>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8007290:	4a44      	ldr	r2, [pc, #272]	; (80073a4 <_usb_ep0setup+0x414>)
 8007292:	6565      	str	r5, [r4, #84]	; 0x54
 8007294:	65a6      	str	r6, [r4, #88]	; 0x58
 8007296:	6522      	str	r2, [r4, #80]	; 0x50
 8007298:	e693      	b.n	8006fc2 <_usb_ep0setup+0x32>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 800729a:	f894 105e 	ldrb.w	r1, [r4, #94]	; 0x5e
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 800729e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80072a0:	f884 1066 	strb.w	r1, [r4, #102]	; 0x66

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 80072a4:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80072a8:	6860      	ldr	r0, [r4, #4]
 80072aa:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80072ae:	6805      	ldr	r5, [r0, #0]
 80072b0:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 80072b4:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 80072b8:	b115      	cbz	r5, 80072c0 <_usb_ep0setup+0x330>
 80072ba:	4620      	mov	r0, r4
 80072bc:	2101      	movs	r1, #1
 80072be:	47a8      	blx	r5
  usbp->state = USB_SELECTED;
 80072c0:	2203      	movs	r2, #3
 80072c2:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 80072c6:	7022      	strb	r2, [r4, #0]
 80072c8:	e742      	b.n	8007150 <_usb_ep0setup+0x1c0>
 80072ca:	2320      	movs	r3, #32
 80072cc:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80072d0:	f7fd fda6 	bl	8004e20 <_dbg_check_lock_from_isr>
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
  unsigned i;

  osalDbgCheckClassI();
 80072d4:	f7fb f83c 	bl	8002350 <chDbgCheckClassI>
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 80072d8:	7823      	ldrb	r3, [r4, #0]
 80072da:	2b04      	cmp	r3, #4
 80072dc:	d014      	beq.n	8007308 <_usb_ep0setup+0x378>
 80072de:	4832      	ldr	r0, [pc, #200]	; (80073a8 <_usb_ep0setup+0x418>)
 80072e0:	f7fd fd4e 	bl	8004d80 <chSysHalt>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 80072e4:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80072e8:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80072ec:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 80072f0:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 80072f4:	e72c      	b.n	8007150 <_usb_ep0setup+0x1c0>
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80072f6:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80072fa:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80072fe:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8007302:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
 8007306:	e723      	b.n	8007150 <_usb_ep0setup+0x1c0>
 8007308:	6f21      	ldr	r1, [r4, #112]	; 0x70

  usbp->transmitting &= 1U;
 800730a:	8922      	ldrh	r2, [r4, #8]
  usbp->receiving    &= 1U;
 800730c:	8963      	ldrh	r3, [r4, #10]
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800730e:	6808      	ldr	r0, [r1, #0]
 8007310:	6760      	str	r0, [r4, #116]	; 0x74

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8007312:	f002 0201 	and.w	r2, r2, #1
  usbp->receiving    &= 1U;
 8007316:	f003 0301 	and.w	r3, r3, #1
 800731a:	688f      	ldr	r7, [r1, #8]
 800731c:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 800731e:	6126      	str	r6, [r4, #16]
 8007320:	6166      	str	r6, [r4, #20]
 8007322:	61a6      	str	r6, [r4, #24]
 8007324:	61e6      	str	r6, [r4, #28]
 8007326:	6226      	str	r6, [r4, #32]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8007328:	8122      	strh	r2, [r4, #8]
  usbp->receiving    &= 1U;
 800732a:	8163      	strh	r3, [r4, #10]

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800732c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8007330:	e00b      	b.n	800734a <_usb_ep0setup+0x3ba>

    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
    }

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8007332:	f8d2 5b00 	ldr.w	r5, [r2, #2816]	; 0xb00
 8007336:	2d00      	cmp	r5, #0
 8007338:	db14      	blt.n	8007364 <_usb_ep0setup+0x3d4>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800733a:	440b      	add	r3, r1

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800733c:	3601      	adds	r6, #1
 800733e:	42be      	cmp	r6, r7

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8007340:	f8c3 0908 	str.w	r0, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8007344:	f8c3 0b08 	str.w	r0, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8007348:	d813      	bhi.n	8007372 <_usb_ep0setup+0x3e2>
 800734a:	0173      	lsls	r3, r6, #5
 800734c:	18ca      	adds	r2, r1, r3

    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 800734e:	f8d2 5900 	ldr.w	r5, [r2, #2304]	; 0x900
 8007352:	2d00      	cmp	r5, #0
 8007354:	daed      	bge.n	8007332 <_usb_ep0setup+0x3a2>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8007356:	f8d2 5900 	ldr.w	r5, [r2, #2304]	; 0x900
 800735a:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 800735e:	f8c2 5900 	str.w	r5, [r2, #2304]	; 0x900
 8007362:	e7e6      	b.n	8007332 <_usb_ep0setup+0x3a2>
    }

    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8007364:	f8d2 5b00 	ldr.w	r5, [r2, #2816]	; 0xb00
 8007368:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 800736c:	f8c2 5b00 	str.w	r5, [r2, #2816]	; 0xb00
 8007370:	e7e3      	b.n	800733a <_usb_ep0setup+0x3aa>
    }

    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8007372:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8007376:	f8c1 381c 	str.w	r3, [r1, #2076]	; 0x81c
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800737a:	f7fd fd39 	bl	8004df0 <_dbg_check_unlock_from_isr>
 800737e:	2300      	movs	r3, #0
 8007380:	f383 8811 	msr	BASEPRI, r3
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8007384:	6862      	ldr	r2, [r4, #4]
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
 8007386:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800738a:	6813      	ldr	r3, [r2, #0]
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
 800738c:	2103      	movs	r1, #3
 800738e:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8007390:	2b00      	cmp	r3, #0
 8007392:	f43f aef6 	beq.w	8007182 <_usb_ep0setup+0x1f2>
 8007396:	4620      	mov	r0, r4
 8007398:	4798      	blx	r3
 800739a:	e6f2      	b.n	8007182 <_usb_ep0setup+0x1f2>
 800739c:	0800d24c 	.word	0x0800d24c
 80073a0:	0800d264 	.word	0x0800d264
 80073a4:	0800d2d4 	.word	0x0800d2d4
 80073a8:	0800d234 	.word	0x0800d234
 80073ac:	00000000 	.word	0x00000000

080073b0 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 80073b0:	4770      	bx	lr
 80073b2:	bf00      	nop
	...

080073c0 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 80073c0:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
 80073c4:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80073c8:	2b20      	cmp	r3, #32
 80073ca:	d001      	beq.n	80073d0 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 80073cc:	2000      	movs	r0, #0
    }
  }
  return false;
}
 80073ce:	4770      	bx	lr
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
    switch (usbp->setup[1]) {
 80073d0:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 80073d4:	2b21      	cmp	r3, #33	; 0x21
 80073d6:	d003      	beq.n	80073e0 <sduRequestsHook+0x20>
 80073d8:	2b22      	cmp	r3, #34	; 0x22
 80073da:	d009      	beq.n	80073f0 <sduRequestsHook+0x30>
 80073dc:	2b20      	cmp	r3, #32
 80073de:	d1f5      	bne.n	80073cc <sduRequestsHook+0xc>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 80073e0:	4b06      	ldr	r3, [pc, #24]	; (80073fc <sduRequestsHook+0x3c>)
 80073e2:	6503      	str	r3, [r0, #80]	; 0x50
 80073e4:	2207      	movs	r2, #7
 80073e6:	2300      	movs	r3, #0
 80073e8:	6542      	str	r2, [r0, #84]	; 0x54
 80073ea:	6583      	str	r3, [r0, #88]	; 0x58
      return true;
 80073ec:	2001      	movs	r0, #1
 80073ee:	4770      	bx	lr
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80073f0:	2300      	movs	r3, #0
 80073f2:	6503      	str	r3, [r0, #80]	; 0x50
 80073f4:	6543      	str	r3, [r0, #84]	; 0x54
 80073f6:	6583      	str	r3, [r0, #88]	; 0x58
      return true;
 80073f8:	2001      	movs	r0, #1
 80073fa:	4770      	bx	lr
 80073fc:	200008f4 	.word	0x200008f4

08007400 <_ctl.lto_priv.91>:
                     sysinterval_t timeout) {

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
}

static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 8007400:	b508      	push	{r3, lr}
  SerialUSBDriver *sdup = (SerialUSBDriver *)ip;

  osalDbgCheck(sdup != NULL);
 8007402:	b118      	cbz	r0, 800740c <_ctl.lto_priv.91+0xc>

  switch (operation) {
 8007404:	b111      	cbz	r1, 800740c <_ctl.lto_priv.91+0xc>
 8007406:	2901      	cmp	r1, #1
 8007408:	d103      	bne.n	8007412 <_ctl.lto_priv.91+0x12>
  case CHN_CTL_NOP:
    osalDbgCheck(arg == NULL);
 800740a:	b112      	cbz	r2, 8007412 <_ctl.lto_priv.91+0x12>
    break;
  case CHN_CTL_INVALID:
    osalDbgAssert(false, "invalid CTL operation");
 800740c:	4802      	ldr	r0, [pc, #8]	; (8007418 <_ctl.lto_priv.91+0x18>)
 800740e:	f7fd fcb7 	bl	8004d80 <chSysHalt>
#else
    break;
#endif
  }
  return MSG_OK;
}
 8007412:	2000      	movs	r0, #0
 8007414:	bd08      	pop	{r3, pc}
 8007416:	bf00      	nop
 8007418:	0800d394 	.word	0x0800d394
 800741c:	00000000 	.word	0x00000000

08007420 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8007420:	b570      	push	{r4, r5, r6, lr}
 8007422:	460d      	mov	r5, r1
 8007424:	4604      	mov	r4, r0

  osalDbgCheckClassS();
 8007426:	f7fa ff5b 	bl	80022e0 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 800742a:	b1d5      	cbz	r5, 8007462 <obqPostFullBufferS+0x42>
 800742c:	69e3      	ldr	r3, [r4, #28]
 800742e:	3b04      	subs	r3, #4
 8007430:	429d      	cmp	r5, r3
 8007432:	d816      	bhi.n	8007462 <obqPostFullBufferS+0x42>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8007434:	68e3      	ldr	r3, [r4, #12]
 8007436:	b1a3      	cbz	r3, 8007462 <obqPostFullBufferS+0x42>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8007438:	6921      	ldr	r1, [r4, #16]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
 800743a:	69a0      	ldr	r0, [r4, #24]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 800743c:	600d      	str	r5, [r1, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
 800743e:	69e3      	ldr	r3, [r4, #28]

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8007440:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
 8007442:	440b      	add	r3, r1
  if (obqp->bwrptr >= obqp->btop) {
 8007444:	4283      	cmp	r3, r0
  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
 8007446:	6123      	str	r3, [r4, #16]
  if (obqp->bwrptr >= obqp->btop) {
    obqp->bwrptr = obqp->buffers;
 8007448:	bf24      	itt	cs
 800744a:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800744c:	6123      	strcs	r3, [r4, #16]

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 800744e:	3a01      	subs	r2, #1

  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8007450:	6b23      	ldr	r3, [r4, #48]	; 0x30

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8007452:	60e2      	str	r2, [r4, #12]
  if (obqp->bwrptr >= obqp->btop) {
    obqp->bwrptr = obqp->buffers;
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8007454:	2200      	movs	r2, #0
 8007456:	62a2      	str	r2, [r4, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8007458:	b133      	cbz	r3, 8007468 <obqPostFullBufferS+0x48>
    obqp->notify(obqp);
 800745a:	4620      	mov	r0, r4
  }
}
 800745c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
    obqp->notify(obqp);
 8007460:	4718      	bx	r3
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {

  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8007462:	4802      	ldr	r0, [pc, #8]	; (800746c <obqPostFullBufferS+0x4c>)
 8007464:	f7fd fc8c 	bl	8004d80 <chSysHalt>
 8007468:	bd70      	pop	{r4, r5, r6, pc}
 800746a:	bf00      	nop
 800746c:	0800d334 	.word	0x0800d334

08007470 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8007470:	b510      	push	{r4, lr}
 8007472:	4604      	mov	r4, r0

  osalDbgCheckClassS();
 8007474:	f7fa ff34 	bl	80022e0 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 8007478:	68e3      	ldr	r3, [r4, #12]
 800747a:	b19b      	cbz	r3, 80074a4 <ibqReleaseEmptyBufferS+0x34>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
  if (ibqp->brdptr >= ibqp->btop) {
 800747c:	f104 0014 	add.w	r0, r4, #20
 8007480:	c80b      	ldmia	r0, {r0, r1, r3}
  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
 8007482:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
 8007484:	428b      	cmp	r3, r1

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8007486:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
 8007488:	6163      	str	r3, [r4, #20]
  if (ibqp->brdptr >= ibqp->btop) {
    ibqp->brdptr = ibqp->buffers;
 800748a:	bf24      	itt	cs
 800748c:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800748e:	6163      	strcs	r3, [r4, #20]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8007490:	3a01      	subs	r2, #1

  /* No "current" buffer.*/
  ibqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8007492:	6b23      	ldr	r3, [r4, #48]	; 0x30

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8007494:	60e2      	str	r2, [r4, #12]
  if (ibqp->brdptr >= ibqp->btop) {
    ibqp->brdptr = ibqp->buffers;
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8007496:	2200      	movs	r2, #0
 8007498:	62a2      	str	r2, [r4, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 800749a:	b133      	cbz	r3, 80074aa <ibqReleaseEmptyBufferS+0x3a>
    ibqp->notify(ibqp);
 800749c:	4620      	mov	r0, r4
  }
}
 800749e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* No "current" buffer.*/
  ibqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
    ibqp->notify(ibqp);
 80074a2:	4718      	bx	r3
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 80074a4:	4801      	ldr	r0, [pc, #4]	; (80074ac <ibqReleaseEmptyBufferS+0x3c>)
 80074a6:	f7fd fc6b 	bl	8004d80 <chSysHalt>
 80074aa:	bd10      	pop	{r4, pc}
 80074ac:	0800d358 	.word	0x0800d358

080074b0 <obqGetEmptyBufferTimeoutS>:
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                sysinterval_t timeout) {
 80074b0:	b538      	push	{r3, r4, r5, lr}
 80074b2:	4604      	mov	r4, r0
 80074b4:	460d      	mov	r5, r1

  osalDbgCheckClassS();
 80074b6:	f7fa ff13 	bl	80022e0 <chDbgCheckClassS>
 80074ba:	e007      	b.n	80074cc <obqGetEmptyBufferTimeoutS+0x1c>

  while (obqIsFullI(obqp)) {
    if (obqp->suspended) {
 80074bc:	7a23      	ldrb	r3, [r4, #8]
 80074be:	b993      	cbnz	r3, 80074e6 <obqGetEmptyBufferTimeoutS+0x36>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
 80074c0:	4620      	mov	r0, r4
 80074c2:	4629      	mov	r1, r5
 80074c4:	f7fb f84c 	bl	8002560 <chThdEnqueueTimeoutS>
      return MSG_RESET;
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
    if (msg < MSG_OK) {
 80074c8:	2800      	cmp	r0, #0
 80074ca:	db0e      	blt.n	80074ea <obqGetEmptyBufferTimeoutS+0x3a>
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                sysinterval_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 80074cc:	68e3      	ldr	r3, [r4, #12]
 80074ce:	2b00      	cmp	r3, #0
 80074d0:	d0f4      	beq.n	80074bc <obqGetEmptyBufferTimeoutS+0xc>
    if (msg < MSG_OK) {
      return msg;
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 80074d2:	68e3      	ldr	r3, [r4, #12]
 80074d4:	b153      	cbz	r3, 80074ec <obqGetEmptyBufferTimeoutS+0x3c>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80074d6:	6922      	ldr	r2, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 80074d8:	69e3      	ldr	r3, [r4, #28]
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80074da:	1d11      	adds	r1, r2, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 80074dc:	4413      	add	r3, r2
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80074de:	62a1      	str	r1, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 80074e0:	62e3      	str	r3, [r4, #44]	; 0x2c
 80074e2:	2000      	movs	r0, #0
 80074e4:	bd38      	pop	{r3, r4, r5, pc}

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
    if (obqp->suspended) {
      return MSG_RESET;
 80074e6:	f06f 0001 	mvn.w	r0, #1
  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  obqp->top = obqp->bwrptr + obqp->bsize;

  return MSG_OK;
}
 80074ea:	bd38      	pop	{r3, r4, r5, pc}
    if (msg < MSG_OK) {
      return msg;
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 80074ec:	4801      	ldr	r0, [pc, #4]	; (80074f4 <obqGetEmptyBufferTimeoutS+0x44>)
 80074ee:	f7fd fc47 	bl	8004d80 <chSysHalt>
 80074f2:	bf00      	nop
 80074f4:	0800d44c 	.word	0x0800d44c
	...

08007500 <ibqGetFullBufferTimeoutS>:
   *                      suspended state.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 sysinterval_t timeout) {
 8007500:	b538      	push	{r3, r4, r5, lr}
 8007502:	4604      	mov	r4, r0
 8007504:	460d      	mov	r5, r1

  osalDbgCheckClassS();
 8007506:	f7fa feeb 	bl	80022e0 <chDbgCheckClassS>
 800750a:	e007      	b.n	800751c <ibqGetFullBufferTimeoutS+0x1c>

  while (ibqIsEmptyI(ibqp)) {
    if (ibqp->suspended) {
 800750c:	7a23      	ldrb	r3, [r4, #8]
 800750e:	b993      	cbnz	r3, 8007536 <ibqGetFullBufferTimeoutS+0x36>
 8007510:	4620      	mov	r0, r4
 8007512:	4629      	mov	r1, r5
 8007514:	f7fb f824 	bl	8002560 <chThdEnqueueTimeoutS>
      return MSG_RESET;
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
    if (msg < MSG_OK) {
 8007518:	2800      	cmp	r0, #0
 800751a:	db0e      	blt.n	800753a <ibqGetFullBufferTimeoutS+0x3a>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 sysinterval_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 800751c:	68e3      	ldr	r3, [r4, #12]
 800751e:	2b00      	cmp	r3, #0
 8007520:	d0f4      	beq.n	800750c <ibqGetFullBufferTimeoutS+0xc>
    if (msg < MSG_OK) {
       return msg;
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 8007522:	68e3      	ldr	r3, [r4, #12]
 8007524:	b153      	cbz	r3, 800753c <ibqGetFullBufferTimeoutS+0x3c>

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8007526:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8007528:	681a      	ldr	r2, [r3, #0]
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800752a:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 800752c:	441a      	add	r2, r3
 800752e:	62e2      	str	r2, [r4, #44]	; 0x2c
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8007530:	62a3      	str	r3, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8007532:	2000      	movs	r0, #0
 8007534:	bd38      	pop	{r3, r4, r5, pc}

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
    if (ibqp->suspended) {
      return MSG_RESET;
 8007536:	f06f 0001 	mvn.w	r0, #1
  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);

  return MSG_OK;
}
 800753a:	bd38      	pop	{r3, r4, r5, pc}
    if (msg < MSG_OK) {
       return msg;
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 800753c:	4801      	ldr	r0, [pc, #4]	; (8007544 <ibqGetFullBufferTimeoutS+0x44>)
 800753e:	f7fd fc1f 	bl	8004d80 <chSysHalt>
 8007542:	bf00      	nop
 8007544:	0800d430 	.word	0x0800d430
	...

08007550 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8007550:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8007554:	4604      	mov	r4, r0
 8007556:	460e      	mov	r6, r1
 8007558:	4615      	mov	r5, r2

  osalDbgCheckClassI();
 800755a:	f7fa fef9 	bl	8002350 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 800755e:	b11c      	cbz	r4, 8007568 <usbInitEndpointI+0x18>
 8007560:	b115      	cbz	r5, 8007568 <usbInitEndpointI+0x18>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8007562:	7823      	ldrb	r3, [r4, #0]
 8007564:	2b04      	cmp	r3, #4
 8007566:	d002      	beq.n	800756e <usbInitEndpointI+0x1e>
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8007568:	485d      	ldr	r0, [pc, #372]	; (80076e0 <usbInitEndpointI+0x190>)
 800756a:	f7fd fc09 	bl	8004d80 <chSysHalt>
 800756e:	fa0f f886 	sxth.w	r8, r6
 8007572:	eb04 0788 	add.w	r7, r4, r8, lsl #2
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8007576:	68f9      	ldr	r1, [r7, #12]
 8007578:	2900      	cmp	r1, #0
 800757a:	d1f5      	bne.n	8007568 <usbInitEndpointI+0x18>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 800757c:	60fd      	str	r5, [r7, #12]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 800757e:	6968      	ldr	r0, [r5, #20]
 8007580:	b110      	cbz	r0, 8007588 <usbInitEndpointI+0x38>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8007582:	2210      	movs	r2, #16
 8007584:	f001 fbb0 	bl	8008ce8 <memset>
  }
  if (epcp->out_state != NULL) {
 8007588:	69a8      	ldr	r0, [r5, #24]
 800758a:	b118      	cbz	r0, 8007594 <usbInitEndpointI+0x44>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800758c:	2100      	movs	r1, #0
 800758e:	2210      	movs	r2, #16
 8007590:	f001 fbaa 	bl	8008ce8 <memset>
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8007594:	68fb      	ldr	r3, [r7, #12]
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 8007596:	6ee5      	ldr	r5, [r4, #108]	; 0x6c

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8007598:	681a      	ldr	r2, [r3, #0]
 800759a:	f002 0203 	and.w	r2, r2, #3
 800759e:	2a02      	cmp	r2, #2
 80075a0:	d05d      	beq.n	800765e <usbInitEndpointI+0x10e>
 80075a2:	2a03      	cmp	r2, #3
 80075a4:	d05e      	beq.n	8007664 <usbInitEndpointI+0x114>
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 80075a6:	484f      	ldr	r0, [pc, #316]	; (80076e4 <usbInitEndpointI+0x194>)
 80075a8:	494f      	ldr	r1, [pc, #316]	; (80076e8 <usbInitEndpointI+0x198>)
 80075aa:	2a01      	cmp	r2, #1
 80075ac:	bf0c      	ite	eq
 80075ae:	4681      	moveq	r9, r0
 80075b0:	4689      	movne	r9, r1
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 80075b2:	0172      	lsls	r2, r6, #5
  if (usbp->epc[ep]->out_state != NULL) {
 80075b4:	6999      	ldr	r1, [r3, #24]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 80075b6:	18a8      	adds	r0, r5, r2
 80075b8:	f04f 0e00 	mov.w	lr, #0
 80075bc:	f8c0 eb10 	str.w	lr, [r0, #2832]	; 0xb10
  if (usbp->epc[ep]->out_state != NULL) {
 80075c0:	2900      	cmp	r1, #0
 80075c2:	d055      	beq.n	8007670 <usbInitEndpointI+0x120>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 80075c4:	8a58      	ldrh	r0, [r3, #18]
 80075c6:	f106 0158 	add.w	r1, r6, #88	; 0x58
 80075ca:	0149      	lsls	r1, r1, #5
 80075cc:	ea49 0000 	orr.w	r0, r9, r0
 80075d0:	5068      	str	r0, [r5, r1]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 80075d2:	f106 0e10 	add.w	lr, r6, #16
 80075d6:	f8d5 081c 	ldr.w	r0, [r5, #2076]	; 0x81c
 80075da:	2101      	movs	r1, #1
 80075dc:	fa01 f10e 	lsl.w	r1, r1, lr
 80075e0:	4301      	orrs	r1, r0
 80075e2:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80075e6:	442a      	add	r2, r5
  if (usbp->epc[ep]->in_state != NULL) {
 80075e8:	6959      	ldr	r1, [r3, #20]
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80075ea:	2000      	movs	r0, #0
 80075ec:	f8c2 0910 	str.w	r0, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 80075f0:	2900      	cmp	r1, #0
 80075f2:	d051      	beq.n	8007698 <usbInitEndpointI+0x148>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 80075f4:	8b9a      	ldrh	r2, [r3, #28]

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80075f6:	8a19      	ldrh	r1, [r3, #16]
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 80075f8:	f8d4 e074 	ldr.w	lr, [r4, #116]	; 0x74
  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 80075fc:	2a01      	cmp	r2, #1

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80075fe:	ea4f 0391 	mov.w	r3, r1, lsr #2
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
 8007602:	bf88      	it	hi
 8007604:	4353      	mulhi	r3, r2
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8007606:	eb03 010e 	add.w	r1, r3, lr
 800760a:	6f22      	ldr	r2, [r4, #112]	; 0x70
 800760c:	6761      	str	r1, [r4, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800760e:	6852      	ldr	r2, [r2, #4]
 8007610:	4291      	cmp	r1, r2
 8007612:	d82a      	bhi.n	800766a <usbInitEndpointI+0x11a>
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8007614:	f106 003f 	add.w	r0, r6, #63	; 0x3f
 8007618:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800761a:	eb05 0080 	add.w	r0, r5, r0, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800761e:	01b1      	lsls	r1, r6, #6
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8007620:	ea4e 4303 	orr.w	r3, lr, r3, lsl #16
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8007624:	f041 0120 	orr.w	r1, r1, #32
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8007628:	6043      	str	r3, [r0, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800762a:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800762c:	6913      	ldr	r3, [r2, #16]
 800762e:	0699      	lsls	r1, r3, #26
 8007630:	d4fc      	bmi.n	800762c <usbInitEndpointI+0xdc>
 * @xclass
 */
#if (PORT_SUPPORTS_RT == TRUE) || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8007632:	2012      	movs	r0, #18
 8007634:	f7fd fb94 	bl	8004d60 <chSysPolledDelayX>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8007638:	68fb      	ldr	r3, [r7, #12]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 800763a:	8a1a      	ldrh	r2, [r3, #16]
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800763c:	f106 0348 	add.w	r3, r6, #72	; 0x48
 8007640:	015b      	lsls	r3, r3, #5
 8007642:	ea42 5286 	orr.w	r2, r2, r6, lsl #22
                           DIEPCTL_TXFNUM(ep) |
 8007646:	ea42 0209 	orr.w	r2, r2, r9
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800764a:	50ea      	str	r2, [r5, r3]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 800764c:	2301      	movs	r3, #1
 800764e:	f8d5 281c 	ldr.w	r2, [r5, #2076]	; 0x81c
 8007652:	40b3      	lsls	r3, r6
 8007654:	4313      	orrs	r3, r2
 8007656:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 800765a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 800765e:	f8df 9094 	ldr.w	r9, [pc, #148]	; 80076f4 <usbInitEndpointI+0x1a4>
 8007662:	e7a6      	b.n	80075b2 <usbInitEndpointI+0x62>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8007664:	f8df 9090 	ldr.w	r9, [pc, #144]	; 80076f8 <usbInitEndpointI+0x1a8>
 8007668:	e7a3      	b.n	80075b2 <usbInitEndpointI+0x62>
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800766a:	4820      	ldr	r0, [pc, #128]	; (80076ec <usbInitEndpointI+0x19c>)
 800766c:	f7fd fb88 	bl	8004d80 <chSysHalt>
 8007670:	eb05 1148 	add.w	r1, r5, r8, lsl #5
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8007674:	f106 0e10 	add.w	lr, r6, #16
  if (usbp->epc[ep]->out_state != NULL) {
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8007678:	f8d1 0b00 	ldr.w	r0, [r1, #2816]	; 0xb00
 800767c:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8007680:	f8c1 0b00 	str.w	r0, [r1, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8007684:	f8d5 081c 	ldr.w	r0, [r5, #2076]	; 0x81c
 8007688:	2101      	movs	r1, #1
 800768a:	fa01 f10e 	lsl.w	r1, r1, lr
 800768e:	ea20 0101 	bic.w	r1, r0, r1
 8007692:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
 8007696:	e7a6      	b.n	80075e6 <usbInitEndpointI+0x96>
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8007698:	f106 033f 	add.w	r3, r6, #63	; 0x3f
 800769c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800769e:	4814      	ldr	r0, [pc, #80]	; (80076f0 <usbInitEndpointI+0x1a0>)
 80076a0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80076a4:	01b1      	lsls	r1, r6, #6
 80076a6:	f041 0120 	orr.w	r1, r1, #32
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80076aa:	6058      	str	r0, [r3, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80076ac:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80076ae:	6913      	ldr	r3, [r2, #16]
 80076b0:	069b      	lsls	r3, r3, #26
 80076b2:	d4fc      	bmi.n	80076ae <usbInitEndpointI+0x15e>
 80076b4:	eb05 1848 	add.w	r8, r5, r8, lsl #5
 80076b8:	2012      	movs	r0, #18
 80076ba:	f7fd fb51 	bl	8004d60 <chSysPolledDelayX>
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80076be:	f8d8 2900 	ldr.w	r2, [r8, #2304]	; 0x900
 80076c2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80076c6:	f8c8 2900 	str.w	r2, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80076ca:	f8d5 281c 	ldr.w	r2, [r5, #2076]	; 0x81c
 80076ce:	2301      	movs	r3, #1
 80076d0:	40b3      	lsls	r3, r6
 80076d2:	ea22 0303 	bic.w	r3, r2, r3
 80076d6:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 80076da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80076de:	bf00      	nop
 80076e0:	0800d380 	.word	0x0800d380
 80076e4:	10048000 	.word	0x10048000
 80076e8:	10008000 	.word	0x10008000
 80076ec:	0800cee8 	.word	0x0800cee8
 80076f0:	02000400 	.word	0x02000400
 80076f4:	10088000 	.word	0x10088000
 80076f8:	100c8000 	.word	0x100c8000
 80076fc:	00000000 	.word	0x00000000

08007700 <sdu_start_receive.lto_priv.102>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8007700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8007702:	f8d0 648c 	ldr.w	r6, [r0, #1164]	; 0x48c
 8007706:	6837      	ldr	r7, [r6, #0]
 8007708:	783b      	ldrb	r3, [r7, #0]
 800770a:	2b04      	cmp	r3, #4
 800770c:	d001      	beq.n	8007712 <sdu_start_receive.lto_priv.102+0x12>
      (sdup->state != SDU_READY)) {
    return true;
 800770e:	2001      	movs	r0, #1
 8007710:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
static bool sdu_start_receive(SerialUSBDriver *sdup) {
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8007712:	7a03      	ldrb	r3, [r0, #8]
 8007714:	2b02      	cmp	r3, #2
 8007716:	d1fa      	bne.n	800770e <sdu_start_receive.lto_priv.102+0xe>
      (sdup->state != SDU_READY)) {
    return true;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8007718:	7932      	ldrb	r2, [r6, #4]
 800771a:	897b      	ldrh	r3, [r7, #10]
 800771c:	2501      	movs	r5, #1
 800771e:	fa05 f202 	lsl.w	r2, r5, r2
 8007722:	421a      	tst	r2, r3
 8007724:	d1f3      	bne.n	800770e <sdu_start_receive.lto_priv.102+0xe>
 8007726:	4604      	mov	r4, r0
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();
 8007728:	f7fa fe12 	bl	8002350 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 800772c:	69e2      	ldr	r2, [r4, #28]
 800772e:	6a23      	ldr	r3, [r4, #32]
 8007730:	429a      	cmp	r2, r3
 8007732:	d009      	beq.n	8007748 <sdu_start_receive.lto_priv.102+0x48>
    return true;
  }

  /* Checking if there is a buffer ready for incoming data.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
  if (buf == NULL) {
 8007734:	3204      	adds	r2, #4
 8007736:	d0ea      	beq.n	800770e <sdu_start_receive.lto_priv.102+0xe>
    return true;
  }

  /* Buffer found, starting a new transaction.*/
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8007738:	4638      	mov	r0, r7
 800773a:	7971      	ldrb	r1, [r6, #5]
 800773c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007740:	f7ff fb8e 	bl	8006e60 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);

  return false;
 8007744:	2000      	movs	r0, #0
 8007746:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007748:	69a3      	ldr	r3, [r4, #24]
 800774a:	2b00      	cmp	r3, #0
 800774c:	d1df      	bne.n	800770e <sdu_start_receive.lto_priv.102+0xe>
 800774e:	e7f1      	b.n	8007734 <sdu_start_receive.lto_priv.102+0x34>

08007750 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  size_t size;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8007750:	310d      	adds	r1, #13
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8007752:	b538      	push	{r3, r4, r5, lr}
  size_t size;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8007754:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]

  if (sdup == NULL) {
 8007758:	b1bc      	cbz	r4, 800778a <sduDataReceived+0x3a>
 800775a:	2320      	movs	r3, #32
 800775c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8007760:	f7fd fb5e 	bl	8004e20 <_dbg_check_lock_from_isr>
  }

  osalSysLockFromISR();

  /* Checking for zero-size transactions.*/
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8007764:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8007768:	6813      	ldr	r3, [r2, #0]
 800776a:	7952      	ldrb	r2, [r2, #5]
 800776c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8007770:	68db      	ldr	r3, [r3, #12]
 8007772:	699b      	ldr	r3, [r3, #24]
 8007774:	685d      	ldr	r5, [r3, #4]
                                       sdup->config->bulk_out);
  if (size > (size_t)0) {
 8007776:	b94d      	cbnz	r5, 800778c <sduDataReceived+0x3c>
  }

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  (void) sdu_start_receive(sdup);
 8007778:	4620      	mov	r0, r4
 800777a:	f7ff ffc1 	bl	8007700 <sdu_start_receive.lto_priv.102>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800777e:	f7fd fb37 	bl	8004df0 <_dbg_check_unlock_from_isr>
 8007782:	2300      	movs	r3, #0
 8007784:	f383 8811 	msr	BASEPRI, r3
 8007788:	bd38      	pop	{r3, r4, r5, pc}
 800778a:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800778c:	1d20      	adds	r0, r4, #4
 800778e:	2104      	movs	r1, #4
 8007790:	f7fa ffa6 	bl	80026e0 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();
 8007794:	f7fa fddc 	bl	8002350 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8007798:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800779a:	3b04      	subs	r3, #4
 800779c:	429d      	cmp	r5, r3
 800779e:	d817      	bhi.n	80077d0 <sduDataReceived+0x80>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 80077a0:	69e2      	ldr	r2, [r4, #28]
 80077a2:	6a23      	ldr	r3, [r4, #32]
 80077a4:	429a      	cmp	r2, r3
 80077a6:	d010      	beq.n	80077ca <sduDataReceived+0x7a>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 80077a8:	6015      	str	r5, [r2, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
 80077aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80077ac:	69a1      	ldr	r1, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 80077ae:	6a60      	ldr	r0, [r4, #36]	; 0x24
  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
 80077b0:	4413      	add	r3, r2

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80077b2:	3101      	adds	r1, #1
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 80077b4:	4283      	cmp	r3, r0

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80077b6:	61a1      	str	r1, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 80077b8:	61e3      	str	r3, [r4, #28]
  if (ibqp->bwrptr >= ibqp->btop) {
 80077ba:	d301      	bcc.n	80077c0 <sduDataReceived+0x70>
    ibqp->bwrptr = ibqp->buffers;
 80077bc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80077be:	61e3      	str	r3, [r4, #28]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 80077c0:	f104 000c 	add.w	r0, r4, #12
 80077c4:	f000 fb4c 	bl	8007e60 <chThdDequeueNextI.constprop.55>
 80077c8:	e7d6      	b.n	8007778 <sduDataReceived+0x28>
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 80077ca:	69a3      	ldr	r3, [r4, #24]
 80077cc:	2b00      	cmp	r3, #0
 80077ce:	d0eb      	beq.n	80077a8 <sduDataReceived+0x58>
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 80077d0:	4801      	ldr	r0, [pc, #4]	; (80077d8 <sduDataReceived+0x88>)
 80077d2:	f7fd fad5 	bl	8004d80 <chSysHalt>
 80077d6:	bf00      	nop
 80077d8:	0800d39c 	.word	0x0800d39c
 80077dc:	00000000 	.word	0x00000000

080077e0 <ibnotify.lto_priv.77>:
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
  (void) sdu_start_receive(sdup);
 80077e0:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80077e2:	f7ff bf8d 	b.w	8007700 <sdu_start_receive.lto_priv.102>
 80077e6:	bf00      	nop
	...

080077f0 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 80077f0:	b538      	push	{r3, r4, r5, lr}
 80077f2:	4604      	mov	r4, r0
 80077f4:	460d      	mov	r5, r1

  osalDbgCheckClassI();
 80077f6:	f7fa fdab 	bl	8002350 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
 80077fa:	6963      	ldr	r3, [r4, #20]
 80077fc:	6922      	ldr	r2, [r4, #16]
 80077fe:	429a      	cmp	r2, r3
 8007800:	d004      	beq.n	800780c <obqGetFullBufferI+0x1c>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8007802:	4618      	mov	r0, r3
 8007804:	f850 3b04 	ldr.w	r3, [r0], #4
 8007808:	602b      	str	r3, [r5, #0]

  return obqp->brdptr + sizeof (size_t);
}
 800780a:	bd38      	pop	{r3, r4, r5, pc}
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 800780c:	68e2      	ldr	r2, [r4, #12]
 800780e:	2a00      	cmp	r2, #0
 8007810:	d0f7      	beq.n	8007802 <obqGetFullBufferI+0x12>
    return NULL;
 8007812:	2000      	movs	r0, #0
 8007814:	bd38      	pop	{r3, r4, r5, pc}
 8007816:	bf00      	nop
	...

08007820 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8007820:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8007822:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8007826:	b083      	sub	sp, #12
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8007828:	6a1c      	ldr	r4, [r3, #32]

  if (sdup == NULL) {
 800782a:	b30c      	cbz	r4, 8007870 <sduDataTransmitted+0x50>
 800782c:	460e      	mov	r6, r1
 800782e:	4605      	mov	r5, r0
 8007830:	2320      	movs	r3, #32
 8007832:	f383 8811 	msr	BASEPRI, r3
 8007836:	eb00 0781 	add.w	r7, r0, r1, lsl #2
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800783a:	f7fd faf1 	bl	8004e20 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800783e:	1d20      	adds	r0, r4, #4
 8007840:	2108      	movs	r1, #8
 8007842:	f7fa ff4d 	bl	80026e0 <chEvtBroadcastFlagsI>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8007846:	68fb      	ldr	r3, [r7, #12]
 8007848:	695b      	ldr	r3, [r3, #20]
 800784a:	681b      	ldr	r3, [r3, #0]
 800784c:	b993      	cbnz	r3, 8007874 <sduDataTransmitted+0x54>
 800784e:	3444      	adds	r4, #68	; 0x44
    obqReleaseEmptyBufferI(&sdup->obqueue);
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8007850:	4620      	mov	r0, r4
 8007852:	a901      	add	r1, sp, #4
 8007854:	f7ff ffcc 	bl	80077f0 <obqGetFullBufferI>

  if (buf != NULL) {
 8007858:	4602      	mov	r2, r0
 800785a:	b338      	cbz	r0, 80078ac <sduDataTransmitted+0x8c>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 800785c:	4628      	mov	r0, r5
 800785e:	4631      	mov	r1, r6
 8007860:	9b01      	ldr	r3, [sp, #4]
 8007862:	f7ff fa85 	bl	8006d70 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8007866:	f7fd fac3 	bl	8004df0 <_dbg_check_unlock_from_isr>
 800786a:	2300      	movs	r3, #0
 800786c:	f383 8811 	msr	BASEPRI, r3
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 8007870:	b003      	add	sp, #12
 8007872:	bdf0      	pop	{r4, r5, r6, r7, pc}
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 8007874:	f7fa fd6c 	bl	8002350 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 8007878:	6da0      	ldr	r0, [r4, #88]	; 0x58
 800787a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800787c:	4283      	cmp	r3, r0
 800787e:	d025      	beq.n	80078cc <sduDataTransmitted+0xac>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
  obqp->brdptr += obqp->bsize;
 8007880:	6e23      	ldr	r3, [r4, #96]	; 0x60

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 8007882:	6d22      	ldr	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
  if (obqp->brdptr >= obqp->btop) {
 8007884:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
  obqp->brdptr += obqp->bsize;
 8007886:	4403      	add	r3, r0

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 8007888:	3201      	adds	r2, #1
  obqp->brdptr += obqp->bsize;
  if (obqp->brdptr >= obqp->btop) {
 800788a:	428b      	cmp	r3, r1

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 800788c:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 800788e:	65a3      	str	r3, [r4, #88]	; 0x58
  if (obqp->brdptr >= obqp->btop) {
 8007890:	d301      	bcc.n	8007896 <sduDataTransmitted+0x76>
    obqp->brdptr = obqp->buffers;
 8007892:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8007894:	65a3      	str	r3, [r4, #88]	; 0x58
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 8007896:	3444      	adds	r4, #68	; 0x44
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 8007898:	4620      	mov	r0, r4
 800789a:	f000 fae1 	bl	8007e60 <chThdDequeueNextI.constprop.55>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
    obqReleaseEmptyBufferI(&sdup->obqueue);
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800789e:	4620      	mov	r0, r4
 80078a0:	a901      	add	r1, sp, #4
 80078a2:	f7ff ffa5 	bl	80077f0 <obqGetFullBufferI>

  if (buf != NULL) {
 80078a6:	4602      	mov	r2, r0
 80078a8:	2800      	cmp	r0, #0
 80078aa:	d1d7      	bne.n	800785c <sduDataTransmitted+0x3c>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80078ac:	68fb      	ldr	r3, [r7, #12]
 80078ae:	695a      	ldr	r2, [r3, #20]
 80078b0:	6812      	ldr	r2, [r2, #0]
 80078b2:	2a00      	cmp	r2, #0
 80078b4:	d0d7      	beq.n	8007866 <sduDataTransmitted+0x46>
           ((usbp->epc[ep]->in_state->txsize &
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 80078b6:	8a1b      	ldrh	r3, [r3, #16]
 80078b8:	3b01      	subs	r3, #1
  if (buf != NULL) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80078ba:	4013      	ands	r3, r2
 80078bc:	d1d3      	bne.n	8007866 <sduDataTransmitted+0x46>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 80078be:	4631      	mov	r1, r6
 80078c0:	4628      	mov	r0, r5
 80078c2:	f105 025c 	add.w	r2, r5, #92	; 0x5c
 80078c6:	f7ff fa53 	bl	8006d70 <usbStartTransmitI>
 80078ca:	e7cc      	b.n	8007866 <sduDataTransmitted+0x46>
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 80078cc:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80078ce:	2b00      	cmp	r3, #0
 80078d0:	d0d6      	beq.n	8007880 <sduDataTransmitted+0x60>
 80078d2:	4801      	ldr	r0, [pc, #4]	; (80078d8 <sduDataTransmitted+0xb8>)
 80078d4:	f7fd fa54 	bl	8004d80 <chSysHalt>
 80078d8:	0800d480 	.word	0x0800d480
 80078dc:	00000000 	.word	0x00000000

080078e0 <obnotify.lto_priv.78>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 80078e0:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80078e2:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80078e4:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 80078e8:	6813      	ldr	r3, [r2, #0]
 80078ea:	7819      	ldrb	r1, [r3, #0]
 80078ec:	2904      	cmp	r1, #4
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 80078ee:	b082      	sub	sp, #8
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80078f0:	d001      	beq.n	80078f6 <obnotify.lto_priv.78+0x16>
       callback is invoked when one has been inserted.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
    osalDbgAssert(buf != NULL, "buffer not found");
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  }
}
 80078f2:	b002      	add	sp, #8
 80078f4:	bd10      	pop	{r4, pc}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80078f6:	7a21      	ldrb	r1, [r4, #8]
 80078f8:	2902      	cmp	r1, #2
 80078fa:	d1fa      	bne.n	80078f2 <obnotify.lto_priv.78+0x12>
      (sdup->state != SDU_READY)) {
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80078fc:	7911      	ldrb	r1, [r2, #4]
 80078fe:	891a      	ldrh	r2, [r3, #8]
 8007900:	2301      	movs	r3, #1
 8007902:	408b      	lsls	r3, r1
 8007904:	4213      	tst	r3, r2
 8007906:	d1f4      	bne.n	80078f2 <obnotify.lto_priv.78+0x12>
    /* Getting a full buffer, a buffer is available for sure because this
       callback is invoked when one has been inserted.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8007908:	f104 0044 	add.w	r0, r4, #68	; 0x44
 800790c:	a901      	add	r1, sp, #4
 800790e:	f7ff ff6f 	bl	80077f0 <obqGetFullBufferI>
    osalDbgAssert(buf != NULL, "buffer not found");
 8007912:	4602      	mov	r2, r0
 8007914:	b138      	cbz	r0, 8007926 <obnotify.lto_priv.78+0x46>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8007916:	f8d4 148c 	ldr.w	r1, [r4, #1164]	; 0x48c
 800791a:	9b01      	ldr	r3, [sp, #4]
 800791c:	6808      	ldr	r0, [r1, #0]
 800791e:	7909      	ldrb	r1, [r1, #4]
 8007920:	f7ff fa26 	bl	8006d70 <usbStartTransmitI>
 8007924:	e7e5      	b.n	80078f2 <obnotify.lto_priv.78+0x12>
  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
    /* Getting a full buffer, a buffer is available for sure because this
       callback is invoked when one has been inserted.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
    osalDbgAssert(buf != NULL, "buffer not found");
 8007926:	4801      	ldr	r0, [pc, #4]	; (800792c <obnotify.lto_priv.78+0x4c>)
 8007928:	f7fd fa2a 	bl	8004d80 <chSysHalt>
 800792c:	0800d468 	.word	0x0800d468

08007930 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8007930:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8007932:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007936:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8007938:	0792      	lsls	r2, r2, #30
 800793a:	d501      	bpl.n	8007940 <stSetAlarm+0x10>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800793c:	6358      	str	r0, [r3, #52]	; 0x34
 800793e:	bd08      	pop	{r3, pc}
 8007940:	4801      	ldr	r0, [pc, #4]	; (8007948 <stSetAlarm+0x18>)
 8007942:	f7fd fa1d 	bl	8004d80 <chSysHalt>
 8007946:	bf00      	nop
 8007948:	0800d498 	.word	0x0800d498
 800794c:	00000000 	.word	0x00000000

08007950 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8007950:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8007952:	4e11      	ldr	r6, [pc, #68]	; (8007998 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8007954:	2500      	movs	r5, #0
 8007956:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 800795a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800795e:	42a3      	cmp	r3, r4
 8007960:	d20d      	bcs.n	800797e <__init_ram_areas+0x2e>
 8007962:	3904      	subs	r1, #4
 8007964:	461a      	mov	r2, r3
      *p = *tp;
 8007966:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800796a:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800796e:	42a2      	cmp	r2, r4
 8007970:	d3f9      	bcc.n	8007966 <__init_ram_areas+0x16>
 8007972:	43da      	mvns	r2, r3
 8007974:	4414      	add	r4, r2
 8007976:	f024 0403 	bic.w	r4, r4, #3
 800797a:	3404      	adds	r4, #4
 800797c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800797e:	68f2      	ldr	r2, [r6, #12]
 8007980:	4293      	cmp	r3, r2
 8007982:	d203      	bcs.n	800798c <__init_ram_areas+0x3c>
      *p = 0;
 8007984:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8007988:	4293      	cmp	r3, r2
 800798a:	d3fb      	bcc.n	8007984 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800798c:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800798e:	42be      	cmp	r6, r7
 8007990:	d3e3      	bcc.n	800795a <__init_ram_areas+0xa>
#endif
}
 8007992:	bcf0      	pop	{r4, r5, r6, r7}
 8007994:	4770      	bx	lr
 8007996:	bf00      	nop
 8007998:	0800d3b0 	.word	0x0800d3b0
 800799c:	00000000 	.word	0x00000000

080079a0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80079a0:	e7fe      	b.n	80079a0 <__default_exit>
 80079a2:	bf00      	nop
	...

080079b0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80079b0:	4770      	bx	lr
 80079b2:	bf00      	nop
	...

080079c0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80079c0:	4770      	bx	lr
 80079c2:	bf00      	nop
	...

080079d0 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, sysinterval_t timeout) {
 80079d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80079d4:	b083      	sub	sp, #12
  size_t w = 0;

  osalDbgCheck(n > 0U);
 80079d6:	4616      	mov	r6, r2
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, sysinterval_t timeout) {
 80079d8:	9301      	str	r3, [sp, #4]
  size_t w = 0;

  osalDbgCheck(n > 0U);
 80079da:	2a00      	cmp	r2, #0
 80079dc:	d072      	beq.n	8007ac4 <obqWriteTimeout+0xf4>
 80079de:	4682      	mov	sl, r0
 80079e0:	468b      	mov	fp, r1
 80079e2:	2720      	movs	r7, #32
 80079e4:	f387 8811 	msr	BASEPRI, r7
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80079e8:	f7fd fa42 	bl	8004e70 <_dbg_check_lock>
 80079ec:	4d40      	ldr	r5, [pc, #256]	; (8007af0 <obqWriteTimeout+0x120>)

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 80079ee:	f8da 0028 	ldr.w	r0, [sl, #40]	; 0x28
 80079f2:	9600      	str	r6, [sp, #0]
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, sysinterval_t timeout) {
  size_t w = 0;
 80079f4:	2400      	movs	r4, #0

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80079f6:	46a8      	mov	r8, r5
 80079f8:	46a1      	mov	r9, r4

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 80079fa:	2800      	cmp	r0, #0
 80079fc:	d057      	beq.n	8007aae <obqWriteTimeout+0xde>
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80079fe:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
    if (size > (n - w)) {
 8007a02:	9b00      	ldr	r3, [sp, #0]
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8007a04:	1a12      	subs	r2, r2, r0
    if (size > (n - w)) {
 8007a06:	1b1e      	subs	r6, r3, r4
 8007a08:	4296      	cmp	r6, r2
 8007a0a:	bf28      	it	cs
 8007a0c:	4616      	movcs	r6, r2
      size = n - w;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8007a0e:	2e40      	cmp	r6, #64	; 0x40
 8007a10:	d926      	bls.n	8007a60 <obqWriteTimeout+0x90>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
 8007a12:	f10b 0240 	add.w	r2, fp, #64	; 0x40
 8007a16:	f8db 6000 	ldr.w	r6, [fp]
 8007a1a:	f8db 1004 	ldr.w	r1, [fp, #4]
 8007a1e:	f8db 3008 	ldr.w	r3, [fp, #8]
 8007a22:	f8db e00c 	ldr.w	lr, [fp, #12]
 8007a26:	f8c0 e00c 	str.w	lr, [r0, #12]
 8007a2a:	f10b 0b10 	add.w	fp, fp, #16
 8007a2e:	4593      	cmp	fp, r2
 8007a30:	6006      	str	r6, [r0, #0]
 8007a32:	6041      	str	r1, [r0, #4]
 8007a34:	6083      	str	r3, [r0, #8]
 8007a36:	f100 0010 	add.w	r0, r0, #16
 8007a3a:	d1ec      	bne.n	8007a16 <obqWriteTimeout+0x46>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8007a3c:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8007a40:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8007a44:	3240      	adds	r2, #64	; 0x40
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8007a46:	4291      	cmp	r1, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
 8007a48:	f104 0440 	add.w	r4, r4, #64	; 0x40
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8007a4c:	f8ca 2028 	str.w	r2, [sl, #40]	; 0x28
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8007a50:	d815      	bhi.n	8007a7e <obqWriteTimeout+0xae>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8007a52:	f8da 101c 	ldr.w	r1, [sl, #28]
 8007a56:	4650      	mov	r0, sl
 8007a58:	3904      	subs	r1, #4
 8007a5a:	f7ff fce1 	bl	8007420 <obqPostFullBufferS>
 8007a5e:	e00e      	b.n	8007a7e <obqWriteTimeout+0xae>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8007a60:	4659      	mov	r1, fp
 8007a62:	4632      	mov	r2, r6
 8007a64:	f7f8 fc70 	bl	8000348 <memcpy>
      bp        += size;
      obqp->ptr += size;
 8007a68:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8007a6c:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
      obqp->ptr += size;
 8007a70:	4432      	add	r2, r6
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8007a72:	4291      	cmp	r1, r2
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
      obqp->ptr += size;
      w         += size;
 8007a74:	4434      	add	r4, r6
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
 8007a76:	44b3      	add	fp, r6
      obqp->ptr += size;
 8007a78:	f8ca 2028 	str.w	r2, [sl, #40]	; 0x28
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8007a7c:	d9e9      	bls.n	8007a52 <obqWriteTimeout+0x82>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007a7e:	f7fd f9e7 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007a82:	682a      	ldr	r2, [r5, #0]
 8007a84:	42aa      	cmp	r2, r5
 8007a86:	d005      	beq.n	8007a94 <obqWriteTimeout+0xc4>
 8007a88:	f8d8 1018 	ldr.w	r1, [r8, #24]
 8007a8c:	6892      	ldr	r2, [r2, #8]
 8007a8e:	6889      	ldr	r1, [r1, #8]
 8007a90:	4291      	cmp	r1, r2
 8007a92:	d314      	bcc.n	8007abe <obqWriteTimeout+0xee>
 8007a94:	f389 8811 	msr	BASEPRI, r9
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (w >= n) {
 8007a98:	9b00      	ldr	r3, [sp, #0]
 8007a9a:	429c      	cmp	r4, r3
 8007a9c:	d223      	bcs.n	8007ae6 <obqWriteTimeout+0x116>
 8007a9e:	f387 8811 	msr	BASEPRI, r7
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007aa2:	f7fd f9e5 	bl	8004e70 <_dbg_check_lock>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8007aa6:	f8da 0028 	ldr.w	r0, [sl, #40]	; 0x28
 8007aaa:	2800      	cmp	r0, #0
 8007aac:	d1a7      	bne.n	80079fe <obqWriteTimeout+0x2e>
      msg_t msg;

      /* Getting an empty buffer using the specified timeout.*/
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8007aae:	4650      	mov	r0, sl
 8007ab0:	9901      	ldr	r1, [sp, #4]
 8007ab2:	f7ff fcfd 	bl	80074b0 <obqGetEmptyBufferTimeoutS>

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8007ab6:	b940      	cbnz	r0, 8007aca <obqWriteTimeout+0xfa>
 8007ab8:	f8da 0028 	ldr.w	r0, [sl, #40]	; 0x28
 8007abc:	e79f      	b.n	80079fe <obqWriteTimeout+0x2e>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007abe:	480d      	ldr	r0, [pc, #52]	; (8007af4 <obqWriteTimeout+0x124>)
 8007ac0:	f7fd f95e 	bl	8004d80 <chSysHalt>
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, sysinterval_t timeout) {
  size_t w = 0;

  osalDbgCheck(n > 0U);
 8007ac4:	480c      	ldr	r0, [pc, #48]	; (8007af8 <obqWriteTimeout+0x128>)
 8007ac6:	f7fd f95b 	bl	8004d80 <chSysHalt>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007aca:	f7fd f9c1 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007ace:	682b      	ldr	r3, [r5, #0]
 8007ad0:	4a07      	ldr	r2, [pc, #28]	; (8007af0 <obqWriteTimeout+0x120>)
 8007ad2:	42ab      	cmp	r3, r5
 8007ad4:	d004      	beq.n	8007ae0 <obqWriteTimeout+0x110>
 8007ad6:	6992      	ldr	r2, [r2, #24]
 8007ad8:	689b      	ldr	r3, [r3, #8]
 8007ada:	6892      	ldr	r2, [r2, #8]
 8007adc:	429a      	cmp	r2, r3
 8007ade:	d3ee      	bcc.n	8007abe <obqWriteTimeout+0xee>
 8007ae0:	2300      	movs	r3, #0
 8007ae2:	f383 8811 	msr	BASEPRI, r3
    if (w >= n) {
      return w;
    }
    osalSysLock();
  }
}
 8007ae6:	4620      	mov	r0, r4
 8007ae8:	b003      	add	sp, #12
 8007aea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007aee:	bf00      	nop
 8007af0:	2000b68c 	.word	0x2000b68c
 8007af4:	0800d474 	.word	0x0800d474
 8007af8:	0800d348 	.word	0x0800d348
 8007afc:	00000000 	.word	0x00000000

08007b00 <_writet.lto_priv.89>:
}

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8007b00:	3044      	adds	r0, #68	; 0x44
 8007b02:	f7ff bf65 	b.w	80079d0 <obqWriteTimeout>
 8007b06:	bf00      	nop
	...

08007b10 <_write.lto_priv.83>:
 * Interface implementation.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8007b10:	3044      	adds	r0, #68	; 0x44
 8007b12:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007b16:	f7ff bf5b 	b.w	80079d0 <obqWriteTimeout>
 8007b1a:	bf00      	nop
 8007b1c:	0000      	movs	r0, r0
	...

08007b20 <obqPutTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    sysinterval_t timeout) {
 8007b20:	b570      	push	{r4, r5, r6, lr}
 8007b22:	2320      	movs	r3, #32
 8007b24:	b082      	sub	sp, #8
 8007b26:	4604      	mov	r4, r0
 8007b28:	460d      	mov	r5, r1
 8007b2a:	4616      	mov	r6, r2
 8007b2c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007b30:	f7fd f99e 	bl	8004e70 <_dbg_check_lock>
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8007b34:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007b36:	b1fb      	cbz	r3, 8007b78 <obqPutTimeout+0x58>
      return msg;
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8007b38:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
 8007b3a:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8007b3c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
  obqp->ptr++;
 8007b3e:	3301      	adds	r3, #1

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8007b40:	4293      	cmp	r3, r2
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
  obqp->ptr++;
 8007b42:	62a3      	str	r3, [r4, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8007b44:	d212      	bcs.n	8007b6c <obqPutTimeout+0x4c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007b46:	f7fd f983 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007b4a:	4b17      	ldr	r3, [pc, #92]	; (8007ba8 <obqPutTimeout+0x88>)
 8007b4c:	681a      	ldr	r2, [r3, #0]
 8007b4e:	429a      	cmp	r2, r3
 8007b50:	d004      	beq.n	8007b5c <obqPutTimeout+0x3c>
 8007b52:	6999      	ldr	r1, [r3, #24]
 8007b54:	6893      	ldr	r3, [r2, #8]
 8007b56:	688a      	ldr	r2, [r1, #8]
 8007b58:	429a      	cmp	r2, r3
 8007b5a:	d304      	bcc.n	8007b66 <obqPutTimeout+0x46>
 8007b5c:	2000      	movs	r0, #0
 8007b5e:	f380 8811 	msr	BASEPRI, r0
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  }

  osalSysUnlock();
  return MSG_OK;
}
 8007b62:	b002      	add	sp, #8
 8007b64:	bd70      	pop	{r4, r5, r6, pc}
 8007b66:	4811      	ldr	r0, [pc, #68]	; (8007bac <obqPutTimeout+0x8c>)
 8007b68:	f7fd f90a 	bl	8004d80 <chSysHalt>
  obqp->ptr++;

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8007b6c:	69e1      	ldr	r1, [r4, #28]
 8007b6e:	4620      	mov	r0, r4
 8007b70:	3904      	subs	r1, #4
 8007b72:	f7ff fc55 	bl	8007420 <obqPostFullBufferS>
 8007b76:	e7e6      	b.n	8007b46 <obqPutTimeout+0x26>

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8007b78:	4631      	mov	r1, r6
 8007b7a:	4620      	mov	r0, r4
 8007b7c:	f7ff fc98 	bl	80074b0 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8007b80:	b908      	cbnz	r0, 8007b86 <obqPutTimeout+0x66>
 8007b82:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007b84:	e7d8      	b.n	8007b38 <obqPutTimeout+0x18>
 8007b86:	9001      	str	r0, [sp, #4]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007b88:	f7fd f962 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007b8c:	4b06      	ldr	r3, [pc, #24]	; (8007ba8 <obqPutTimeout+0x88>)
 8007b8e:	9801      	ldr	r0, [sp, #4]
 8007b90:	681a      	ldr	r2, [r3, #0]
 8007b92:	429a      	cmp	r2, r3
 8007b94:	d004      	beq.n	8007ba0 <obqPutTimeout+0x80>
 8007b96:	6999      	ldr	r1, [r3, #24]
 8007b98:	6893      	ldr	r3, [r2, #8]
 8007b9a:	688a      	ldr	r2, [r1, #8]
 8007b9c:	429a      	cmp	r2, r3
 8007b9e:	d3e2      	bcc.n	8007b66 <obqPutTimeout+0x46>
 8007ba0:	2300      	movs	r3, #0
 8007ba2:	f383 8811 	msr	BASEPRI, r3
 8007ba6:	e7dc      	b.n	8007b62 <obqPutTimeout+0x42>
 8007ba8:	2000b68c 	.word	0x2000b68c
 8007bac:	0800d474 	.word	0x0800d474

08007bb0 <_putt.lto_priv.87>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
}

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8007bb0:	3044      	adds	r0, #68	; 0x44
 8007bb2:	f7ff bfb5 	b.w	8007b20 <obqPutTimeout>
 8007bb6:	bf00      	nop
	...

08007bc0 <_put.lto_priv.85>:
                        n, TIME_INFINITE);
}

static msg_t _put(void *ip, uint8_t b) {

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8007bc0:	3044      	adds	r0, #68	; 0x44
 8007bc2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8007bc6:	f7ff bfab 	b.w	8007b20 <obqPutTimeout>
 8007bca:	bf00      	nop
 8007bcc:	0000      	movs	r0, r0
	...

08007bd0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8007bd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007bd4:	b083      	sub	sp, #12
  size_t r = 0;

  osalDbgCheck(n > 0U);
 8007bd6:	4690      	mov	r8, r2
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8007bd8:	9301      	str	r3, [sp, #4]
  size_t r = 0;

  osalDbgCheck(n > 0U);
 8007bda:	2a00      	cmp	r2, #0
 8007bdc:	d06b      	beq.n	8007cb6 <ibqReadTimeout+0xe6>
 8007bde:	4604      	mov	r4, r0
 8007be0:	460e      	mov	r6, r1
 8007be2:	f04f 0920 	mov.w	r9, #32
 8007be6:	f389 8811 	msr	BASEPRI, r9
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007bea:	f7fd f941 	bl	8004e70 <_dbg_check_lock>
 8007bee:	4f3c      	ldr	r7, [pc, #240]	; (8007ce0 <ibqReadTimeout+0x110>)

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8007bf0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8007bf2:	f8cd 9000 	str.w	r9, [sp]
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
  size_t r = 0;
 8007bf6:	2500      	movs	r5, #0

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007bf8:	46b9      	mov	r9, r7
 8007bfa:	46aa      	mov	sl, r5

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8007bfc:	2900      	cmp	r1, #0
 8007bfe:	d050      	beq.n	8007ca2 <ibqReadTimeout+0xd2>
        return r;
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8007c00:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if (size > (n - r)) {
 8007c02:	ebc5 0b08 	rsb	fp, r5, r8
        return r;
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8007c06:	1a5b      	subs	r3, r3, r1
 8007c08:	459b      	cmp	fp, r3
 8007c0a:	bf28      	it	cs
 8007c0c:	469b      	movcs	fp, r3
      size = n - r;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
 8007c0e:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
 8007c12:	d923      	bls.n	8007c5c <ibqReadTimeout+0x8c>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
 8007c14:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8007c18:	4633      	mov	r3, r6
 8007c1a:	f8d1 c000 	ldr.w	ip, [r1]
 8007c1e:	f8d1 e004 	ldr.w	lr, [r1, #4]
 8007c22:	6888      	ldr	r0, [r1, #8]
 8007c24:	f8d1 b00c 	ldr.w	fp, [r1, #12]
 8007c28:	f8c3 b00c 	str.w	fp, [r3, #12]
 8007c2c:	3110      	adds	r1, #16
 8007c2e:	4291      	cmp	r1, r2
 8007c30:	f8c3 c000 	str.w	ip, [r3]
 8007c34:	f8c3 e004 	str.w	lr, [r3, #4]
 8007c38:	6098      	str	r0, [r3, #8]
 8007c3a:	f103 0310 	add.w	r3, r3, #16
 8007c3e:	d1ec      	bne.n	8007c1a <ibqReadTimeout+0x4a>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8007c40:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8007c42:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8007c44:	3340      	adds	r3, #64	; 0x40
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8007c46:	429a      	cmp	r2, r3
    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
 8007c48:	f106 0640 	add.w	r6, r6, #64	; 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
 8007c4c:	f105 0540 	add.w	r5, r5, #64	; 0x40
       this impacts throughput however.*/
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
 8007c50:	62a3      	str	r3, [r4, #40]	; 0x28
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8007c52:	d80f      	bhi.n	8007c74 <ibqReadTimeout+0xa4>
      ibqReleaseEmptyBufferS(ibqp);
 8007c54:	4620      	mov	r0, r4
 8007c56:	f7ff fc0b 	bl	8007470 <ibqReleaseEmptyBufferS>
 8007c5a:	e00b      	b.n	8007c74 <ibqReadTimeout+0xa4>
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8007c5c:	4630      	mov	r0, r6
 8007c5e:	465a      	mov	r2, fp
 8007c60:	f7f8 fb72 	bl	8000348 <memcpy>
      bp        += size;
      ibqp->ptr += size;
 8007c64:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8007c66:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
      ibqp->ptr += size;
 8007c68:	445b      	add	r3, fp
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8007c6a:	429a      	cmp	r2, r3
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
      ibqp->ptr += size;
      r         += size;
 8007c6c:	445d      	add	r5, fp
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
 8007c6e:	445e      	add	r6, fp
      ibqp->ptr += size;
 8007c70:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8007c72:	d9ef      	bls.n	8007c54 <ibqReadTimeout+0x84>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007c74:	f7fd f8ec 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007c78:	683b      	ldr	r3, [r7, #0]
 8007c7a:	42bb      	cmp	r3, r7
 8007c7c:	d005      	beq.n	8007c8a <ibqReadTimeout+0xba>
 8007c7e:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8007c82:	689b      	ldr	r3, [r3, #8]
 8007c84:	6892      	ldr	r2, [r2, #8]
 8007c86:	429a      	cmp	r2, r3
 8007c88:	d312      	bcc.n	8007cb0 <ibqReadTimeout+0xe0>
 8007c8a:	f38a 8811 	msr	BASEPRI, sl
      ibqReleaseEmptyBufferS(ibqp);
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (r >= n) {
 8007c8e:	4545      	cmp	r5, r8
 8007c90:	d222      	bcs.n	8007cd8 <ibqReadTimeout+0x108>
 8007c92:	9b00      	ldr	r3, [sp, #0]
 8007c94:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007c98:	f7fd f8ea 	bl	8004e70 <_dbg_check_lock>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8007c9c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8007c9e:	2900      	cmp	r1, #0
 8007ca0:	d1ae      	bne.n	8007c00 <ibqReadTimeout+0x30>
      msg_t msg;

      /* Getting a data buffer using the specified timeout.*/
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8007ca2:	4620      	mov	r0, r4
 8007ca4:	9901      	ldr	r1, [sp, #4]
 8007ca6:	f7ff fc2b 	bl	8007500 <ibqGetFullBufferTimeoutS>

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8007caa:	b938      	cbnz	r0, 8007cbc <ibqReadTimeout+0xec>
 8007cac:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8007cae:	e7a7      	b.n	8007c00 <ibqReadTimeout+0x30>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007cb0:	480c      	ldr	r0, [pc, #48]	; (8007ce4 <ibqReadTimeout+0x114>)
 8007cb2:	f7fd f865 	bl	8004d80 <chSysHalt>
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
  size_t r = 0;

  osalDbgCheck(n > 0U);
 8007cb6:	480c      	ldr	r0, [pc, #48]	; (8007ce8 <ibqReadTimeout+0x118>)
 8007cb8:	f7fd f862 	bl	8004d80 <chSysHalt>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007cbc:	f7fd f8c8 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007cc0:	683b      	ldr	r3, [r7, #0]
 8007cc2:	4a07      	ldr	r2, [pc, #28]	; (8007ce0 <ibqReadTimeout+0x110>)
 8007cc4:	42bb      	cmp	r3, r7
 8007cc6:	d004      	beq.n	8007cd2 <ibqReadTimeout+0x102>
 8007cc8:	6992      	ldr	r2, [r2, #24]
 8007cca:	689b      	ldr	r3, [r3, #8]
 8007ccc:	6892      	ldr	r2, [r2, #8]
 8007cce:	429a      	cmp	r2, r3
 8007cd0:	d3ee      	bcc.n	8007cb0 <ibqReadTimeout+0xe0>
 8007cd2:	2300      	movs	r3, #0
 8007cd4:	f383 8811 	msr	BASEPRI, r3
    if (r >= n) {
      return r;
    }
    osalSysLock();
  }
}
 8007cd8:	4628      	mov	r0, r5
 8007cda:	b003      	add	sp, #12
 8007cdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007ce0:	2000b68c 	.word	0x2000b68c
 8007ce4:	0800d474 	.word	0x0800d474
 8007ce8:	0800d370 	.word	0x0800d370
 8007cec:	00000000 	.word	0x00000000

08007cf0 <_readt.lto_priv.90>:
}

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8007cf0:	300c      	adds	r0, #12
 8007cf2:	f7ff bf6d 	b.w	8007bd0 <ibqReadTimeout>
 8007cf6:	bf00      	nop
	...

08007d00 <_read.lto_priv.84>:
                         n, TIME_INFINITE);
}

static size_t _read(void *ip, uint8_t *bp, size_t n) {

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8007d00:	300c      	adds	r0, #12
 8007d02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8007d06:	f7ff bf63 	b.w	8007bd0 <ibqReadTimeout>
 8007d0a:	bf00      	nop
 8007d0c:	0000      	movs	r0, r0
	...

08007d10 <ibqGetTimeout>:
 * @retval MSG_RESET    if the queue has been reset or has been put in
 *                      suspended state.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
 8007d10:	b530      	push	{r4, r5, lr}
 8007d12:	2320      	movs	r3, #32
 8007d14:	b083      	sub	sp, #12
 8007d16:	4604      	mov	r4, r0
 8007d18:	460d      	mov	r5, r1
 8007d1a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8007d1e:	f7fd f8a7 	bl	8004e70 <_dbg_check_lock>
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 8007d22:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007d24:	b1eb      	cbz	r3, 8007d62 <ibqGetTimeout+0x52>
      return msg;
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 8007d26:	f813 5b01 	ldrb.w	r5, [r3], #1
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8007d2a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
  ibqp->ptr++;
 8007d2c:	62a3      	str	r3, [r4, #40]	; 0x28

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8007d2e:	4293      	cmp	r3, r2
 8007d30:	d213      	bcs.n	8007d5a <ibqGetTimeout+0x4a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007d32:	f7fd f88d 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007d36:	4b17      	ldr	r3, [pc, #92]	; (8007d94 <ibqGetTimeout+0x84>)
 8007d38:	681a      	ldr	r2, [r3, #0]
 8007d3a:	429a      	cmp	r2, r3
 8007d3c:	d004      	beq.n	8007d48 <ibqGetTimeout+0x38>
 8007d3e:	6999      	ldr	r1, [r3, #24]
 8007d40:	6893      	ldr	r3, [r2, #8]
 8007d42:	688a      	ldr	r2, [r1, #8]
 8007d44:	429a      	cmp	r2, r3
 8007d46:	d305      	bcc.n	8007d54 <ibqGetTimeout+0x44>
 8007d48:	2300      	movs	r3, #0
 8007d4a:	f383 8811 	msr	BASEPRI, r3
    ibqReleaseEmptyBufferS(ibqp);
  }

  osalSysUnlock();
  return msg;
 8007d4e:	4628      	mov	r0, r5
}
 8007d50:	b003      	add	sp, #12
 8007d52:	bd30      	pop	{r4, r5, pc}
 8007d54:	4810      	ldr	r0, [pc, #64]	; (8007d98 <ibqGetTimeout+0x88>)
 8007d56:	f7fd f813 	bl	8004d80 <chSysHalt>
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
    ibqReleaseEmptyBufferS(ibqp);
 8007d5a:	4620      	mov	r0, r4
 8007d5c:	f7ff fb88 	bl	8007470 <ibqReleaseEmptyBufferS>
 8007d60:	e7e7      	b.n	8007d32 <ibqGetTimeout+0x22>

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8007d62:	4629      	mov	r1, r5
 8007d64:	4620      	mov	r0, r4
 8007d66:	f7ff fbcb 	bl	8007500 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 8007d6a:	b908      	cbnz	r0, 8007d70 <ibqGetTimeout+0x60>
 8007d6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007d6e:	e7da      	b.n	8007d26 <ibqGetTimeout+0x16>
 8007d70:	9001      	str	r0, [sp, #4]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8007d72:	f7fd f86d 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 8007d76:	4b07      	ldr	r3, [pc, #28]	; (8007d94 <ibqGetTimeout+0x84>)
 8007d78:	9801      	ldr	r0, [sp, #4]
 8007d7a:	681a      	ldr	r2, [r3, #0]
 8007d7c:	429a      	cmp	r2, r3
 8007d7e:	d004      	beq.n	8007d8a <ibqGetTimeout+0x7a>
 8007d80:	6999      	ldr	r1, [r3, #24]
 8007d82:	6893      	ldr	r3, [r2, #8]
 8007d84:	688a      	ldr	r2, [r1, #8]
 8007d86:	429a      	cmp	r2, r3
 8007d88:	d3e4      	bcc.n	8007d54 <ibqGetTimeout+0x44>
 8007d8a:	2300      	movs	r3, #0
 8007d8c:	f383 8811 	msr	BASEPRI, r3
 8007d90:	e7de      	b.n	8007d50 <ibqGetTimeout+0x40>
 8007d92:	bf00      	nop
 8007d94:	2000b68c 	.word	0x2000b68c
 8007d98:	0800d474 	.word	0x0800d474
 8007d9c:	00000000 	.word	0x00000000

08007da0 <_gett.lto_priv.88>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
}

static msg_t _gett(void *ip, sysinterval_t timeout) {

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8007da0:	300c      	adds	r0, #12
 8007da2:	f7ff bfb5 	b.w	8007d10 <ibqGetTimeout>
 8007da6:	bf00      	nop
	...

08007db0 <_get.lto_priv.86>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 8007db0:	300c      	adds	r0, #12
 8007db2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8007db6:	f7ff bfab 	b.w	8007d10 <ibqGetTimeout>
 8007dba:	bf00      	nop
 8007dbc:	0000      	movs	r0, r0
	...

08007dc0 <long_to_string_with_divisor.constprop.37>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8007dc0:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8007dc2:	f100 070b 	add.w	r7, r0, #11
 8007dc6:	463c      	mov	r4, r7
 8007dc8:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 8007dca:	fbb1 f6f2 	udiv	r6, r1, r2
 8007dce:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8007dd2:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9') {
 8007dd6:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8007dd8:	bfc8      	it	gt
 8007dda:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    }
    *--q = i;
 8007dde:	b2db      	uxtb	r3, r3
 8007de0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8007de4:	fbb5 f5f2 	udiv	r5, r5, r2
    i += '0';
    if (i > '9') {
      i += 'A' - '0' - 10;
    }
    *--q = i;
    l /= radix;
 8007de8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 8007dea:	2d00      	cmp	r5, #0
 8007dec:	d1ed      	bne.n	8007dca <long_to_string_with_divisor.constprop.37+0xa>

  i = (int)(p + MAX_FILLER - q);
 8007dee:	1b3a      	subs	r2, r7, r4
 8007df0:	4402      	add	r2, r0
 8007df2:	e001      	b.n	8007df8 <long_to_string_with_divisor.constprop.37+0x38>
 8007df4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
 8007df8:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8007dfc:	4290      	cmp	r0, r2
 8007dfe:	d1f9      	bne.n	8007df4 <long_to_string_with_divisor.constprop.37+0x34>

  return p;
}
 8007e00:	bcf0      	pop	{r4, r5, r6, r7}
 8007e02:	4770      	bx	lr
	...

08007e10 <chThdDequeueAllI.constprop.57>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8007e10:	b538      	push	{r3, r4, r5, lr}
 8007e12:	6803      	ldr	r3, [r0, #0]

  while (ch_queue_notempty(&tqp->queue)) {
 8007e14:	4298      	cmp	r0, r3
 8007e16:	d00a      	beq.n	8007e2e <chThdDequeueAllI.constprop.57+0x1e>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
 8007e18:	681a      	ldr	r2, [r3, #0]
 8007e1a:	6002      	str	r2, [r0, #0]
  qp->next->prev = qp;
 8007e1c:	6050      	str	r0, [r2, #4]

  chDbgAssert(ch_queue_notempty(&tqp->queue), "empty queue");

  tp = (thread_t *)ch_queue_fifo_remove(&tqp->queue);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8007e1e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8007e22:	2a04      	cmp	r2, #4
 8007e24:	4604      	mov	r4, r0
 8007e26:	d003      	beq.n	8007e30 <chThdDequeueAllI.constprop.57+0x20>
 8007e28:	480a      	ldr	r0, [pc, #40]	; (8007e54 <chThdDequeueAllI.constprop.57+0x44>)
 8007e2a:	f7fc ffa9 	bl	8004d80 <chSysHalt>
 8007e2e:	bd38      	pop	{r3, r4, r5, pc}

  tp->u.rdymsg = msg;
 8007e30:	f06f 0501 	mvn.w	r5, #1
 8007e34:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8007e36:	4618      	mov	r0, r3
 8007e38:	f7fa fc2a 	bl	8002690 <chSchReadyI>
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
 8007e3c:	6823      	ldr	r3, [r4, #0]
 8007e3e:	42a3      	cmp	r3, r4
 8007e40:	d0f5      	beq.n	8007e2e <chThdDequeueAllI.constprop.57+0x1e>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
 8007e42:	681a      	ldr	r2, [r3, #0]
 8007e44:	6022      	str	r2, [r4, #0]
  qp->next->prev = qp;
 8007e46:	6054      	str	r4, [r2, #4]

  chDbgAssert(ch_queue_notempty(&tqp->queue), "empty queue");

  tp = (thread_t *)ch_queue_fifo_remove(&tqp->queue);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8007e48:	f893 2020 	ldrb.w	r2, [r3, #32]
 8007e4c:	2a04      	cmp	r2, #4
 8007e4e:	d1eb      	bne.n	8007e28 <chThdDequeueAllI.constprop.57+0x18>
 8007e50:	e7f0      	b.n	8007e34 <chThdDequeueAllI.constprop.57+0x24>
 8007e52:	bf00      	nop
 8007e54:	0800d4e0 	.word	0x0800d4e0
	...

08007e60 <chThdDequeueNextI.constprop.55>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8007e60:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool ch_queue_notempty(const ch_queue_t *qp) {

  return (bool)(qp->next != qp);
 8007e62:	6803      	ldr	r3, [r0, #0]

  if (ch_queue_notempty(&tqp->queue)) {
 8007e64:	4298      	cmp	r0, r3
 8007e66:	d009      	beq.n	8007e7c <chThdDequeueNextI.constprop.55+0x1c>
 * @notapi
 */
static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
  ch_queue_t *p = qp->next;

  qp->next       = p->next;
 8007e68:	681a      	ldr	r2, [r3, #0]
 8007e6a:	6002      	str	r2, [r0, #0]
  qp->next->prev = qp;
 8007e6c:	6050      	str	r0, [r2, #4]
 8007e6e:	f893 2020 	ldrb.w	r2, [r3, #32]
 8007e72:	2a04      	cmp	r2, #4
 8007e74:	d003      	beq.n	8007e7e <chThdDequeueNextI.constprop.55+0x1e>
 8007e76:	4805      	ldr	r0, [pc, #20]	; (8007e8c <chThdDequeueNextI.constprop.55+0x2c>)
 8007e78:	f7fc ff82 	bl	8004d80 <chSysHalt>
 8007e7c:	bd08      	pop	{r3, pc}

  tp->u.rdymsg = msg;
 8007e7e:	2200      	movs	r2, #0
 8007e80:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8007e82:	4618      	mov	r0, r3
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8007e84:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8007e88:	f7fa bc02 	b.w	8002690 <chSchReadyI>
 8007e8c:	0800d4e0 	.word	0x0800d4e0

08007e90 <dac_lld_put_channel.constprop.51>:
 * @param[in] channel   DAC channel number
 * @param[in] sample    value to be output
 *
 * @api
 */
void dac_lld_put_channel(DACDriver *dacp,
 8007e90:	b508      	push	{r3, lr}
                         dacchannel_t channel,
                         dacsample_t sample) {

  switch (dacp->config->datamode) {
 8007e92:	6903      	ldr	r3, [r0, #16]
 8007e94:	789b      	ldrb	r3, [r3, #2]
 8007e96:	2b01      	cmp	r3, #1
 8007e98:	d00c      	beq.n	8007eb4 <dac_lld_put_channel.constprop.51+0x24>
 8007e9a:	d312      	bcc.n	8007ec2 <dac_lld_put_channel.constprop.51+0x32>
 8007e9c:	2b02      	cmp	r3, #2
 8007e9e:	d106      	bne.n	8007eae <dac_lld_put_channel.constprop.51+0x1e>
#endif
    if (channel == 0U) {
#if STM32_DAC_DUAL_MODE
      dacp->params->dac->DHR8R1 = (uint32_t)sample;
#else
      *(&dacp->params->dac->DHR8R1 + dacp->params->dataoffset) = (uint32_t)sample;
 8007ea0:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8007ea2:	6813      	ldr	r3, [r2, #0]
 8007ea4:	6852      	ldr	r2, [r2, #4]
 8007ea6:	3310      	adds	r3, #16
 8007ea8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8007eac:	bd08      	pop	{r3, pc}
      dacp->params->dac->DHR8R2 = (uint32_t)sample;
    }
#endif
    break;
  default:
    osalDbgAssert(false, "unexpected DAC mode");
 8007eae:	4808      	ldr	r0, [pc, #32]	; (8007ed0 <dac_lld_put_channel.constprop.51+0x40>)
 8007eb0:	f7fc ff66 	bl	8004d80 <chSysHalt>
#endif
    if (channel == 0U) {
#if STM32_DAC_DUAL_MODE
      dacp->params->dac->DHR12L1 = (uint32_t)sample;
#else
      *(&dacp->params->dac->DHR12L1 + dacp->params->dataoffset) = (uint32_t)sample;
 8007eb4:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8007eb6:	6813      	ldr	r3, [r2, #0]
 8007eb8:	6852      	ldr	r2, [r2, #4]
 8007eba:	330c      	adds	r3, #12
 8007ebc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8007ec0:	bd08      	pop	{r3, pc}
#endif
    if (channel == 0U) {
#if STM32_DAC_DUAL_MODE
      dacp->params->dac->DHR12R1 = (uint32_t)sample;
#else
      *(&dacp->params->dac->DHR12R1 + dacp->params->dataoffset) = (uint32_t)sample;
 8007ec2:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8007ec4:	6813      	ldr	r3, [r2, #0]
 8007ec6:	6852      	ldr	r2, [r2, #4]
 8007ec8:	3308      	adds	r3, #8
 8007eca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8007ece:	bd08      	pop	{r3, pc}
 8007ed0:	0800d4a4 	.word	0x0800d4a4
	...

08007ee0 <chprintf.constprop.35>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8007ee0:	b40e      	push	{r1, r2, r3}
 8007ee2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007ee6:	b086      	sub	sp, #24
 8007ee8:	ab0f      	add	r3, sp, #60	; 0x3c
 8007eea:	aa03      	add	r2, sp, #12
 8007eec:	f853 6b04 	ldr.w	r6, [r3], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8007ef0:	9302      	str	r3, [sp, #8]
 8007ef2:	4699      	mov	r9, r3
 8007ef4:	f10d 030d 	add.w	r3, sp, #13
 8007ef8:	1a9b      	subs	r3, r3, r2
 8007efa:	9301      	str	r3, [sp, #4]
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8007efc:	f04f 0800 	mov.w	r8, #0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8007f00:	7831      	ldrb	r1, [r6, #0]
 8007f02:	1c72      	adds	r2, r6, #1
    if (c == 0) {
 8007f04:	b179      	cbz	r1, 8007f26 <chprintf.constprop.35+0x46>
      return n;
    }
    
    if (c != '%') {
 8007f06:	2925      	cmp	r1, #37	; 0x25
 8007f08:	d013      	beq.n	8007f32 <chprintf.constprop.35+0x52>
      streamPut(chp, (uint8_t)c);
 8007f0a:	f8df b37c 	ldr.w	fp, [pc, #892]	; 8008288 <chprintf.constprop.35+0x3a8>
 8007f0e:	f8db 0000 	ldr.w	r0, [fp]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8007f12:	4616      	mov	r6, r2
    if (c == 0) {
      return n;
    }
    
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8007f14:	68c4      	ldr	r4, [r0, #12]
 8007f16:	4658      	mov	r0, fp
 8007f18:	47a0      	blx	r4
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8007f1a:	7831      	ldrb	r1, [r6, #0]
      return n;
    }
    
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 8007f1c:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8007f20:	1c72      	adds	r2, r6, #1
    if (c == 0) {
 8007f22:	2900      	cmp	r1, #0
 8007f24:	d1ef      	bne.n	8007f06 <chprintf.constprop.35+0x26>
  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8007f26:	4640      	mov	r0, r8
 8007f28:	b006      	add	sp, #24
 8007f2a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007f2e:	b003      	add	sp, #12
 8007f30:	4770      	bx	lr
    p = tmpbuf;
    s = tmpbuf;

    /* Alignment mode.*/
    left_align = false;
    if (*fmt == '-') {
 8007f32:	7871      	ldrb	r1, [r6, #1]
 8007f34:	292d      	cmp	r1, #45	; 0x2d
 8007f36:	bf03      	ittte	eq
 8007f38:	78b1      	ldrbeq	r1, [r6, #2]
      fmt++;
 8007f3a:	1cb2      	addeq	r2, r6, #2
      left_align = true;
 8007f3c:	f04f 0a01 	moveq.w	sl, #1
    
    p = tmpbuf;
    s = tmpbuf;

    /* Alignment mode.*/
    left_align = false;
 8007f40:	f04f 0a00 	movne.w	sl, #0
      left_align = true;
    }

    /* Sign mode.*/
    do_sign = false;
    if (*fmt == '+') {
 8007f44:	292b      	cmp	r1, #43	; 0x2b
 8007f46:	bf03      	ittte	eq
 8007f48:	7851      	ldrbeq	r1, [r2, #1]
      fmt++;
      do_sign = true;
 8007f4a:	2001      	moveq	r0, #1
    }

    /* Sign mode.*/
    do_sign = false;
    if (*fmt == '+') {
      fmt++;
 8007f4c:	1812      	addeq	r2, r2, r0
      fmt++;
      left_align = true;
    }

    /* Sign mode.*/
    do_sign = false;
 8007f4e:	2000      	movne	r0, #0
      do_sign = true;
    }

    /* Filler mode.*/
    filler = ' ';
    if (*fmt == '0') {
 8007f50:	2930      	cmp	r1, #48	; 0x30
      fmt++;
      filler = '0';
 8007f52:	bf05      	ittet	eq
 8007f54:	460d      	moveq	r5, r1
 8007f56:	7851      	ldrbeq	r1, [r2, #1]
      fmt++;
      do_sign = true;
    }

    /* Filler mode.*/
    filler = ' ';
 8007f58:	2520      	movne	r5, #32
    if (*fmt == '0') {
      fmt++;
 8007f5a:	3201      	addeq	r2, #1
      filler = '0';
    }
    
    /* Width modifier.*/
    if ( *fmt == '*') {
 8007f5c:	292a      	cmp	r1, #42	; 0x2a
 8007f5e:	d018      	beq.n	8007f92 <chprintf.constprop.35+0xb2>
      c = *fmt++;
    }
    else {
      width = 0;
      while (true) {
        c = *fmt++;
 8007f60:	1c56      	adds	r6, r2, #1
        if (c == 0) {
 8007f62:	2900      	cmp	r1, #0
 8007f64:	d0df      	beq.n	8007f26 <chprintf.constprop.35+0x46>
          return n;
        }
        if (c >= '0' && c <= '9') {
 8007f66:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8007f6a:	b2db      	uxtb	r3, r3
 8007f6c:	2b09      	cmp	r3, #9
 8007f6e:	f04f 0400 	mov.w	r4, #0
 8007f72:	d902      	bls.n	8007f7a <chprintf.constprop.35+0x9a>
 8007f74:	e013      	b.n	8007f9e <chprintf.constprop.35+0xbe>
 8007f76:	2b09      	cmp	r3, #9
 8007f78:	d811      	bhi.n	8007f9e <chprintf.constprop.35+0xbe>
      c = *fmt++;
    }
    else {
      width = 0;
      while (true) {
        c = *fmt++;
 8007f7a:	f816 1b01 	ldrb.w	r1, [r6], #1
        if (c == 0) {
          return n;
        }
        if (c >= '0' && c <= '9') {
          c -= '0';
          width = width * 10 + c;
 8007f7e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
      while (true) {
        c = *fmt++;
        if (c == 0) {
          return n;
        }
        if (c >= '0' && c <= '9') {
 8007f82:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
          c -= '0';
          width = width * 10 + c;
 8007f86:	eb03 0444 	add.w	r4, r3, r4, lsl #1
      while (true) {
        c = *fmt++;
        if (c == 0) {
          return n;
        }
        if (c >= '0' && c <= '9') {
 8007f8a:	b2d3      	uxtb	r3, r2
    }
    else {
      width = 0;
      while (true) {
        c = *fmt++;
        if (c == 0) {
 8007f8c:	2900      	cmp	r1, #0
 8007f8e:	d1f2      	bne.n	8007f76 <chprintf.constprop.35+0x96>
 8007f90:	e7c9      	b.n	8007f26 <chprintf.constprop.35+0x46>
    
    /* Width modifier.*/
    if ( *fmt == '*') {
      width = va_arg(ap, int);
      ++fmt;
      c = *fmt++;
 8007f92:	7851      	ldrb	r1, [r2, #1]
      filler = '0';
    }
    
    /* Width modifier.*/
    if ( *fmt == '*') {
      width = va_arg(ap, int);
 8007f94:	f8d9 4000 	ldr.w	r4, [r9]
      ++fmt;
      c = *fmt++;
 8007f98:	1c96      	adds	r6, r2, #2
      filler = '0';
    }
    
    /* Width modifier.*/
    if ( *fmt == '*') {
      width = va_arg(ap, int);
 8007f9a:	f109 0904 	add.w	r9, r9, #4
      }
    }
    
    /* Precision modifier.*/
    precision = 0;
    if (c == '.') {
 8007f9e:	292e      	cmp	r1, #46	; 0x2e
 8007fa0:	f000 8082 	beq.w	80080a8 <chprintf.constprop.35+0x1c8>
        }
      }
    }
    
    /* Precision modifier.*/
    precision = 0;
 8007fa4:	2300      	movs	r3, #0
        }
      }
    }
    
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8007fa6:	f001 02df 	and.w	r2, r1, #223	; 0xdf
 8007faa:	2a4c      	cmp	r2, #76	; 0x4c
 8007fac:	d03b      	beq.n	8008026 <chprintf.constprop.35+0x146>
    else {
      is_long = (c >= 'A') && (c <= 'Z');
    }

    /* Command decoding.*/
    switch (c) {
 8007fae:	f1a1 0244 	sub.w	r2, r1, #68	; 0x44
 8007fb2:	2a34      	cmp	r2, #52	; 0x34
 8007fb4:	f200 813b 	bhi.w	800822e <chprintf.constprop.35+0x34e>
 8007fb8:	e8df f012 	tbh	[pc, r2, lsl #1]
 8007fbc:	0139011a 	.word	0x0139011a
 8007fc0:	01390139 	.word	0x01390139
 8007fc4:	011a0139 	.word	0x011a0139
 8007fc8:	01390139 	.word	0x01390139
 8007fcc:	01390139 	.word	0x01390139
 8007fd0:	01290139 	.word	0x01290139
 8007fd4:	0139008e 	.word	0x0139008e
 8007fd8:	01390139 	.word	0x01390139
 8007fdc:	00e30139 	.word	0x00e30139
 8007fe0:	01390139 	.word	0x01390139
 8007fe4:	0139008e 	.word	0x0139008e
 8007fe8:	01390139 	.word	0x01390139
 8007fec:	01390139 	.word	0x01390139
 8007ff0:	01390139 	.word	0x01390139
 8007ff4:	01390139 	.word	0x01390139
 8007ff8:	00e50139 	.word	0x00e50139
 8007ffc:	0139011a 	.word	0x0139011a
 8008000:	01390139 	.word	0x01390139
 8008004:	011a0139 	.word	0x011a0139
 8008008:	01390139 	.word	0x01390139
 800800c:	01390139 	.word	0x01390139
 8008010:	01290139 	.word	0x01290139
 8008014:	0139008e 	.word	0x0139008e
 8008018:	00fe0139 	.word	0x00fe0139
 800801c:	00e30139 	.word	0x00e30139
 8008020:	01390139 	.word	0x01390139
 8008024:	008e      	.short	0x008e
    }
    
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = true;
      c = *fmt++;
 8008026:	7831      	ldrb	r1, [r6, #0]
 8008028:	3601      	adds	r6, #1
      if (c == 0) {
 800802a:	2900      	cmp	r1, #0
 800802c:	f43f af7b 	beq.w	8007f26 <chprintf.constprop.35+0x46>
    else {
      is_long = (c >= 'A') && (c <= 'Z');
    }

    /* Command decoding.*/
    switch (c) {
 8008030:	f1a1 0244 	sub.w	r2, r1, #68	; 0x44
 8008034:	2a34      	cmp	r2, #52	; 0x34
 8008036:	f200 80fa 	bhi.w	800822e <chprintf.constprop.35+0x34e>
 800803a:	e8df f012 	tbh	[pc, r2, lsl #1]
 800803e:	00d9      	.short	0x00d9
 8008040:	00f800f8 	.word	0x00f800f8
 8008044:	00f800f8 	.word	0x00f800f8
 8008048:	00f800d9 	.word	0x00f800d9
 800804c:	00f800f8 	.word	0x00f800f8
 8008050:	00f800f8 	.word	0x00f800f8
 8008054:	004d00e8 	.word	0x004d00e8
 8008058:	00f800f8 	.word	0x00f800f8
 800805c:	00f800f8 	.word	0x00f800f8
 8008060:	00f800a2 	.word	0x00f800a2
 8008064:	004d00f8 	.word	0x004d00f8
 8008068:	00f800f8 	.word	0x00f800f8
 800806c:	00f800f8 	.word	0x00f800f8
 8008070:	00f800f8 	.word	0x00f800f8
 8008074:	00f800f8 	.word	0x00f800f8
 8008078:	00f800f8 	.word	0x00f800f8
 800807c:	00d900a4 	.word	0x00d900a4
 8008080:	00f800f8 	.word	0x00f800f8
 8008084:	00f800f8 	.word	0x00f800f8
 8008088:	00f800d9 	.word	0x00f800d9
 800808c:	00f800f8 	.word	0x00f800f8
 8008090:	00f800f8 	.word	0x00f800f8
 8008094:	004d00e8 	.word	0x004d00e8
 8008098:	00f800f8 	.word	0x00f800f8
 800809c:	00f800bd 	.word	0x00f800bd
 80080a0:	00f800a2 	.word	0x00f800a2
 80080a4:	004d00f8 	.word	0x004d00f8
    }
    
    /* Precision modifier.*/
    precision = 0;
    if (c == '.') {
      c = *fmt++;
 80080a8:	7831      	ldrb	r1, [r6, #0]
      if (c == 0) {
 80080aa:	2900      	cmp	r1, #0
 80080ac:	f43f af3b 	beq.w	8007f26 <chprintf.constprop.35+0x46>
        return n;
      }
      if (c == '*') {
 80080b0:	292a      	cmp	r1, #42	; 0x2a
 80080b2:	f000 80d7 	beq.w	8008264 <chprintf.constprop.35+0x384>
    }
    
    /* Precision modifier.*/
    precision = 0;
    if (c == '.') {
      c = *fmt++;
 80080b6:	3601      	adds	r6, #1
 80080b8:	2300      	movs	r3, #0
      if (c == '*') {
        precision = va_arg(ap, int);
        c = *fmt++;
      }
      else {
        while (c >= '0' && c <= '9') {
 80080ba:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 80080be:	b2d2      	uxtb	r2, r2
 80080c0:	2a09      	cmp	r2, #9
          c -= '0';
          precision = precision * 10 + c;
 80080c2:	eb03 0783 	add.w	r7, r3, r3, lsl #2
      if (c == '*') {
        precision = va_arg(ap, int);
        c = *fmt++;
      }
      else {
        while (c >= '0' && c <= '9') {
 80080c6:	f63f af6e 	bhi.w	8007fa6 <chprintf.constprop.35+0xc6>
          c -= '0';
          precision = precision * 10 + c;
          c = *fmt++;
 80080ca:	f816 1b01 	ldrb.w	r1, [r6], #1
        c = *fmt++;
      }
      else {
        while (c >= '0' && c <= '9') {
          c -= '0';
          precision = precision * 10 + c;
 80080ce:	eb02 0347 	add.w	r3, r2, r7, lsl #1
          c = *fmt++;
          if (c == 0) {
 80080d2:	2900      	cmp	r1, #0
 80080d4:	d1f1      	bne.n	80080ba <chprintf.constprop.35+0x1da>
 80080d6:	e726      	b.n	8007f26 <chprintf.constprop.35+0x46>
    else {
      is_long = (c >= 'A') && (c <= 'Z');
    }

    /* Command decoding.*/
    switch (c) {
 80080d8:	2210      	movs	r2, #16
unsigned_common:
      if (is_long) {
        l = va_arg(ap, unsigned long);
      }
      else {
        l = va_arg(ap, unsigned int);
 80080da:	f8d9 1000 	ldr.w	r1, [r9]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80080de:	a803      	add	r0, sp, #12
unsigned_common:
      if (is_long) {
        l = va_arg(ap, unsigned long);
      }
      else {
        l = va_arg(ap, unsigned int);
 80080e0:	f109 0904 	add.w	r9, r9, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80080e4:	f7ff fe6c 	bl	8007dc0 <long_to_string_with_divisor.constprop.37>
 80080e8:	ab03      	add	r3, sp, #12
 80080ea:	1ac0      	subs	r0, r0, r3
 80080ec:	f100 3bff 	add.w	fp, r0, #4294967295	; 0xffffffff
      n++;
      continue;
    }
    
    p = tmpbuf;
    s = tmpbuf;
 80080f0:	461f      	mov	r7, r3
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0) {
 80080f2:	1a24      	subs	r4, r4, r0
 80080f4:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
      width = 0;
    }
    if (left_align == false) {
 80080f8:	f1ba 0f00 	cmp.w	sl, #0
 80080fc:	d155      	bne.n	80081aa <chprintf.constprop.35+0x2ca>
 80080fe:	f8cd b000 	str.w	fp, [sp]
      width = -width;
 8008102:	f1c4 0a00 	rsb	sl, r4, #0
    }
    if (width < 0) {
 8008106:	f1ba 0f00 	cmp.w	sl, #0
 800810a:	f000 8098 	beq.w	800823e <chprintf.constprop.35+0x35e>
      if ((*s == '-' || *s == '+') && filler == '0') {
 800810e:	7839      	ldrb	r1, [r7, #0]
        streamPut(chp, (uint8_t)*s++);
 8008110:	f8df b174 	ldr.w	fp, [pc, #372]	; 8008288 <chprintf.constprop.35+0x3a8>
    }
    if (left_align == false) {
      width = -width;
    }
    if (width < 0) {
      if ((*s == '-' || *s == '+') && filler == '0') {
 8008114:	292d      	cmp	r1, #45	; 0x2d
 8008116:	d07c      	beq.n	8008212 <chprintf.constprop.35+0x332>
 8008118:	292b      	cmp	r1, #43	; 0x2b
 800811a:	d07a      	beq.n	8008212 <chprintf.constprop.35+0x332>
        streamPut(chp, (uint8_t)*s++);
        n++;
 800811c:	4654      	mov	r4, sl
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800811e:	f8db 3000 	ldr.w	r3, [fp]
 8008122:	4859      	ldr	r0, [pc, #356]	; (8008288 <chprintf.constprop.35+0x3a8>)
 8008124:	68db      	ldr	r3, [r3, #12]
 8008126:	4629      	mov	r1, r5
 8008128:	4798      	blx	r3
        n++;
      } while (++width != 0);
 800812a:	3401      	adds	r4, #1
 800812c:	d1f7      	bne.n	800811e <chprintf.constprop.35+0x23e>
    }
    while (--i >= 0) {
 800812e:	9b00      	ldr	r3, [sp, #0]
 8008130:	2b00      	cmp	r3, #0
 8008132:	ebca 0808 	rsb	r8, sl, r8
 8008136:	f6ff aee3 	blt.w	8007f00 <chprintf.constprop.35+0x20>
    }
    i = (int)(p - s);
    if ((width -= i) < 0) {
      width = 0;
    }
    if (left_align == false) {
 800813a:	f8dd a000 	ldr.w	sl, [sp]
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 800813e:	f8db 3000 	ldr.w	r3, [fp]
 8008142:	4851      	ldr	r0, [pc, #324]	; (8008288 <chprintf.constprop.35+0x3a8>)
 8008144:	68db      	ldr	r3, [r3, #12]
 8008146:	f817 1b01 	ldrb.w	r1, [r7], #1
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800814a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
      streamPut(chp, (uint8_t)*s++);
 800814e:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8008150:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 8008154:	d1f3      	bne.n	800813e <chprintf.constprop.35+0x25e>
 8008156:	9b00      	ldr	r3, [sp, #0]
 8008158:	f108 0801 	add.w	r8, r8, #1
 800815c:	2b00      	cmp	r3, #0
 800815e:	bfa8      	it	ge
 8008160:	4498      	addge	r8, r3
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8008162:	2c00      	cmp	r4, #0
 8008164:	f43f aecc 	beq.w	8007f00 <chprintf.constprop.35+0x20>
 8008168:	f8df b11c 	ldr.w	fp, [pc, #284]	; 8008288 <chprintf.constprop.35+0x3a8>
 800816c:	4627      	mov	r7, r4
      streamPut(chp, (uint8_t)filler);
 800816e:	f8db 3000 	ldr.w	r3, [fp]
 8008172:	4845      	ldr	r0, [pc, #276]	; (8008288 <chprintf.constprop.35+0x3a8>)
 8008174:	68db      	ldr	r3, [r3, #12]
 8008176:	4629      	mov	r1, r5
 8008178:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800817a:	3f01      	subs	r7, #1
 800817c:	d1f7      	bne.n	800816e <chprintf.constprop.35+0x28e>
 800817e:	44a0      	add	r8, r4
 8008180:	e6be      	b.n	8007f00 <chprintf.constprop.35+0x20>
 8008182:	220a      	movs	r2, #10
 8008184:	e7a9      	b.n	80080da <chprintf.constprop.35+0x1fa>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8008186:	f8d9 3000 	ldr.w	r3, [r9]
 800818a:	f88d 300c 	strb.w	r3, [sp, #12]
 800818e:	9b01      	ldr	r3, [sp, #4]
 8008190:	4618      	mov	r0, r3
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0) {
 8008192:	1a24      	subs	r4, r4, r0

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8008194:	f109 0904 	add.w	r9, r9, #4
 8008198:	f103 3bff 	add.w	fp, r3, #4294967295	; 0xffffffff
    }

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 800819c:	2520      	movs	r5, #32
      n++;
      continue;
    }
    
    p = tmpbuf;
    s = tmpbuf;
 800819e:	af03      	add	r7, sp, #12
 80081a0:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    }
    i = (int)(p - s);
    if ((width -= i) < 0) {
      width = 0;
    }
    if (left_align == false) {
 80081a4:	f1ba 0f00 	cmp.w	sl, #0
 80081a8:	d0a9      	beq.n	80080fe <chprintf.constprop.35+0x21e>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80081aa:	f1bb 0300 	subs.w	r3, fp, #0
 80081ae:	9300      	str	r3, [sp, #0]
 80081b0:	dbd7      	blt.n	8008162 <chprintf.constprop.35+0x282>
 80081b2:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 8008288 <chprintf.constprop.35+0x3a8>
 80081b6:	e7c0      	b.n	800813a <chprintf.constprop.35+0x25a>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0) {
 80081b8:	f8d9 7000 	ldr.w	r7, [r9]
        s = "(null)";
 80081bc:	4a33      	ldr	r2, [pc, #204]	; (800828c <chprintf.constprop.35+0x3ac>)
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0) {
 80081be:	f109 0904 	add.w	r9, r9, #4
        s = "(null)";
 80081c2:	2f00      	cmp	r7, #0
 80081c4:	bf08      	it	eq
 80081c6:	4617      	moveq	r7, r2
      }
      if (precision == 0) {
 80081c8:	2b00      	cmp	r3, #0
 80081ca:	d13d      	bne.n	8008248 <chprintf.constprop.35+0x368>
        precision = 32767;
      }
      for (p = s; *p && (--precision >= 0); p++)
 80081cc:	783b      	ldrb	r3, [r7, #0]
 80081ce:	2b00      	cmp	r3, #0
 80081d0:	d03e      	beq.n	8008250 <chprintf.constprop.35+0x370>
 80081d2:	f647 73fe 	movw	r3, #32766	; 0x7ffe
 80081d6:	4638      	mov	r0, r7
 80081d8:	e001      	b.n	80081de <chprintf.constprop.35+0x2fe>
 80081da:	3b01      	subs	r3, #1
 80081dc:	d403      	bmi.n	80081e6 <chprintf.constprop.35+0x306>
 80081de:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 80081e2:	2a00      	cmp	r2, #0
 80081e4:	d1f9      	bne.n	80081da <chprintf.constprop.35+0x2fa>
 80081e6:	1bc0      	subs	r0, r0, r7
 80081e8:	f100 3bff 	add.w	fp, r0, #4294967295	; 0xffffffff
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80081ec:	2520      	movs	r5, #32
 80081ee:	e780      	b.n	80080f2 <chprintf.constprop.35+0x212>
    case 'i':
      if (is_long) {
        l = va_arg(ap, long);
      }
      else {
        l = va_arg(ap, int);
 80081f0:	f8d9 1000 	ldr.w	r1, [r9]
      }
      if (l < 0) {
 80081f4:	2900      	cmp	r1, #0
    case 'i':
      if (is_long) {
        l = va_arg(ap, long);
      }
      else {
        l = va_arg(ap, int);
 80081f6:	f109 0904 	add.w	r9, r9, #4
      }
      if (l < 0) {
 80081fa:	db3c      	blt.n	8008276 <chprintf.constprop.35+0x396>
        *p++ = '-';
        l = -l;
      }
      else
        if (do_sign) {
 80081fc:	2800      	cmp	r0, #0
 80081fe:	d038      	beq.n	8008272 <chprintf.constprop.35+0x392>
          *p++ = '+';
 8008200:	232b      	movs	r3, #43	; 0x2b
 8008202:	f88d 300c 	strb.w	r3, [sp, #12]
 8008206:	f10d 000d 	add.w	r0, sp, #13
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 800820a:	220a      	movs	r2, #10
 800820c:	e76a      	b.n	80080e4 <chprintf.constprop.35+0x204>
 800820e:	2208      	movs	r2, #8
 8008210:	e763      	b.n	80080da <chprintf.constprop.35+0x1fa>
    }
    if (left_align == false) {
      width = -width;
    }
    if (width < 0) {
      if ((*s == '-' || *s == '+') && filler == '0') {
 8008212:	2d30      	cmp	r5, #48	; 0x30
 8008214:	d182      	bne.n	800811c <chprintf.constprop.35+0x23c>
        streamPut(chp, (uint8_t)*s++);
 8008216:	f8db 2000 	ldr.w	r2, [fp]
 800821a:	4658      	mov	r0, fp
 800821c:	68d2      	ldr	r2, [r2, #12]
 800821e:	4790      	blx	r2
 8008220:	9b00      	ldr	r3, [sp, #0]
 8008222:	3b01      	subs	r3, #1
 8008224:	3701      	adds	r7, #1
        n++;
 8008226:	f108 0801 	add.w	r8, r8, #1
 800822a:	9300      	str	r3, [sp, #0]
 800822c:	e776      	b.n	800811c <chprintf.constprop.35+0x23c>
 800822e:	9b01      	ldr	r3, [sp, #4]
        l = va_arg(ap, unsigned int);
      }
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8008230:	f88d 100c 	strb.w	r1, [sp, #12]
 8008234:	4618      	mov	r0, r3
 8008236:	f103 3bff 	add.w	fp, r3, #4294967295	; 0xffffffff
      n++;
      continue;
    }
    
    p = tmpbuf;
    s = tmpbuf;
 800823a:	af03      	add	r7, sp, #12
 800823c:	e759      	b.n	80080f2 <chprintf.constprop.35+0x212>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800823e:	9b00      	ldr	r3, [sp, #0]
 8008240:	2b00      	cmp	r3, #0
      width = 0;
    }
    if (left_align == false) {
      width = -width;
    }
    if (width < 0) {
 8008242:	4654      	mov	r4, sl
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8008244:	dab5      	bge.n	80081b2 <chprintf.constprop.35+0x2d2>
 8008246:	e65b      	b.n	8007f00 <chprintf.constprop.35+0x20>
        s = "(null)";
      }
      if (precision == 0) {
        precision = 32767;
      }
      for (p = s; *p && (--precision >= 0); p++)
 8008248:	783a      	ldrb	r2, [r7, #0]
 800824a:	b10a      	cbz	r2, 8008250 <chprintf.constprop.35+0x370>
 800824c:	3b01      	subs	r3, #1
 800824e:	d5c2      	bpl.n	80081d6 <chprintf.constprop.35+0x2f6>
 8008250:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
    }
    i = (int)(p - s);
    if ((width -= i) < 0) {
      width = 0;
    }
    if (left_align == false) {
 8008254:	f1ba 0f00 	cmp.w	sl, #0
 8008258:	d114      	bne.n	8008284 <chprintf.constprop.35+0x3a4>
 800825a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800825e:	9300      	str	r3, [sp, #0]
 8008260:	2520      	movs	r5, #32
 8008262:	e74e      	b.n	8008102 <chprintf.constprop.35+0x222>
      c = *fmt++;
      if (c == 0) {
        return n;
      }
      if (c == '*') {
        precision = va_arg(ap, int);
 8008264:	f8d9 3000 	ldr.w	r3, [r9]
        c = *fmt++;
 8008268:	7871      	ldrb	r1, [r6, #1]
      c = *fmt++;
      if (c == 0) {
        return n;
      }
      if (c == '*') {
        precision = va_arg(ap, int);
 800826a:	f109 0904 	add.w	r9, r9, #4
        c = *fmt++;
 800826e:	3602      	adds	r6, #2
 8008270:	e699      	b.n	8007fa6 <chprintf.constprop.35+0xc6>
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    
    p = tmpbuf;
 8008272:	a803      	add	r0, sp, #12
 8008274:	e7c9      	b.n	800820a <chprintf.constprop.35+0x32a>
      }
      else {
        l = va_arg(ap, int);
      }
      if (l < 0) {
        *p++ = '-';
 8008276:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8008278:	4249      	negs	r1, r1
      }
      else {
        l = va_arg(ap, int);
      }
      if (l < 0) {
        *p++ = '-';
 800827a:	f88d 300c 	strb.w	r3, [sp, #12]
 800827e:	f10d 000d 	add.w	r0, sp, #13
 8008282:	e7c2      	b.n	800820a <chprintf.constprop.35+0x32a>
    }
    i = (int)(p - s);
    if ((width -= i) < 0) {
      width = 0;
    }
    if (left_align == false) {
 8008284:	2520      	movs	r5, #32
 8008286:	e76c      	b.n	8008162 <chprintf.constprop.35+0x282>
 8008288:	2000b1fc 	.word	0x2000b1fc
 800828c:	0800d4d0 	.word	0x0800d4d0

08008290 <chSchWakeupS.constprop.34>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8008290:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8008292:	4d1a      	ldr	r5, [pc, #104]	; (80082fc <chSchWakeupS.constprop.34+0x6c>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8008294:	4604      	mov	r4, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 8008296:	f7fa f823 	bl	80022e0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 800829a:	682b      	ldr	r3, [r5, #0]
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 800829c:	69a8      	ldr	r0, [r5, #24]

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 800829e:	42ab      	cmp	r3, r5
 80082a0:	d02a      	beq.n	80082f8 <chSchWakeupS.constprop.34+0x68>
 80082a2:	689a      	ldr	r2, [r3, #8]
 80082a4:	6883      	ldr	r3, [r0, #8]
 80082a6:	4293      	cmp	r3, r2
 80082a8:	d320      	bcc.n	80082ec <chSchWakeupS.constprop.34+0x5c>

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
 80082aa:	68a2      	ldr	r2, [r4, #8]
              (ch.rlist.current->hdr.pqueue.prio >= ch.rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80082ac:	2100      	movs	r1, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
 80082ae:	4293      	cmp	r3, r2
              (ch.rlist.current->hdr.pqueue.prio >= ch.rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80082b0:	6261      	str	r1, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
 80082b2:	d216      	bcs.n	80082e2 <chSchWakeupS.constprop.34+0x52>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyAheadI(otp);
 80082b4:	f7fa f96c 	bl	8002590 <chSchReadyAheadI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80082b8:	2301      	movs	r3, #1

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80082ba:	4601      	mov	r1, r0
     list instead.*/
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyAheadI(otp);
 80082bc:	4606      	mov	r6, r0
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80082be:	f884 3020 	strb.w	r3, [r4, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80082c2:	4620      	mov	r0, r4
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80082c4:	61ac      	str	r4, [r5, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80082c6:	f7f9 ffeb 	bl	80022a0 <_trace_switch>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80082ca:	f3ef 8309 	mrs	r3, PSP
 80082ce:	69f2      	ldr	r2, [r6, #28]
 80082d0:	3b64      	subs	r3, #100	; 0x64
 80082d2:	429a      	cmp	r2, r3
 80082d4:	d80d      	bhi.n	80082f2 <chSchWakeupS.constprop.34+0x62>
 80082d6:	4620      	mov	r0, r4
 80082d8:	4631      	mov	r1, r6
  }
}
 80082da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80082de:	f7f8 b813 	b.w	8000308 <_port_switch>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
    (void) chSchReadyI(ntp);
 80082e2:	4620      	mov	r0, r4
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80082e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
    (void) chSchReadyI(ntp);
 80082e8:	f7fa b9d2 	b.w	8002690 <chSchReadyI>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80082ec:	4804      	ldr	r0, [pc, #16]	; (8008300 <chSchWakeupS.constprop.34+0x70>)
 80082ee:	f7fc fd47 	bl	8004d80 <chSysHalt>
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80082f2:	4804      	ldr	r0, [pc, #16]	; (8008304 <chSchWakeupS.constprop.34+0x74>)
 80082f4:	f7fc fd44 	bl	8004d80 <chSysHalt>
 80082f8:	6883      	ldr	r3, [r0, #8]
 80082fa:	e7d6      	b.n	80082aa <chSchWakeupS.constprop.34+0x1a>
 80082fc:	2000b68c 	.word	0x2000b68c
 8008300:	0800d4c0 	.word	0x0800d4c0
 8008304:	0800cd8c 	.word	0x0800cd8c
	...

08008310 <vmc_heap_alloc_n.constprop.21>:
    }
  }
  DBG_GPIO_CLR(DBG1);
}

heap_index vmc_heap_alloc_n(vmc_t *container, unsigned int n) {
 8008310:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008314:	4680      	mov	r8, r0

  heap_index head = HEAP_NULL;

  cam_value_t list = get_cam_val((UINT)HEAP_NULL, VALUE_PTR_BIT);

  for(int retries = 0; retries < 2; retries ++) {
 8008316:	2702      	movs	r7, #2
/*   return val_s; */
/* } */

cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
 8008318:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
  heap->value_flags[i].snd = value.flags;
 800831c:	f44f 4600 	mov.w	r6, #32768	; 0x8000
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 8008320:	f04f 0903 	mov.w	r9, #3
 8008324:	e000      	b.n	8008328 <vmc_heap_alloc_n.constprop.21+0x18>
 8008326:	4625      	mov	r5, r4
    for (int i = 0; i < (int)n; i ++) {

      head = heap_allocate(&container->heap);
 8008328:	4640      	mov	r0, r8
 800832a:	f000 fb49 	bl	80089c0 <heap_allocate>

      if (head == HEAP_NULL) {
 800832e:	1c43      	adds	r3, r0, #1
  cam_value_t list = get_cam_val((UINT)HEAP_NULL, VALUE_PTR_BIT);

  for(int retries = 0; retries < 2; retries ++) {
    for (int i = 0; i < (int)n; i ++) {

      head = heap_allocate(&container->heap);
 8008330:	4604      	mov	r4, r0

      if (head == HEAP_NULL) {
 8008332:	d00f      	beq.n	8008354 <vmc_heap_alloc_n.constprop.21+0x44>
 8008334:	f8d8 2000 	ldr.w	r2, [r8]
  heap->value_flags[i].snd = value.flags;
 8008338:	f8d8 3014 	ldr.w	r3, [r8, #20]
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 800833c:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
  heap->value_flags[i].snd = value.flags;
 8008340:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  heap_index head = HEAP_NULL;

  cam_value_t list = get_cam_val((UINT)HEAP_NULL, VALUE_PTR_BIT);

  for(int retries = 0; retries < 2; retries ++) {
    for (int i = 0; i < (int)n; i ++) {
 8008344:	f1b9 0901 	subs.w	r9, r9, #1
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 8008348:	6055      	str	r5, [r2, #4]
  heap->value_flags[i].snd = value.flags;
 800834a:	805e      	strh	r6, [r3, #2]
 800834c:	d1eb      	bne.n	8008326 <vmc_heap_alloc_n.constprop.21+0x16>
    heap_mark_phase(container);
  }

  /* head should be HEAP_NULL or a list of cells */
  return head;
}
 800834e:	4620      	mov	r0, r4
 8008350:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }

    if (head != HEAP_NULL) {
      break;
    }
    heap_mark_phase(container);
 8008354:	4640      	mov	r0, r8
 8008356:	f000 fa03 	bl	8008760 <heap_mark_phase.lto_priv.61>

  heap_index head = HEAP_NULL;

  cam_value_t list = get_cam_val((UINT)HEAP_NULL, VALUE_PTR_BIT);

  for(int retries = 0; retries < 2; retries ++) {
 800835a:	2f01      	cmp	r7, #1
 800835c:	d0f7      	beq.n	800834e <vmc_heap_alloc_n.constprop.21+0x3e>
 800835e:	2701      	movs	r7, #1
 8008360:	e7de      	b.n	8008320 <vmc_heap_alloc_n.constprop.21+0x10>
 8008362:	bf00      	nop
	...

08008370 <message_pass.constprop.17>:

  return 1;

}

static int message_pass( vmc_t *container
 8008370:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008374:	b093      	sub	sp, #76	; 0x4c
 8008376:	4604      	mov	r4, r0
 8008378:	9104      	str	r1, [sp, #16]
                       , sched_order_t sched_order){
  //This function looks at the environment of the blocked context;
  // It finds the event which demanded synchronization and checks
  // if there are post synchronization actions associated with it
  // If yes; it calls postSync otherwise simply places the msg on the env
  cam_value_t event = container->contexts[ctx_id].env;
 800837a:	3101      	adds	r1, #1
 800837c:	9105      	str	r1, [sp, #20]
 800837e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8008382:	eb00 1101 	add.w	r1, r0, r1, lsl #4

  return 1;

}

static int message_pass( vmc_t *container
 8008386:	f89d 9074 	ldrb.w	r9, [sp, #116]	; 0x74
  //This function looks at the environment of the blocked context;
  // It finds the event which demanded synchronization and checks
  // if there are post synchronization actions associated with it
  // If yes; it calls postSync otherwise simply places the msg on the env
  cam_value_t event = container->contexts[ctx_id].env;
  heap_index index  = event.value;
 800838a:	684d      	ldr	r5, [r1, #4]

  return 1;

}

static int message_pass( vmc_t *container
 800838c:	f89d 1070 	ldrb.w	r1, [sp, #112]	; 0x70
 8008390:	9103      	str	r1, [sp, #12]
  // (depending on who synchronised second) will call this method on the
  // corresponding receiver or sender to clean all the channels which got blocked.

  heap_index index = *evts;

  while(index != HEAP_NULL){
 8008392:	1c6e      	adds	r6, r5, #1

  return 1;

}

static int message_pass( vmc_t *container
 8008394:	a906      	add	r1, sp, #24
 8008396:	e881 000c 	stmia.w	r1, {r2, r3}
  // (depending on who synchronised second) will call this method on the
  // corresponding receiver or sender to clean all the channels which got blocked.

  heap_index index = *evts;

  while(index != HEAP_NULL){
 800839a:	f000 8087 	beq.w	80084ac <message_pass.constprop.17+0x13c>
 800839e:	46ab      	mov	fp, r5
 80083a0:	af0a      	add	r7, sp, #40	; 0x28
 80083a2:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 80083a6:	ae0e      	add	r6, sp, #56	; 0x38
    /****************************************************/
    // polling the channel queuss cleans the dirty entries
    if(bevt_simple.e_type == SEND)
      poll_sendq(container, &container->channels[bevt_simple.channel_id].sendq);
    else if (bevt_simple.e_type == RECV)
      poll_recvq(container, &container->channels[bevt_simple.channel_id].recvq);
 80083a8:	f04f 0a2c 	mov.w	sl, #44	; 0x2c
 80083ac:	e009      	b.n	80083c2 <message_pass.constprop.17+0x52>

    /****************************************************/
    // polling the channel queuss cleans the dirty entries
    if(bevt_simple.e_type == SEND)
      poll_sendq(container, &container->channels[bevt_simple.channel_id].sendq);
    else if (bevt_simple.e_type == RECV)
 80083ae:	2b01      	cmp	r3, #1
 80083b0:	d023      	beq.n	80083fa <message_pass.constprop.17+0x8a>
      poll_recvq(container, &container->channels[bevt_simple.channel_id].recvq);

    // continue the while loop

    cam_value_t pointer_to_next = heap_snd(&container->heap, index);
 80083b2:	462a      	mov	r2, r5
 80083b4:	a810      	add	r0, sp, #64	; 0x40
 80083b6:	4621      	mov	r1, r4
 80083b8:	f000 fb6a 	bl	8008a90 <heap_snd>
    index = (heap_index)pointer_to_next.value;
 80083bc:	9d11      	ldr	r5, [sp, #68]	; 0x44
  // (depending on who synchronised second) will call this method on the
  // corresponding receiver or sender to clean all the channels which got blocked.

  heap_index index = *evts;

  while(index != HEAP_NULL){
 80083be:	1c68      	adds	r0, r5, #1
 80083c0:	d024      	beq.n	800840c <message_pass.constprop.17+0x9c>

    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);
 80083c2:	4638      	mov	r0, r7
 80083c4:	4621      	mov	r1, r4
 80083c6:	462a      	mov	r2, r5
 80083c8:	f000 fb72 	bl	8008ab0 <heap_fst>

    cam_value_t base_evt_ptr =
 80083cc:	4640      	mov	r0, r8
 80083ce:	4621      	mov	r1, r4
 80083d0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80083d2:	f000 fb6d 	bl	8008ab0 <heap_fst>
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);

    cam_value_t base_evt_simple =
 80083d6:	4621      	mov	r1, r4
 80083d8:	4630      	mov	r0, r6
 80083da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80083dc:	f000 fb68 	bl	8008ab0 <heap_fst>
 80083e0:	990f      	ldr	r1, [sp, #60]	; 0x3c
      heap_fst(&container->heap, (heap_index)base_evt_ptr.value);


    base_evt_simple_t bevt_simple =
 80083e2:	f3c1 2307 	ubfx	r3, r1, #8, #8
        , .channel_id = extract_bits(base_evt_simple.value,  0, 8)
      };

    /****************************************************/
    // polling the channel queuss cleans the dirty entries
    if(bevt_simple.e_type == SEND)
 80083e6:	2b00      	cmp	r3, #0
 80083e8:	d1e1      	bne.n	80083ae <message_pass.constprop.17+0x3e>
 80083ea:	b2c9      	uxtb	r1, r1
      poll_sendq(container, &container->channels[bevt_simple.channel_id].sendq);
 80083ec:	fb0a 4101 	mla	r1, sl, r1, r4
 80083f0:	31f4      	adds	r1, #244	; 0xf4
 80083f2:	4620      	mov	r0, r4
 80083f4:	f000 fc0c 	bl	8008c10 <poll_sendq>
 80083f8:	e7db      	b.n	80083b2 <message_pass.constprop.17+0x42>
 80083fa:	b2c9      	uxtb	r1, r1
    else if (bevt_simple.e_type == RECV)
      poll_recvq(container, &container->channels[bevt_simple.channel_id].recvq);
 80083fc:	fb0a 4101 	mla	r1, sl, r1, r4
 8008400:	f501 7184 	add.w	r1, r1, #264	; 0x108
 8008404:	4620      	mov	r0, r4
 8008406:	f000 fc4b 	bl	8008ca0 <poll_recvq>
 800840a:	e7d2      	b.n	80083b2 <message_pass.constprop.17+0x42>
 800840c:	465d      	mov	r5, fp
      } else {
        container->contexts[ctx_id].env = msg;
        return 1;
      }
    }
    cam_value_t pointer_to_next = heap_snd(&container->heap, index);
 800840e:	46b2      	mov	sl, r6
  // accumulate entries for all the times that it lost the synchronisation race.
  event_t syncingThreadEvt = (event_t)index;
  cleanupChannels(container, &syncingThreadEvt);

  do{
    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);
 8008410:	462a      	mov	r2, r5
 8008412:	a808      	add	r0, sp, #32
 8008414:	4621      	mov	r1, r4
 8008416:	f000 fb4b 	bl	8008ab0 <heap_fst>

    cam_value_t base_evt_ptr =
 800841a:	4638      	mov	r0, r7
 800841c:	4621      	mov	r1, r4
 800841e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008420:	f000 fb46 	bl	8008ab0 <heap_fst>
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);

    cam_value_t base_evt_simple =
      heap_fst(&container->heap, (heap_index)base_evt_ptr.value);
 8008424:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
    cam_value_t cam_evt_pointer = heap_fst(&container->heap, index);

    cam_value_t base_evt_ptr =
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);

    cam_value_t base_evt_simple =
 8008428:	4640      	mov	r0, r8
 800842a:	465a      	mov	r2, fp
 800842c:	4621      	mov	r1, r4
 800842e:	f000 fb3f 	bl	8008ab0 <heap_fst>
 8008432:	9e0d      	ldr	r6, [sp, #52]	; 0x34
      heap_fst(&container->heap, (heap_index)base_evt_ptr.value);

    cam_value_t wrap_fptr =
 8008434:	465a      	mov	r2, fp
 8008436:	4650      	mov	r0, sl
 8008438:	4621      	mov	r1, r4
 800843a:	f000 fb29 	bl	8008a90 <heap_snd>
    base_evt_simple_t bevt_simple =
      {   .e_type     = extract_bits(base_evt_simple.value,  8, 8)
        , .channel_id = extract_bits(base_evt_simple.value,  0, 8)
      };

    if((bevt_simple.e_type == ety) && (bevt_simple.channel_id == chan_id)){
 800843e:	f3c6 2307 	ubfx	r3, r6, #8, #8
 8008442:	454b      	cmp	r3, r9
      } else {
        container->contexts[ctx_id].env = msg;
        return 1;
      }
    }
    cam_value_t pointer_to_next = heap_snd(&container->heap, index);
 8008444:	462a      	mov	r2, r5
 8008446:	a810      	add	r0, sp, #64	; 0x40
 8008448:	4621      	mov	r1, r4
    base_evt_simple_t bevt_simple =
      {   .e_type     = extract_bits(base_evt_simple.value,  8, 8)
        , .channel_id = extract_bits(base_evt_simple.value,  0, 8)
      };

    if((bevt_simple.e_type == ety) && (bevt_simple.channel_id == chan_id)){
 800844a:	b2f6      	uxtb	r6, r6
      heap_fst(&container->heap, (heap_index)cam_evt_pointer.value);

    cam_value_t base_evt_simple =
      heap_fst(&container->heap, (heap_index)base_evt_ptr.value);

    cam_value_t wrap_fptr =
 800844c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    base_evt_simple_t bevt_simple =
      {   .e_type     = extract_bits(base_evt_simple.value,  8, 8)
        , .channel_id = extract_bits(base_evt_simple.value,  0, 8)
      };

    if((bevt_simple.e_type == ety) && (bevt_simple.channel_id == chan_id)){
 800844e:	d102      	bne.n	8008456 <message_pass.constprop.17+0xe6>
 8008450:	9b03      	ldr	r3, [sp, #12]
 8008452:	429e      	cmp	r6, r3
 8008454:	d008      	beq.n	8008468 <message_pass.constprop.17+0xf8>
      } else {
        container->contexts[ctx_id].env = msg;
        return 1;
      }
    }
    cam_value_t pointer_to_next = heap_snd(&container->heap, index);
 8008456:	f000 fb1b 	bl	8008a90 <heap_snd>
    index = (heap_index)pointer_to_next.value;
 800845a:	9d11      	ldr	r5, [sp, #68]	; 0x44


  } while(index != HEAP_NULL);
 800845c:	1c6b      	adds	r3, r5, #1
 800845e:	d1d7      	bne.n	8008410 <message_pass.constprop.17+0xa0>

  return -1; // could not find the right event to sync
 8008460:	4628      	mov	r0, r5
}
 8008462:	b013      	add	sp, #76	; 0x4c
 8008464:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      {   .e_type     = extract_bits(base_evt_simple.value,  8, 8)
        , .channel_id = extract_bits(base_evt_simple.value,  0, 8)
      };

    if((bevt_simple.e_type == ety) && (bevt_simple.channel_id == chan_id)){
      if((heap_index)wrap_fptr.value != HEAP_NULL){
 8008468:	1c69      	adds	r1, r5, #1
 800846a:	d011      	beq.n	8008490 <message_pass.constprop.17+0x120>

        int q = postSync( container
 800846c:	9a04      	ldr	r2, [sp, #16]
 800846e:	9200      	str	r2, [sp, #0]
 8008470:	2300      	movs	r3, #0
 8008472:	9301      	str	r3, [sp, #4]
 8008474:	ab06      	add	r3, sp, #24
 8008476:	cb0c      	ldmia	r3, {r2, r3}
 8008478:	4620      	mov	r0, r4
 800847a:	4629      	mov	r1, r5
 800847c:	f000 fb28 	bl	8008ad0 <postSync.isra.2.lto_priv.62>
                        , sched_order);
        if(q == -1){
          DEBUG_PRINT(("Post synchronization error\n"));
          return q;
        }
        return 1;
 8008480:	1c42      	adds	r2, r0, #1
 8008482:	bf0c      	ite	eq
 8008484:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
 8008488:	2001      	movne	r0, #1


  } while(index != HEAP_NULL);

  return -1; // could not find the right event to sync
}
 800848a:	b013      	add	sp, #76	; 0x4c
 800848c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          return q;
        }
        return 1;

      } else {
        container->contexts[ctx_id].env = msg;
 8008490:	ab06      	add	r3, sp, #24
 8008492:	e893 0003 	ldmia.w	r3, {r0, r1}
 8008496:	9b05      	ldr	r3, [sp, #20]
 8008498:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800849c:	eb04 1403 	add.w	r4, r4, r3, lsl #4
 80084a0:	e884 0003 	stmia.w	r4, {r0, r1}
        return 1;
 80084a4:	2001      	movs	r0, #1


  } while(index != HEAP_NULL);

  return -1; // could not find the right event to sync
}
 80084a6:	b013      	add	sp, #76	; 0x4c
 80084a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80084ac:	af0a      	add	r7, sp, #40	; 0x28
 80084ae:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 80084b2:	ae0e      	add	r6, sp, #56	; 0x38
 80084b4:	e7ab      	b.n	800840e <message_pass.constprop.17+0x9e>
 80084b6:	bf00      	nop
	...

080084c0 <_sbrk_r>:
}

/***************************************************************************/

__attribute__((used))
caddr_t _sbrk_r(struct _reent *r, int incr) {
 80084c0:	b538      	push	{r3, r4, r5, lr}
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr >= 0);
 80084c2:	1e0c      	subs	r4, r1, #0
 80084c4:	db27      	blt.n	8008516 <_sbrk_r+0x56>
 80084c6:	4605      	mov	r5, r0
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80084c8:	2320      	movs	r3, #32
 80084ca:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80084ce:	f7fc fccf 	bl	8004e70 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocFromBaseI(size_t size, unsigned align, size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
 80084d2:	f7f9 ff3d 	bl	8002350 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.basemem + offset, align);
 80084d6:	4b14      	ldr	r3, [pc, #80]	; (8008528 <_sbrk_r+0x68>)
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.topmem) || (next < ch_memcore.basemem)) {
 80084d8:	e893 0005 	ldmia.w	r3, {r0, r2}

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.basemem + offset, align);
  next = p + size;
 80084dc:	1901      	adds	r1, r0, r4

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.topmem) || (next < ch_memcore.basemem)) {
 80084de:	4291      	cmp	r1, r2
 80084e0:	d814      	bhi.n	800850c <_sbrk_r+0x4c>
 80084e2:	4288      	cmp	r0, r1
 80084e4:	d812      	bhi.n	800850c <_sbrk_r+0x4c>
    return NULL;
  }

  ch_memcore.basemem = next;
 80084e6:	6019      	str	r1, [r3, #0]
 80084e8:	4604      	mov	r4, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80084ea:	f7fc fcb1 	bl	8004e50 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.pqueue.next == &ch.rlist.pqueue) ||
 80084ee:	4b0f      	ldr	r3, [pc, #60]	; (800852c <_sbrk_r+0x6c>)
 80084f0:	681a      	ldr	r2, [r3, #0]
 80084f2:	429a      	cmp	r2, r3
 80084f4:	d004      	beq.n	8008500 <_sbrk_r+0x40>
 80084f6:	6999      	ldr	r1, [r3, #24]
 80084f8:	6893      	ldr	r3, [r2, #8]
 80084fa:	688a      	ldr	r2, [r1, #8]
 80084fc:	429a      	cmp	r2, r3
 80084fe:	d307      	bcc.n	8008510 <_sbrk_r+0x50>
 8008500:	2300      	movs	r3, #0
 8008502:	f383 8811 	msr	BASEPRI, r3

  p = chCoreAllocFromBase((size_t)incr, 1U, 0U);
  if (p == NULL) {
 8008506:	b14c      	cbz	r4, 800851c <_sbrk_r+0x5c>
 8008508:	4620      	mov	r0, r4
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 800850a:	bd38      	pop	{r3, r4, r5, pc}
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.basemem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.topmem) || (next < ch_memcore.basemem)) {
    return NULL;
 800850c:	2400      	movs	r4, #0
 800850e:	e7ec      	b.n	80084ea <_sbrk_r+0x2a>
 8008510:	4807      	ldr	r0, [pc, #28]	; (8008530 <_sbrk_r+0x70>)
 8008512:	f7fc fc35 	bl	8004d80 <chSysHalt>
__attribute__((used))
caddr_t _sbrk_r(struct _reent *r, int incr) {
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr >= 0);
 8008516:	4807      	ldr	r0, [pc, #28]	; (8008534 <_sbrk_r+0x74>)
 8008518:	f7fc fc32 	bl	8004d80 <chSysHalt>

  p = chCoreAllocFromBase((size_t)incr, 1U, 0U);
  if (p == NULL) {
    __errno_r(r)  = ENOMEM;
 800851c:	230c      	movs	r3, #12
 800851e:	602b      	str	r3, [r5, #0]
    return (caddr_t)-1;
 8008520:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008524:	bd38      	pop	{r3, r4, r5, pc}
 8008526:	bf00      	nop
 8008528:	2000bf14 	.word	0x2000bf14
 800852c:	2000b68c 	.word	0x2000b68c
 8008530:	0800d4f4 	.word	0x0800d4f4
 8008534:	0800d4b8 	.word	0x0800d4b8
	...

08008540 <heap_mark>:

// Deutsch-Schorr-Waite pointer reversal marking
// Todo: lots of testing and tweaking until it works.

//void heap_mark(heap_t * heap, UINT value, value_flags_t v_flags) {
void heap_mark(heap_t *heap, cam_value_t v) {
 8008540:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008544:	b083      	sub	sp, #12
 8008546:	ab02      	add	r3, sp, #8
 8008548:	e903 0006 	stmdb	r3, {r1, r2}
  
  bool done = false;
  cam_value_t curr = v;
 800854c:	f8bd 6000 	ldrh.w	r6, [sp]
 8008550:	9b01      	ldr	r3, [sp, #4]
  cam_value_t prev = get_cam_val(HEAP_NULL, VALUE_PTR_BIT);

  // Abort if value is not a pointer to a heap structure.
  if (is_atomic(curr)) {
 8008552:	0432      	lsls	r2, r6, #16
 8008554:	d402      	bmi.n	800855c <heap_mark+0x1c>
      cam_value_t hs = heap_snd(heap, prev.value);
      curr = hs;
      heap_set_snd(heap, prev.value, next);
    }
  }
}
 8008556:	b003      	add	sp, #12
 8008558:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  bool done = false;
  cam_value_t curr = v;
  cam_value_t prev = get_cam_val(HEAP_NULL, VALUE_PTR_BIT);

  // Abort if value is not a pointer to a heap structure.
  if (is_atomic(curr)) {
 800855c:	f44f 4500 	mov.w	r5, #32768	; 0x8000
 8008560:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  }
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
 8008564:	0434      	lsls	r4, r6, #16
 8008566:	d525      	bpl.n	80085b4 <heap_mark+0x74>
 8008568:	1c59      	adds	r1, r3, #1
 800856a:	d023      	beq.n	80085b4 <heap_mark+0x74>
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 800856c:	6981      	ldr	r1, [r0, #24]
 800856e:	5ccc      	ldrb	r4, [r1, r3]
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
	   (heap_index)curr.value != HEAP_NULL &&
 8008570:	0627      	lsls	r7, r4, #24
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 8008572:	4419      	add	r1, r3
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
	   (heap_index)curr.value != HEAP_NULL &&
 8008574:	d41e      	bmi.n	80085b4 <heap_mark+0x74>
  heap->cells[i].snd = value.value;
  heap->value_flags[i].snd = value.flags;
}

static inline void set_gc_mark(heap_t *heap, heap_index i) {
  heap->flags[i] |= HEAP_GC_MARK_BIT;
 8008576:	f064 047f 	orn	r4, r4, #127	; 0x7f
 800857a:	700c      	strb	r4, [r1, #0]
cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
}
cam_value_t heap_fst(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
 800857c:	6941      	ldr	r1, [r0, #20]
 800857e:	6804      	ldr	r4, [r0, #0]
 8008580:	f831 7023 	ldrh.w	r7, [r1, r3, lsl #2]
 8008584:	f854 e033 	ldr.w	lr, [r4, r3, lsl #3]
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 8008588:	f844 2033 	str.w	r2, [r4, r3, lsl #3]
  }
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
 800858c:	f417 4f00 	tst.w	r7, #32768	; 0x8000
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
 8008590:	f821 5023 	strh.w	r5, [r1, r3, lsl #2]
 8008594:	461a      	mov	r2, r3
 8008596:	4635      	mov	r5, r6
  }
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
 8008598:	d052      	beq.n	8008640 <heap_mark+0x100>
 800859a:	f1be 3fff 	cmp.w	lr, #4294967295	; 0xffffffff
 800859e:	d04f      	beq.n	8008640 <heap_mark+0x100>
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 80085a0:	6981      	ldr	r1, [r0, #24]
 80085a2:	f811 400e 	ldrb.w	r4, [r1, lr]
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
	   (heap_index)curr.value != HEAP_NULL &&
 80085a6:	f014 0f80 	tst.w	r4, #128	; 0x80
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 80085aa:	4471      	add	r1, lr
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
	   (heap_index)curr.value != HEAP_NULL &&
 80085ac:	d148      	bne.n	8008640 <heap_mark+0x100>
 80085ae:	4673      	mov	r3, lr
 80085b0:	463e      	mov	r6, r7
 80085b2:	e7e0      	b.n	8008576 <heap_mark+0x36>
        heap_set_fst(heap, curr.value, pv);
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
 80085b4:	042f      	lsls	r7, r5, #16
 80085b6:	d551      	bpl.n	800865c <heap_mark+0x11c>
 80085b8:	1c54      	adds	r4, r2, #1
 80085ba:	d0cc      	beq.n	8008556 <heap_mark+0x16>
static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
}

static inline int get_gc_flag(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_FLAG_BIT;
 80085bc:	6987      	ldr	r7, [r0, #24]
 80085be:	5cbc      	ldrb	r4, [r7, r2]
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
	    (heap_index)prev.value != HEAP_NULL &&
 80085c0:	0661      	lsls	r1, r4, #25
static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
}

static inline int get_gc_flag(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_FLAG_BIT;
 80085c2:	4417      	add	r7, r2
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
	    (heap_index)prev.value != HEAP_NULL &&
 80085c4:	d40a      	bmi.n	80085dc <heap_mark+0x9c>
 80085c6:	e040      	b.n	800864a <heap_mark+0x10a>
        heap_set_fst(heap, curr.value, pv);
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
 80085c8:	1c4c      	adds	r4, r1, #1
 80085ca:	d0c4      	beq.n	8008556 <heap_mark+0x16>
static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
}

static inline int get_gc_flag(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_FLAG_BIT;
 80085cc:	6987      	ldr	r7, [r0, #24]
 80085ce:	5c7c      	ldrb	r4, [r7, r1]
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
	    (heap_index)prev.value != HEAP_NULL &&
 80085d0:	f014 0f40 	tst.w	r4, #64	; 0x40
static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
}

static inline int get_gc_flag(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_FLAG_BIT;
 80085d4:	440f      	add	r7, r1
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
	    (heap_index)prev.value != HEAP_NULL &&
 80085d6:	d03c      	beq.n	8008652 <heap_mark+0x112>
 80085d8:	460a      	mov	r2, r1
 80085da:	4675      	mov	r5, lr
static inline void clr_gc_mark(heap_t *heap, heap_index i) {
  heap->flags[i] &= ~HEAP_GC_MARK_BIT;
}

static inline void clr_gc_flag(heap_t *heap, heap_index i) {
  heap->flags[i] &= ~HEAP_GC_FLAG_BIT;
 80085dc:	f024 0440 	bic.w	r4, r4, #64	; 0x40
 80085e0:	703c      	strb	r4, [r7, #0]
cam_value_t heap_fst(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
}

cam_value_t heap_snd(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
 80085e2:	6944      	ldr	r4, [r0, #20]
 80085e4:	6807      	ldr	r7, [r0, #0]
 80085e6:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 80085ea:	eb07 07c2 	add.w	r7, r7, r2, lsl #3
 80085ee:	f8b4 e002 	ldrh.w	lr, [r4, #2]
 80085f2:	6879      	ldr	r1, [r7, #4]
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 80085f4:	607b      	str	r3, [r7, #4]
        heap_set_fst(heap, curr.value, pv);
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
 80085f6:	f41e 4f00 	tst.w	lr, #32768	; 0x8000
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
  heap->value_flags[i].snd = value.flags;
 80085fa:	8066      	strh	r6, [r4, #2]
 80085fc:	4613      	mov	r3, r2
 80085fe:	462e      	mov	r6, r5
        heap_set_fst(heap, curr.value, pv);
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
 8008600:	d1e2      	bne.n	80085c8 <heap_mark+0x88>
 8008602:	6983      	ldr	r3, [r0, #24]
 8008604:	5c5c      	ldrb	r4, [r3, r1]
	    (heap_index)prev.value != HEAP_NULL &&
 8008606:	46ac      	mov	ip, r5
 8008608:	4691      	mov	r9, r2
 800860a:	4675      	mov	r5, lr
 800860c:	185f      	adds	r7, r3, r1
 800860e:	460a      	mov	r2, r1
static inline void set_gc_mark(heap_t *heap, heap_index i) {
  heap->flags[i] |= HEAP_GC_MARK_BIT;
}

static inline void set_gc_flag(heap_t *heap, heap_index i) {
  heap->flags[i] |= HEAP_GC_FLAG_BIT;
 8008610:	f044 0440 	orr.w	r4, r4, #64	; 0x40
 8008614:	703c      	strb	r4, [r7, #0]
cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
}
cam_value_t heap_fst(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
 8008616:	6803      	ldr	r3, [r0, #0]
 8008618:	6946      	ldr	r6, [r0, #20]
 800861a:	f853 8031 	ldr.w	r8, [r3, r1, lsl #3]
 800861e:	f836 e021 	ldrh.w	lr, [r6, r1, lsl #2]
  heap->value_flags[i].fst = f.flags;
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
 8008622:	f843 9031 	str.w	r9, [r3, r1, lsl #3]
cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
}
cam_value_t heap_fst(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
 8008626:	eb03 04c1 	add.w	r4, r3, r1, lsl #3
 800862a:	eb06 0781 	add.w	r7, r6, r1, lsl #2
  heap->value_flags[i].snd = s.flags;
}

void heap_set_fst(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
 800862e:	f826 c021 	strh.w	ip, [r6, r1, lsl #2]
cam_value_t heap_fst(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
}

cam_value_t heap_snd(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
 8008632:	6863      	ldr	r3, [r4, #4]
 8008634:	887e      	ldrh	r6, [r7, #2]
  heap->cells[i].fst = value.value;
  heap->value_flags[i].fst = value.flags;
}

void heap_set_snd(heap_t *heap, heap_index i, cam_value_t value) {
  heap->cells[i].snd = value.value;
 8008636:	f8c4 8004 	str.w	r8, [r4, #4]
  heap->value_flags[i].snd = value.flags;
 800863a:	f8a7 e002 	strh.w	lr, [r7, #2]
 800863e:	e791      	b.n	8008564 <heap_mark+0x24>
    
  // curr_val is a pointer onto the heap.
  while (!done) {
    // Follow left pointers
    while (is_pointer(curr) &&
	   (heap_index)curr.value != HEAP_NULL &&
 8008640:	4635      	mov	r5, r6
 8008642:	461a      	mov	r2, r3
 8008644:	463e      	mov	r6, r7
 8008646:	4673      	mov	r3, lr
 8008648:	e7b6      	b.n	80085b8 <heap_mark+0x78>
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
	    (heap_index)prev.value != HEAP_NULL &&
 800864a:	4611      	mov	r1, r2
 800864c:	46ae      	mov	lr, r5
 800864e:	461a      	mov	r2, r3
 8008650:	4635      	mov	r5, r6
 8008652:	46ac      	mov	ip, r5
 8008654:	4691      	mov	r9, r2
 8008656:	4675      	mov	r5, lr
 8008658:	460a      	mov	r2, r1
 800865a:	e7d9      	b.n	8008610 <heap_mark+0xd0>
        heap_set_fst(heap, curr.value, pv);
        prev = curr;
        curr = next;
      }
    }
    while  (is_pointer(prev) &&
 800865c:	4611      	mov	r1, r2
 800865e:	46ae      	mov	lr, r5
 8008660:	461a      	mov	r2, r3
 8008662:	4635      	mov	r5, r6
 8008664:	e7cd      	b.n	8008602 <heap_mark+0xc2>
 8008666:	bf00      	nop
	...

08008670 <pq_insert>:

  return 1;

}

int pq_insert(PriorityQ_t *pq, pq_data_t pq_data){
 8008670:	b082      	sub	sp, #8
 8008672:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008676:	b087      	sub	sp, #28
 8008678:	a90e      	add	r1, sp, #56	; 0x38
 800867a:	e881 000c 	stmia.w	r1, {r2, r3}

  if(pq->size == pq->capacity){
 800867e:	6886      	ldr	r6, [r0, #8]
 8008680:	6843      	ldr	r3, [r0, #4]
 8008682:	429e      	cmp	r6, r3

  return 1;

}

int pq_insert(PriorityQ_t *pq, pq_data_t pq_data){
 8008684:	4605      	mov	r5, r0

  if(pq->size == pq->capacity){
 8008686:	d061      	beq.n	800874c <pq_insert+0xdc>
    return -1;
  }

  pq->size++;
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;
 8008688:	468e      	mov	lr, r1
 800868a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800868e:	682c      	ldr	r4, [r5, #0]
 8008690:	0077      	lsls	r7, r6, #1
 8008692:	eb07 0c06 	add.w	ip, r7, r6
 8008696:	eb04 04cc 	add.w	r4, r4, ip, lsl #3
  if(pq->size == pq->capacity){
    DEBUG_PRINT(("Priority queue full; Cannot insert\n"));
    return -1;
  }

  pq->size++;
 800869a:	f106 0c01 	add.w	ip, r6, #1
 800869e:	f8c5 c008 	str.w	ip, [r5, #8]
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;
 80086a2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80086a4:	e89e 0003 	ldmia.w	lr, {r0, r1}
 80086a8:	e884 0003 	stmia.w	r4, {r0, r1}

  while(insertIdx != 0 &&
 80086ac:	bb4e      	cbnz	r6, 8008702 <pq_insert+0x92>
 80086ae:	e047      	b.n	8008740 <pq_insert+0xd0>
    return (d1->deadline < d2->deadline);
}

static inline bool greaterThan(pq_data_t *d1, pq_data_t *d2, Comparator_t c){
  if(c == BASELINE)
    return (d1->baseline > d2->baseline);
 80086b0:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 80086b4:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 80086b8:	4299      	cmp	r1, r3
 80086ba:	bf08      	it	eq
 80086bc:	4290      	cmpeq	r0, r2
 80086be:	bf34      	ite	cc
 80086c0:	2301      	movcc	r3, #1
 80086c2:	2300      	movcs	r3, #0
#include<stdbool.h>


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
 80086c4:	46ee      	mov	lr, sp
  *x = *y;
 80086c6:	46b1      	mov	r9, r6
  *y = temp;
 80086c8:	46e8      	mov	r8, sp
 80086ca:	46bc      	mov	ip, r7

  pq->size++;
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;

  while(insertIdx != 0 &&
 80086cc:	2b00      	cmp	r3, #0
 80086ce:	d037      	beq.n	8008740 <pq_insert+0xd0>
#include<stdbool.h>


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
 80086d0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80086d2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80086d6:	e896 0003 	ldmia.w	r6, {r0, r1}
 80086da:	e88e 0003 	stmia.w	lr, {r0, r1}
  *x = *y;
 80086de:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80086e0:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
 80086e4:	e897 0003 	ldmia.w	r7, {r0, r1}
 80086e8:	e886 0003 	stmia.w	r6, {r0, r1}
  *y = temp;
 80086ec:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 80086f0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80086f4:	e89e 0003 	ldmia.w	lr, {r0, r1}

  pq->size++;
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;

  while(insertIdx != 0 &&
 80086f8:	4626      	mov	r6, r4

static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
  *x = *y;
  *y = temp;
 80086fa:	e887 0003 	stmia.w	r7, {r0, r1}

  pq->size++;
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;

  while(insertIdx != 0 &&
 80086fe:	b1fc      	cbz	r4, 8008740 <pq_insert+0xd0>
 8008700:	0067      	lsls	r7, r4, #1
  pq_data_t temp = *x;
  *x = *y;
  *y = temp;
}

static inline int parentIdx(int i) { return (i-1)/2; }
 8008702:	1e74      	subs	r4, r6, #1
 8008704:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
  pq->size++;
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;

  while(insertIdx != 0 &&
        greaterThan(  &pq->data[parentIdx(insertIdx)]
 8008708:	682b      	ldr	r3, [r5, #0]
  else
    return (d1->deadline < d2->deadline);
}

static inline bool greaterThan(pq_data_t *d1, pq_data_t *d2, Comparator_t c){
  if(c == BASELINE)
 800870a:	7b2a      	ldrb	r2, [r5, #12]
  pq_data_t temp = *x;
  *x = *y;
  *y = temp;
}

static inline int parentIdx(int i) { return (i-1)/2; }
 800870c:	1064      	asrs	r4, r4, #1
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;

  while(insertIdx != 0 &&
        greaterThan(  &pq->data[parentIdx(insertIdx)]
                    , &pq->data[insertIdx]
 800870e:	443e      	add	r6, r7
  pq->size++;
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;

  while(insertIdx != 0 &&
        greaterThan(  &pq->data[parentIdx(insertIdx)]
 8008710:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 8008714:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
 8008718:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  else
    return (d1->deadline < d2->deadline);
}

static inline bool greaterThan(pq_data_t *d1, pq_data_t *d2, Comparator_t c){
  if(c == BASELINE)
 800871c:	2a00      	cmp	r2, #0
 800871e:	d0c7      	beq.n	80086b0 <pq_insert+0x40>
    return (d1->baseline > d2->baseline);
  else
    return (d1->deadline > d2->deadline);
 8008720:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8008724:	e9d6 0104 	ldrd	r0, r1, [r6, #16]
 8008728:	4299      	cmp	r1, r3
 800872a:	bf08      	it	eq
 800872c:	4290      	cmpeq	r0, r2
 800872e:	bf34      	ite	cc
 8008730:	2301      	movcc	r3, #1
 8008732:	2300      	movcs	r3, #0
#include<stdbool.h>


static inline void swapElems(pq_data_t *x, pq_data_t *y)
{
  pq_data_t temp = *x;
 8008734:	46ee      	mov	lr, sp
  *x = *y;
 8008736:	46b1      	mov	r9, r6
  *y = temp;
 8008738:	46e8      	mov	r8, sp
 800873a:	46bc      	mov	ip, r7

  pq->size++;
  int insertIdx = pq->size - 1;
  pq->data[insertIdx] = pq_data;

  while(insertIdx != 0 &&
 800873c:	2b00      	cmp	r3, #0
 800873e:	d1c7      	bne.n	80086d0 <pq_insert+0x60>
                    , pq->cmp)
        ){
    swapElems(&pq->data[insertIdx], &pq->data[parentIdx(insertIdx)]);
    insertIdx = parentIdx(insertIdx);
  }
  return 1;
 8008740:	2001      	movs	r0, #1
}
 8008742:	b007      	add	sp, #28
 8008744:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008748:	b002      	add	sp, #8
 800874a:	4770      	bx	lr

int pq_insert(PriorityQ_t *pq, pq_data_t pq_data){

  if(pq->size == pq->capacity){
    DEBUG_PRINT(("Priority queue full; Cannot insert\n"));
    return -1;
 800874c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008750:	e7f7      	b.n	8008742 <pq_insert+0xd2>
 8008752:	bf00      	nop
	...

08008760 <heap_mark_phase.lto_priv.61>:
      get_cam_val(context->stack.data[i], context->stack.flags[i]);
    heap_mark(heap, cv);
  }
}

static void heap_mark_phase(vmc_t *container) {
 8008760:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008764:	4604      	mov	r4, r0
 8008766:	b083      	sub	sp, #12
 8008768:	f100 08ef 	add.w	r8, r0, #239	; 0xef
 800876c:	f100 0630 	add.w	r6, r0, #48	; 0x30
 8008770:	f100 09f0 	add.w	r9, r0, #240	; 0xf0
  //  (  &container->contexts[container->current_running_context_id]
  //     , &container->heap);

  /* GC all active contexts */
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    if(container->context_used[i] ){
 8008774:	f818 3f01 	ldrb.w	r3, [r8, #1]!
 8008778:	bbeb      	cbnz	r3, 80087f6 <heap_mark_phase.lto_priv.61+0x96>
 800877a:	3630      	adds	r6, #48	; 0x30
  //mark_heap_context
  //  (  &container->contexts[container->current_running_context_id]
  //     , &container->heap);

  /* GC all active contexts */
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
 800877c:	454e      	cmp	r6, r9
 800877e:	d1f9      	bne.n	8008774 <heap_mark_phase.lto_priv.61+0x14>
 8008780:	f504 5589 	add.w	r5, r4, #4384	; 0x1120
 8008784:	3510      	adds	r5, #16
 8008786:	4626      	mov	r6, r4
    }
  }

  //GC all the dirty flags associated with the channels
  for(int i = 0; i < MAX_CHANNELS; i++){
    if(container->channels[i].in_use){
 8008788:	f896 311c 	ldrb.w	r3, [r6, #284]	; 0x11c
 800878c:	b36b      	cbz	r3, 80087ea <heap_mark_phase.lto_priv.61+0x8a>
      // first check if channel is in use
      // and then mark all live dirty flags
      // in the sendq and then in the recvq

      for(int j = 0; j < container->channels[i].sendq.size; j++){
 800878e:	f8d6 3104 	ldr.w	r3, [r6, #260]	; 0x104
 8008792:	2b00      	cmp	r3, #0
 8008794:	dd12      	ble.n	80087bc <heap_mark_phase.lto_priv.61+0x5c>
 8008796:	2700      	movs	r7, #0
 8008798:	46b8      	mov	r8, r7
	heap_mark(  &container->heap
 800879a:	f8d6 30f4 	ldr.w	r3, [r6, #244]	; 0xf4
 800879e:	443b      	add	r3, r7
 80087a0:	330c      	adds	r3, #12
 80087a2:	e893 0006 	ldmia.w	r3, {r1, r2}
 80087a6:	4620      	mov	r0, r4
 80087a8:	f7ff feca 	bl	8008540 <heap_mark>
    if(container->channels[i].in_use){
      // first check if channel is in use
      // and then mark all live dirty flags
      // in the sendq and then in the recvq

      for(int j = 0; j < container->channels[i].sendq.size; j++){
 80087ac:	f8d6 3104 	ldr.w	r3, [r6, #260]	; 0x104
 80087b0:	f108 0801 	add.w	r8, r8, #1
 80087b4:	4543      	cmp	r3, r8
 80087b6:	f107 0714 	add.w	r7, r7, #20
 80087ba:	dcee      	bgt.n	800879a <heap_mark_phase.lto_priv.61+0x3a>
	// could the message potentially be a heap structure ?
	//heap_mark(  &container->heap
        //            , container->channels[i].sendq.data[j].message);
      }

      for(int j = 0; j < container->channels[i].recvq.size; j++){
 80087bc:	f8d6 3118 	ldr.w	r3, [r6, #280]	; 0x118
 80087c0:	2b00      	cmp	r3, #0
 80087c2:	dd12      	ble.n	80087ea <heap_mark_phase.lto_priv.61+0x8a>
 80087c4:	2700      	movs	r7, #0
 80087c6:	46b8      	mov	r8, r7
	heap_mark(  &container->heap
 80087c8:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 80087cc:	443b      	add	r3, r7
 80087ce:	3304      	adds	r3, #4
 80087d0:	e893 0006 	ldmia.w	r3, {r1, r2}
 80087d4:	4620      	mov	r0, r4
 80087d6:	f7ff feb3 	bl	8008540 <heap_mark>
	// could the message potentially be a heap structure ?
	//heap_mark(  &container->heap
        //            , container->channels[i].sendq.data[j].message);
      }

      for(int j = 0; j < container->channels[i].recvq.size; j++){
 80087da:	f8d6 3118 	ldr.w	r3, [r6, #280]	; 0x118
 80087de:	f108 0801 	add.w	r8, r8, #1
 80087e2:	4543      	cmp	r3, r8
 80087e4:	f107 070c 	add.w	r7, r7, #12
 80087e8:	dcee      	bgt.n	80087c8 <heap_mark_phase.lto_priv.61+0x68>
 80087ea:	362c      	adds	r6, #44	; 0x2c
      mark_heap_context(&container->contexts[i], &container->heap);
    }
  }

  //GC all the dirty flags associated with the channels
  for(int i = 0; i < MAX_CHANNELS; i++){
 80087ec:	42ae      	cmp	r6, r5
 80087ee:	d1cb      	bne.n	8008788 <heap_mark_phase.lto_priv.61+0x28>
		    , container->channels[i].recvq.data[j].dirty_flag_pointer);
      }
    }
  }
  DBG_GPIO_CLR(DBG1);
}
 80087f0:	b003      	add	sp, #12
 80087f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

static inline void mark_heap_context(Context_t *context, heap_t *heap){
  /* GC Roots - env register, the full stack */

  // run mark from env
  heap_mark(heap, context->env);
 80087f6:	4620      	mov	r0, r4
 80087f8:	e896 0006 	ldmia.w	r6, {r1, r2}
 80087fc:	f7ff fea0 	bl	8008540 <heap_mark>

  // run mark for each element of the stack
  for(unsigned int i = 0; i < context->stack.size; i++){
 8008800:	69b3      	ldr	r3, [r6, #24]
 8008802:	2b00      	cmp	r3, #0
 8008804:	d0b9      	beq.n	800877a <heap_mark_phase.lto_priv.61+0x1a>
 8008806:	2500      	movs	r5, #0
 8008808:	466f      	mov	r7, sp
    cam_value_t cv =
      get_cam_val(context->stack.data[i], context->stack.flags[i]);
 800880a:	6932      	ldr	r2, [r6, #16]
 800880c:	68f3      	ldr	r3, [r6, #12]
 800880e:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
/*   return val_s; */
/* } */

cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
 8008812:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
 8008816:	f8ad 3000 	strh.w	r3, [sp]
 800881a:	9201      	str	r2, [sp, #4]
    heap_mark(heap, cv);
 800881c:	e897 0006 	ldmia.w	r7, {r1, r2}
 8008820:	4620      	mov	r0, r4
 8008822:	f7ff fe8d 	bl	8008540 <heap_mark>

  // run mark from env
  heap_mark(heap, context->env);

  // run mark for each element of the stack
  for(unsigned int i = 0; i < context->stack.size; i++){
 8008826:	69b3      	ldr	r3, [r6, #24]
 8008828:	3501      	adds	r5, #1
 800882a:	429d      	cmp	r5, r3
 800882c:	d3ed      	bcc.n	800880a <heap_mark_phase.lto_priv.61+0xaa>
 800882e:	e7a4      	b.n	800877a <heap_mark_phase.lto_priv.61+0x1a>

08008830 <stack_pop>:
/*   s->data[s->sp] = ptr; */
/*   s->flags[s->sp++] = VALUE_PTR_BIT; */
/*   return 1; */
/* } */
int stack_pop(cam_stack_t *s, cam_register_t *r) {
  if (s->sp == 0){
 8008830:	6883      	ldr	r3, [r0, #8]
 8008832:	b173      	cbz	r3, 8008852 <stack_pop+0x22>
    DEBUG_PRINT(("Stack Underflow!!\n"));
    return 0;
  }

  s->sp--;
  r->value = s->data[s->sp];
 8008834:	6842      	ldr	r2, [r0, #4]

/*   s->data[s->sp] = ptr; */
/*   s->flags[s->sp++] = VALUE_PTR_BIT; */
/*   return 1; */
/* } */
int stack_pop(cam_stack_t *s, cam_register_t *r) {
 8008836:	b410      	push	{r4}
  if (s->sp == 0){
    DEBUG_PRINT(("Stack Underflow!!\n"));
    return 0;
  }

  s->sp--;
 8008838:	3b01      	subs	r3, #1
  r->value = s->data[s->sp];
  r->flags = s->flags[s->sp];
 800883a:	6804      	ldr	r4, [r0, #0]
  if (s->sp == 0){
    DEBUG_PRINT(("Stack Underflow!!\n"));
    return 0;
  }

  s->sp--;
 800883c:	6083      	str	r3, [r0, #8]
  r->value = s->data[s->sp];
 800883e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  r->flags = s->flags[s->sp];
 8008842:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
 8008846:	800b      	strh	r3, [r1, #0]
  return 1;
 8008848:	2001      	movs	r0, #1
    DEBUG_PRINT(("Stack Underflow!!\n"));
    return 0;
  }

  s->sp--;
  r->value = s->data[s->sp];
 800884a:	604a      	str	r2, [r1, #4]
  r->flags = s->flags[s->sp];
  return 1;
}
 800884c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008850:	4770      	bx	lr
/*   return 1; */
/* } */
int stack_pop(cam_stack_t *s, cam_register_t *r) {
  if (s->sp == 0){
    DEBUG_PRINT(("Stack Underflow!!\n"));
    return 0;
 8008852:	4618      	mov	r0, r3
 8008854:	4770      	bx	lr
 8008856:	bf00      	nop
	...

08008860 <stack_push>:
  s->size = num_elt;

  return 1;
}

int stack_push(cam_stack_t *s, cam_value_t cvalue) {
 8008860:	b430      	push	{r4, r5}
 8008862:	b082      	sub	sp, #8
 8008864:	ab02      	add	r3, sp, #8
 8008866:	e903 0006 	stmdb	r3, {r1, r2}
  if (s->sp == s->size) {
 800886a:	6883      	ldr	r3, [r0, #8]
 800886c:	68c2      	ldr	r2, [r0, #12]
 800886e:	4293      	cmp	r3, r2
 8008870:	d00e      	beq.n	8008890 <stack_push+0x30>
    /* DEBUG_PRINT(("Stack Pointer %u \n Stack size %u\n Elements : %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", s->sp, s->size, s->data[failedsp], s->data[failedsp-1], s->data[failedsp-2], s->data[failedsp-3], s->data[failedsp-4], s->data[failedsp-5], s->data[failedsp-6], s->data[failedsp-7], s->data[failedsp-8], s->data[failedsp-9])); */

    return 0;
  }
  s->data[s->sp] = cvalue.value;
  s->flags[s->sp++] = cvalue.flags;
 8008872:	e890 0014 	ldmia.w	r0, {r2, r4}
    /* unsigned int failedsp = s->sp; */
    /* DEBUG_PRINT(("Stack Pointer %u \n Stack size %u\n Elements : %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", s->sp, s->size, s->data[failedsp], s->data[failedsp-1], s->data[failedsp-2], s->data[failedsp-3], s->data[failedsp-4], s->data[failedsp-5], s->data[failedsp-6], s->data[failedsp-7], s->data[failedsp-8], s->data[failedsp-9])); */

    return 0;
  }
  s->data[s->sp] = cvalue.value;
 8008876:	9d01      	ldr	r5, [sp, #4]
 8008878:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
  s->flags[s->sp++] = cvalue.flags;
 800887c:	f8bd 1000 	ldrh.w	r1, [sp]
 8008880:	1c5c      	adds	r4, r3, #1
 8008882:	6084      	str	r4, [r0, #8]
  return 1;
 8008884:	2001      	movs	r0, #1
    /* DEBUG_PRINT(("Stack Pointer %u \n Stack size %u\n Elements : %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", s->sp, s->size, s->data[failedsp], s->data[failedsp-1], s->data[failedsp-2], s->data[failedsp-3], s->data[failedsp-4], s->data[failedsp-5], s->data[failedsp-6], s->data[failedsp-7], s->data[failedsp-8], s->data[failedsp-9])); */

    return 0;
  }
  s->data[s->sp] = cvalue.value;
  s->flags[s->sp++] = cvalue.flags;
 8008886:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
  return 1;
}
 800888a:	b002      	add	sp, #8
 800888c:	bc30      	pop	{r4, r5}
 800888e:	4770      	bx	lr

    // Stack overflow debugging toolkit; Uncomment when necessary
    /* unsigned int failedsp = s->sp; */
    /* DEBUG_PRINT(("Stack Pointer %u \n Stack size %u\n Elements : %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", s->sp, s->size, s->data[failedsp], s->data[failedsp-1], s->data[failedsp-2], s->data[failedsp-3], s->data[failedsp-4], s->data[failedsp-5], s->data[failedsp-6], s->data[failedsp-7], s->data[failedsp-8], s->data[failedsp-9])); */

    return 0;
 8008890:	2000      	movs	r0, #0
  }
  s->data[s->sp] = cvalue.value;
  s->flags[s->sp++] = cvalue.flags;
  return 1;
}
 8008892:	b002      	add	sp, #8
 8008894:	bc30      	pop	{r4, r5}
 8008896:	4770      	bx	lr
	...

080088a0 <setAlarm.lto_priv.101>:

  return 1;
}


static int setAlarm(Time alarmTime){
 80088a0:	b508      	push	{r3, lr}
  return alarm.alarm_time;
}

bool sys_is_alarm_set(void){
  
  return alarm.active;
 80088a2:	4b09      	ldr	r3, [pc, #36]	; (80088c8 <setAlarm.lto_priv.101+0x28>)
  // if alarm is not set, set it directly
  // else check if the set wakeuptime is more than
  // the requested alarm time only then set alarm

  bool b = true;
  if(!sys_is_alarm_set()){
 80088a4:	781a      	ldrb	r2, [r3, #0]
 80088a6:	b13a      	cbz	r2, 80088b8 <setAlarm.lto_priv.101+0x18>
    b = sys_time_set_wake_up(alarmTime);
  } else {
    Time wakeupTimeSet = sys_get_wake_up_time();
    if(alarmTime < wakeupTimeSet) {
 80088a8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80088ac:	4299      	cmp	r1, r3
 80088ae:	bf08      	it	eq
 80088b0:	4290      	cmpeq	r0, r2
 80088b2:	d301      	bcc.n	80088b8 <setAlarm.lto_priv.101+0x18>
    // something seriously wrong
    DEBUG_PRINT(("Setting wakeup time has failed \n"));
    return -1;
  }

  return 1;
 80088b4:	2001      	movs	r0, #1

}
 80088b6:	bd08      	pop	{r3, pc}
  // else check if the set wakeuptime is more than
  // the requested alarm time only then set alarm

  bool b = true;
  if(!sys_is_alarm_set()){
    b = sys_time_set_wake_up(alarmTime);
 80088b8:	f7fd fd02 	bl	80062c0 <sys_time_set_wake_up>
    // something seriously wrong
    DEBUG_PRINT(("Setting wakeup time has failed \n"));
    return -1;
  }

  return 1;
 80088bc:	2800      	cmp	r0, #0
 80088be:	bf0c      	ite	eq
 80088c0:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
 80088c4:	2001      	movne	r0, #1
 80088c6:	bd08      	pop	{r3, pc}
 80088c8:	2000a300 	.word	0x2000a300
 80088cc:	00000000 	.word	0x00000000

080088d0 <dispatch>:
  }
  DEBUG_PRINT(("Cannot spawn more threads \n"));
  return -1;
}

int dispatch(vmc_t *container){
 80088d0:	b510      	push	{r4, lr}
 80088d2:	4604      	mov	r4, r0
 80088d4:	b086      	sub	sp, #24
  pq_data_t thread_info;
  int de_q_status = pq_extractMin(&container->rdyQ, &thread_info);
 80088d6:	f500 5091 	add.w	r0, r0, #4640	; 0x1220
 80088da:	4669      	mov	r1, sp
 80088dc:	3004      	adds	r0, #4
 80088de:	f7fd fc2f 	bl	8006140 <pq_extractMin>
  if (de_q_status == -1){
 80088e2:	1c43      	adds	r3, r0, #1
    DEBUG_PRINT(("Ready Queue is empty\n"));
    container->current_running_context_id = UUID_NONE;
    return -1;
  }
  DEBUG_PRINT(("Switching to thread : %u\n", thread_info.context_id));
  container->current_running_context_id = thread_info.context_id;
 80088e4:	bf17      	itett	ne
 80088e6:	f89d 3000 	ldrbne.w	r3, [sp]
    // where processes are blocked and sleeping, waiting
    // for interrupts to arrive. Setting the
    // current_running_context_id = UUID_NONE is an indicator
    // to zephyr to now wait for interrupts;
    DEBUG_PRINT(("Ready Queue is empty\n"));
    container->current_running_context_id = UUID_NONE;
 80088ea:	f884 002c 	strbeq.w	r0, [r4, #44]	; 0x2c
    return -1;
  }
  DEBUG_PRINT(("Switching to thread : %u\n", thread_info.context_id));
  container->current_running_context_id = thread_info.context_id;
  return 1;
 80088ee:	2001      	movne	r0, #1
    DEBUG_PRINT(("Ready Queue is empty\n"));
    container->current_running_context_id = UUID_NONE;
    return -1;
  }
  DEBUG_PRINT(("Switching to thread : %u\n", thread_info.context_id));
  container->current_running_context_id = thread_info.context_id;
 80088f0:	f884 302c 	strbne.w	r3, [r4, #44]	; 0x2c
  return 1;
}
 80088f4:	b006      	add	sp, #24
 80088f6:	bd10      	pop	{r4, pc}
	...

08008900 <spawn>:
  }
  DEBUG_PRINT(("All channels in current container in use \n"));
  return -1;
}

int spawn(vmc_t *container, uint16_t label){
 8008900:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008902:	f100 03ef 	add.w	r3, r0, #239	; 0xef
 8008906:	b08d      	sub	sp, #52	; 0x34
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
 8008908:	2400      	movs	r4, #0
    if(container->context_used[i] == false){
 800890a:	f813 5f01 	ldrb.w	r5, [r3, #1]!
 800890e:	b135      	cbz	r5, 800891e <spawn+0x1e>
  DEBUG_PRINT(("All channels in current container in use \n"));
  return -1;
}

int spawn(vmc_t *container, uint16_t label){
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
 8008910:	3401      	adds	r4, #1
 8008912:	2c04      	cmp	r4, #4
 8008914:	d1f9      	bne.n	800890a <spawn+0xa>
      // so that the parent context can continue running
      return 1;
    }
  }
  DEBUG_PRINT(("Cannot spawn more threads \n"));
  return -1;
 8008916:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 800891a:	b00d      	add	sp, #52	; 0x34
 800891c:	bdf0      	pop	{r4, r5, r6, r7, pc}
}

int spawn(vmc_t *container, uint16_t label){
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    if(container->context_used[i] == false){
      container->contexts[i].pc = (UINT)label;
 800891e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8008922:	0112      	lsls	r2, r2, #4
 8008924:	1883      	adds	r3, r0, r2
      container->contexts[i].env =
        container->contexts[container->current_running_context_id].env; //copying the environment

      /*** Push label graveyard address on the stack ****/
      INT jump_address = container->code_size - 1;
 8008926:	6a86      	ldr	r6, [r0, #40]	; 0x28
}

int spawn(vmc_t *container, uint16_t label){
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    if(container->context_used[i] == false){
      container->contexts[i].pc = (UINT)label;
 8008928:	6399      	str	r1, [r3, #56]	; 0x38
      container->contexts[i].env =
        container->contexts[container->current_running_context_id].env; //copying the environment
 800892a:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c

      /*** Push label graveyard address on the stack ****/
      INT jump_address = container->code_size - 1;
      cam_value_t j_add = { .value = (UINT)jump_address };
 800892e:	9504      	str	r5, [sp, #16]

int spawn(vmc_t *container, uint16_t label){
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    if(container->context_used[i] == false){
      container->contexts[i].pc = (UINT)label;
      container->contexts[i].env =
 8008930:	3301      	adds	r3, #1
 8008932:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008936:	eb00 1303 	add.w	r3, r0, r3, lsl #4
 800893a:	4607      	mov	r7, r0
 800893c:	e893 0003 	ldmia.w	r3, {r0, r1}
 8008940:	1c63      	adds	r3, r4, #1
        container->contexts[container->current_running_context_id].env; //copying the environment

      /*** Push label graveyard address on the stack ****/
      INT jump_address = container->code_size - 1;
 8008942:	3e01      	subs	r6, #1

int spawn(vmc_t *container, uint16_t label){
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    if(container->context_used[i] == false){
      container->contexts[i].pc = (UINT)label;
      container->contexts[i].env =
 8008944:	eb03 0343 	add.w	r3, r3, r3, lsl #1
        container->contexts[container->current_running_context_id].env; //copying the environment

      /*** Push label graveyard address on the stack ****/
      INT jump_address = container->code_size - 1;
      cam_value_t j_add = { .value = (UINT)jump_address };
      int q = stack_push(&container->contexts[i].stack, j_add);
 8008948:	443a      	add	r2, r7
      container->contexts[i].env =
        container->contexts[container->current_running_context_id].env; //copying the environment

      /*** Push label graveyard address on the stack ****/
      INT jump_address = container->code_size - 1;
      cam_value_t j_add = { .value = (UINT)jump_address };
 800894a:	9605      	str	r6, [sp, #20]

int spawn(vmc_t *container, uint16_t label){
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    if(container->context_used[i] == false){
      container->contexts[i].pc = (UINT)label;
      container->contexts[i].env =
 800894c:	eb07 1303 	add.w	r3, r7, r3, lsl #4
        container->contexts[container->current_running_context_id].env; //copying the environment

      /*** Push label graveyard address on the stack ****/
      INT jump_address = container->code_size - 1;
      cam_value_t j_add = { .value = (UINT)jump_address };
      int q = stack_push(&container->contexts[i].stack, j_add);
 8008950:	ae04      	add	r6, sp, #16

int spawn(vmc_t *container, uint16_t label){
  for(int i = 0; i < VMC_MAX_CONTEXTS; i++){
    if(container->context_used[i] == false){
      container->contexts[i].pc = (UINT)label;
      container->contexts[i].env =
 8008952:	e883 0003 	stmia.w	r3, {r0, r1}
        container->contexts[container->current_running_context_id].env; //copying the environment

      /*** Push label graveyard address on the stack ****/
      INT jump_address = container->code_size - 1;
      cam_value_t j_add = { .value = (UINT)jump_address };
      int q = stack_push(&container->contexts[i].stack, j_add);
 8008956:	f102 003c 	add.w	r0, r2, #60	; 0x3c
 800895a:	e896 0006 	ldmia.w	r6, {r1, r2}
 800895e:	f7ff ff7f 	bl	8008860 <stack_push>
      if(q == 0){
 8008962:	2800      	cmp	r0, #0
 8008964:	d0d7      	beq.n	8008916 <spawn+0x16>
      }
      /**************************************************/

      container->context_used[i] = true;

      pq_data_t elem = {   .context_id = i
 8008966:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800896a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800896e:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8008972:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
                         , .baseline = TIME_MAX
                         , .deadline = TIME_MAX };
      int j = pq_insert(&container->rdyQ, elem);
 8008976:	ab0c      	add	r3, sp, #48	; 0x30
 8008978:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 800897c:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
        DEBUG_PRINT(("Stack push has failed"));
        return -1;
      }
      /**************************************************/

      container->context_used[i] = true;
 8008980:	eb07 0e04 	add.w	lr, r7, r4

      pq_data_t elem = {   .context_id = i
 8008984:	f88d 4018 	strb.w	r4, [sp, #24]
                         , .baseline = TIME_MAX
                         , .deadline = TIME_MAX };
      int j = pq_insert(&container->rdyQ, elem);
 8008988:	ab06      	add	r3, sp, #24
        DEBUG_PRINT(("Stack push has failed"));
        return -1;
      }
      /**************************************************/

      container->context_used[i] = true;
 800898a:	2601      	movs	r6, #1

      pq_data_t elem = {   .context_id = i
                         , .baseline = TIME_MAX
                         , .deadline = TIME_MAX };
      int j = pq_insert(&container->rdyQ, elem);
 800898c:	f507 5091 	add.w	r0, r7, #4640	; 0x1220
 8008990:	cb0c      	ldmia	r3, {r2, r3}
        DEBUG_PRINT(("Stack push has failed"));
        return -1;
      }
      /**************************************************/

      container->context_used[i] = true;
 8008992:	f88e 60f0 	strb.w	r6, [lr, #240]	; 0xf0

      pq_data_t elem = {   .context_id = i
                         , .baseline = TIME_MAX
                         , .deadline = TIME_MAX };
      int j = pq_insert(&container->rdyQ, elem);
 8008996:	3004      	adds	r0, #4
 8008998:	f7ff fe6a 	bl	8008670 <pq_insert>
      if(j == -1){
 800899c:	3001      	adds	r0, #1
 800899e:	d0ba      	beq.n	8008916 <spawn+0x16>
        return -1;
      }

      // Place the context-id(or process-id) on the environment register
      cam_value_t process_id = { .value = (UINT)i, .flags = 0 };
      container->contexts[container->current_running_context_id].env = process_id;
 80089a0:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 80089a4:	4433      	add	r3, r6
 80089a6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80089aa:	011b      	lsls	r3, r3, #4
 80089ac:	18fa      	adds	r2, r7, r3
 80089ae:	52fd      	strh	r5, [r7, r3]

      // eval_RTS_spawn should now simply do *pc_idx+=2
      // so that the parent context can continue running
      return 1;
 80089b0:	4630      	mov	r0, r6
        return -1;
      }

      // Place the context-id(or process-id) on the environment register
      cam_value_t process_id = { .value = (UINT)i, .flags = 0 };
      container->contexts[container->current_running_context_id].env = process_id;
 80089b2:	6054      	str	r4, [r2, #4]
 80089b4:	e7b1      	b.n	800891a <spawn+0x1a>
 80089b6:	bf00      	nop
	...

080089c0 <heap_allocate>:
}
/*******************/
/* Heap Allocation */
/*******************/

heap_index heap_allocate(heap_t *heap) {
 80089c0:	b4f0      	push	{r4, r5, r6, r7}
  /* wait for the allocation call to happen and lazily sweep  */
  /* then and instead of returning to the free list return    */
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {
 80089c2:	68c3      	ldr	r3, [r0, #12]
 80089c4:	6904      	ldr	r4, [r0, #16]
 80089c6:	42a3      	cmp	r3, r4
}
/*******************/
/* Heap Allocation */
/*******************/

heap_index heap_allocate(heap_t *heap) {
 80089c8:	4601      	mov	r1, r0
  /* wait for the allocation call to happen and lazily sweep  */
  /* then and instead of returning to the free list return    */
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {
 80089ca:	dd14      	ble.n	80089f6 <heap_allocate+0x36>
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 80089cc:	6982      	ldr	r2, [r0, #24]
 80089ce:	5d13      	ldrb	r3, [r2, r4]
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {

    if (get_gc_mark(heap, heap->sweep_pos)) {
 80089d0:	0618      	lsls	r0, r3, #24
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 80089d2:	4422      	add	r2, r4
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {

    if (get_gc_mark(heap, heap->sweep_pos)) {
 80089d4:	d405      	bmi.n	80089e2 <heap_allocate+0x22>
 80089d6:	e014      	b.n	8008a02 <heap_allocate+0x42>
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 80089d8:	698a      	ldr	r2, [r1, #24]
 80089da:	5cd3      	ldrb	r3, [r2, r3]
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {

    if (get_gc_mark(heap, heap->sweep_pos)) {
 80089dc:	061d      	lsls	r5, r3, #24
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 80089de:	4422      	add	r2, r4
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {

    if (get_gc_mark(heap, heap->sweep_pos)) {
 80089e0:	d50f      	bpl.n	8008a02 <heap_allocate+0x42>
static inline void set_gc_flag(heap_t *heap, heap_index i) {
  heap->flags[i] |= HEAP_GC_FLAG_BIT;
}

static inline void clr_gc_mark(heap_t *heap, heap_index i) {
  heap->flags[i] &= ~HEAP_GC_MARK_BIT;
 80089e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80089e6:	7013      	strb	r3, [r2, #0]
  
  while (heap->sweep_pos < heap->size_cells) {

    if (get_gc_mark(heap, heap->sweep_pos)) {
      clr_gc_mark(heap, heap->sweep_pos);
      heap->sweep_pos++;
 80089e8:	690b      	ldr	r3, [r1, #16]
  /* wait for the allocation call to happen and lazily sweep  */
  /* then and instead of returning to the free list return    */
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {
 80089ea:	68ca      	ldr	r2, [r1, #12]

    if (get_gc_mark(heap, heap->sweep_pos)) {
      clr_gc_mark(heap, heap->sweep_pos);
      heap->sweep_pos++;
 80089ec:	3301      	adds	r3, #1
  /* wait for the allocation call to happen and lazily sweep  */
  /* then and instead of returning to the free list return    */
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {
 80089ee:	429a      	cmp	r2, r3
static inline int is_pointer(cam_value_t v) {
  return (v.flags & VALUE_PTR_BIT);
}

static inline int get_gc_mark(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_MARK_BIT;
 80089f0:	461c      	mov	r4, r3
  
  while (heap->sweep_pos < heap->size_cells) {

    if (get_gc_mark(heap, heap->sweep_pos)) {
      clr_gc_mark(heap, heap->sweep_pos);
      heap->sweep_pos++;
 80089f2:	610b      	str	r3, [r1, #16]
  /* wait for the allocation call to happen and lazily sweep  */
  /* then and instead of returning to the free list return    */
  /* the current index as the place for allocation. Further   */
  /* allocations will keep clearing cells, unmarking them etc */
  
  while (heap->sweep_pos < heap->size_cells) {
 80089f4:	dcf0      	bgt.n	80089d8 <heap_allocate+0x18>
      DBG_GPIO_CLR(DBG0);
      return heap->sweep_pos++;
    }
  }

  heap->sweep_pos = 0;
 80089f6:	2300      	movs	r3, #0

  DBG_GPIO_CLR(DBG0);
  return HEAP_NULL;
 80089f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      DBG_GPIO_CLR(DBG0);
      return heap->sweep_pos++;
    }
  }

  heap->sweep_pos = 0;
 80089fc:	610b      	str	r3, [r1, #16]

  DBG_GPIO_CLR(DBG0);
  return HEAP_NULL;
}
 80089fe:	bcf0      	pop	{r4, r5, r6, r7}
 8008a00:	4770      	bx	lr
static inline int get_gc_flag(heap_t *heap, heap_index i) {
  return heap->flags[i] & HEAP_GC_FLAG_BIT;
}

static inline void clr_cell(heap_t *heap, heap_index i) {
  heap->flags[i] = 0;
 8008a02:	2300      	movs	r3, #0
 8008a04:	7013      	strb	r3, [r2, #0]
  heap->cells[i].fst = 0;
  heap->cells[i].snd = 0;
  heap->value_flags[i].fst = 0;
 8008a06:	694d      	ldr	r5, [r1, #20]
  return heap->flags[i] & HEAP_GC_FLAG_BIT;
}

static inline void clr_cell(heap_t *heap, heap_index i) {
  heap->flags[i] = 0;
  heap->cells[i].fst = 0;
 8008a08:	680a      	ldr	r2, [r1, #0]
      clr_cell(heap, heap->sweep_pos);
#ifdef HEAP_COLLECT_STATS
      gc_stats.num_allocated ++;
#endif
      DBG_GPIO_CLR(DBG0);
      return heap->sweep_pos++;
 8008a0a:	6908      	ldr	r0, [r1, #16]
  return heap->flags[i] & HEAP_GC_FLAG_BIT;
}

static inline void clr_cell(heap_t *heap, heap_index i) {
  heap->flags[i] = 0;
  heap->cells[i].fst = 0;
 8008a0c:	f842 3034 	str.w	r3, [r2, r4, lsl #3]
 8008a10:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
  heap->cells[i].snd = 0;
  heap->value_flags[i].fst = 0;
 8008a14:	eb05 0784 	add.w	r7, r5, r4, lsl #2
      clr_cell(heap, heap->sweep_pos);
#ifdef HEAP_COLLECT_STATS
      gc_stats.num_allocated ++;
#endif
      DBG_GPIO_CLR(DBG0);
      return heap->sweep_pos++;
 8008a18:	1c46      	adds	r6, r0, #1
}

static inline void clr_cell(heap_t *heap, heap_index i) {
  heap->flags[i] = 0;
  heap->cells[i].fst = 0;
  heap->cells[i].snd = 0;
 8008a1a:	6053      	str	r3, [r2, #4]
  heap->value_flags[i].fst = 0;
 8008a1c:	f825 3024 	strh.w	r3, [r5, r4, lsl #2]
  heap->value_flags[i].snd = 0;
 8008a20:	807b      	strh	r3, [r7, #2]
      clr_cell(heap, heap->sweep_pos);
#ifdef HEAP_COLLECT_STATS
      gc_stats.num_allocated ++;
#endif
      DBG_GPIO_CLR(DBG0);
      return heap->sweep_pos++;
 8008a22:	610e      	str	r6, [r1, #16]

  heap->sweep_pos = 0;

  DBG_GPIO_CLR(DBG0);
  return HEAP_NULL;
}
 8008a24:	bcf0      	pop	{r4, r5, r6, r7}
 8008a26:	4770      	bx	lr
	...

08008a30 <vmc_heap_alloc_withGC>:

  /* head should be HEAP_NULL or a list of cells */
  return head;
}

heap_index vmc_heap_alloc_withGC(vmc_t *container) {
 8008a30:	b510      	push	{r4, lr}
 8008a32:	4604      	mov	r4, r0

  heap_index hi = heap_allocate(&container->heap);
 8008a34:	f7ff ffc4 	bl	80089c0 <heap_allocate>
  if(hi == HEAP_NULL){
 8008a38:	1c43      	adds	r3, r0, #1
 8008a3a:	d000      	beq.n	8008a3e <vmc_heap_alloc_withGC+0xe>
    // if heap_allocate_helper returns HEAP_NULL again need to resize heap
    return heap_allocate(&container->heap);
  }

  return hi;
}
 8008a3c:	bd10      	pop	{r4, pc}
  heap_index hi = heap_allocate(&container->heap);
  if(hi == HEAP_NULL){
    // heap full; time to do a GC

    /* GC parent context */
    heap_mark_phase(container);
 8008a3e:	4620      	mov	r0, r4
 8008a40:	f7ff fe8e 	bl	8008760 <heap_mark_phase.lto_priv.61>
    // First phase mark complete; try allocating again
    // Sweeping is lazy and integrated into the allocator


    // if heap_allocate_helper returns HEAP_NULL again need to resize heap
    return heap_allocate(&container->heap);
 8008a44:	4620      	mov	r0, r4
  }

  return hi;
}
 8008a46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // First phase mark complete; try allocating again
    // Sweeping is lazy and integrated into the allocator


    // if heap_allocate_helper returns HEAP_NULL again need to resize heap
    return heap_allocate(&container->heap);
 8008a4a:	f7ff bfb9 	b.w	80089c0 <heap_allocate>
 8008a4e:	bf00      	nop

08008a50 <heap_set>:

cam_value_t heap_snd(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
}

void heap_set(heap_t *heap, heap_index i, cam_value_t f, cam_value_t s) {
 8008a50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008a52:	b083      	sub	sp, #12
 8008a54:	ac02      	add	r4, sp, #8
 8008a56:	e904 000c 	stmdb	r4, {r2, r3}
  heap->cells[i].fst = f.value;
 8008a5a:	6802      	ldr	r2, [r0, #0]
  heap->cells[i].snd = s.value;
  heap->value_flags[i].fst = f.flags;
 8008a5c:	6943      	ldr	r3, [r0, #20]
cam_value_t heap_snd(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
}

void heap_set(heap_t *heap, heap_index i, cam_value_t f, cam_value_t s) {
  heap->cells[i].fst = f.value;
 8008a5e:	9e01      	ldr	r6, [sp, #4]
  heap->cells[i].snd = s.value;
 8008a60:	9d09      	ldr	r5, [sp, #36]	; 0x24
  heap->value_flags[i].fst = f.flags;
 8008a62:	f8bd 7000 	ldrh.w	r7, [sp]
  heap->value_flags[i].snd = s.flags;
 8008a66:	f8bd 4020 	ldrh.w	r4, [sp, #32]
cam_value_t heap_snd(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
}

void heap_set(heap_t *heap, heap_index i, cam_value_t f, cam_value_t s) {
  heap->cells[i].fst = f.value;
 8008a6a:	f842 6031 	str.w	r6, [r2, r1, lsl #3]
 8008a6e:	eb02 0ec1 	add.w	lr, r2, r1, lsl #3
  heap->cells[i].snd = s.value;
  heap->value_flags[i].fst = f.flags;
 8008a72:	eb03 0081 	add.w	r0, r3, r1, lsl #2
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
}

void heap_set(heap_t *heap, heap_index i, cam_value_t f, cam_value_t s) {
  heap->cells[i].fst = f.value;
  heap->cells[i].snd = s.value;
 8008a76:	f8ce 5004 	str.w	r5, [lr, #4]
  heap->value_flags[i].fst = f.flags;
 8008a7a:	f823 7021 	strh.w	r7, [r3, r1, lsl #2]
  heap->value_flags[i].snd = s.flags;
 8008a7e:	8044      	strh	r4, [r0, #2]
}
 8008a80:	b003      	add	sp, #12
 8008a82:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08008a90 <heap_snd>:
}
cam_value_t heap_fst(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
}

cam_value_t heap_snd(heap_t *heap, heap_index i) {
 8008a90:	b410      	push	{r4}
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
 8008a92:	680c      	ldr	r4, [r1, #0]
 8008a94:	694b      	ldr	r3, [r1, #20]
 8008a96:	eb04 01c2 	add.w	r1, r4, r2, lsl #3
 8008a9a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8008a9e:	6849      	ldr	r1, [r1, #4]
/*   return val_s; */
/* } */

cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
 8008aa0:	8852      	ldrh	r2, [r2, #2]
 8008aa2:	8002      	strh	r2, [r0, #0]
 8008aa4:	6041      	str	r1, [r0, #4]
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
}

cam_value_t heap_snd(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].snd, heap->value_flags[i].snd);
}
 8008aa6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008aaa:	4770      	bx	lr
 8008aac:	0000      	movs	r0, r0
	...

08008ab0 <heap_fst>:

cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
}
cam_value_t heap_fst(heap_t *heap, heap_index i) {
 8008ab0:	b410      	push	{r4}
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
 8008ab2:	680c      	ldr	r4, [r1, #0]
 8008ab4:	694b      	ldr	r3, [r1, #20]
 8008ab6:	f854 1032 	ldr.w	r1, [r4, r2, lsl #3]
/*   return val_s; */
/* } */

cam_value_t get_cam_val(UINT ui, value_flags_t f){
  cam_value_t cvt = { .value = ui, .flags = f };
  return cvt;
 8008aba:	f833 2022 	ldrh.w	r2, [r3, r2, lsl #2]
 8008abe:	8002      	strh	r2, [r0, #0]
 8008ac0:	6041      	str	r1, [r0, #4]
}
cam_value_t heap_fst(heap_t *heap, heap_index i) {
  return get_cam_val(heap->cells[i].fst, heap->value_flags[i].fst);
}
 8008ac2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008ac6:	4770      	bx	lr
	...

08008ad0 <postSync.isra.2.lto_priv.62>:
  DEBUG_PRINT(("Switching to thread : %u\n", thread_info.context_id));
  container->current_running_context_id = thread_info.context_id;
  return 1;
}

static int postSync( vmc_t *container
 8008ad0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008ad4:	b08a      	sub	sp, #40	; 0x28
 8008ad6:	460f      	mov	r7, r1
 8008ad8:	ac02      	add	r4, sp, #8
                   , sched_order_t sched_order){


  heap_index closure_address = wrap_fptr.value;

  cam_value_t heap_f = heap_fst(&container->heap, closure_address);
 8008ada:	f10d 0a10 	add.w	sl, sp, #16
  DEBUG_PRINT(("Switching to thread : %u\n", thread_info.context_id));
  container->current_running_context_id = thread_info.context_id;
  return 1;
}

static int postSync( vmc_t *container
 8008ade:	e884 000c 	stmia.w	r4, {r2, r3}
                   , sched_order_t sched_order){


  heap_index closure_address = wrap_fptr.value;

  cam_value_t heap_f = heap_fst(&container->heap, closure_address);
 8008ae2:	4601      	mov	r1, r0
 8008ae4:	463a      	mov	r2, r7
  DEBUG_PRINT(("Switching to thread : %u\n", thread_info.context_id));
  container->current_running_context_id = thread_info.context_id;
  return 1;
}

static int postSync( vmc_t *container
 8008ae6:	4605      	mov	r5, r0
                   , sched_order_t sched_order){


  heap_index closure_address = wrap_fptr.value;

  cam_value_t heap_f = heap_fst(&container->heap, closure_address);
 8008ae8:	4650      	mov	r0, sl
  DEBUG_PRINT(("Switching to thread : %u\n", thread_info.context_id));
  container->current_running_context_id = thread_info.context_id;
  return 1;
}

static int postSync( vmc_t *container
 8008aea:	f89d 6048 	ldrb.w	r6, [sp, #72]	; 0x48
 8008aee:	f89d 904c 	ldrb.w	r9, [sp, #76]	; 0x4c
                   , sched_order_t sched_order){


  heap_index closure_address = wrap_fptr.value;

  cam_value_t heap_f = heap_fst(&container->heap, closure_address);
 8008af2:	f7ff ffdd 	bl	8008ab0 <heap_fst>
  cam_value_t heap_s = heap_snd(&container->heap, closure_address);
 8008af6:	463a      	mov	r2, r7
 8008af8:	4629      	mov	r1, r5
 8008afa:	a806      	add	r0, sp, #24
                   , sched_order_t sched_order){


  heap_index closure_address = wrap_fptr.value;

  cam_value_t heap_f = heap_fst(&container->heap, closure_address);
 8008afc:	f8dd 8014 	ldr.w	r8, [sp, #20]
  cam_value_t heap_s = heap_snd(&container->heap, closure_address);
 8008b00:	f7ff ffc6 	bl	8008a90 <heap_snd>
 8008b04:	9f07      	ldr	r7, [sp, #28]

  cam_value_t label;


  //update the env
  if(heap_s.value == COMB){ // if combinator
 8008b06:	1c7b      	adds	r3, r7, #1
 8008b08:	d046      	beq.n	8008b98 <postSync.isra.2.lto_priv.62+0xc8>

    container->contexts[ctx_id].env = msg_content;

  } else { // not a combinator but a closure

    cam_value_t val = heap_f;
 8008b0a:	e89a 0003 	ldmia.w	sl, {r0, r1}
 8008b0e:	f10d 0820 	add.w	r8, sp, #32
 8008b12:	e888 0003 	stmia.w	r8, {r0, r1}
    label = heap_s;

    heap_index hi = vmc_heap_alloc_withGC(container);
 8008b16:	4628      	mov	r0, r5
 8008b18:	f7ff ff8a 	bl	8008a30 <vmc_heap_alloc_withGC>
    if(hi == HEAP_NULL){
 8008b1c:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
  } else { // not a combinator but a closure

    cam_value_t val = heap_f;
    label = heap_s;

    heap_index hi = vmc_heap_alloc_withGC(container);
 8008b20:	4682      	mov	sl, r0
    if(hi == HEAP_NULL){
 8008b22:	d046      	beq.n	8008bb2 <postSync.isra.2.lto_priv.62+0xe2>
      DEBUG_PRINT(("Heap allocation failed in post-syncer"));
      return -1;
    }
    heap_set(&container->heap, hi, val, msg_content);
 8008b24:	e894 0003 	ldmia.w	r4, {r0, r1}
 8008b28:	e898 000c 	ldmia.w	r8, {r2, r3}
 8008b2c:	e88d 0003 	stmia.w	sp, {r0, r1}
 8008b30:	4651      	mov	r1, sl
 8008b32:	4628      	mov	r0, r5
 8008b34:	f7ff ff8c 	bl	8008a50 <heap_set>
    cam_value_t new_env_pointer =
      { .value = (UINT)hi, .flags = VALUE_PTR_BIT };
    container->contexts[ctx_id].env
      = new_env_pointer;
 8008b38:	1c73      	adds	r3, r6, #1
 8008b3a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008b3e:	011b      	lsls	r3, r3, #4
 8008b40:	18ea      	adds	r2, r5, r3
 8008b42:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8008b46:	52e9      	strh	r1, [r5, r3]
 8008b48:	f8c2 a004 	str.w	sl, [r2, #4]
  }


  // update the PC
  UINT current_pc =
 8008b4c:	0073      	lsls	r3, r6, #1
 8008b4e:	199a      	adds	r2, r3, r6
 8008b50:	eb05 1202 	add.w	r2, r5, r2, lsl #4
 8008b54:	6b92      	ldr	r2, [r2, #56]	; 0x38
    container->contexts[ctx_id].pc;

  cam_value_t j_add;
  if(sched_order == SCHEDULED_FIRST)
 8008b56:	f1b9 0f00 	cmp.w	r9, #0
 8008b5a:	d115      	bne.n	8008b88 <postSync.isra.2.lto_priv.62+0xb8>
    j_add = (cam_value_t){ .value = current_pc };
 8008b5c:	f8cd 9020 	str.w	r9, [sp, #32]
 8008b60:	9209      	str	r2, [sp, #36]	; 0x24
  else if (sched_order == SCHEDULED_SECOND)
    j_add = (cam_value_t){ .value = current_pc + 2};

  int q =
    stack_push(  &container->contexts[ctx_id].stack
 8008b62:	4433      	add	r3, r6
 8008b64:	011c      	lsls	r4, r3, #4
 8008b66:	1928      	adds	r0, r5, r4
  if(sched_order == SCHEDULED_FIRST)
    j_add = (cam_value_t){ .value = current_pc };
  else if (sched_order == SCHEDULED_SECOND)
    j_add = (cam_value_t){ .value = current_pc + 2};

  int q =
 8008b68:	303c      	adds	r0, #60	; 0x3c
 8008b6a:	e898 0006 	ldmia.w	r8, {r1, r2}
 8008b6e:	f7ff fe77 	bl	8008860 <stack_push>
    stack_push(  &container->contexts[ctx_id].stack
               , j_add);
  if(q == 0){
 8008b72:	b1f0      	cbz	r0, 8008bb2 <postSync.isra.2.lto_priv.62+0xe2>
  // but after the postSync action is executed, inside
  // CAM.c a "*pc_idx = (*pc_idx) + 2" increments the PC
  // futher and corrupts the PC. So we instead do the
  // following and then in CAM.C the +2 increment sets
  // the final PC at the desired label position
  if(ctx_id == container->current_running_context_id)
 8008b74:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 8008b78:	42b3      	cmp	r3, r6
    container->contexts[ctx_id].pc = label.value - 2;
 8008b7a:	442c      	add	r4, r5
  // but after the postSync action is executed, inside
  // CAM.c a "*pc_idx = (*pc_idx) + 2" increments the PC
  // futher and corrupts the PC. So we instead do the
  // following and then in CAM.C the +2 increment sets
  // the final PC at the desired label position
  if(ctx_id == container->current_running_context_id)
 8008b7c:	d01c      	beq.n	8008bb8 <postSync.isra.2.lto_priv.62+0xe8>
    container->contexts[ctx_id].pc = label.value - 2;
  else
    container->contexts[ctx_id].pc = label.value;

  return 1;
 8008b7e:	2001      	movs	r0, #1
  // following and then in CAM.C the +2 increment sets
  // the final PC at the desired label position
  if(ctx_id == container->current_running_context_id)
    container->contexts[ctx_id].pc = label.value - 2;
  else
    container->contexts[ctx_id].pc = label.value;
 8008b80:	63a7      	str	r7, [r4, #56]	; 0x38

  return 1;

}
 8008b82:	b00a      	add	sp, #40	; 0x28
 8008b84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    container->contexts[ctx_id].pc;

  cam_value_t j_add;
  if(sched_order == SCHEDULED_FIRST)
    j_add = (cam_value_t){ .value = current_pc };
  else if (sched_order == SCHEDULED_SECOND)
 8008b88:	f1b9 0f01 	cmp.w	r9, #1
 8008b8c:	d1e9      	bne.n	8008b62 <postSync.isra.2.lto_priv.62+0x92>
    j_add = (cam_value_t){ .value = current_pc + 2};
 8008b8e:	3202      	adds	r2, #2
 8008b90:	2100      	movs	r1, #0
 8008b92:	9209      	str	r2, [sp, #36]	; 0x24
 8008b94:	9108      	str	r1, [sp, #32]
 8008b96:	e7e4      	b.n	8008b62 <postSync.isra.2.lto_priv.62+0x92>
  //update the env
  if(heap_s.value == COMB){ // if combinator

    label = heap_f;

    container->contexts[ctx_id].env = msg_content;
 8008b98:	1c73      	adds	r3, r6, #1
 8008b9a:	e894 0003 	ldmia.w	r4, {r0, r1}
 8008b9e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008ba2:	eb05 1303 	add.w	r3, r5, r3, lsl #4


  //update the env
  if(heap_s.value == COMB){ // if combinator

    label = heap_f;
 8008ba6:	4647      	mov	r7, r8

    container->contexts[ctx_id].env = msg_content;
 8008ba8:	e883 0003 	stmia.w	r3, {r0, r1}
 8008bac:	f10d 0820 	add.w	r8, sp, #32
 8008bb0:	e7cc      	b.n	8008b4c <postSync.isra.2.lto_priv.62+0x7c>
  int q =
    stack_push(  &container->contexts[ctx_id].stack
               , j_add);
  if(q == 0){
    DEBUG_PRINT(("Stack push failed in post-syncer"));
    return -1;
 8008bb2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008bb6:	e7e4      	b.n	8008b82 <postSync.isra.2.lto_priv.62+0xb2>
  // CAM.c a "*pc_idx = (*pc_idx) + 2" increments the PC
  // futher and corrupts the PC. So we instead do the
  // following and then in CAM.C the +2 increment sets
  // the final PC at the desired label position
  if(ctx_id == container->current_running_context_id)
    container->contexts[ctx_id].pc = label.value - 2;
 8008bb8:	3f02      	subs	r7, #2
  else
    container->contexts[ctx_id].pc = label.value;

  return 1;
 8008bba:	2001      	movs	r0, #1
  // CAM.c a "*pc_idx = (*pc_idx) + 2" increments the PC
  // futher and corrupts the PC. So we instead do the
  // following and then in CAM.C the +2 increment sets
  // the final PC at the desired label position
  if(ctx_id == container->current_running_context_id)
    container->contexts[ctx_id].pc = label.value - 2;
 8008bbc:	63a7      	str	r7, [r4, #56]	; 0x38
  else
    container->contexts[ctx_id].pc = label.value;

  return 1;

}
 8008bbe:	b00a      	add	sp, #40	; 0x28
 8008bc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08008bd0 <chan_send_q_dequeue>:

}

int chan_send_q_dequeue(chan_send_queue_t *q, send_data_t *send_data){

  if (is_empty(q)){
 8008bd0:	6903      	ldr	r3, [r0, #16]
  q->size = q->size + 1;
  return 1;

}

int chan_send_q_dequeue(chan_send_queue_t *q, send_data_t *send_data){
 8008bd2:	b470      	push	{r4, r5, r6}
 8008bd4:	4606      	mov	r6, r0

  if (is_empty(q)){
 8008bd6:	b1c3      	cbz	r3, 8008c0a <chan_send_q_dequeue+0x3a>
    DEBUG_PRINT(("Chan send queue is empty\n"));
    return -1;
  }
  *send_data = q->data[q->front];
 8008bd8:	6885      	ldr	r5, [r0, #8]
 8008bda:	6803      	ldr	r3, [r0, #0]
 8008bdc:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 8008be0:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8008be4:	460c      	mov	r4, r1
 8008be6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8008be8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8008bea:	682b      	ldr	r3, [r5, #0]
 8008bec:	6023      	str	r3, [r4, #0]
  q->front = (q->front + 1)%q->capacity;
 8008bee:	68b3      	ldr	r3, [r6, #8]
 8008bf0:	6870      	ldr	r0, [r6, #4]
  q->size = q->size - 1;
 8008bf2:	6932      	ldr	r2, [r6, #16]
  if (is_empty(q)){
    DEBUG_PRINT(("Chan send queue is empty\n"));
    return -1;
  }
  *send_data = q->data[q->front];
  q->front = (q->front + 1)%q->capacity;
 8008bf4:	3301      	adds	r3, #1
  q->size = q->size - 1;
 8008bf6:	3a01      	subs	r2, #1
  if (is_empty(q)){
    DEBUG_PRINT(("Chan send queue is empty\n"));
    return -1;
  }
  *send_data = q->data[q->front];
  q->front = (q->front + 1)%q->capacity;
 8008bf8:	fb93 f1f0 	sdiv	r1, r3, r0
 8008bfc:	fb00 3311 	mls	r3, r0, r1, r3
 8008c00:	60b3      	str	r3, [r6, #8]
  q->size = q->size - 1;
 8008c02:	6132      	str	r2, [r6, #16]
  return 1;
 8008c04:	2001      	movs	r0, #1
}
 8008c06:	bc70      	pop	{r4, r5, r6}
 8008c08:	4770      	bx	lr

int chan_send_q_dequeue(chan_send_queue_t *q, send_data_t *send_data){

  if (is_empty(q)){
    DEBUG_PRINT(("Chan send queue is empty\n"));
    return -1;
 8008c0a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008c0e:	e7fa      	b.n	8008c06 <chan_send_q_dequeue+0x36>

08008c10 <poll_sendq>:
  return 1;
}

int chan_send_q_front  (chan_send_queue_t *q, send_data_t *send_data){

  if (is_empty(q)){
 8008c10:	690b      	ldr	r3, [r1, #16]
 8008c12:	b1f3      	cbz	r3, 8008c52 <poll_sendq+0x42>

#include <SVM_DEBUG.h>

#include <event.h>

bool poll_sendq(vmc_t *container, chan_send_queue_t *q){
 8008c14:	b530      	push	{r4, r5, lr}
 8008c16:	4605      	mov	r5, r0
 8008c18:	b089      	sub	sp, #36	; 0x24
 8008c1a:	460c      	mov	r4, r1
 8008c1c:	e003      	b.n	8008c26 <poll_sendq+0x16>
      cam_value_t dirty_flag =
        heap_fst(  &container->heap
                 , (heap_index)send_data.dirty_flag_pointer.value);
      if((dirty_flag.value & 1) == 1){ // if dirty flag is SET
        send_data_t temp;
        chan_send_q_dequeue(q, &temp); // no need to check status we know there is data
 8008c1e:	f7ff ffd7 	bl	8008bd0 <chan_send_q_dequeue>
 8008c22:	6923      	ldr	r3, [r4, #16]
 8008c24:	b193      	cbz	r3, 8008c4c <poll_sendq+0x3c>
    DEBUG_PRINT(("Chan send queue is empty\n"));
    return -1;
  }

  *send_data = q->data[q->front];
 8008c26:	68a3      	ldr	r3, [r4, #8]
 8008c28:	6822      	ldr	r2, [r4, #0]
 8008c2a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8008c2e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    send_data_t send_data;
    int op_status = chan_send_q_front(q, &send_data);
    if(op_status == -1){ //empty queue
      return false;
    } else {
      cam_value_t dirty_flag =
 8008c32:	a801      	add	r0, sp, #4
 8008c34:	691a      	ldr	r2, [r3, #16]
 8008c36:	4629      	mov	r1, r5
 8008c38:	f7ff ff3a 	bl	8008ab0 <heap_fst>
        heap_fst(  &container->heap
                 , (heap_index)send_data.dirty_flag_pointer.value);
      if((dirty_flag.value & 1) == 1){ // if dirty flag is SET
 8008c3c:	9b02      	ldr	r3, [sp, #8]
 8008c3e:	07db      	lsls	r3, r3, #31
        send_data_t temp;
        chan_send_q_dequeue(q, &temp); // no need to check status we know there is data
 8008c40:	4620      	mov	r0, r4
 8008c42:	a903      	add	r1, sp, #12
      return false;
    } else {
      cam_value_t dirty_flag =
        heap_fst(  &container->heap
                 , (heap_index)send_data.dirty_flag_pointer.value);
      if((dirty_flag.value & 1) == 1){ // if dirty flag is SET
 8008c44:	d4eb      	bmi.n	8008c1e <poll_sendq+0xe>
        send_data_t temp;
        chan_send_q_dequeue(q, &temp); // no need to check status we know there is data
      } else {
        return true; // the actual dequeing should happen inside doFn
 8008c46:	2001      	movs	r0, #1
      }
    }
  }
}
 8008c48:	b009      	add	sp, #36	; 0x24
 8008c4a:	bd30      	pop	{r4, r5, pc}
bool poll_sendq(vmc_t *container, chan_send_queue_t *q){
  while(true){
    send_data_t send_data;
    int op_status = chan_send_q_front(q, &send_data);
    if(op_status == -1){ //empty queue
      return false;
 8008c4c:	2000      	movs	r0, #0
      } else {
        return true; // the actual dequeing should happen inside doFn
      }
    }
  }
}
 8008c4e:	b009      	add	sp, #36	; 0x24
 8008c50:	bd30      	pop	{r4, r5, pc}
bool poll_sendq(vmc_t *container, chan_send_queue_t *q){
  while(true){
    send_data_t send_data;
    int op_status = chan_send_q_front(q, &send_data);
    if(op_status == -1){ //empty queue
      return false;
 8008c52:	2000      	movs	r0, #0
      } else {
        return true; // the actual dequeing should happen inside doFn
      }
    }
  }
}
 8008c54:	4770      	bx	lr
 8008c56:	bf00      	nop
	...

08008c60 <chan_recv_q_dequeue>:

}

int chan_recv_q_dequeue(chan_recv_queue_t *q, recv_data_t *chan_data){

  if (is_empty(q)){
 8008c60:	6902      	ldr	r2, [r0, #16]
  q->size = q->size + 1;
  return 1;

}

int chan_recv_q_dequeue(chan_recv_queue_t *q, recv_data_t *chan_data){
 8008c62:	4603      	mov	r3, r0

  if (is_empty(q)){
 8008c64:	b1ca      	cbz	r2, 8008c9a <chan_recv_q_dequeue+0x3a>
  q->size = q->size + 1;
  return 1;

}

int chan_recv_q_dequeue(chan_recv_queue_t *q, recv_data_t *chan_data){
 8008c66:	b410      	push	{r4}

  if (is_empty(q)){
    DEBUG_PRINT(("Chan recv queue is empty\n"));
    return -1;
  }
  *chan_data = q->data[q->front];
 8008c68:	6882      	ldr	r2, [r0, #8]
 8008c6a:	460c      	mov	r4, r1
 8008c6c:	6801      	ldr	r1, [r0, #0]
 8008c6e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8008c72:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8008c76:	ca07      	ldmia	r2, {r0, r1, r2}
 8008c78:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  q->front = (q->front + 1)%q->capacity;
 8008c7c:	689a      	ldr	r2, [r3, #8]
 8008c7e:	685c      	ldr	r4, [r3, #4]
  q->size = q->size - 1;
 8008c80:	6919      	ldr	r1, [r3, #16]
  if (is_empty(q)){
    DEBUG_PRINT(("Chan recv queue is empty\n"));
    return -1;
  }
  *chan_data = q->data[q->front];
  q->front = (q->front + 1)%q->capacity;
 8008c82:	3201      	adds	r2, #1
  q->size = q->size - 1;
 8008c84:	3901      	subs	r1, #1
  if (is_empty(q)){
    DEBUG_PRINT(("Chan recv queue is empty\n"));
    return -1;
  }
  *chan_data = q->data[q->front];
  q->front = (q->front + 1)%q->capacity;
 8008c86:	fb92 f0f4 	sdiv	r0, r2, r4
 8008c8a:	fb04 2210 	mls	r2, r4, r0, r2
 8008c8e:	609a      	str	r2, [r3, #8]
  q->size = q->size - 1;
  return 1;
 8008c90:	2001      	movs	r0, #1
    DEBUG_PRINT(("Chan recv queue is empty\n"));
    return -1;
  }
  *chan_data = q->data[q->front];
  q->front = (q->front + 1)%q->capacity;
  q->size = q->size - 1;
 8008c92:	6119      	str	r1, [r3, #16]
  return 1;
}
 8008c94:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008c98:	4770      	bx	lr

int chan_recv_q_dequeue(chan_recv_queue_t *q, recv_data_t *chan_data){

  if (is_empty(q)){
    DEBUG_PRINT(("Chan recv queue is empty\n"));
    return -1;
 8008c9a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008c9e:	4770      	bx	lr

08008ca0 <poll_recvq>:
  return 1;
}

int chan_recv_q_front  (chan_recv_queue_t *q, recv_data_t *chan_data){

  if (is_empty(q)){
 8008ca0:	690b      	ldr	r3, [r1, #16]
 8008ca2:	b1f3      	cbz	r3, 8008ce2 <poll_recvq+0x42>

bool poll_recvq(vmc_t *container, chan_recv_queue_t *q){
 8008ca4:	b530      	push	{r4, r5, lr}
 8008ca6:	4605      	mov	r5, r0
 8008ca8:	b087      	sub	sp, #28
 8008caa:	460c      	mov	r4, r1
 8008cac:	e003      	b.n	8008cb6 <poll_recvq+0x16>
        heap_fst(  &container->heap
                 , (heap_index)recv_data.dirty_flag_pointer.value);

      if((dirty_flag.value & 1) == 1){ // if dirty flag is SET
        recv_data_t temp;
        chan_recv_q_dequeue(q, &temp); // no need to check status
 8008cae:	f7ff ffd7 	bl	8008c60 <chan_recv_q_dequeue>
 8008cb2:	6923      	ldr	r3, [r4, #16]
 8008cb4:	b193      	cbz	r3, 8008cdc <poll_recvq+0x3c>
    DEBUG_PRINT(("Chan recv queue is empty\n"));
    return -1;
  }

  *chan_data = q->data[q->front];
 8008cb6:	68a3      	ldr	r3, [r4, #8]
 8008cb8:	6822      	ldr	r2, [r4, #0]
 8008cba:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8008cbe:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    recv_data_t recv_data;
    int op_status = chan_recv_q_front(q, &recv_data);
    if(op_status == -1){ //empty queue
      return false;
    } else {
      cam_value_t dirty_flag =
 8008cc2:	a801      	add	r0, sp, #4
 8008cc4:	689a      	ldr	r2, [r3, #8]
 8008cc6:	4629      	mov	r1, r5
 8008cc8:	f7ff fef2 	bl	8008ab0 <heap_fst>
        heap_fst(  &container->heap
                 , (heap_index)recv_data.dirty_flag_pointer.value);

      if((dirty_flag.value & 1) == 1){ // if dirty flag is SET
 8008ccc:	9b02      	ldr	r3, [sp, #8]
 8008cce:	07db      	lsls	r3, r3, #31
        recv_data_t temp;
        chan_recv_q_dequeue(q, &temp); // no need to check status
 8008cd0:	4620      	mov	r0, r4
 8008cd2:	a903      	add	r1, sp, #12
    } else {
      cam_value_t dirty_flag =
        heap_fst(  &container->heap
                 , (heap_index)recv_data.dirty_flag_pointer.value);

      if((dirty_flag.value & 1) == 1){ // if dirty flag is SET
 8008cd4:	d4eb      	bmi.n	8008cae <poll_recvq+0xe>
        recv_data_t temp;
        chan_recv_q_dequeue(q, &temp); // no need to check status
                                       // we know there is data
      } else {
        return true; // the actual dequeing should happen inside doFn
 8008cd6:	2001      	movs	r0, #1
      }
    }
  }
}
 8008cd8:	b007      	add	sp, #28
 8008cda:	bd30      	pop	{r4, r5, pc}
bool poll_recvq(vmc_t *container, chan_recv_queue_t *q){
  while(true){
    recv_data_t recv_data;
    int op_status = chan_recv_q_front(q, &recv_data);
    if(op_status == -1){ //empty queue
      return false;
 8008cdc:	2000      	movs	r0, #0
      } else {
        return true; // the actual dequeing should happen inside doFn
      }
    }
  }
}
 8008cde:	b007      	add	sp, #28
 8008ce0:	bd30      	pop	{r4, r5, pc}
bool poll_recvq(vmc_t *container, chan_recv_queue_t *q){
  while(true){
    recv_data_t recv_data;
    int op_status = chan_recv_q_front(q, &recv_data);
    if(op_status == -1){ //empty queue
      return false;
 8008ce2:	2000      	movs	r0, #0
      } else {
        return true; // the actual dequeing should happen inside doFn
      }
    }
  }
}
 8008ce4:	4770      	bx	lr
 8008ce6:	bf00      	nop

08008ce8 <memset>:
 8008ce8:	b470      	push	{r4, r5, r6}
 8008cea:	0784      	lsls	r4, r0, #30
 8008cec:	d046      	beq.n	8008d7c <memset+0x94>
 8008cee:	1e54      	subs	r4, r2, #1
 8008cf0:	2a00      	cmp	r2, #0
 8008cf2:	d041      	beq.n	8008d78 <memset+0x90>
 8008cf4:	b2cd      	uxtb	r5, r1
 8008cf6:	4603      	mov	r3, r0
 8008cf8:	e002      	b.n	8008d00 <memset+0x18>
 8008cfa:	1e62      	subs	r2, r4, #1
 8008cfc:	b3e4      	cbz	r4, 8008d78 <memset+0x90>
 8008cfe:	4614      	mov	r4, r2
 8008d00:	f803 5b01 	strb.w	r5, [r3], #1
 8008d04:	079a      	lsls	r2, r3, #30
 8008d06:	d1f8      	bne.n	8008cfa <memset+0x12>
 8008d08:	2c03      	cmp	r4, #3
 8008d0a:	d92e      	bls.n	8008d6a <memset+0x82>
 8008d0c:	b2cd      	uxtb	r5, r1
 8008d0e:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8008d12:	2c0f      	cmp	r4, #15
 8008d14:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8008d18:	d919      	bls.n	8008d4e <memset+0x66>
 8008d1a:	f103 0210 	add.w	r2, r3, #16
 8008d1e:	4626      	mov	r6, r4
 8008d20:	3e10      	subs	r6, #16
 8008d22:	2e0f      	cmp	r6, #15
 8008d24:	f842 5c10 	str.w	r5, [r2, #-16]
 8008d28:	f842 5c0c 	str.w	r5, [r2, #-12]
 8008d2c:	f842 5c08 	str.w	r5, [r2, #-8]
 8008d30:	f842 5c04 	str.w	r5, [r2, #-4]
 8008d34:	f102 0210 	add.w	r2, r2, #16
 8008d38:	d8f2      	bhi.n	8008d20 <memset+0x38>
 8008d3a:	f1a4 0210 	sub.w	r2, r4, #16
 8008d3e:	f022 020f 	bic.w	r2, r2, #15
 8008d42:	f004 040f 	and.w	r4, r4, #15
 8008d46:	3210      	adds	r2, #16
 8008d48:	2c03      	cmp	r4, #3
 8008d4a:	4413      	add	r3, r2
 8008d4c:	d90d      	bls.n	8008d6a <memset+0x82>
 8008d4e:	461e      	mov	r6, r3
 8008d50:	4622      	mov	r2, r4
 8008d52:	3a04      	subs	r2, #4
 8008d54:	2a03      	cmp	r2, #3
 8008d56:	f846 5b04 	str.w	r5, [r6], #4
 8008d5a:	d8fa      	bhi.n	8008d52 <memset+0x6a>
 8008d5c:	1f22      	subs	r2, r4, #4
 8008d5e:	f022 0203 	bic.w	r2, r2, #3
 8008d62:	3204      	adds	r2, #4
 8008d64:	4413      	add	r3, r2
 8008d66:	f004 0403 	and.w	r4, r4, #3
 8008d6a:	b12c      	cbz	r4, 8008d78 <memset+0x90>
 8008d6c:	b2c9      	uxtb	r1, r1
 8008d6e:	441c      	add	r4, r3
 8008d70:	f803 1b01 	strb.w	r1, [r3], #1
 8008d74:	42a3      	cmp	r3, r4
 8008d76:	d1fb      	bne.n	8008d70 <memset+0x88>
 8008d78:	bc70      	pop	{r4, r5, r6}
 8008d7a:	4770      	bx	lr
 8008d7c:	4614      	mov	r4, r2
 8008d7e:	4603      	mov	r3, r0
 8008d80:	e7c2      	b.n	8008d08 <memset+0x20>
 8008d82:	bf00      	nop

08008d84 <_vsnprintf_r>:
 8008d84:	b570      	push	{r4, r5, r6, lr}
 8008d86:	2a00      	cmp	r2, #0
 8008d88:	b09a      	sub	sp, #104	; 0x68
 8008d8a:	4605      	mov	r5, r0
 8008d8c:	db2f      	blt.n	8008dee <_vsnprintf_r+0x6a>
 8008d8e:	4614      	mov	r4, r2
 8008d90:	461a      	mov	r2, r3
 8008d92:	f44f 7302 	mov.w	r3, #520	; 0x208
 8008d96:	9100      	str	r1, [sp, #0]
 8008d98:	9104      	str	r1, [sp, #16]
 8008d9a:	f8ad 300c 	strh.w	r3, [sp, #12]
 8008d9e:	d011      	beq.n	8008dc4 <_vsnprintf_r+0x40>
 8008da0:	3c01      	subs	r4, #1
 8008da2:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8008da6:	4669      	mov	r1, sp
 8008da8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8008daa:	9402      	str	r4, [sp, #8]
 8008dac:	9405      	str	r4, [sp, #20]
 8008dae:	f8ad 600e 	strh.w	r6, [sp, #14]
 8008db2:	f000 f831 	bl	8008e18 <_svfprintf_r>
 8008db6:	1c42      	adds	r2, r0, #1
 8008db8:	db16      	blt.n	8008de8 <_vsnprintf_r+0x64>
 8008dba:	9b00      	ldr	r3, [sp, #0]
 8008dbc:	2200      	movs	r2, #0
 8008dbe:	701a      	strb	r2, [r3, #0]
 8008dc0:	b01a      	add	sp, #104	; 0x68
 8008dc2:	bd70      	pop	{r4, r5, r6, pc}
 8008dc4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8008dc6:	9402      	str	r4, [sp, #8]
 8008dc8:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8008dcc:	4669      	mov	r1, sp
 8008dce:	9405      	str	r4, [sp, #20]
 8008dd0:	f8ad 600e 	strh.w	r6, [sp, #14]
 8008dd4:	f000 f820 	bl	8008e18 <_svfprintf_r>
 8008dd8:	1c43      	adds	r3, r0, #1
 8008dda:	db01      	blt.n	8008de0 <_vsnprintf_r+0x5c>
 8008ddc:	b01a      	add	sp, #104	; 0x68
 8008dde:	bd70      	pop	{r4, r5, r6, pc}
 8008de0:	238b      	movs	r3, #139	; 0x8b
 8008de2:	602b      	str	r3, [r5, #0]
 8008de4:	b01a      	add	sp, #104	; 0x68
 8008de6:	bd70      	pop	{r4, r5, r6, pc}
 8008de8:	238b      	movs	r3, #139	; 0x8b
 8008dea:	602b      	str	r3, [r5, #0]
 8008dec:	e7e5      	b.n	8008dba <_vsnprintf_r+0x36>
 8008dee:	238b      	movs	r3, #139	; 0x8b
 8008df0:	6003      	str	r3, [r0, #0]
 8008df2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8008df6:	e7f1      	b.n	8008ddc <_vsnprintf_r+0x58>

08008df8 <vsnprintf>:
 8008df8:	b530      	push	{r4, r5, lr}
 8008dfa:	b083      	sub	sp, #12
 8008dfc:	4c05      	ldr	r4, [pc, #20]	; (8008e14 <vsnprintf+0x1c>)
 8008dfe:	9300      	str	r3, [sp, #0]
 8008e00:	6824      	ldr	r4, [r4, #0]
 8008e02:	460d      	mov	r5, r1
 8008e04:	4613      	mov	r3, r2
 8008e06:	4601      	mov	r1, r0
 8008e08:	462a      	mov	r2, r5
 8008e0a:	4620      	mov	r0, r4
 8008e0c:	f7ff ffba 	bl	8008d84 <_vsnprintf_r>
 8008e10:	b003      	add	sp, #12
 8008e12:	bd30      	pop	{r4, r5, pc}
 8008e14:	20000d28 	.word	0x20000d28

08008e18 <_svfprintf_r>:
 8008e18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008e1c:	b0bf      	sub	sp, #252	; 0xfc
 8008e1e:	4689      	mov	r9, r1
 8008e20:	9206      	str	r2, [sp, #24]
 8008e22:	930a      	str	r3, [sp, #40]	; 0x28
 8008e24:	9004      	str	r0, [sp, #16]
 8008e26:	f002 fa45 	bl	800b2b4 <_localeconv_r>
 8008e2a:	6803      	ldr	r3, [r0, #0]
 8008e2c:	9313      	str	r3, [sp, #76]	; 0x4c
 8008e2e:	4618      	mov	r0, r3
 8008e30:	f003 f848 	bl	800bec4 <strlen>
 8008e34:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8008e38:	9014      	str	r0, [sp, #80]	; 0x50
 8008e3a:	061a      	lsls	r2, r3, #24
 8008e3c:	d504      	bpl.n	8008e48 <_svfprintf_r+0x30>
 8008e3e:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8008e42:	2b00      	cmp	r3, #0
 8008e44:	f001 80a1 	beq.w	8009f8a <_svfprintf_r+0x1172>
 8008e48:	ed9f 7b99 	vldr	d7, [pc, #612]	; 80090b0 <_svfprintf_r+0x298>
 8008e4c:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8008e50:	2300      	movs	r3, #0
 8008e52:	af2e      	add	r7, sp, #184	; 0xb8
 8008e54:	930f      	str	r3, [sp, #60]	; 0x3c
 8008e56:	9323      	str	r3, [sp, #140]	; 0x8c
 8008e58:	9322      	str	r3, [sp, #136]	; 0x88
 8008e5a:	9312      	str	r3, [sp, #72]	; 0x48
 8008e5c:	9315      	str	r3, [sp, #84]	; 0x54
 8008e5e:	9307      	str	r3, [sp, #28]
 8008e60:	9721      	str	r7, [sp, #132]	; 0x84
 8008e62:	463c      	mov	r4, r7
 8008e64:	464e      	mov	r6, r9
 8008e66:	9d06      	ldr	r5, [sp, #24]
 8008e68:	782b      	ldrb	r3, [r5, #0]
 8008e6a:	2b00      	cmp	r3, #0
 8008e6c:	f000 80a9 	beq.w	8008fc2 <_svfprintf_r+0x1aa>
 8008e70:	2b25      	cmp	r3, #37	; 0x25
 8008e72:	d102      	bne.n	8008e7a <_svfprintf_r+0x62>
 8008e74:	e0a5      	b.n	8008fc2 <_svfprintf_r+0x1aa>
 8008e76:	2b25      	cmp	r3, #37	; 0x25
 8008e78:	d003      	beq.n	8008e82 <_svfprintf_r+0x6a>
 8008e7a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8008e7e:	2b00      	cmp	r3, #0
 8008e80:	d1f9      	bne.n	8008e76 <_svfprintf_r+0x5e>
 8008e82:	9b06      	ldr	r3, [sp, #24]
 8008e84:	1aeb      	subs	r3, r5, r3
 8008e86:	b173      	cbz	r3, 8008ea6 <_svfprintf_r+0x8e>
 8008e88:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8008e8a:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8008e8c:	9806      	ldr	r0, [sp, #24]
 8008e8e:	6020      	str	r0, [r4, #0]
 8008e90:	3201      	adds	r2, #1
 8008e92:	4419      	add	r1, r3
 8008e94:	2a07      	cmp	r2, #7
 8008e96:	6063      	str	r3, [r4, #4]
 8008e98:	9123      	str	r1, [sp, #140]	; 0x8c
 8008e9a:	9222      	str	r2, [sp, #136]	; 0x88
 8008e9c:	dc72      	bgt.n	8008f84 <_svfprintf_r+0x16c>
 8008e9e:	3408      	adds	r4, #8
 8008ea0:	9a07      	ldr	r2, [sp, #28]
 8008ea2:	441a      	add	r2, r3
 8008ea4:	9207      	str	r2, [sp, #28]
 8008ea6:	782b      	ldrb	r3, [r5, #0]
 8008ea8:	2b00      	cmp	r3, #0
 8008eaa:	f000 87cb 	beq.w	8009e44 <_svfprintf_r+0x102c>
 8008eae:	2300      	movs	r3, #0
 8008eb0:	1c69      	adds	r1, r5, #1
 8008eb2:	786d      	ldrb	r5, [r5, #1]
 8008eb4:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
 8008eb8:	461a      	mov	r2, r3
 8008eba:	9308      	str	r3, [sp, #32]
 8008ebc:	9303      	str	r3, [sp, #12]
 8008ebe:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
 8008ec2:	1c4b      	adds	r3, r1, #1
 8008ec4:	f1a5 0120 	sub.w	r1, r5, #32
 8008ec8:	2958      	cmp	r1, #88	; 0x58
 8008eca:	f200 83e4 	bhi.w	8009696 <_svfprintf_r+0x87e>
 8008ece:	e8df f011 	tbh	[pc, r1, lsl #1]
 8008ed2:	0277      	.short	0x0277
 8008ed4:	03e203e2 	.word	0x03e203e2
 8008ed8:	03e2037b 	.word	0x03e2037b
 8008edc:	03e203e2 	.word	0x03e203e2
 8008ee0:	03e203e2 	.word	0x03e203e2
 8008ee4:	02f703e2 	.word	0x02f703e2
 8008ee8:	03e20214 	.word	0x03e20214
 8008eec:	021801fb 	.word	0x021801fb
 8008ef0:	038203e2 	.word	0x038203e2
 8008ef4:	02c102c1 	.word	0x02c102c1
 8008ef8:	02c102c1 	.word	0x02c102c1
 8008efc:	02c102c1 	.word	0x02c102c1
 8008f00:	02c102c1 	.word	0x02c102c1
 8008f04:	03e202c1 	.word	0x03e202c1
 8008f08:	03e203e2 	.word	0x03e203e2
 8008f0c:	03e203e2 	.word	0x03e203e2
 8008f10:	03e203e2 	.word	0x03e203e2
 8008f14:	03e203e2 	.word	0x03e203e2
 8008f18:	02d003e2 	.word	0x02d003e2
 8008f1c:	03e20391 	.word	0x03e20391
 8008f20:	03e20391 	.word	0x03e20391
 8008f24:	03e203e2 	.word	0x03e203e2
 8008f28:	037403e2 	.word	0x037403e2
 8008f2c:	03e203e2 	.word	0x03e203e2
 8008f30:	03e2030c 	.word	0x03e2030c
 8008f34:	03e203e2 	.word	0x03e203e2
 8008f38:	03e203e2 	.word	0x03e203e2
 8008f3c:	03e2032a 	.word	0x03e2032a
 8008f40:	034403e2 	.word	0x034403e2
 8008f44:	03e203e2 	.word	0x03e203e2
 8008f48:	03e203e2 	.word	0x03e203e2
 8008f4c:	03e203e2 	.word	0x03e203e2
 8008f50:	03e203e2 	.word	0x03e203e2
 8008f54:	03e203e2 	.word	0x03e203e2
 8008f58:	0233035f 	.word	0x0233035f
 8008f5c:	03910391 	.word	0x03910391
 8008f60:	03050391 	.word	0x03050391
 8008f64:	03e20233 	.word	0x03e20233
 8008f68:	02ed03e2 	.word	0x02ed03e2
 8008f6c:	028503e2 	.word	0x028503e2
 8008f70:	03cb0202 	.word	0x03cb0202
 8008f74:	03e2027e 	.word	0x03e2027e
 8008f78:	03e20299 	.word	0x03e20299
 8008f7c:	03e2007a 	.word	0x03e2007a
 8008f80:	025103e2 	.word	0x025103e2
 8008f84:	9804      	ldr	r0, [sp, #16]
 8008f86:	9303      	str	r3, [sp, #12]
 8008f88:	4631      	mov	r1, r6
 8008f8a:	aa21      	add	r2, sp, #132	; 0x84
 8008f8c:	f002 ffc8 	bl	800bf20 <__ssprint_r>
 8008f90:	b950      	cbnz	r0, 8008fa8 <_svfprintf_r+0x190>
 8008f92:	463c      	mov	r4, r7
 8008f94:	9b03      	ldr	r3, [sp, #12]
 8008f96:	e783      	b.n	8008ea0 <_svfprintf_r+0x88>
 8008f98:	9804      	ldr	r0, [sp, #16]
 8008f9a:	4631      	mov	r1, r6
 8008f9c:	aa21      	add	r2, sp, #132	; 0x84
 8008f9e:	f002 ffbf 	bl	800bf20 <__ssprint_r>
 8008fa2:	2800      	cmp	r0, #0
 8008fa4:	f000 818c 	beq.w	80092c0 <_svfprintf_r+0x4a8>
 8008fa8:	46b1      	mov	r9, r6
 8008faa:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8008fae:	f013 0f40 	tst.w	r3, #64	; 0x40
 8008fb2:	9b07      	ldr	r3, [sp, #28]
 8008fb4:	bf18      	it	ne
 8008fb6:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
 8008fba:	4618      	mov	r0, r3
 8008fbc:	b03f      	add	sp, #252	; 0xfc
 8008fbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008fc2:	9d06      	ldr	r5, [sp, #24]
 8008fc4:	e76f      	b.n	8008ea6 <_svfprintf_r+0x8e>
 8008fc6:	9306      	str	r3, [sp, #24]
 8008fc8:	9b03      	ldr	r3, [sp, #12]
 8008fca:	0698      	lsls	r0, r3, #26
 8008fcc:	f140 82b4 	bpl.w	8009538 <_svfprintf_r+0x720>
 8008fd0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008fd2:	f103 0907 	add.w	r9, r3, #7
 8008fd6:	f029 0307 	bic.w	r3, r9, #7
 8008fda:	f103 0208 	add.w	r2, r3, #8
 8008fde:	e9d3 8900 	ldrd	r8, r9, [r3]
 8008fe2:	920a      	str	r2, [sp, #40]	; 0x28
 8008fe4:	2301      	movs	r3, #1
 8008fe6:	f04f 0c00 	mov.w	ip, #0
 8008fea:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 8008fee:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8008ff2:	f1ba 0f00 	cmp.w	sl, #0
 8008ff6:	db03      	blt.n	8009000 <_svfprintf_r+0x1e8>
 8008ff8:	9a03      	ldr	r2, [sp, #12]
 8008ffa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8008ffe:	9203      	str	r2, [sp, #12]
 8009000:	ea58 0209 	orrs.w	r2, r8, r9
 8009004:	f040 8357 	bne.w	80096b6 <_svfprintf_r+0x89e>
 8009008:	f1ba 0f00 	cmp.w	sl, #0
 800900c:	f000 845c 	beq.w	80098c8 <_svfprintf_r+0xab0>
 8009010:	2b01      	cmp	r3, #1
 8009012:	f000 835a 	beq.w	80096ca <_svfprintf_r+0x8b2>
 8009016:	2b02      	cmp	r3, #2
 8009018:	f000 849a 	beq.w	8009950 <_svfprintf_r+0xb38>
 800901c:	4639      	mov	r1, r7
 800901e:	ea4f 02d8 	mov.w	r2, r8, lsr #3
 8009022:	ea42 7249 	orr.w	r2, r2, r9, lsl #29
 8009026:	ea4f 00d9 	mov.w	r0, r9, lsr #3
 800902a:	f008 0307 	and.w	r3, r8, #7
 800902e:	4681      	mov	r9, r0
 8009030:	4690      	mov	r8, r2
 8009032:	3330      	adds	r3, #48	; 0x30
 8009034:	ea58 0209 	orrs.w	r2, r8, r9
 8009038:	f801 3d01 	strb.w	r3, [r1, #-1]!
 800903c:	d1ef      	bne.n	800901e <_svfprintf_r+0x206>
 800903e:	9a03      	ldr	r2, [sp, #12]
 8009040:	910c      	str	r1, [sp, #48]	; 0x30
 8009042:	07d2      	lsls	r2, r2, #31
 8009044:	f100 856e 	bmi.w	8009b24 <_svfprintf_r+0xd0c>
 8009048:	1a7b      	subs	r3, r7, r1
 800904a:	9309      	str	r3, [sp, #36]	; 0x24
 800904c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800904e:	4592      	cmp	sl, r2
 8009050:	4653      	mov	r3, sl
 8009052:	bfb8      	it	lt
 8009054:	4613      	movlt	r3, r2
 8009056:	9305      	str	r3, [sp, #20]
 8009058:	2300      	movs	r3, #0
 800905a:	930e      	str	r3, [sp, #56]	; 0x38
 800905c:	f1bc 0f00 	cmp.w	ip, #0
 8009060:	d002      	beq.n	8009068 <_svfprintf_r+0x250>
 8009062:	9b05      	ldr	r3, [sp, #20]
 8009064:	3301      	adds	r3, #1
 8009066:	9305      	str	r3, [sp, #20]
 8009068:	9b03      	ldr	r3, [sp, #12]
 800906a:	f013 0302 	ands.w	r3, r3, #2
 800906e:	930b      	str	r3, [sp, #44]	; 0x2c
 8009070:	d002      	beq.n	8009078 <_svfprintf_r+0x260>
 8009072:	9b05      	ldr	r3, [sp, #20]
 8009074:	3302      	adds	r3, #2
 8009076:	9305      	str	r3, [sp, #20]
 8009078:	9b03      	ldr	r3, [sp, #12]
 800907a:	f013 0984 	ands.w	r9, r3, #132	; 0x84
 800907e:	f040 8317 	bne.w	80096b0 <_svfprintf_r+0x898>
 8009082:	9b08      	ldr	r3, [sp, #32]
 8009084:	9a05      	ldr	r2, [sp, #20]
 8009086:	ebc2 0803 	rsb	r8, r2, r3
 800908a:	f1b8 0f00 	cmp.w	r8, #0
 800908e:	f340 830f 	ble.w	80096b0 <_svfprintf_r+0x898>
 8009092:	f1b8 0f10 	cmp.w	r8, #16
 8009096:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8009098:	9a22      	ldr	r2, [sp, #136]	; 0x88
 800909a:	f8df a01c 	ldr.w	sl, [pc, #28]	; 80090b8 <_svfprintf_r+0x2a0>
 800909e:	dd30      	ble.n	8009102 <_svfprintf_r+0x2ea>
 80090a0:	4653      	mov	r3, sl
 80090a2:	f04f 0b10 	mov.w	fp, #16
 80090a6:	46c2      	mov	sl, r8
 80090a8:	46a8      	mov	r8, r5
 80090aa:	461d      	mov	r5, r3
 80090ac:	e00d      	b.n	80090ca <_svfprintf_r+0x2b2>
 80090ae:	bf00      	nop
	...
 80090b8:	0800d514 	.word	0x0800d514
 80090bc:	f1aa 0a10 	sub.w	sl, sl, #16
 80090c0:	f1ba 0f10 	cmp.w	sl, #16
 80090c4:	f104 0408 	add.w	r4, r4, #8
 80090c8:	dd17      	ble.n	80090fa <_svfprintf_r+0x2e2>
 80090ca:	3201      	adds	r2, #1
 80090cc:	3110      	adds	r1, #16
 80090ce:	2a07      	cmp	r2, #7
 80090d0:	9123      	str	r1, [sp, #140]	; 0x8c
 80090d2:	9222      	str	r2, [sp, #136]	; 0x88
 80090d4:	e884 0820 	stmia.w	r4, {r5, fp}
 80090d8:	ddf0      	ble.n	80090bc <_svfprintf_r+0x2a4>
 80090da:	9804      	ldr	r0, [sp, #16]
 80090dc:	4631      	mov	r1, r6
 80090de:	aa21      	add	r2, sp, #132	; 0x84
 80090e0:	f002 ff1e 	bl	800bf20 <__ssprint_r>
 80090e4:	2800      	cmp	r0, #0
 80090e6:	f47f af5f 	bne.w	8008fa8 <_svfprintf_r+0x190>
 80090ea:	f1aa 0a10 	sub.w	sl, sl, #16
 80090ee:	f1ba 0f10 	cmp.w	sl, #16
 80090f2:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80090f4:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80090f6:	463c      	mov	r4, r7
 80090f8:	dce7      	bgt.n	80090ca <_svfprintf_r+0x2b2>
 80090fa:	462b      	mov	r3, r5
 80090fc:	4645      	mov	r5, r8
 80090fe:	46d0      	mov	r8, sl
 8009100:	469a      	mov	sl, r3
 8009102:	3201      	adds	r2, #1
 8009104:	eb08 0b01 	add.w	fp, r8, r1
 8009108:	2a07      	cmp	r2, #7
 800910a:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800910e:	9222      	str	r2, [sp, #136]	; 0x88
 8009110:	f8c4 a000 	str.w	sl, [r4]
 8009114:	f8c4 8004 	str.w	r8, [r4, #4]
 8009118:	f300 847e 	bgt.w	8009a18 <_svfprintf_r+0xc00>
 800911c:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8009120:	3408      	adds	r4, #8
 8009122:	f1bc 0f00 	cmp.w	ip, #0
 8009126:	d00f      	beq.n	8009148 <_svfprintf_r+0x330>
 8009128:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800912a:	3301      	adds	r3, #1
 800912c:	f10b 0b01 	add.w	fp, fp, #1
 8009130:	f10d 0167 	add.w	r1, sp, #103	; 0x67
 8009134:	2201      	movs	r2, #1
 8009136:	2b07      	cmp	r3, #7
 8009138:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800913c:	9322      	str	r3, [sp, #136]	; 0x88
 800913e:	e884 0006 	stmia.w	r4, {r1, r2}
 8009142:	f300 83ea 	bgt.w	800991a <_svfprintf_r+0xb02>
 8009146:	3408      	adds	r4, #8
 8009148:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800914a:	b173      	cbz	r3, 800916a <_svfprintf_r+0x352>
 800914c:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800914e:	3301      	adds	r3, #1
 8009150:	f10b 0b02 	add.w	fp, fp, #2
 8009154:	a91a      	add	r1, sp, #104	; 0x68
 8009156:	2202      	movs	r2, #2
 8009158:	2b07      	cmp	r3, #7
 800915a:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800915e:	9322      	str	r3, [sp, #136]	; 0x88
 8009160:	e884 0006 	stmia.w	r4, {r1, r2}
 8009164:	f300 83cd 	bgt.w	8009902 <_svfprintf_r+0xaea>
 8009168:	3408      	adds	r4, #8
 800916a:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
 800916e:	f000 8315 	beq.w	800979c <_svfprintf_r+0x984>
 8009172:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009174:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009176:	ebc2 0a03 	rsb	sl, r2, r3
 800917a:	f1ba 0f00 	cmp.w	sl, #0
 800917e:	dd3c      	ble.n	80091fa <_svfprintf_r+0x3e2>
 8009180:	f1ba 0f10 	cmp.w	sl, #16
 8009184:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8009186:	f8df 9464 	ldr.w	r9, [pc, #1124]	; 80095ec <_svfprintf_r+0x7d4>
 800918a:	dd2b      	ble.n	80091e4 <_svfprintf_r+0x3cc>
 800918c:	4649      	mov	r1, r9
 800918e:	465b      	mov	r3, fp
 8009190:	46a9      	mov	r9, r5
 8009192:	f04f 0810 	mov.w	r8, #16
 8009196:	f8dd b010 	ldr.w	fp, [sp, #16]
 800919a:	460d      	mov	r5, r1
 800919c:	e006      	b.n	80091ac <_svfprintf_r+0x394>
 800919e:	f1aa 0a10 	sub.w	sl, sl, #16
 80091a2:	f1ba 0f10 	cmp.w	sl, #16
 80091a6:	f104 0408 	add.w	r4, r4, #8
 80091aa:	dd17      	ble.n	80091dc <_svfprintf_r+0x3c4>
 80091ac:	3201      	adds	r2, #1
 80091ae:	3310      	adds	r3, #16
 80091b0:	2a07      	cmp	r2, #7
 80091b2:	9323      	str	r3, [sp, #140]	; 0x8c
 80091b4:	9222      	str	r2, [sp, #136]	; 0x88
 80091b6:	e884 0120 	stmia.w	r4, {r5, r8}
 80091ba:	ddf0      	ble.n	800919e <_svfprintf_r+0x386>
 80091bc:	4658      	mov	r0, fp
 80091be:	4631      	mov	r1, r6
 80091c0:	aa21      	add	r2, sp, #132	; 0x84
 80091c2:	f002 fead 	bl	800bf20 <__ssprint_r>
 80091c6:	2800      	cmp	r0, #0
 80091c8:	f47f aeee 	bne.w	8008fa8 <_svfprintf_r+0x190>
 80091cc:	f1aa 0a10 	sub.w	sl, sl, #16
 80091d0:	f1ba 0f10 	cmp.w	sl, #16
 80091d4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80091d6:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80091d8:	463c      	mov	r4, r7
 80091da:	dce7      	bgt.n	80091ac <_svfprintf_r+0x394>
 80091dc:	469b      	mov	fp, r3
 80091de:	462b      	mov	r3, r5
 80091e0:	464d      	mov	r5, r9
 80091e2:	4699      	mov	r9, r3
 80091e4:	3201      	adds	r2, #1
 80091e6:	44d3      	add	fp, sl
 80091e8:	2a07      	cmp	r2, #7
 80091ea:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 80091ee:	9222      	str	r2, [sp, #136]	; 0x88
 80091f0:	e884 0600 	stmia.w	r4, {r9, sl}
 80091f4:	f300 8379 	bgt.w	80098ea <_svfprintf_r+0xad2>
 80091f8:	3408      	adds	r4, #8
 80091fa:	9b03      	ldr	r3, [sp, #12]
 80091fc:	05d9      	lsls	r1, r3, #23
 80091fe:	f100 8270 	bmi.w	80096e2 <_svfprintf_r+0x8ca>
 8009202:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009204:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009206:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009208:	6022      	str	r2, [r4, #0]
 800920a:	3301      	adds	r3, #1
 800920c:	448b      	add	fp, r1
 800920e:	2b07      	cmp	r3, #7
 8009210:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009214:	6061      	str	r1, [r4, #4]
 8009216:	9322      	str	r3, [sp, #136]	; 0x88
 8009218:	f300 834a 	bgt.w	80098b0 <_svfprintf_r+0xa98>
 800921c:	3408      	adds	r4, #8
 800921e:	9b03      	ldr	r3, [sp, #12]
 8009220:	075a      	lsls	r2, r3, #29
 8009222:	d541      	bpl.n	80092a8 <_svfprintf_r+0x490>
 8009224:	9b08      	ldr	r3, [sp, #32]
 8009226:	9a05      	ldr	r2, [sp, #20]
 8009228:	1a9d      	subs	r5, r3, r2
 800922a:	2d00      	cmp	r5, #0
 800922c:	dd3c      	ble.n	80092a8 <_svfprintf_r+0x490>
 800922e:	2d10      	cmp	r5, #16
 8009230:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009232:	f8df a3bc 	ldr.w	sl, [pc, #956]	; 80095f0 <_svfprintf_r+0x7d8>
 8009236:	dd23      	ble.n	8009280 <_svfprintf_r+0x468>
 8009238:	f04f 0810 	mov.w	r8, #16
 800923c:	465a      	mov	r2, fp
 800923e:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8009242:	e004      	b.n	800924e <_svfprintf_r+0x436>
 8009244:	3d10      	subs	r5, #16
 8009246:	2d10      	cmp	r5, #16
 8009248:	f104 0408 	add.w	r4, r4, #8
 800924c:	dd17      	ble.n	800927e <_svfprintf_r+0x466>
 800924e:	3301      	adds	r3, #1
 8009250:	3210      	adds	r2, #16
 8009252:	2b07      	cmp	r3, #7
 8009254:	9223      	str	r2, [sp, #140]	; 0x8c
 8009256:	9322      	str	r3, [sp, #136]	; 0x88
 8009258:	f8c4 a000 	str.w	sl, [r4]
 800925c:	f8c4 8004 	str.w	r8, [r4, #4]
 8009260:	ddf0      	ble.n	8009244 <_svfprintf_r+0x42c>
 8009262:	4648      	mov	r0, r9
 8009264:	4631      	mov	r1, r6
 8009266:	aa21      	add	r2, sp, #132	; 0x84
 8009268:	f002 fe5a 	bl	800bf20 <__ssprint_r>
 800926c:	2800      	cmp	r0, #0
 800926e:	f47f ae9b 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009272:	3d10      	subs	r5, #16
 8009274:	2d10      	cmp	r5, #16
 8009276:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8009278:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800927a:	463c      	mov	r4, r7
 800927c:	dce7      	bgt.n	800924e <_svfprintf_r+0x436>
 800927e:	4693      	mov	fp, r2
 8009280:	3301      	adds	r3, #1
 8009282:	44ab      	add	fp, r5
 8009284:	2b07      	cmp	r3, #7
 8009286:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800928a:	9322      	str	r3, [sp, #136]	; 0x88
 800928c:	f8c4 a000 	str.w	sl, [r4]
 8009290:	6065      	str	r5, [r4, #4]
 8009292:	dd09      	ble.n	80092a8 <_svfprintf_r+0x490>
 8009294:	9804      	ldr	r0, [sp, #16]
 8009296:	4631      	mov	r1, r6
 8009298:	aa21      	add	r2, sp, #132	; 0x84
 800929a:	f002 fe41 	bl	800bf20 <__ssprint_r>
 800929e:	2800      	cmp	r0, #0
 80092a0:	f47f ae82 	bne.w	8008fa8 <_svfprintf_r+0x190>
 80092a4:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80092a8:	9b07      	ldr	r3, [sp, #28]
 80092aa:	9a05      	ldr	r2, [sp, #20]
 80092ac:	9908      	ldr	r1, [sp, #32]
 80092ae:	428a      	cmp	r2, r1
 80092b0:	bfac      	ite	ge
 80092b2:	189b      	addge	r3, r3, r2
 80092b4:	185b      	addlt	r3, r3, r1
 80092b6:	9307      	str	r3, [sp, #28]
 80092b8:	f1bb 0f00 	cmp.w	fp, #0
 80092bc:	f47f ae6c 	bne.w	8008f98 <_svfprintf_r+0x180>
 80092c0:	2300      	movs	r3, #0
 80092c2:	9322      	str	r3, [sp, #136]	; 0x88
 80092c4:	463c      	mov	r4, r7
 80092c6:	e5ce      	b.n	8008e66 <_svfprintf_r+0x4e>
 80092c8:	4619      	mov	r1, r3
 80092ca:	9803      	ldr	r0, [sp, #12]
 80092cc:	781d      	ldrb	r5, [r3, #0]
 80092ce:	f040 0004 	orr.w	r0, r0, #4
 80092d2:	9003      	str	r0, [sp, #12]
 80092d4:	e5f5      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80092d6:	9306      	str	r3, [sp, #24]
 80092d8:	9b03      	ldr	r3, [sp, #12]
 80092da:	f013 0320 	ands.w	r3, r3, #32
 80092de:	f000 810e 	beq.w	80094fe <_svfprintf_r+0x6e6>
 80092e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80092e4:	f103 0907 	add.w	r9, r3, #7
 80092e8:	f029 0307 	bic.w	r3, r9, #7
 80092ec:	f103 0208 	add.w	r2, r3, #8
 80092f0:	e9d3 8900 	ldrd	r8, r9, [r3]
 80092f4:	920a      	str	r2, [sp, #40]	; 0x28
 80092f6:	2300      	movs	r3, #0
 80092f8:	e675      	b.n	8008fe6 <_svfprintf_r+0x1ce>
 80092fa:	781d      	ldrb	r5, [r3, #0]
 80092fc:	4619      	mov	r1, r3
 80092fe:	222b      	movs	r2, #43	; 0x2b
 8009300:	e5df      	b.n	8008ec2 <_svfprintf_r+0xaa>
 8009302:	781d      	ldrb	r5, [r3, #0]
 8009304:	2d2a      	cmp	r5, #42	; 0x2a
 8009306:	f103 0101 	add.w	r1, r3, #1
 800930a:	f000 87b8 	beq.w	800a27e <_svfprintf_r+0x1466>
 800930e:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 8009312:	2809      	cmp	r0, #9
 8009314:	460b      	mov	r3, r1
 8009316:	f04f 0a00 	mov.w	sl, #0
 800931a:	f63f add3 	bhi.w	8008ec4 <_svfprintf_r+0xac>
 800931e:	f813 5b01 	ldrb.w	r5, [r3], #1
 8009322:	eb0a 0a8a 	add.w	sl, sl, sl, lsl #2
 8009326:	eb00 0a4a 	add.w	sl, r0, sl, lsl #1
 800932a:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 800932e:	2809      	cmp	r0, #9
 8009330:	d9f5      	bls.n	800931e <_svfprintf_r+0x506>
 8009332:	ea4a 7aea 	orr.w	sl, sl, sl, asr #31
 8009336:	e5c5      	b.n	8008ec4 <_svfprintf_r+0xac>
 8009338:	9306      	str	r3, [sp, #24]
 800933a:	9b03      	ldr	r3, [sp, #12]
 800933c:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 8009340:	069b      	lsls	r3, r3, #26
 8009342:	f140 80a1 	bpl.w	8009488 <_svfprintf_r+0x670>
 8009346:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009348:	f103 0907 	add.w	r9, r3, #7
 800934c:	f029 0907 	bic.w	r9, r9, #7
 8009350:	e9d9 2300 	ldrd	r2, r3, [r9]
 8009354:	f109 0108 	add.w	r1, r9, #8
 8009358:	910a      	str	r1, [sp, #40]	; 0x28
 800935a:	4690      	mov	r8, r2
 800935c:	4699      	mov	r9, r3
 800935e:	2a00      	cmp	r2, #0
 8009360:	f173 0300 	sbcs.w	r3, r3, #0
 8009364:	f2c0 840e 	blt.w	8009b84 <_svfprintf_r+0xd6c>
 8009368:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 800936c:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8009370:	2301      	movs	r3, #1
 8009372:	e63e      	b.n	8008ff2 <_svfprintf_r+0x1da>
 8009374:	9306      	str	r3, [sp, #24]
 8009376:	4b9b      	ldr	r3, [pc, #620]	; (80095e4 <_svfprintf_r+0x7cc>)
 8009378:	9312      	str	r3, [sp, #72]	; 0x48
 800937a:	9b03      	ldr	r3, [sp, #12]
 800937c:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 8009380:	069b      	lsls	r3, r3, #26
 8009382:	f140 80f3 	bpl.w	800956c <_svfprintf_r+0x754>
 8009386:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009388:	f103 0907 	add.w	r9, r3, #7
 800938c:	f029 0307 	bic.w	r3, r9, #7
 8009390:	e9d3 8900 	ldrd	r8, r9, [r3]
 8009394:	f103 0208 	add.w	r2, r3, #8
 8009398:	920a      	str	r2, [sp, #40]	; 0x28
 800939a:	9b03      	ldr	r3, [sp, #12]
 800939c:	07d9      	lsls	r1, r3, #31
 800939e:	f140 80f5 	bpl.w	800958c <_svfprintf_r+0x774>
 80093a2:	ea58 0309 	orrs.w	r3, r8, r9
 80093a6:	f000 80f1 	beq.w	800958c <_svfprintf_r+0x774>
 80093aa:	9a03      	ldr	r2, [sp, #12]
 80093ac:	f88d 5069 	strb.w	r5, [sp, #105]	; 0x69
 80093b0:	2330      	movs	r3, #48	; 0x30
 80093b2:	f042 0202 	orr.w	r2, r2, #2
 80093b6:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
 80093ba:	9203      	str	r2, [sp, #12]
 80093bc:	2302      	movs	r3, #2
 80093be:	e612      	b.n	8008fe6 <_svfprintf_r+0x1ce>
 80093c0:	781d      	ldrb	r5, [r3, #0]
 80093c2:	4619      	mov	r1, r3
 80093c4:	2a00      	cmp	r2, #0
 80093c6:	f47f ad7c 	bne.w	8008ec2 <_svfprintf_r+0xaa>
 80093ca:	2220      	movs	r2, #32
 80093cc:	e579      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80093ce:	9903      	ldr	r1, [sp, #12]
 80093d0:	f041 0120 	orr.w	r1, r1, #32
 80093d4:	9103      	str	r1, [sp, #12]
 80093d6:	781d      	ldrb	r5, [r3, #0]
 80093d8:	4619      	mov	r1, r3
 80093da:	e572      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80093dc:	9306      	str	r3, [sp, #24]
 80093de:	9b03      	ldr	r3, [sp, #12]
 80093e0:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 80093e4:	069a      	lsls	r2, r3, #26
 80093e6:	f140 84b0 	bpl.w	8009d4a <_svfprintf_r+0xf32>
 80093ea:	9907      	ldr	r1, [sp, #28]
 80093ec:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80093ee:	ea4f 79e1 	mov.w	r9, r1, asr #31
 80093f2:	6813      	ldr	r3, [r2, #0]
 80093f4:	4608      	mov	r0, r1
 80093f6:	4688      	mov	r8, r1
 80093f8:	3204      	adds	r2, #4
 80093fa:	4649      	mov	r1, r9
 80093fc:	920a      	str	r2, [sp, #40]	; 0x28
 80093fe:	e9c3 0100 	strd	r0, r1, [r3]
 8009402:	e530      	b.n	8008e66 <_svfprintf_r+0x4e>
 8009404:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8009406:	9306      	str	r3, [sp, #24]
 8009408:	6813      	ldr	r3, [r2, #0]
 800940a:	930c      	str	r3, [sp, #48]	; 0x30
 800940c:	f04f 0b00 	mov.w	fp, #0
 8009410:	f88d b067 	strb.w	fp, [sp, #103]	; 0x67
 8009414:	f102 0904 	add.w	r9, r2, #4
 8009418:	2b00      	cmp	r3, #0
 800941a:	f000 8646 	beq.w	800a0aa <_svfprintf_r+0x1292>
 800941e:	f1ba 0f00 	cmp.w	sl, #0
 8009422:	980c      	ldr	r0, [sp, #48]	; 0x30
 8009424:	f2c0 85f6 	blt.w	800a014 <_svfprintf_r+0x11fc>
 8009428:	4659      	mov	r1, fp
 800942a:	4652      	mov	r2, sl
 800942c:	f002 f9d8 	bl	800b7e0 <memchr>
 8009430:	2800      	cmp	r0, #0
 8009432:	f000 8677 	beq.w	800a124 <_svfprintf_r+0x130c>
 8009436:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009438:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 800943c:	1ac3      	subs	r3, r0, r3
 800943e:	9309      	str	r3, [sp, #36]	; 0x24
 8009440:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 8009444:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8009448:	9305      	str	r3, [sp, #20]
 800944a:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
 800944e:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8009452:	e603      	b.n	800905c <_svfprintf_r+0x244>
 8009454:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 8009458:	2100      	movs	r1, #0
 800945a:	f813 5b01 	ldrb.w	r5, [r3], #1
 800945e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8009462:	eb00 0141 	add.w	r1, r0, r1, lsl #1
 8009466:	f1a5 0030 	sub.w	r0, r5, #48	; 0x30
 800946a:	2809      	cmp	r0, #9
 800946c:	d9f5      	bls.n	800945a <_svfprintf_r+0x642>
 800946e:	9108      	str	r1, [sp, #32]
 8009470:	e528      	b.n	8008ec4 <_svfprintf_r+0xac>
 8009472:	9306      	str	r3, [sp, #24]
 8009474:	9b03      	ldr	r3, [sp, #12]
 8009476:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 800947a:	f043 0310 	orr.w	r3, r3, #16
 800947e:	9303      	str	r3, [sp, #12]
 8009480:	9b03      	ldr	r3, [sp, #12]
 8009482:	069b      	lsls	r3, r3, #26
 8009484:	f53f af5f 	bmi.w	8009346 <_svfprintf_r+0x52e>
 8009488:	9b03      	ldr	r3, [sp, #12]
 800948a:	06d8      	lsls	r0, r3, #27
 800948c:	f100 836b 	bmi.w	8009b66 <_svfprintf_r+0xd4e>
 8009490:	9b03      	ldr	r3, [sp, #12]
 8009492:	0659      	lsls	r1, r3, #25
 8009494:	f140 8367 	bpl.w	8009b66 <_svfprintf_r+0xd4e>
 8009498:	990a      	ldr	r1, [sp, #40]	; 0x28
 800949a:	f9b1 8000 	ldrsh.w	r8, [r1]
 800949e:	3104      	adds	r1, #4
 80094a0:	ea4f 79e8 	mov.w	r9, r8, asr #31
 80094a4:	4642      	mov	r2, r8
 80094a6:	464b      	mov	r3, r9
 80094a8:	910a      	str	r1, [sp, #40]	; 0x28
 80094aa:	e758      	b.n	800935e <_svfprintf_r+0x546>
 80094ac:	781d      	ldrb	r5, [r3, #0]
 80094ae:	9903      	ldr	r1, [sp, #12]
 80094b0:	2d6c      	cmp	r5, #108	; 0x6c
 80094b2:	f000 84d3 	beq.w	8009e5c <_svfprintf_r+0x1044>
 80094b6:	f041 0110 	orr.w	r1, r1, #16
 80094ba:	9103      	str	r1, [sp, #12]
 80094bc:	4619      	mov	r1, r3
 80094be:	e500      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80094c0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80094c2:	6829      	ldr	r1, [r5, #0]
 80094c4:	9108      	str	r1, [sp, #32]
 80094c6:	4608      	mov	r0, r1
 80094c8:	2800      	cmp	r0, #0
 80094ca:	4629      	mov	r1, r5
 80094cc:	f101 0104 	add.w	r1, r1, #4
 80094d0:	f2c0 84cb 	blt.w	8009e6a <_svfprintf_r+0x1052>
 80094d4:	910a      	str	r1, [sp, #40]	; 0x28
 80094d6:	781d      	ldrb	r5, [r3, #0]
 80094d8:	4619      	mov	r1, r3
 80094da:	e4f2      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80094dc:	9903      	ldr	r1, [sp, #12]
 80094de:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 80094e2:	9103      	str	r1, [sp, #12]
 80094e4:	781d      	ldrb	r5, [r3, #0]
 80094e6:	4619      	mov	r1, r3
 80094e8:	e4eb      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80094ea:	9306      	str	r3, [sp, #24]
 80094ec:	9b03      	ldr	r3, [sp, #12]
 80094ee:	f043 0310 	orr.w	r3, r3, #16
 80094f2:	9303      	str	r3, [sp, #12]
 80094f4:	9b03      	ldr	r3, [sp, #12]
 80094f6:	f013 0320 	ands.w	r3, r3, #32
 80094fa:	f47f aef2 	bne.w	80092e2 <_svfprintf_r+0x4ca>
 80094fe:	9a03      	ldr	r2, [sp, #12]
 8009500:	f012 0210 	ands.w	r2, r2, #16
 8009504:	f040 831c 	bne.w	8009b40 <_svfprintf_r+0xd28>
 8009508:	9b03      	ldr	r3, [sp, #12]
 800950a:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 800950e:	f000 8317 	beq.w	8009b40 <_svfprintf_r+0xd28>
 8009512:	990a      	ldr	r1, [sp, #40]	; 0x28
 8009514:	4613      	mov	r3, r2
 8009516:	460a      	mov	r2, r1
 8009518:	3204      	adds	r2, #4
 800951a:	f8b1 8000 	ldrh.w	r8, [r1]
 800951e:	920a      	str	r2, [sp, #40]	; 0x28
 8009520:	f04f 0900 	mov.w	r9, #0
 8009524:	e55f      	b.n	8008fe6 <_svfprintf_r+0x1ce>
 8009526:	9306      	str	r3, [sp, #24]
 8009528:	9b03      	ldr	r3, [sp, #12]
 800952a:	f043 0310 	orr.w	r3, r3, #16
 800952e:	9303      	str	r3, [sp, #12]
 8009530:	9b03      	ldr	r3, [sp, #12]
 8009532:	0698      	lsls	r0, r3, #26
 8009534:	f53f ad4c 	bmi.w	8008fd0 <_svfprintf_r+0x1b8>
 8009538:	9b03      	ldr	r3, [sp, #12]
 800953a:	06d9      	lsls	r1, r3, #27
 800953c:	f100 8309 	bmi.w	8009b52 <_svfprintf_r+0xd3a>
 8009540:	9b03      	ldr	r3, [sp, #12]
 8009542:	065a      	lsls	r2, r3, #25
 8009544:	f140 8305 	bpl.w	8009b52 <_svfprintf_r+0xd3a>
 8009548:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800954a:	f8b2 8000 	ldrh.w	r8, [r2]
 800954e:	3204      	adds	r2, #4
 8009550:	f04f 0900 	mov.w	r9, #0
 8009554:	2301      	movs	r3, #1
 8009556:	920a      	str	r2, [sp, #40]	; 0x28
 8009558:	e545      	b.n	8008fe6 <_svfprintf_r+0x1ce>
 800955a:	9306      	str	r3, [sp, #24]
 800955c:	4b22      	ldr	r3, [pc, #136]	; (80095e8 <_svfprintf_r+0x7d0>)
 800955e:	9312      	str	r3, [sp, #72]	; 0x48
 8009560:	9b03      	ldr	r3, [sp, #12]
 8009562:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 8009566:	069b      	lsls	r3, r3, #26
 8009568:	f53f af0d 	bmi.w	8009386 <_svfprintf_r+0x56e>
 800956c:	9b03      	ldr	r3, [sp, #12]
 800956e:	06d8      	lsls	r0, r3, #27
 8009570:	f140 83dc 	bpl.w	8009d2c <_svfprintf_r+0xf14>
 8009574:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8009576:	4613      	mov	r3, r2
 8009578:	681b      	ldr	r3, [r3, #0]
 800957a:	4698      	mov	r8, r3
 800957c:	9b03      	ldr	r3, [sp, #12]
 800957e:	3204      	adds	r2, #4
 8009580:	07d9      	lsls	r1, r3, #31
 8009582:	920a      	str	r2, [sp, #40]	; 0x28
 8009584:	f04f 0900 	mov.w	r9, #0
 8009588:	f53f af0b 	bmi.w	80093a2 <_svfprintf_r+0x58a>
 800958c:	2302      	movs	r3, #2
 800958e:	e52a      	b.n	8008fe6 <_svfprintf_r+0x1ce>
 8009590:	990a      	ldr	r1, [sp, #40]	; 0x28
 8009592:	9306      	str	r3, [sp, #24]
 8009594:	680a      	ldr	r2, [r1, #0]
 8009596:	f88d 2090 	strb.w	r2, [sp, #144]	; 0x90
 800959a:	2300      	movs	r3, #0
 800959c:	2201      	movs	r2, #1
 800959e:	3104      	adds	r1, #4
 80095a0:	469c      	mov	ip, r3
 80095a2:	9205      	str	r2, [sp, #20]
 80095a4:	910a      	str	r1, [sp, #40]	; 0x28
 80095a6:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
 80095aa:	ab24      	add	r3, sp, #144	; 0x90
 80095ac:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 80095b0:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
 80095b4:	9209      	str	r2, [sp, #36]	; 0x24
 80095b6:	930c      	str	r3, [sp, #48]	; 0x30
 80095b8:	e556      	b.n	8009068 <_svfprintf_r+0x250>
 80095ba:	9903      	ldr	r1, [sp, #12]
 80095bc:	f041 0108 	orr.w	r1, r1, #8
 80095c0:	9103      	str	r1, [sp, #12]
 80095c2:	781d      	ldrb	r5, [r3, #0]
 80095c4:	4619      	mov	r1, r3
 80095c6:	e47c      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80095c8:	9903      	ldr	r1, [sp, #12]
 80095ca:	f041 0101 	orr.w	r1, r1, #1
 80095ce:	9103      	str	r1, [sp, #12]
 80095d0:	781d      	ldrb	r5, [r3, #0]
 80095d2:	4619      	mov	r1, r3
 80095d4:	e475      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80095d6:	9903      	ldr	r1, [sp, #12]
 80095d8:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80095dc:	9103      	str	r1, [sp, #12]
 80095de:	781d      	ldrb	r5, [r3, #0]
 80095e0:	4619      	mov	r1, r3
 80095e2:	e46e      	b.n	8008ec2 <_svfprintf_r+0xaa>
 80095e4:	0800d548 	.word	0x0800d548
 80095e8:	0800d534 	.word	0x0800d534
 80095ec:	0800d504 	.word	0x0800d504
 80095f0:	0800d514 	.word	0x0800d514
 80095f4:	9306      	str	r3, [sp, #24]
 80095f6:	9b03      	ldr	r3, [sp, #12]
 80095f8:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 80095fc:	f013 0f08 	tst.w	r3, #8
 8009600:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009602:	46d3      	mov	fp, sl
 8009604:	f103 0907 	add.w	r9, r3, #7
 8009608:	f000 8386 	beq.w	8009d18 <_svfprintf_r+0xf00>
 800960c:	f029 0307 	bic.w	r3, r9, #7
 8009610:	ed93 7b00 	vldr	d7, [r3]
 8009614:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8009618:	f103 0208 	add.w	r2, r3, #8
 800961c:	920a      	str	r2, [sp, #40]	; 0x28
 800961e:	ed9d 0b10 	vldr	d0, [sp, #64]	; 0x40
 8009622:	f002 fc21 	bl	800be68 <__fpclassifyd>
 8009626:	2801      	cmp	r0, #1
 8009628:	f040 835a 	bne.w	8009ce0 <_svfprintf_r+0xec8>
 800962c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 8009630:	2200      	movs	r2, #0
 8009632:	2300      	movs	r3, #0
 8009634:	f7f7 fb4c 	bl	8000cd0 <__aeabi_dcmplt>
 8009638:	2800      	cmp	r0, #0
 800963a:	f040 856b 	bne.w	800a114 <_svfprintf_r+0x12fc>
 800963e:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8009642:	9b03      	ldr	r3, [sp, #12]
 8009644:	4abd      	ldr	r2, [pc, #756]	; (800993c <_svfprintf_r+0xb24>)
 8009646:	f8df e300 	ldr.w	lr, [pc, #768]	; 8009948 <_svfprintf_r+0xb30>
 800964a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800964e:	9303      	str	r3, [sp, #12]
 8009650:	4613      	mov	r3, r2
 8009652:	2103      	movs	r1, #3
 8009654:	2000      	movs	r0, #0
 8009656:	2d47      	cmp	r5, #71	; 0x47
 8009658:	bfd8      	it	le
 800965a:	4673      	movle	r3, lr
 800965c:	9105      	str	r1, [sp, #20]
 800965e:	900d      	str	r0, [sp, #52]	; 0x34
 8009660:	930c      	str	r3, [sp, #48]	; 0x30
 8009662:	9109      	str	r1, [sp, #36]	; 0x24
 8009664:	900e      	str	r0, [sp, #56]	; 0x38
 8009666:	e4f9      	b.n	800905c <_svfprintf_r+0x244>
 8009668:	980a      	ldr	r0, [sp, #40]	; 0x28
 800966a:	9903      	ldr	r1, [sp, #12]
 800966c:	9306      	str	r3, [sp, #24]
 800966e:	2230      	movs	r2, #48	; 0x30
 8009670:	6803      	ldr	r3, [r0, #0]
 8009672:	f88d 2068 	strb.w	r2, [sp, #104]	; 0x68
 8009676:	4602      	mov	r2, r0
 8009678:	2578      	movs	r5, #120	; 0x78
 800967a:	f041 0102 	orr.w	r1, r1, #2
 800967e:	3204      	adds	r2, #4
 8009680:	4698      	mov	r8, r3
 8009682:	4baf      	ldr	r3, [pc, #700]	; (8009940 <_svfprintf_r+0xb28>)
 8009684:	9312      	str	r3, [sp, #72]	; 0x48
 8009686:	9103      	str	r1, [sp, #12]
 8009688:	920a      	str	r2, [sp, #40]	; 0x28
 800968a:	f04f 0900 	mov.w	r9, #0
 800968e:	f88d 5069 	strb.w	r5, [sp, #105]	; 0x69
 8009692:	2302      	movs	r3, #2
 8009694:	e4a7      	b.n	8008fe6 <_svfprintf_r+0x1ce>
 8009696:	9306      	str	r3, [sp, #24]
 8009698:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
 800969c:	2d00      	cmp	r5, #0
 800969e:	f000 83d1 	beq.w	8009e44 <_svfprintf_r+0x102c>
 80096a2:	2300      	movs	r3, #0
 80096a4:	2201      	movs	r2, #1
 80096a6:	469c      	mov	ip, r3
 80096a8:	9205      	str	r2, [sp, #20]
 80096aa:	f88d 5090 	strb.w	r5, [sp, #144]	; 0x90
 80096ae:	e77a      	b.n	80095a6 <_svfprintf_r+0x78e>
 80096b0:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80096b4:	e535      	b.n	8009122 <_svfprintf_r+0x30a>
 80096b6:	2b01      	cmp	r3, #1
 80096b8:	f47f acad 	bne.w	8009016 <_svfprintf_r+0x1fe>
 80096bc:	f1b9 0f00 	cmp.w	r9, #0
 80096c0:	bf08      	it	eq
 80096c2:	f1b8 0f0a 	cmpeq.w	r8, #10
 80096c6:	f080 820d 	bcs.w	8009ae4 <_svfprintf_r+0xccc>
 80096ca:	f10d 0bf8 	add.w	fp, sp, #248	; 0xf8
 80096ce:	f108 0830 	add.w	r8, r8, #48	; 0x30
 80096d2:	f80b 8d41 	strb.w	r8, [fp, #-65]!
 80096d6:	ebcb 0307 	rsb	r3, fp, r7
 80096da:	9309      	str	r3, [sp, #36]	; 0x24
 80096dc:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 80096e0:	e4b4      	b.n	800904c <_svfprintf_r+0x234>
 80096e2:	2d65      	cmp	r5, #101	; 0x65
 80096e4:	f340 80a0 	ble.w	8009828 <_svfprintf_r+0xa10>
 80096e8:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 80096ec:	2200      	movs	r2, #0
 80096ee:	2300      	movs	r3, #0
 80096f0:	f7f7 fae4 	bl	8000cbc <__aeabi_dcmpeq>
 80096f4:	2800      	cmp	r0, #0
 80096f6:	f000 8144 	beq.w	8009982 <_svfprintf_r+0xb6a>
 80096fa:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80096fc:	4a91      	ldr	r2, [pc, #580]	; (8009944 <_svfprintf_r+0xb2c>)
 80096fe:	6022      	str	r2, [r4, #0]
 8009700:	3301      	adds	r3, #1
 8009702:	f10b 0b01 	add.w	fp, fp, #1
 8009706:	2201      	movs	r2, #1
 8009708:	2b07      	cmp	r3, #7
 800970a:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800970e:	9322      	str	r3, [sp, #136]	; 0x88
 8009710:	6062      	str	r2, [r4, #4]
 8009712:	f300 833f 	bgt.w	8009d94 <_svfprintf_r+0xf7c>
 8009716:	3408      	adds	r4, #8
 8009718:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800971a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800971c:	4293      	cmp	r3, r2
 800971e:	db03      	blt.n	8009728 <_svfprintf_r+0x910>
 8009720:	9b03      	ldr	r3, [sp, #12]
 8009722:	07da      	lsls	r2, r3, #31
 8009724:	f57f ad7b 	bpl.w	800921e <_svfprintf_r+0x406>
 8009728:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800972a:	9914      	ldr	r1, [sp, #80]	; 0x50
 800972c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800972e:	6022      	str	r2, [r4, #0]
 8009730:	3301      	adds	r3, #1
 8009732:	448b      	add	fp, r1
 8009734:	2b07      	cmp	r3, #7
 8009736:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800973a:	6061      	str	r1, [r4, #4]
 800973c:	9322      	str	r3, [sp, #136]	; 0x88
 800973e:	f300 839b 	bgt.w	8009e78 <_svfprintf_r+0x1060>
 8009742:	3408      	adds	r4, #8
 8009744:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009746:	1e5d      	subs	r5, r3, #1
 8009748:	2d00      	cmp	r5, #0
 800974a:	f77f ad68 	ble.w	800921e <_svfprintf_r+0x406>
 800974e:	2d10      	cmp	r5, #16
 8009750:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009752:	f8df 91f8 	ldr.w	r9, [pc, #504]	; 800994c <_svfprintf_r+0xb34>
 8009756:	f340 81b9 	ble.w	8009acc <_svfprintf_r+0xcb4>
 800975a:	f04f 0810 	mov.w	r8, #16
 800975e:	465a      	mov	r2, fp
 8009760:	f8dd a010 	ldr.w	sl, [sp, #16]
 8009764:	e004      	b.n	8009770 <_svfprintf_r+0x958>
 8009766:	3408      	adds	r4, #8
 8009768:	3d10      	subs	r5, #16
 800976a:	2d10      	cmp	r5, #16
 800976c:	f340 81ad 	ble.w	8009aca <_svfprintf_r+0xcb2>
 8009770:	3301      	adds	r3, #1
 8009772:	3210      	adds	r2, #16
 8009774:	2b07      	cmp	r3, #7
 8009776:	9223      	str	r2, [sp, #140]	; 0x8c
 8009778:	9322      	str	r3, [sp, #136]	; 0x88
 800977a:	f8c4 9000 	str.w	r9, [r4]
 800977e:	f8c4 8004 	str.w	r8, [r4, #4]
 8009782:	ddf0      	ble.n	8009766 <_svfprintf_r+0x94e>
 8009784:	4650      	mov	r0, sl
 8009786:	4631      	mov	r1, r6
 8009788:	aa21      	add	r2, sp, #132	; 0x84
 800978a:	f002 fbc9 	bl	800bf20 <__ssprint_r>
 800978e:	2800      	cmp	r0, #0
 8009790:	f47f ac0a 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009794:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8009796:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009798:	463c      	mov	r4, r7
 800979a:	e7e5      	b.n	8009768 <_svfprintf_r+0x950>
 800979c:	9b08      	ldr	r3, [sp, #32]
 800979e:	9a05      	ldr	r2, [sp, #20]
 80097a0:	ebc2 0a03 	rsb	sl, r2, r3
 80097a4:	f1ba 0f00 	cmp.w	sl, #0
 80097a8:	f77f ace3 	ble.w	8009172 <_svfprintf_r+0x35a>
 80097ac:	f1ba 0f10 	cmp.w	sl, #16
 80097b0:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80097b2:	f8df 9198 	ldr.w	r9, [pc, #408]	; 800994c <_svfprintf_r+0xb34>
 80097b6:	dd2b      	ble.n	8009810 <_svfprintf_r+0x9f8>
 80097b8:	4649      	mov	r1, r9
 80097ba:	465b      	mov	r3, fp
 80097bc:	46a9      	mov	r9, r5
 80097be:	f04f 0810 	mov.w	r8, #16
 80097c2:	f8dd b010 	ldr.w	fp, [sp, #16]
 80097c6:	460d      	mov	r5, r1
 80097c8:	e006      	b.n	80097d8 <_svfprintf_r+0x9c0>
 80097ca:	f1aa 0a10 	sub.w	sl, sl, #16
 80097ce:	f1ba 0f10 	cmp.w	sl, #16
 80097d2:	f104 0408 	add.w	r4, r4, #8
 80097d6:	dd17      	ble.n	8009808 <_svfprintf_r+0x9f0>
 80097d8:	3201      	adds	r2, #1
 80097da:	3310      	adds	r3, #16
 80097dc:	2a07      	cmp	r2, #7
 80097de:	9323      	str	r3, [sp, #140]	; 0x8c
 80097e0:	9222      	str	r2, [sp, #136]	; 0x88
 80097e2:	e884 0120 	stmia.w	r4, {r5, r8}
 80097e6:	ddf0      	ble.n	80097ca <_svfprintf_r+0x9b2>
 80097e8:	4658      	mov	r0, fp
 80097ea:	4631      	mov	r1, r6
 80097ec:	aa21      	add	r2, sp, #132	; 0x84
 80097ee:	f002 fb97 	bl	800bf20 <__ssprint_r>
 80097f2:	2800      	cmp	r0, #0
 80097f4:	f47f abd8 	bne.w	8008fa8 <_svfprintf_r+0x190>
 80097f8:	f1aa 0a10 	sub.w	sl, sl, #16
 80097fc:	f1ba 0f10 	cmp.w	sl, #16
 8009800:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8009802:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8009804:	463c      	mov	r4, r7
 8009806:	dce7      	bgt.n	80097d8 <_svfprintf_r+0x9c0>
 8009808:	469b      	mov	fp, r3
 800980a:	462b      	mov	r3, r5
 800980c:	464d      	mov	r5, r9
 800980e:	4699      	mov	r9, r3
 8009810:	3201      	adds	r2, #1
 8009812:	44d3      	add	fp, sl
 8009814:	2a07      	cmp	r2, #7
 8009816:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800981a:	9222      	str	r2, [sp, #136]	; 0x88
 800981c:	e884 0600 	stmia.w	r4, {r9, sl}
 8009820:	f300 8251 	bgt.w	8009cc6 <_svfprintf_r+0xeae>
 8009824:	3408      	adds	r4, #8
 8009826:	e4a4      	b.n	8009172 <_svfprintf_r+0x35a>
 8009828:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800982a:	9d22      	ldr	r5, [sp, #136]	; 0x88
 800982c:	2b01      	cmp	r3, #1
 800982e:	f340 821f 	ble.w	8009c70 <_svfprintf_r+0xe58>
 8009832:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009834:	6023      	str	r3, [r4, #0]
 8009836:	3501      	adds	r5, #1
 8009838:	f10b 0301 	add.w	r3, fp, #1
 800983c:	2201      	movs	r2, #1
 800983e:	2d07      	cmp	r5, #7
 8009840:	9323      	str	r3, [sp, #140]	; 0x8c
 8009842:	9522      	str	r5, [sp, #136]	; 0x88
 8009844:	6062      	str	r2, [r4, #4]
 8009846:	f300 8225 	bgt.w	8009c94 <_svfprintf_r+0xe7c>
 800984a:	3408      	adds	r4, #8
 800984c:	9914      	ldr	r1, [sp, #80]	; 0x50
 800984e:	6061      	str	r1, [r4, #4]
 8009850:	3501      	adds	r5, #1
 8009852:	eb03 0b01 	add.w	fp, r3, r1
 8009856:	2d07      	cmp	r5, #7
 8009858:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800985a:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800985e:	9522      	str	r5, [sp, #136]	; 0x88
 8009860:	6023      	str	r3, [r4, #0]
 8009862:	f300 8223 	bgt.w	8009cac <_svfprintf_r+0xe94>
 8009866:	3408      	adds	r4, #8
 8009868:	2300      	movs	r3, #0
 800986a:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800986e:	2200      	movs	r2, #0
 8009870:	f7f7 fa24 	bl	8000cbc <__aeabi_dcmpeq>
 8009874:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009876:	2800      	cmp	r0, #0
 8009878:	f040 80dd 	bne.w	8009a36 <_svfprintf_r+0xc1e>
 800987c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800987e:	3b01      	subs	r3, #1
 8009880:	3501      	adds	r5, #1
 8009882:	3201      	adds	r2, #1
 8009884:	449b      	add	fp, r3
 8009886:	2d07      	cmp	r5, #7
 8009888:	9522      	str	r5, [sp, #136]	; 0x88
 800988a:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800988e:	6022      	str	r2, [r4, #0]
 8009890:	6063      	str	r3, [r4, #4]
 8009892:	f300 810d 	bgt.w	8009ab0 <_svfprintf_r+0xc98>
 8009896:	3408      	adds	r4, #8
 8009898:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800989a:	6062      	str	r2, [r4, #4]
 800989c:	3501      	adds	r5, #1
 800989e:	4493      	add	fp, r2
 80098a0:	ab1d      	add	r3, sp, #116	; 0x74
 80098a2:	2d07      	cmp	r5, #7
 80098a4:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 80098a8:	9522      	str	r5, [sp, #136]	; 0x88
 80098aa:	6023      	str	r3, [r4, #0]
 80098ac:	f77f acb6 	ble.w	800921c <_svfprintf_r+0x404>
 80098b0:	9804      	ldr	r0, [sp, #16]
 80098b2:	4631      	mov	r1, r6
 80098b4:	aa21      	add	r2, sp, #132	; 0x84
 80098b6:	f002 fb33 	bl	800bf20 <__ssprint_r>
 80098ba:	2800      	cmp	r0, #0
 80098bc:	f47f ab74 	bne.w	8008fa8 <_svfprintf_r+0x190>
 80098c0:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80098c4:	463c      	mov	r4, r7
 80098c6:	e4aa      	b.n	800921e <_svfprintf_r+0x406>
 80098c8:	2b00      	cmp	r3, #0
 80098ca:	d132      	bne.n	8009932 <_svfprintf_r+0xb1a>
 80098cc:	9b03      	ldr	r3, [sp, #12]
 80098ce:	07d8      	lsls	r0, r3, #31
 80098d0:	d52f      	bpl.n	8009932 <_svfprintf_r+0xb1a>
 80098d2:	f10d 0bf8 	add.w	fp, sp, #248	; 0xf8
 80098d6:	2330      	movs	r3, #48	; 0x30
 80098d8:	f80b 3d41 	strb.w	r3, [fp, #-65]!
 80098dc:	ebcb 0307 	rsb	r3, fp, r7
 80098e0:	9309      	str	r3, [sp, #36]	; 0x24
 80098e2:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 80098e6:	f7ff bbb1 	b.w	800904c <_svfprintf_r+0x234>
 80098ea:	9804      	ldr	r0, [sp, #16]
 80098ec:	4631      	mov	r1, r6
 80098ee:	aa21      	add	r2, sp, #132	; 0x84
 80098f0:	f002 fb16 	bl	800bf20 <__ssprint_r>
 80098f4:	2800      	cmp	r0, #0
 80098f6:	f47f ab57 	bne.w	8008fa8 <_svfprintf_r+0x190>
 80098fa:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 80098fe:	463c      	mov	r4, r7
 8009900:	e47b      	b.n	80091fa <_svfprintf_r+0x3e2>
 8009902:	9804      	ldr	r0, [sp, #16]
 8009904:	4631      	mov	r1, r6
 8009906:	aa21      	add	r2, sp, #132	; 0x84
 8009908:	f002 fb0a 	bl	800bf20 <__ssprint_r>
 800990c:	2800      	cmp	r0, #0
 800990e:	f47f ab4b 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009912:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009916:	463c      	mov	r4, r7
 8009918:	e427      	b.n	800916a <_svfprintf_r+0x352>
 800991a:	9804      	ldr	r0, [sp, #16]
 800991c:	4631      	mov	r1, r6
 800991e:	aa21      	add	r2, sp, #132	; 0x84
 8009920:	f002 fafe 	bl	800bf20 <__ssprint_r>
 8009924:	2800      	cmp	r0, #0
 8009926:	f47f ab3f 	bne.w	8008fa8 <_svfprintf_r+0x190>
 800992a:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 800992e:	463c      	mov	r4, r7
 8009930:	e40a      	b.n	8009148 <_svfprintf_r+0x330>
 8009932:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 8009936:	970c      	str	r7, [sp, #48]	; 0x30
 8009938:	f7ff bb88 	b.w	800904c <_svfprintf_r+0x234>
 800993c:	0800d528 	.word	0x0800d528
 8009940:	0800d548 	.word	0x0800d548
 8009944:	0800cda0 	.word	0x0800cda0
 8009948:	0800d524 	.word	0x0800d524
 800994c:	0800d504 	.word	0x0800d504
 8009950:	9812      	ldr	r0, [sp, #72]	; 0x48
 8009952:	46bb      	mov	fp, r7
 8009954:	ea4f 1318 	mov.w	r3, r8, lsr #4
 8009958:	f008 010f 	and.w	r1, r8, #15
 800995c:	ea43 7309 	orr.w	r3, r3, r9, lsl #28
 8009960:	ea4f 1219 	mov.w	r2, r9, lsr #4
 8009964:	4698      	mov	r8, r3
 8009966:	4691      	mov	r9, r2
 8009968:	5c43      	ldrb	r3, [r0, r1]
 800996a:	f80b 3d01 	strb.w	r3, [fp, #-1]!
 800996e:	ea58 0309 	orrs.w	r3, r8, r9
 8009972:	d1ef      	bne.n	8009954 <_svfprintf_r+0xb3c>
 8009974:	465b      	mov	r3, fp
 8009976:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 800997a:	1afb      	subs	r3, r7, r3
 800997c:	9309      	str	r3, [sp, #36]	; 0x24
 800997e:	f7ff bb65 	b.w	800904c <_svfprintf_r+0x234>
 8009982:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 8009984:	2d00      	cmp	r5, #0
 8009986:	f340 8211 	ble.w	8009dac <_svfprintf_r+0xf94>
 800998a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800998c:	990e      	ldr	r1, [sp, #56]	; 0x38
 800998e:	428a      	cmp	r2, r1
 8009990:	4613      	mov	r3, r2
 8009992:	bfa8      	it	ge
 8009994:	460b      	movge	r3, r1
 8009996:	461d      	mov	r5, r3
 8009998:	990c      	ldr	r1, [sp, #48]	; 0x30
 800999a:	2d00      	cmp	r5, #0
 800999c:	eb01 0a02 	add.w	sl, r1, r2
 80099a0:	dd0b      	ble.n	80099ba <_svfprintf_r+0xba2>
 80099a2:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80099a4:	6021      	str	r1, [r4, #0]
 80099a6:	3301      	adds	r3, #1
 80099a8:	44ab      	add	fp, r5
 80099aa:	2b07      	cmp	r3, #7
 80099ac:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 80099b0:	6065      	str	r5, [r4, #4]
 80099b2:	9322      	str	r3, [sp, #136]	; 0x88
 80099b4:	f300 8355 	bgt.w	800a062 <_svfprintf_r+0x124a>
 80099b8:	3408      	adds	r4, #8
 80099ba:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80099bc:	2d00      	cmp	r5, #0
 80099be:	bfa8      	it	ge
 80099c0:	1b5b      	subge	r3, r3, r5
 80099c2:	2b00      	cmp	r3, #0
 80099c4:	461d      	mov	r5, r3
 80099c6:	f340 80f5 	ble.w	8009bb4 <_svfprintf_r+0xd9c>
 80099ca:	2d10      	cmp	r5, #16
 80099cc:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80099ce:	f8df 9608 	ldr.w	r9, [pc, #1544]	; 8009fd8 <_svfprintf_r+0x11c0>
 80099d2:	f340 81d2 	ble.w	8009d7a <_svfprintf_r+0xf62>
 80099d6:	465a      	mov	r2, fp
 80099d8:	f04f 0810 	mov.w	r8, #16
 80099dc:	f8dd b010 	ldr.w	fp, [sp, #16]
 80099e0:	e004      	b.n	80099ec <_svfprintf_r+0xbd4>
 80099e2:	3408      	adds	r4, #8
 80099e4:	3d10      	subs	r5, #16
 80099e6:	2d10      	cmp	r5, #16
 80099e8:	f340 81c6 	ble.w	8009d78 <_svfprintf_r+0xf60>
 80099ec:	3301      	adds	r3, #1
 80099ee:	3210      	adds	r2, #16
 80099f0:	2b07      	cmp	r3, #7
 80099f2:	9223      	str	r2, [sp, #140]	; 0x8c
 80099f4:	9322      	str	r3, [sp, #136]	; 0x88
 80099f6:	f8c4 9000 	str.w	r9, [r4]
 80099fa:	f8c4 8004 	str.w	r8, [r4, #4]
 80099fe:	ddf0      	ble.n	80099e2 <_svfprintf_r+0xbca>
 8009a00:	4658      	mov	r0, fp
 8009a02:	4631      	mov	r1, r6
 8009a04:	aa21      	add	r2, sp, #132	; 0x84
 8009a06:	f002 fa8b 	bl	800bf20 <__ssprint_r>
 8009a0a:	2800      	cmp	r0, #0
 8009a0c:	f47f aacc 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009a10:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8009a12:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009a14:	463c      	mov	r4, r7
 8009a16:	e7e5      	b.n	80099e4 <_svfprintf_r+0xbcc>
 8009a18:	9804      	ldr	r0, [sp, #16]
 8009a1a:	4631      	mov	r1, r6
 8009a1c:	aa21      	add	r2, sp, #132	; 0x84
 8009a1e:	f002 fa7f 	bl	800bf20 <__ssprint_r>
 8009a22:	2800      	cmp	r0, #0
 8009a24:	f47f aac0 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009a28:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8009a2c:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009a30:	463c      	mov	r4, r7
 8009a32:	f7ff bb76 	b.w	8009122 <_svfprintf_r+0x30a>
 8009a36:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 8009a3a:	f1b8 0f00 	cmp.w	r8, #0
 8009a3e:	f77f af2b 	ble.w	8009898 <_svfprintf_r+0xa80>
 8009a42:	f1b8 0f10 	cmp.w	r8, #16
 8009a46:	f8df 9590 	ldr.w	r9, [pc, #1424]	; 8009fd8 <_svfprintf_r+0x11c0>
 8009a4a:	dd25      	ble.n	8009a98 <_svfprintf_r+0xc80>
 8009a4c:	465b      	mov	r3, fp
 8009a4e:	f04f 0a10 	mov.w	sl, #16
 8009a52:	f8dd b010 	ldr.w	fp, [sp, #16]
 8009a56:	e006      	b.n	8009a66 <_svfprintf_r+0xc4e>
 8009a58:	f1a8 0810 	sub.w	r8, r8, #16
 8009a5c:	f1b8 0f10 	cmp.w	r8, #16
 8009a60:	f104 0408 	add.w	r4, r4, #8
 8009a64:	dd17      	ble.n	8009a96 <_svfprintf_r+0xc7e>
 8009a66:	3501      	adds	r5, #1
 8009a68:	3310      	adds	r3, #16
 8009a6a:	2d07      	cmp	r5, #7
 8009a6c:	9323      	str	r3, [sp, #140]	; 0x8c
 8009a6e:	9522      	str	r5, [sp, #136]	; 0x88
 8009a70:	e884 0600 	stmia.w	r4, {r9, sl}
 8009a74:	ddf0      	ble.n	8009a58 <_svfprintf_r+0xc40>
 8009a76:	4658      	mov	r0, fp
 8009a78:	4631      	mov	r1, r6
 8009a7a:	aa21      	add	r2, sp, #132	; 0x84
 8009a7c:	f002 fa50 	bl	800bf20 <__ssprint_r>
 8009a80:	2800      	cmp	r0, #0
 8009a82:	f47f aa91 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009a86:	f1a8 0810 	sub.w	r8, r8, #16
 8009a8a:	f1b8 0f10 	cmp.w	r8, #16
 8009a8e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8009a90:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8009a92:	463c      	mov	r4, r7
 8009a94:	dce7      	bgt.n	8009a66 <_svfprintf_r+0xc4e>
 8009a96:	469b      	mov	fp, r3
 8009a98:	3501      	adds	r5, #1
 8009a9a:	44c3      	add	fp, r8
 8009a9c:	2d07      	cmp	r5, #7
 8009a9e:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009aa2:	9522      	str	r5, [sp, #136]	; 0x88
 8009aa4:	f8c4 9000 	str.w	r9, [r4]
 8009aa8:	f8c4 8004 	str.w	r8, [r4, #4]
 8009aac:	f77f aef3 	ble.w	8009896 <_svfprintf_r+0xa7e>
 8009ab0:	9804      	ldr	r0, [sp, #16]
 8009ab2:	4631      	mov	r1, r6
 8009ab4:	aa21      	add	r2, sp, #132	; 0x84
 8009ab6:	f002 fa33 	bl	800bf20 <__ssprint_r>
 8009aba:	2800      	cmp	r0, #0
 8009abc:	f47f aa74 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009ac0:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009ac4:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8009ac6:	463c      	mov	r4, r7
 8009ac8:	e6e6      	b.n	8009898 <_svfprintf_r+0xa80>
 8009aca:	4693      	mov	fp, r2
 8009acc:	3301      	adds	r3, #1
 8009ace:	44ab      	add	fp, r5
 8009ad0:	2b07      	cmp	r3, #7
 8009ad2:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009ad6:	9322      	str	r3, [sp, #136]	; 0x88
 8009ad8:	f8c4 9000 	str.w	r9, [r4]
 8009adc:	6065      	str	r5, [r4, #4]
 8009ade:	f77f ab9d 	ble.w	800921c <_svfprintf_r+0x404>
 8009ae2:	e6e5      	b.n	80098b0 <_svfprintf_r+0xa98>
 8009ae4:	46bb      	mov	fp, r7
 8009ae6:	f8cd c014 	str.w	ip, [sp, #20]
 8009aea:	4640      	mov	r0, r8
 8009aec:	4649      	mov	r1, r9
 8009aee:	220a      	movs	r2, #10
 8009af0:	2300      	movs	r3, #0
 8009af2:	f7f7 f93d 	bl	8000d70 <__aeabi_uldivmod>
 8009af6:	3230      	adds	r2, #48	; 0x30
 8009af8:	4640      	mov	r0, r8
 8009afa:	4649      	mov	r1, r9
 8009afc:	f80b 2d01 	strb.w	r2, [fp, #-1]!
 8009b00:	2300      	movs	r3, #0
 8009b02:	220a      	movs	r2, #10
 8009b04:	f7f7 f934 	bl	8000d70 <__aeabi_uldivmod>
 8009b08:	4680      	mov	r8, r0
 8009b0a:	4689      	mov	r9, r1
 8009b0c:	ea58 0309 	orrs.w	r3, r8, r9
 8009b10:	d1eb      	bne.n	8009aea <_svfprintf_r+0xcd2>
 8009b12:	465b      	mov	r3, fp
 8009b14:	1afb      	subs	r3, r7, r3
 8009b16:	f8dd c014 	ldr.w	ip, [sp, #20]
 8009b1a:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 8009b1e:	9309      	str	r3, [sp, #36]	; 0x24
 8009b20:	f7ff ba94 	b.w	800904c <_svfprintf_r+0x234>
 8009b24:	2b30      	cmp	r3, #48	; 0x30
 8009b26:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009b28:	f43f af27 	beq.w	800997a <_svfprintf_r+0xb62>
 8009b2c:	3b01      	subs	r3, #1
 8009b2e:	461a      	mov	r2, r3
 8009b30:	930c      	str	r3, [sp, #48]	; 0x30
 8009b32:	1aba      	subs	r2, r7, r2
 8009b34:	2330      	movs	r3, #48	; 0x30
 8009b36:	9209      	str	r2, [sp, #36]	; 0x24
 8009b38:	f801 3c01 	strb.w	r3, [r1, #-1]
 8009b3c:	f7ff ba86 	b.w	800904c <_svfprintf_r+0x234>
 8009b40:	990a      	ldr	r1, [sp, #40]	; 0x28
 8009b42:	680a      	ldr	r2, [r1, #0]
 8009b44:	3104      	adds	r1, #4
 8009b46:	910a      	str	r1, [sp, #40]	; 0x28
 8009b48:	4690      	mov	r8, r2
 8009b4a:	f04f 0900 	mov.w	r9, #0
 8009b4e:	f7ff ba4a 	b.w	8008fe6 <_svfprintf_r+0x1ce>
 8009b52:	990a      	ldr	r1, [sp, #40]	; 0x28
 8009b54:	680a      	ldr	r2, [r1, #0]
 8009b56:	3104      	adds	r1, #4
 8009b58:	2301      	movs	r3, #1
 8009b5a:	910a      	str	r1, [sp, #40]	; 0x28
 8009b5c:	4690      	mov	r8, r2
 8009b5e:	f04f 0900 	mov.w	r9, #0
 8009b62:	f7ff ba40 	b.w	8008fe6 <_svfprintf_r+0x1ce>
 8009b66:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8009b68:	6813      	ldr	r3, [r2, #0]
 8009b6a:	4698      	mov	r8, r3
 8009b6c:	ea4f 79e3 	mov.w	r9, r3, asr #31
 8009b70:	4613      	mov	r3, r2
 8009b72:	3304      	adds	r3, #4
 8009b74:	4642      	mov	r2, r8
 8009b76:	930a      	str	r3, [sp, #40]	; 0x28
 8009b78:	2a00      	cmp	r2, #0
 8009b7a:	464b      	mov	r3, r9
 8009b7c:	f173 0300 	sbcs.w	r3, r3, #0
 8009b80:	f6bf abf2 	bge.w	8009368 <_svfprintf_r+0x550>
 8009b84:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
 8009b88:	f1d8 0800 	rsbs	r8, r8, #0
 8009b8c:	eb69 0949 	sbc.w	r9, r9, r9, lsl #1
 8009b90:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 8009b94:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8009b98:	2301      	movs	r3, #1
 8009b9a:	f7ff ba2a 	b.w	8008ff2 <_svfprintf_r+0x1da>
 8009b9e:	9804      	ldr	r0, [sp, #16]
 8009ba0:	4631      	mov	r1, r6
 8009ba2:	aa21      	add	r2, sp, #132	; 0x84
 8009ba4:	f002 f9bc 	bl	800bf20 <__ssprint_r>
 8009ba8:	2800      	cmp	r0, #0
 8009baa:	f47f a9fd 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009bae:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009bb2:	463c      	mov	r4, r7
 8009bb4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009bb6:	990e      	ldr	r1, [sp, #56]	; 0x38
 8009bb8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8009bba:	440a      	add	r2, r1
 8009bbc:	4690      	mov	r8, r2
 8009bbe:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8009bc0:	4293      	cmp	r3, r2
 8009bc2:	db46      	blt.n	8009c52 <_svfprintf_r+0xe3a>
 8009bc4:	9a03      	ldr	r2, [sp, #12]
 8009bc6:	07d0      	lsls	r0, r2, #31
 8009bc8:	d443      	bmi.n	8009c52 <_svfprintf_r+0xe3a>
 8009bca:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8009bcc:	ebc8 050a 	rsb	r5, r8, sl
 8009bd0:	1ad3      	subs	r3, r2, r3
 8009bd2:	429d      	cmp	r5, r3
 8009bd4:	bfa8      	it	ge
 8009bd6:	461d      	movge	r5, r3
 8009bd8:	2d00      	cmp	r5, #0
 8009bda:	dd0c      	ble.n	8009bf6 <_svfprintf_r+0xdde>
 8009bdc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8009bde:	f8c4 8000 	str.w	r8, [r4]
 8009be2:	3201      	adds	r2, #1
 8009be4:	44ab      	add	fp, r5
 8009be6:	2a07      	cmp	r2, #7
 8009be8:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009bec:	6065      	str	r5, [r4, #4]
 8009bee:	9222      	str	r2, [sp, #136]	; 0x88
 8009bf0:	f300 826f 	bgt.w	800a0d2 <_svfprintf_r+0x12ba>
 8009bf4:	3408      	adds	r4, #8
 8009bf6:	2d00      	cmp	r5, #0
 8009bf8:	bfac      	ite	ge
 8009bfa:	1b5d      	subge	r5, r3, r5
 8009bfc:	461d      	movlt	r5, r3
 8009bfe:	2d00      	cmp	r5, #0
 8009c00:	f77f ab0d 	ble.w	800921e <_svfprintf_r+0x406>
 8009c04:	2d10      	cmp	r5, #16
 8009c06:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009c08:	f8df 93cc 	ldr.w	r9, [pc, #972]	; 8009fd8 <_svfprintf_r+0x11c0>
 8009c0c:	f77f af5e 	ble.w	8009acc <_svfprintf_r+0xcb4>
 8009c10:	f04f 0810 	mov.w	r8, #16
 8009c14:	465a      	mov	r2, fp
 8009c16:	f8dd a010 	ldr.w	sl, [sp, #16]
 8009c1a:	e004      	b.n	8009c26 <_svfprintf_r+0xe0e>
 8009c1c:	3408      	adds	r4, #8
 8009c1e:	3d10      	subs	r5, #16
 8009c20:	2d10      	cmp	r5, #16
 8009c22:	f77f af52 	ble.w	8009aca <_svfprintf_r+0xcb2>
 8009c26:	3301      	adds	r3, #1
 8009c28:	3210      	adds	r2, #16
 8009c2a:	2b07      	cmp	r3, #7
 8009c2c:	9223      	str	r2, [sp, #140]	; 0x8c
 8009c2e:	9322      	str	r3, [sp, #136]	; 0x88
 8009c30:	f8c4 9000 	str.w	r9, [r4]
 8009c34:	f8c4 8004 	str.w	r8, [r4, #4]
 8009c38:	ddf0      	ble.n	8009c1c <_svfprintf_r+0xe04>
 8009c3a:	4650      	mov	r0, sl
 8009c3c:	4631      	mov	r1, r6
 8009c3e:	aa21      	add	r2, sp, #132	; 0x84
 8009c40:	f002 f96e 	bl	800bf20 <__ssprint_r>
 8009c44:	2800      	cmp	r0, #0
 8009c46:	f47f a9af 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009c4a:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8009c4c:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009c4e:	463c      	mov	r4, r7
 8009c50:	e7e5      	b.n	8009c1e <_svfprintf_r+0xe06>
 8009c52:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8009c54:	9814      	ldr	r0, [sp, #80]	; 0x50
 8009c56:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8009c58:	6021      	str	r1, [r4, #0]
 8009c5a:	3201      	adds	r2, #1
 8009c5c:	4483      	add	fp, r0
 8009c5e:	2a07      	cmp	r2, #7
 8009c60:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009c64:	6060      	str	r0, [r4, #4]
 8009c66:	9222      	str	r2, [sp, #136]	; 0x88
 8009c68:	f300 8207 	bgt.w	800a07a <_svfprintf_r+0x1262>
 8009c6c:	3408      	adds	r4, #8
 8009c6e:	e7ac      	b.n	8009bca <_svfprintf_r+0xdb2>
 8009c70:	9b03      	ldr	r3, [sp, #12]
 8009c72:	07d9      	lsls	r1, r3, #31
 8009c74:	f53f addd 	bmi.w	8009832 <_svfprintf_r+0xa1a>
 8009c78:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009c7a:	6023      	str	r3, [r4, #0]
 8009c7c:	3501      	adds	r5, #1
 8009c7e:	f10b 0b01 	add.w	fp, fp, #1
 8009c82:	2301      	movs	r3, #1
 8009c84:	2d07      	cmp	r5, #7
 8009c86:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009c8a:	9522      	str	r5, [sp, #136]	; 0x88
 8009c8c:	6063      	str	r3, [r4, #4]
 8009c8e:	f77f ae02 	ble.w	8009896 <_svfprintf_r+0xa7e>
 8009c92:	e70d      	b.n	8009ab0 <_svfprintf_r+0xc98>
 8009c94:	9804      	ldr	r0, [sp, #16]
 8009c96:	4631      	mov	r1, r6
 8009c98:	aa21      	add	r2, sp, #132	; 0x84
 8009c9a:	f002 f941 	bl	800bf20 <__ssprint_r>
 8009c9e:	2800      	cmp	r0, #0
 8009ca0:	f47f a982 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009ca4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8009ca6:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8009ca8:	463c      	mov	r4, r7
 8009caa:	e5cf      	b.n	800984c <_svfprintf_r+0xa34>
 8009cac:	9804      	ldr	r0, [sp, #16]
 8009cae:	4631      	mov	r1, r6
 8009cb0:	aa21      	add	r2, sp, #132	; 0x84
 8009cb2:	f002 f935 	bl	800bf20 <__ssprint_r>
 8009cb6:	2800      	cmp	r0, #0
 8009cb8:	f47f a976 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009cbc:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009cc0:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8009cc2:	463c      	mov	r4, r7
 8009cc4:	e5d0      	b.n	8009868 <_svfprintf_r+0xa50>
 8009cc6:	9804      	ldr	r0, [sp, #16]
 8009cc8:	4631      	mov	r1, r6
 8009cca:	aa21      	add	r2, sp, #132	; 0x84
 8009ccc:	f002 f928 	bl	800bf20 <__ssprint_r>
 8009cd0:	2800      	cmp	r0, #0
 8009cd2:	f47f a969 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009cd6:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009cda:	463c      	mov	r4, r7
 8009cdc:	f7ff ba49 	b.w	8009172 <_svfprintf_r+0x35a>
 8009ce0:	ed9d 0b10 	vldr	d0, [sp, #64]	; 0x40
 8009ce4:	f002 f8c0 	bl	800be68 <__fpclassifyd>
 8009ce8:	2800      	cmp	r0, #0
 8009cea:	f040 80d1 	bne.w	8009e90 <_svfprintf_r+0x1078>
 8009cee:	4686      	mov	lr, r0
 8009cf0:	4ab6      	ldr	r2, [pc, #728]	; (8009fcc <_svfprintf_r+0x11b4>)
 8009cf2:	4bb7      	ldr	r3, [pc, #732]	; (8009fd0 <_svfprintf_r+0x11b8>)
 8009cf4:	900d      	str	r0, [sp, #52]	; 0x34
 8009cf6:	9803      	ldr	r0, [sp, #12]
 8009cf8:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8009cfc:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
 8009d00:	2103      	movs	r1, #3
 8009d02:	f020 0080 	bic.w	r0, r0, #128	; 0x80
 8009d06:	2d47      	cmp	r5, #71	; 0x47
 8009d08:	bfd8      	it	le
 8009d0a:	461a      	movle	r2, r3
 8009d0c:	9105      	str	r1, [sp, #20]
 8009d0e:	9003      	str	r0, [sp, #12]
 8009d10:	920c      	str	r2, [sp, #48]	; 0x30
 8009d12:	9109      	str	r1, [sp, #36]	; 0x24
 8009d14:	f7ff b9a2 	b.w	800905c <_svfprintf_r+0x244>
 8009d18:	f029 0907 	bic.w	r9, r9, #7
 8009d1c:	ed99 7b00 	vldr	d7, [r9]
 8009d20:	f109 0308 	add.w	r3, r9, #8
 8009d24:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 8009d28:	930a      	str	r3, [sp, #40]	; 0x28
 8009d2a:	e478      	b.n	800961e <_svfprintf_r+0x806>
 8009d2c:	9b03      	ldr	r3, [sp, #12]
 8009d2e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8009d30:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009d34:	4613      	mov	r3, r2
 8009d36:	f43f ac1f 	beq.w	8009578 <_svfprintf_r+0x760>
 8009d3a:	3304      	adds	r3, #4
 8009d3c:	f8b2 8000 	ldrh.w	r8, [r2]
 8009d40:	930a      	str	r3, [sp, #40]	; 0x28
 8009d42:	f04f 0900 	mov.w	r9, #0
 8009d46:	f7ff bb28 	b.w	800939a <_svfprintf_r+0x582>
 8009d4a:	9b03      	ldr	r3, [sp, #12]
 8009d4c:	06db      	lsls	r3, r3, #27
 8009d4e:	d40b      	bmi.n	8009d68 <_svfprintf_r+0xf50>
 8009d50:	9b03      	ldr	r3, [sp, #12]
 8009d52:	065d      	lsls	r5, r3, #25
 8009d54:	d508      	bpl.n	8009d68 <_svfprintf_r+0xf50>
 8009d56:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8009d58:	6813      	ldr	r3, [r2, #0]
 8009d5a:	3204      	adds	r2, #4
 8009d5c:	920a      	str	r2, [sp, #40]	; 0x28
 8009d5e:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8009d62:	801a      	strh	r2, [r3, #0]
 8009d64:	f7ff b87f 	b.w	8008e66 <_svfprintf_r+0x4e>
 8009d68:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8009d6a:	6813      	ldr	r3, [r2, #0]
 8009d6c:	3204      	adds	r2, #4
 8009d6e:	920a      	str	r2, [sp, #40]	; 0x28
 8009d70:	9a07      	ldr	r2, [sp, #28]
 8009d72:	601a      	str	r2, [r3, #0]
 8009d74:	f7ff b877 	b.w	8008e66 <_svfprintf_r+0x4e>
 8009d78:	4693      	mov	fp, r2
 8009d7a:	3301      	adds	r3, #1
 8009d7c:	44ab      	add	fp, r5
 8009d7e:	2b07      	cmp	r3, #7
 8009d80:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009d84:	9322      	str	r3, [sp, #136]	; 0x88
 8009d86:	f8c4 9000 	str.w	r9, [r4]
 8009d8a:	6065      	str	r5, [r4, #4]
 8009d8c:	f73f af07 	bgt.w	8009b9e <_svfprintf_r+0xd86>
 8009d90:	3408      	adds	r4, #8
 8009d92:	e70f      	b.n	8009bb4 <_svfprintf_r+0xd9c>
 8009d94:	9804      	ldr	r0, [sp, #16]
 8009d96:	4631      	mov	r1, r6
 8009d98:	aa21      	add	r2, sp, #132	; 0x84
 8009d9a:	f002 f8c1 	bl	800bf20 <__ssprint_r>
 8009d9e:	2800      	cmp	r0, #0
 8009da0:	f47f a902 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009da4:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009da8:	463c      	mov	r4, r7
 8009daa:	e4b5      	b.n	8009718 <_svfprintf_r+0x900>
 8009dac:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009dae:	4a89      	ldr	r2, [pc, #548]	; (8009fd4 <_svfprintf_r+0x11bc>)
 8009db0:	6022      	str	r2, [r4, #0]
 8009db2:	3301      	adds	r3, #1
 8009db4:	f10b 0b01 	add.w	fp, fp, #1
 8009db8:	2201      	movs	r2, #1
 8009dba:	2b07      	cmp	r3, #7
 8009dbc:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 8009dc0:	9322      	str	r3, [sp, #136]	; 0x88
 8009dc2:	6062      	str	r2, [r4, #4]
 8009dc4:	f300 80f1 	bgt.w	8009faa <_svfprintf_r+0x1192>
 8009dc8:	3408      	adds	r4, #8
 8009dca:	b92d      	cbnz	r5, 8009dd8 <_svfprintf_r+0xfc0>
 8009dcc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009dce:	b91b      	cbnz	r3, 8009dd8 <_svfprintf_r+0xfc0>
 8009dd0:	9b03      	ldr	r3, [sp, #12]
 8009dd2:	07db      	lsls	r3, r3, #31
 8009dd4:	f57f aa23 	bpl.w	800921e <_svfprintf_r+0x406>
 8009dd8:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009dda:	9814      	ldr	r0, [sp, #80]	; 0x50
 8009ddc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8009dde:	6022      	str	r2, [r4, #0]
 8009de0:	3301      	adds	r3, #1
 8009de2:	eb0b 0100 	add.w	r1, fp, r0
 8009de6:	2b07      	cmp	r3, #7
 8009de8:	9123      	str	r1, [sp, #140]	; 0x8c
 8009dea:	6060      	str	r0, [r4, #4]
 8009dec:	9322      	str	r3, [sp, #136]	; 0x88
 8009dee:	f300 81ef 	bgt.w	800a1d0 <_svfprintf_r+0x13b8>
 8009df2:	f104 0208 	add.w	r2, r4, #8
 8009df6:	426d      	negs	r5, r5
 8009df8:	2d00      	cmp	r5, #0
 8009dfa:	f340 80fa 	ble.w	8009ff2 <_svfprintf_r+0x11da>
 8009dfe:	2d10      	cmp	r5, #16
 8009e00:	f8df 91d4 	ldr.w	r9, [pc, #468]	; 8009fd8 <_svfprintf_r+0x11c0>
 8009e04:	f340 8146 	ble.w	800a094 <_svfprintf_r+0x127c>
 8009e08:	2410      	movs	r4, #16
 8009e0a:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8009e0e:	e004      	b.n	8009e1a <_svfprintf_r+0x1002>
 8009e10:	3208      	adds	r2, #8
 8009e12:	3d10      	subs	r5, #16
 8009e14:	2d10      	cmp	r5, #16
 8009e16:	f340 813d 	ble.w	800a094 <_svfprintf_r+0x127c>
 8009e1a:	3301      	adds	r3, #1
 8009e1c:	3110      	adds	r1, #16
 8009e1e:	2b07      	cmp	r3, #7
 8009e20:	9123      	str	r1, [sp, #140]	; 0x8c
 8009e22:	9322      	str	r3, [sp, #136]	; 0x88
 8009e24:	f8c2 9000 	str.w	r9, [r2]
 8009e28:	6054      	str	r4, [r2, #4]
 8009e2a:	ddf1      	ble.n	8009e10 <_svfprintf_r+0xff8>
 8009e2c:	4640      	mov	r0, r8
 8009e2e:	4631      	mov	r1, r6
 8009e30:	aa21      	add	r2, sp, #132	; 0x84
 8009e32:	f002 f875 	bl	800bf20 <__ssprint_r>
 8009e36:	2800      	cmp	r0, #0
 8009e38:	f47f a8b6 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009e3c:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8009e3e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009e40:	463a      	mov	r2, r7
 8009e42:	e7e6      	b.n	8009e12 <_svfprintf_r+0xffa>
 8009e44:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8009e46:	46b1      	mov	r9, r6
 8009e48:	2b00      	cmp	r3, #0
 8009e4a:	f43f a8ae 	beq.w	8008faa <_svfprintf_r+0x192>
 8009e4e:	9804      	ldr	r0, [sp, #16]
 8009e50:	4631      	mov	r1, r6
 8009e52:	aa21      	add	r2, sp, #132	; 0x84
 8009e54:	f002 f864 	bl	800bf20 <__ssprint_r>
 8009e58:	f7ff b8a7 	b.w	8008faa <_svfprintf_r+0x192>
 8009e5c:	f041 0120 	orr.w	r1, r1, #32
 8009e60:	9103      	str	r1, [sp, #12]
 8009e62:	785d      	ldrb	r5, [r3, #1]
 8009e64:	1c59      	adds	r1, r3, #1
 8009e66:	f7ff b82c 	b.w	8008ec2 <_svfprintf_r+0xaa>
 8009e6a:	9808      	ldr	r0, [sp, #32]
 8009e6c:	910a      	str	r1, [sp, #40]	; 0x28
 8009e6e:	4240      	negs	r0, r0
 8009e70:	9008      	str	r0, [sp, #32]
 8009e72:	4619      	mov	r1, r3
 8009e74:	f7ff ba29 	b.w	80092ca <_svfprintf_r+0x4b2>
 8009e78:	9804      	ldr	r0, [sp, #16]
 8009e7a:	4631      	mov	r1, r6
 8009e7c:	aa21      	add	r2, sp, #132	; 0x84
 8009e7e:	f002 f84f 	bl	800bf20 <__ssprint_r>
 8009e82:	2800      	cmp	r0, #0
 8009e84:	f47f a890 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009e88:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009e8c:	463c      	mov	r4, r7
 8009e8e:	e459      	b.n	8009744 <_svfprintf_r+0x92c>
 8009e90:	f025 0320 	bic.w	r3, r5, #32
 8009e94:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
 8009e98:	9305      	str	r3, [sp, #20]
 8009e9a:	f000 8093 	beq.w	8009fc4 <_svfprintf_r+0x11ac>
 8009e9e:	2b47      	cmp	r3, #71	; 0x47
 8009ea0:	d105      	bne.n	8009eae <_svfprintf_r+0x1096>
 8009ea2:	f1ba 0f00 	cmp.w	sl, #0
 8009ea6:	bf14      	ite	ne
 8009ea8:	46d3      	movne	fp, sl
 8009eaa:	f04f 0b01 	moveq.w	fp, #1
 8009eae:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8009eb0:	9a03      	ldr	r2, [sp, #12]
 8009eb2:	2b00      	cmp	r3, #0
 8009eb4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8009eb8:	920b      	str	r2, [sp, #44]	; 0x2c
 8009eba:	f2c0 81a4 	blt.w	800a206 <_svfprintf_r+0x13ee>
 8009ebe:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 8009ec2:	ed8d 7b16 	vstr	d7, [sp, #88]	; 0x58
 8009ec6:	f04f 0a00 	mov.w	sl, #0
 8009eca:	2d66      	cmp	r5, #102	; 0x66
 8009ecc:	f000 80ac 	beq.w	800a028 <_svfprintf_r+0x1210>
 8009ed0:	2d46      	cmp	r5, #70	; 0x46
 8009ed2:	f000 80a9 	beq.w	800a028 <_svfprintf_r+0x1210>
 8009ed6:	9b05      	ldr	r3, [sp, #20]
 8009ed8:	9804      	ldr	r0, [sp, #16]
 8009eda:	2b45      	cmp	r3, #69	; 0x45
 8009edc:	bf0c      	ite	eq
 8009ede:	f10b 0901 	addeq.w	r9, fp, #1
 8009ee2:	46d9      	movne	r9, fp
 8009ee4:	aa1c      	add	r2, sp, #112	; 0x70
 8009ee6:	ab1f      	add	r3, sp, #124	; 0x7c
 8009ee8:	e88d 000c 	stmia.w	sp, {r2, r3}
 8009eec:	ed9d 0b16 	vldr	d0, [sp, #88]	; 0x58
 8009ef0:	2102      	movs	r1, #2
 8009ef2:	464a      	mov	r2, r9
 8009ef4:	ab1b      	add	r3, sp, #108	; 0x6c
 8009ef6:	f000 fa8b 	bl	800a410 <_dtoa_r>
 8009efa:	2d67      	cmp	r5, #103	; 0x67
 8009efc:	900c      	str	r0, [sp, #48]	; 0x30
 8009efe:	d002      	beq.n	8009f06 <_svfprintf_r+0x10ee>
 8009f00:	2d47      	cmp	r5, #71	; 0x47
 8009f02:	f040 809f 	bne.w	800a044 <_svfprintf_r+0x122c>
 8009f06:	9b03      	ldr	r3, [sp, #12]
 8009f08:	07db      	lsls	r3, r3, #31
 8009f0a:	f140 8192 	bpl.w	800a232 <_svfprintf_r+0x141a>
 8009f0e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8009f10:	eb03 0809 	add.w	r8, r3, r9
 8009f14:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 8009f18:	2200      	movs	r2, #0
 8009f1a:	2300      	movs	r3, #0
 8009f1c:	f7f6 fece 	bl	8000cbc <__aeabi_dcmpeq>
 8009f20:	2800      	cmp	r0, #0
 8009f22:	f040 80fd 	bne.w	800a120 <_svfprintf_r+0x1308>
 8009f26:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8009f28:	4598      	cmp	r8, r3
 8009f2a:	d906      	bls.n	8009f3a <_svfprintf_r+0x1122>
 8009f2c:	2130      	movs	r1, #48	; 0x30
 8009f2e:	1c5a      	adds	r2, r3, #1
 8009f30:	921f      	str	r2, [sp, #124]	; 0x7c
 8009f32:	7019      	strb	r1, [r3, #0]
 8009f34:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8009f36:	4598      	cmp	r8, r3
 8009f38:	d8f9      	bhi.n	8009f2e <_svfprintf_r+0x1116>
 8009f3a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009f3c:	1a9b      	subs	r3, r3, r2
 8009f3e:	930f      	str	r3, [sp, #60]	; 0x3c
 8009f40:	9b05      	ldr	r3, [sp, #20]
 8009f42:	2b47      	cmp	r3, #71	; 0x47
 8009f44:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8009f46:	f000 80de 	beq.w	800a106 <_svfprintf_r+0x12ee>
 8009f4a:	2d65      	cmp	r5, #101	; 0x65
 8009f4c:	f340 80f8 	ble.w	800a140 <_svfprintf_r+0x1328>
 8009f50:	2d66      	cmp	r5, #102	; 0x66
 8009f52:	930e      	str	r3, [sp, #56]	; 0x38
 8009f54:	f000 8160 	beq.w	800a218 <_svfprintf_r+0x1400>
 8009f58:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8009f5a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8009f5c:	4293      	cmp	r3, r2
 8009f5e:	f300 8144 	bgt.w	800a1ea <_svfprintf_r+0x13d2>
 8009f62:	9b03      	ldr	r3, [sp, #12]
 8009f64:	07d9      	lsls	r1, r3, #31
 8009f66:	f100 8166 	bmi.w	800a236 <_svfprintf_r+0x141e>
 8009f6a:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8009f6e:	9209      	str	r2, [sp, #36]	; 0x24
 8009f70:	f1ba 0f00 	cmp.w	sl, #0
 8009f74:	f040 80bc 	bne.w	800a0f0 <_svfprintf_r+0x12d8>
 8009f78:	9305      	str	r3, [sp, #20]
 8009f7a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009f7c:	9303      	str	r3, [sp, #12]
 8009f7e:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8009f82:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 8009f86:	f7ff b869 	b.w	800905c <_svfprintf_r+0x244>
 8009f8a:	9804      	ldr	r0, [sp, #16]
 8009f8c:	2140      	movs	r1, #64	; 0x40
 8009f8e:	f001 f995 	bl	800b2bc <_malloc_r>
 8009f92:	f8c9 0000 	str.w	r0, [r9]
 8009f96:	f8c9 0010 	str.w	r0, [r9, #16]
 8009f9a:	2800      	cmp	r0, #0
 8009f9c:	f000 8197 	beq.w	800a2ce <_svfprintf_r+0x14b6>
 8009fa0:	2340      	movs	r3, #64	; 0x40
 8009fa2:	f8c9 3014 	str.w	r3, [r9, #20]
 8009fa6:	f7fe bf4f 	b.w	8008e48 <_svfprintf_r+0x30>
 8009faa:	9804      	ldr	r0, [sp, #16]
 8009fac:	4631      	mov	r1, r6
 8009fae:	aa21      	add	r2, sp, #132	; 0x84
 8009fb0:	f001 ffb6 	bl	800bf20 <__ssprint_r>
 8009fb4:	2800      	cmp	r0, #0
 8009fb6:	f47e aff7 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009fba:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 8009fbc:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 8009fc0:	463c      	mov	r4, r7
 8009fc2:	e702      	b.n	8009dca <_svfprintf_r+0xfb2>
 8009fc4:	f04f 0b06 	mov.w	fp, #6
 8009fc8:	e771      	b.n	8009eae <_svfprintf_r+0x1096>
 8009fca:	bf00      	nop
 8009fcc:	0800d530 	.word	0x0800d530
 8009fd0:	0800d52c 	.word	0x0800d52c
 8009fd4:	0800cda0 	.word	0x0800cda0
 8009fd8:	0800d504 	.word	0x0800d504
 8009fdc:	9804      	ldr	r0, [sp, #16]
 8009fde:	4631      	mov	r1, r6
 8009fe0:	aa21      	add	r2, sp, #132	; 0x84
 8009fe2:	f001 ff9d 	bl	800bf20 <__ssprint_r>
 8009fe6:	2800      	cmp	r0, #0
 8009fe8:	f47e afde 	bne.w	8008fa8 <_svfprintf_r+0x190>
 8009fec:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8009fee:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8009ff0:	463a      	mov	r2, r7
 8009ff2:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8009ff4:	6054      	str	r4, [r2, #4]
 8009ff6:	3301      	adds	r3, #1
 8009ff8:	eb01 0b04 	add.w	fp, r1, r4
 8009ffc:	2b07      	cmp	r3, #7
 8009ffe:	990c      	ldr	r1, [sp, #48]	; 0x30
 800a000:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800a004:	9322      	str	r3, [sp, #136]	; 0x88
 800a006:	6011      	str	r1, [r2, #0]
 800a008:	f73f ac52 	bgt.w	80098b0 <_svfprintf_r+0xa98>
 800a00c:	f102 0408 	add.w	r4, r2, #8
 800a010:	f7ff b905 	b.w	800921e <_svfprintf_r+0x406>
 800a014:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 800a018:	f001 ff54 	bl	800bec4 <strlen>
 800a01c:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 800a020:	9009      	str	r0, [sp, #36]	; 0x24
 800a022:	4603      	mov	r3, r0
 800a024:	f7ff ba0e 	b.w	8009444 <_svfprintf_r+0x62c>
 800a028:	aa1c      	add	r2, sp, #112	; 0x70
 800a02a:	ab1f      	add	r3, sp, #124	; 0x7c
 800a02c:	e88d 000c 	stmia.w	sp, {r2, r3}
 800a030:	9804      	ldr	r0, [sp, #16]
 800a032:	ed9d 0b16 	vldr	d0, [sp, #88]	; 0x58
 800a036:	2103      	movs	r1, #3
 800a038:	465a      	mov	r2, fp
 800a03a:	ab1b      	add	r3, sp, #108	; 0x6c
 800a03c:	f000 f9e8 	bl	800a410 <_dtoa_r>
 800a040:	46d9      	mov	r9, fp
 800a042:	900c      	str	r0, [sp, #48]	; 0x30
 800a044:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a046:	eb03 0809 	add.w	r8, r3, r9
 800a04a:	9b05      	ldr	r3, [sp, #20]
 800a04c:	2b46      	cmp	r3, #70	; 0x46
 800a04e:	f47f af61 	bne.w	8009f14 <_svfprintf_r+0x10fc>
 800a052:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a054:	781b      	ldrb	r3, [r3, #0]
 800a056:	2b30      	cmp	r3, #48	; 0x30
 800a058:	f000 8103 	beq.w	800a262 <_svfprintf_r+0x144a>
 800a05c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800a05e:	4498      	add	r8, r3
 800a060:	e758      	b.n	8009f14 <_svfprintf_r+0x10fc>
 800a062:	9804      	ldr	r0, [sp, #16]
 800a064:	4631      	mov	r1, r6
 800a066:	aa21      	add	r2, sp, #132	; 0x84
 800a068:	f001 ff5a 	bl	800bf20 <__ssprint_r>
 800a06c:	2800      	cmp	r0, #0
 800a06e:	f47e af9b 	bne.w	8008fa8 <_svfprintf_r+0x190>
 800a072:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 800a076:	463c      	mov	r4, r7
 800a078:	e49f      	b.n	80099ba <_svfprintf_r+0xba2>
 800a07a:	9804      	ldr	r0, [sp, #16]
 800a07c:	4631      	mov	r1, r6
 800a07e:	aa21      	add	r2, sp, #132	; 0x84
 800a080:	f001 ff4e 	bl	800bf20 <__ssprint_r>
 800a084:	2800      	cmp	r0, #0
 800a086:	f47e af8f 	bne.w	8008fa8 <_svfprintf_r+0x190>
 800a08a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800a08c:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 800a090:	463c      	mov	r4, r7
 800a092:	e59a      	b.n	8009bca <_svfprintf_r+0xdb2>
 800a094:	3301      	adds	r3, #1
 800a096:	4429      	add	r1, r5
 800a098:	2b07      	cmp	r3, #7
 800a09a:	9123      	str	r1, [sp, #140]	; 0x8c
 800a09c:	9322      	str	r3, [sp, #136]	; 0x88
 800a09e:	f8c2 9000 	str.w	r9, [r2]
 800a0a2:	6055      	str	r5, [r2, #4]
 800a0a4:	dc9a      	bgt.n	8009fdc <_svfprintf_r+0x11c4>
 800a0a6:	3208      	adds	r2, #8
 800a0a8:	e7a3      	b.n	8009ff2 <_svfprintf_r+0x11da>
 800a0aa:	4653      	mov	r3, sl
 800a0ac:	2b06      	cmp	r3, #6
 800a0ae:	bf28      	it	cs
 800a0b0:	2306      	movcs	r3, #6
 800a0b2:	9309      	str	r3, [sp, #36]	; 0x24
 800a0b4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a0b8:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 800a0bc:	9305      	str	r3, [sp, #20]
 800a0be:	4b87      	ldr	r3, [pc, #540]	; (800a2dc <_svfprintf_r+0x14c4>)
 800a0c0:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 800a0c4:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 800a0c8:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
 800a0cc:	930c      	str	r3, [sp, #48]	; 0x30
 800a0ce:	f7fe bfc5 	b.w	800905c <_svfprintf_r+0x244>
 800a0d2:	9804      	ldr	r0, [sp, #16]
 800a0d4:	4631      	mov	r1, r6
 800a0d6:	aa21      	add	r2, sp, #132	; 0x84
 800a0d8:	f001 ff22 	bl	800bf20 <__ssprint_r>
 800a0dc:	2800      	cmp	r0, #0
 800a0de:	f47e af63 	bne.w	8008fa8 <_svfprintf_r+0x190>
 800a0e2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800a0e4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800a0e6:	f8dd b08c 	ldr.w	fp, [sp, #140]	; 0x8c
 800a0ea:	1ad3      	subs	r3, r2, r3
 800a0ec:	463c      	mov	r4, r7
 800a0ee:	e582      	b.n	8009bf6 <_svfprintf_r+0xdde>
 800a0f0:	9305      	str	r3, [sp, #20]
 800a0f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a0f4:	9303      	str	r3, [sp, #12]
 800a0f6:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
 800a0fa:	2300      	movs	r3, #0
 800a0fc:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 800a100:	930d      	str	r3, [sp, #52]	; 0x34
 800a102:	f7fe bfae 	b.w	8009062 <_svfprintf_r+0x24a>
 800a106:	1cda      	adds	r2, r3, #3
 800a108:	db19      	blt.n	800a13e <_svfprintf_r+0x1326>
 800a10a:	459b      	cmp	fp, r3
 800a10c:	db17      	blt.n	800a13e <_svfprintf_r+0x1326>
 800a10e:	930e      	str	r3, [sp, #56]	; 0x38
 800a110:	2567      	movs	r5, #103	; 0x67
 800a112:	e721      	b.n	8009f58 <_svfprintf_r+0x1140>
 800a114:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
 800a118:	f88d c067 	strb.w	ip, [sp, #103]	; 0x67
 800a11c:	f7ff ba91 	b.w	8009642 <_svfprintf_r+0x82a>
 800a120:	4643      	mov	r3, r8
 800a122:	e70a      	b.n	8009f3a <_svfprintf_r+0x1122>
 800a124:	ea2a 73ea 	bic.w	r3, sl, sl, asr #31
 800a128:	900d      	str	r0, [sp, #52]	; 0x34
 800a12a:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 800a12e:	900e      	str	r0, [sp, #56]	; 0x38
 800a130:	f89d c067 	ldrb.w	ip, [sp, #103]	; 0x67
 800a134:	9305      	str	r3, [sp, #20]
 800a136:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 800a13a:	f7fe bf8f 	b.w	800905c <_svfprintf_r+0x244>
 800a13e:	3d02      	subs	r5, #2
 800a140:	3b01      	subs	r3, #1
 800a142:	2b00      	cmp	r3, #0
 800a144:	931b      	str	r3, [sp, #108]	; 0x6c
 800a146:	bfba      	itte	lt
 800a148:	425b      	neglt	r3, r3
 800a14a:	222d      	movlt	r2, #45	; 0x2d
 800a14c:	222b      	movge	r2, #43	; 0x2b
 800a14e:	2b09      	cmp	r3, #9
 800a150:	f88d 5074 	strb.w	r5, [sp, #116]	; 0x74
 800a154:	f88d 2075 	strb.w	r2, [sp, #117]	; 0x75
 800a158:	dd7b      	ble.n	800a252 <_svfprintf_r+0x143a>
 800a15a:	f10d 0e83 	add.w	lr, sp, #131	; 0x83
 800a15e:	4670      	mov	r0, lr
 800a160:	4a5f      	ldr	r2, [pc, #380]	; (800a2e0 <_svfprintf_r+0x14c8>)
 800a162:	fb82 2103 	smull	r2, r1, r2, r3
 800a166:	17da      	asrs	r2, r3, #31
 800a168:	ebc2 02a1 	rsb	r2, r2, r1, asr #2
 800a16c:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800a170:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
 800a174:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800a178:	2a09      	cmp	r2, #9
 800a17a:	4613      	mov	r3, r2
 800a17c:	f800 1d01 	strb.w	r1, [r0, #-1]!
 800a180:	dcee      	bgt.n	800a160 <_svfprintf_r+0x1348>
 800a182:	4602      	mov	r2, r0
 800a184:	3330      	adds	r3, #48	; 0x30
 800a186:	b2d9      	uxtb	r1, r3
 800a188:	f802 1d01 	strb.w	r1, [r2, #-1]!
 800a18c:	4596      	cmp	lr, r2
 800a18e:	f240 809b 	bls.w	800a2c8 <_svfprintf_r+0x14b0>
 800a192:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 800a196:	4603      	mov	r3, r0
 800a198:	e001      	b.n	800a19e <_svfprintf_r+0x1386>
 800a19a:	f813 1b01 	ldrb.w	r1, [r3], #1
 800a19e:	f802 1b01 	strb.w	r1, [r2], #1
 800a1a2:	4573      	cmp	r3, lr
 800a1a4:	d1f9      	bne.n	800a19a <_svfprintf_r+0x1382>
 800a1a6:	ab21      	add	r3, sp, #132	; 0x84
 800a1a8:	1a1b      	subs	r3, r3, r0
 800a1aa:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 800a1ae:	4413      	add	r3, r2
 800a1b0:	aa1d      	add	r2, sp, #116	; 0x74
 800a1b2:	1a9b      	subs	r3, r3, r2
 800a1b4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800a1b6:	9315      	str	r3, [sp, #84]	; 0x54
 800a1b8:	2a01      	cmp	r2, #1
 800a1ba:	4413      	add	r3, r2
 800a1bc:	9309      	str	r3, [sp, #36]	; 0x24
 800a1be:	dd74      	ble.n	800a2aa <_svfprintf_r+0x1492>
 800a1c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a1c2:	2200      	movs	r2, #0
 800a1c4:	3301      	adds	r3, #1
 800a1c6:	9309      	str	r3, [sp, #36]	; 0x24
 800a1c8:	920e      	str	r2, [sp, #56]	; 0x38
 800a1ca:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a1ce:	e6cf      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a1d0:	9804      	ldr	r0, [sp, #16]
 800a1d2:	4631      	mov	r1, r6
 800a1d4:	aa21      	add	r2, sp, #132	; 0x84
 800a1d6:	f001 fea3 	bl	800bf20 <__ssprint_r>
 800a1da:	2800      	cmp	r0, #0
 800a1dc:	f47e aee4 	bne.w	8008fa8 <_svfprintf_r+0x190>
 800a1e0:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 800a1e2:	9923      	ldr	r1, [sp, #140]	; 0x8c
 800a1e4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800a1e6:	463a      	mov	r2, r7
 800a1e8:	e605      	b.n	8009df6 <_svfprintf_r+0xfde>
 800a1ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a1ec:	2b00      	cmp	r3, #0
 800a1ee:	bfd8      	it	le
 800a1f0:	f1c3 0802 	rsble	r8, r3, #2
 800a1f4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800a1f6:	bfc8      	it	gt
 800a1f8:	f04f 0801 	movgt.w	r8, #1
 800a1fc:	4443      	add	r3, r8
 800a1fe:	9309      	str	r3, [sp, #36]	; 0x24
 800a200:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a204:	e6b4      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a206:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800a20a:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 800a20e:	9016      	str	r0, [sp, #88]	; 0x58
 800a210:	9317      	str	r3, [sp, #92]	; 0x5c
 800a212:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
 800a216:	e658      	b.n	8009eca <_svfprintf_r+0x10b2>
 800a218:	2b00      	cmp	r3, #0
 800a21a:	dd3d      	ble.n	800a298 <_svfprintf_r+0x1480>
 800a21c:	f1bb 0f00 	cmp.w	fp, #0
 800a220:	d10f      	bne.n	800a242 <_svfprintf_r+0x142a>
 800a222:	9b03      	ldr	r3, [sp, #12]
 800a224:	07db      	lsls	r3, r3, #31
 800a226:	d40c      	bmi.n	800a242 <_svfprintf_r+0x142a>
 800a228:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800a22a:	9209      	str	r2, [sp, #36]	; 0x24
 800a22c:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 800a230:	e69e      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a232:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800a234:	e681      	b.n	8009f3a <_svfprintf_r+0x1122>
 800a236:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a238:	3301      	adds	r3, #1
 800a23a:	9309      	str	r3, [sp, #36]	; 0x24
 800a23c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a240:	e696      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a242:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800a244:	f10b 0801 	add.w	r8, fp, #1
 800a248:	4443      	add	r3, r8
 800a24a:	9309      	str	r3, [sp, #36]	; 0x24
 800a24c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a250:	e68e      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a252:	3330      	adds	r3, #48	; 0x30
 800a254:	2230      	movs	r2, #48	; 0x30
 800a256:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
 800a25a:	f88d 2076 	strb.w	r2, [sp, #118]	; 0x76
 800a25e:	ab1e      	add	r3, sp, #120	; 0x78
 800a260:	e7a6      	b.n	800a1b0 <_svfprintf_r+0x1398>
 800a262:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
 800a266:	2200      	movs	r2, #0
 800a268:	2300      	movs	r3, #0
 800a26a:	f7f6 fd27 	bl	8000cbc <__aeabi_dcmpeq>
 800a26e:	2800      	cmp	r0, #0
 800a270:	f47f aef4 	bne.w	800a05c <_svfprintf_r+0x1244>
 800a274:	f1c9 0301 	rsb	r3, r9, #1
 800a278:	931b      	str	r3, [sp, #108]	; 0x6c
 800a27a:	4498      	add	r8, r3
 800a27c:	e64a      	b.n	8009f14 <_svfprintf_r+0x10fc>
 800a27e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800a280:	f8d5 a000 	ldr.w	sl, [r5]
 800a284:	4628      	mov	r0, r5
 800a286:	3004      	adds	r0, #4
 800a288:	f1ba 0f00 	cmp.w	sl, #0
 800a28c:	785d      	ldrb	r5, [r3, #1]
 800a28e:	900a      	str	r0, [sp, #40]	; 0x28
 800a290:	f6be ae17 	bge.w	8008ec2 <_svfprintf_r+0xaa>
 800a294:	f7fe be13 	b.w	8008ebe <_svfprintf_r+0xa6>
 800a298:	f1bb 0f00 	cmp.w	fp, #0
 800a29c:	d10e      	bne.n	800a2bc <_svfprintf_r+0x14a4>
 800a29e:	9b03      	ldr	r3, [sp, #12]
 800a2a0:	07d8      	lsls	r0, r3, #31
 800a2a2:	d40b      	bmi.n	800a2bc <_svfprintf_r+0x14a4>
 800a2a4:	2301      	movs	r3, #1
 800a2a6:	9309      	str	r3, [sp, #36]	; 0x24
 800a2a8:	e662      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a2aa:	9b03      	ldr	r3, [sp, #12]
 800a2ac:	f013 0301 	ands.w	r3, r3, #1
 800a2b0:	d186      	bne.n	800a1c0 <_svfprintf_r+0x13a8>
 800a2b2:	930e      	str	r3, [sp, #56]	; 0x38
 800a2b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a2b6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a2ba:	e659      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a2bc:	f10b 0302 	add.w	r3, fp, #2
 800a2c0:	9309      	str	r3, [sp, #36]	; 0x24
 800a2c2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800a2c6:	e653      	b.n	8009f70 <_svfprintf_r+0x1158>
 800a2c8:	f10d 0376 	add.w	r3, sp, #118	; 0x76
 800a2cc:	e770      	b.n	800a1b0 <_svfprintf_r+0x1398>
 800a2ce:	9a04      	ldr	r2, [sp, #16]
 800a2d0:	230c      	movs	r3, #12
 800a2d2:	6013      	str	r3, [r2, #0]
 800a2d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800a2d8:	f7fe be70 	b.w	8008fbc <_svfprintf_r+0x1a4>
 800a2dc:	0800d4d0 	.word	0x0800d4d0
 800a2e0:	66666667 	.word	0x66666667

0800a2e4 <quorem>:
 800a2e4:	6902      	ldr	r2, [r0, #16]
 800a2e6:	690b      	ldr	r3, [r1, #16]
 800a2e8:	4293      	cmp	r3, r2
 800a2ea:	f300 808f 	bgt.w	800a40c <quorem+0x128>
 800a2ee:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a2f2:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
 800a2f6:	f101 0714 	add.w	r7, r1, #20
 800a2fa:	f100 0b14 	add.w	fp, r0, #20
 800a2fe:	f857 2028 	ldr.w	r2, [r7, r8, lsl #2]
 800a302:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
 800a306:	ea4f 0488 	mov.w	r4, r8, lsl #2
 800a30a:	b083      	sub	sp, #12
 800a30c:	3201      	adds	r2, #1
 800a30e:	fbb3 f9f2 	udiv	r9, r3, r2
 800a312:	eb0b 0304 	add.w	r3, fp, r4
 800a316:	9400      	str	r4, [sp, #0]
 800a318:	eb07 0a04 	add.w	sl, r7, r4
 800a31c:	9301      	str	r3, [sp, #4]
 800a31e:	f1b9 0f00 	cmp.w	r9, #0
 800a322:	d03b      	beq.n	800a39c <quorem+0xb8>
 800a324:	2600      	movs	r6, #0
 800a326:	4632      	mov	r2, r6
 800a328:	46bc      	mov	ip, r7
 800a32a:	46de      	mov	lr, fp
 800a32c:	4634      	mov	r4, r6
 800a32e:	f85c 6b04 	ldr.w	r6, [ip], #4
 800a332:	f8de 5000 	ldr.w	r5, [lr]
 800a336:	b2b3      	uxth	r3, r6
 800a338:	0c36      	lsrs	r6, r6, #16
 800a33a:	fb03 4409 	mla	r4, r3, r9, r4
 800a33e:	fb06 f609 	mul.w	r6, r6, r9
 800a342:	eb06 4614 	add.w	r6, r6, r4, lsr #16
 800a346:	b2a3      	uxth	r3, r4
 800a348:	1ad3      	subs	r3, r2, r3
 800a34a:	b2b4      	uxth	r4, r6
 800a34c:	fa13 f385 	uxtah	r3, r3, r5
 800a350:	ebc4 4415 	rsb	r4, r4, r5, lsr #16
 800a354:	eb04 4423 	add.w	r4, r4, r3, asr #16
 800a358:	b29b      	uxth	r3, r3
 800a35a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 800a35e:	45e2      	cmp	sl, ip
 800a360:	ea4f 4224 	mov.w	r2, r4, asr #16
 800a364:	f84e 3b04 	str.w	r3, [lr], #4
 800a368:	ea4f 4416 	mov.w	r4, r6, lsr #16
 800a36c:	d2df      	bcs.n	800a32e <quorem+0x4a>
 800a36e:	9b00      	ldr	r3, [sp, #0]
 800a370:	f85b 3003 	ldr.w	r3, [fp, r3]
 800a374:	b993      	cbnz	r3, 800a39c <quorem+0xb8>
 800a376:	9c01      	ldr	r4, [sp, #4]
 800a378:	1f23      	subs	r3, r4, #4
 800a37a:	459b      	cmp	fp, r3
 800a37c:	d20c      	bcs.n	800a398 <quorem+0xb4>
 800a37e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 800a382:	b94b      	cbnz	r3, 800a398 <quorem+0xb4>
 800a384:	f1a4 0308 	sub.w	r3, r4, #8
 800a388:	e002      	b.n	800a390 <quorem+0xac>
 800a38a:	681a      	ldr	r2, [r3, #0]
 800a38c:	3b04      	subs	r3, #4
 800a38e:	b91a      	cbnz	r2, 800a398 <quorem+0xb4>
 800a390:	459b      	cmp	fp, r3
 800a392:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800a396:	d3f8      	bcc.n	800a38a <quorem+0xa6>
 800a398:	f8c0 8010 	str.w	r8, [r0, #16]
 800a39c:	4604      	mov	r4, r0
 800a39e:	f001 fc77 	bl	800bc90 <__mcmp>
 800a3a2:	2800      	cmp	r0, #0
 800a3a4:	db2e      	blt.n	800a404 <quorem+0x120>
 800a3a6:	f109 0901 	add.w	r9, r9, #1
 800a3aa:	465d      	mov	r5, fp
 800a3ac:	2300      	movs	r3, #0
 800a3ae:	f857 1b04 	ldr.w	r1, [r7], #4
 800a3b2:	6828      	ldr	r0, [r5, #0]
 800a3b4:	b28a      	uxth	r2, r1
 800a3b6:	1a9a      	subs	r2, r3, r2
 800a3b8:	0c09      	lsrs	r1, r1, #16
 800a3ba:	fa12 f280 	uxtah	r2, r2, r0
 800a3be:	ebc1 4310 	rsb	r3, r1, r0, lsr #16
 800a3c2:	eb03 4322 	add.w	r3, r3, r2, asr #16
 800a3c6:	b291      	uxth	r1, r2
 800a3c8:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800a3cc:	45ba      	cmp	sl, r7
 800a3ce:	f845 1b04 	str.w	r1, [r5], #4
 800a3d2:	ea4f 4323 	mov.w	r3, r3, asr #16
 800a3d6:	d2ea      	bcs.n	800a3ae <quorem+0xca>
 800a3d8:	f85b 2028 	ldr.w	r2, [fp, r8, lsl #2]
 800a3dc:	eb0b 0388 	add.w	r3, fp, r8, lsl #2
 800a3e0:	b982      	cbnz	r2, 800a404 <quorem+0x120>
 800a3e2:	1f1a      	subs	r2, r3, #4
 800a3e4:	4593      	cmp	fp, r2
 800a3e6:	d20b      	bcs.n	800a400 <quorem+0x11c>
 800a3e8:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800a3ec:	b942      	cbnz	r2, 800a400 <quorem+0x11c>
 800a3ee:	3b08      	subs	r3, #8
 800a3f0:	e002      	b.n	800a3f8 <quorem+0x114>
 800a3f2:	681a      	ldr	r2, [r3, #0]
 800a3f4:	3b04      	subs	r3, #4
 800a3f6:	b91a      	cbnz	r2, 800a400 <quorem+0x11c>
 800a3f8:	459b      	cmp	fp, r3
 800a3fa:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800a3fe:	d3f8      	bcc.n	800a3f2 <quorem+0x10e>
 800a400:	f8c4 8010 	str.w	r8, [r4, #16]
 800a404:	4648      	mov	r0, r9
 800a406:	b003      	add	sp, #12
 800a408:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a40c:	2000      	movs	r0, #0
 800a40e:	4770      	bx	lr

0800a410 <_dtoa_r>:
 800a410:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a414:	b099      	sub	sp, #100	; 0x64
 800a416:	4604      	mov	r4, r0
 800a418:	9103      	str	r1, [sp, #12]
 800a41a:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800a41c:	9d22      	ldr	r5, [sp, #136]	; 0x88
 800a41e:	9304      	str	r3, [sp, #16]
 800a420:	4692      	mov	sl, r2
 800a422:	ed8d 0b00 	vstr	d0, [sp]
 800a426:	b141      	cbz	r1, 800a43a <_dtoa_r+0x2a>
 800a428:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800a42a:	604a      	str	r2, [r1, #4]
 800a42c:	2301      	movs	r3, #1
 800a42e:	4093      	lsls	r3, r2
 800a430:	608b      	str	r3, [r1, #8]
 800a432:	f001 fa49 	bl	800b8c8 <_Bfree>
 800a436:	2300      	movs	r3, #0
 800a438:	6423      	str	r3, [r4, #64]	; 0x40
 800a43a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800a43e:	2b00      	cmp	r3, #0
 800a440:	4699      	mov	r9, r3
 800a442:	db36      	blt.n	800a4b2 <_dtoa_r+0xa2>
 800a444:	2300      	movs	r3, #0
 800a446:	602b      	str	r3, [r5, #0]
 800a448:	4ba5      	ldr	r3, [pc, #660]	; (800a6e0 <_dtoa_r+0x2d0>)
 800a44a:	461a      	mov	r2, r3
 800a44c:	ea09 0303 	and.w	r3, r9, r3
 800a450:	4293      	cmp	r3, r2
 800a452:	d017      	beq.n	800a484 <_dtoa_r+0x74>
 800a454:	e9dd 6700 	ldrd	r6, r7, [sp]
 800a458:	2200      	movs	r2, #0
 800a45a:	2300      	movs	r3, #0
 800a45c:	4630      	mov	r0, r6
 800a45e:	4639      	mov	r1, r7
 800a460:	f7f6 fc2c 	bl	8000cbc <__aeabi_dcmpeq>
 800a464:	4680      	mov	r8, r0
 800a466:	2800      	cmp	r0, #0
 800a468:	d02b      	beq.n	800a4c2 <_dtoa_r+0xb2>
 800a46a:	9a04      	ldr	r2, [sp, #16]
 800a46c:	2301      	movs	r3, #1
 800a46e:	6013      	str	r3, [r2, #0]
 800a470:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800a472:	2b00      	cmp	r3, #0
 800a474:	f000 80cc 	beq.w	800a610 <_dtoa_r+0x200>
 800a478:	489a      	ldr	r0, [pc, #616]	; (800a6e4 <_dtoa_r+0x2d4>)
 800a47a:	6018      	str	r0, [r3, #0]
 800a47c:	3801      	subs	r0, #1
 800a47e:	b019      	add	sp, #100	; 0x64
 800a480:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a484:	9a04      	ldr	r2, [sp, #16]
 800a486:	f242 730f 	movw	r3, #9999	; 0x270f
 800a48a:	6013      	str	r3, [r2, #0]
 800a48c:	9b00      	ldr	r3, [sp, #0]
 800a48e:	2b00      	cmp	r3, #0
 800a490:	f000 80a7 	beq.w	800a5e2 <_dtoa_r+0x1d2>
 800a494:	4894      	ldr	r0, [pc, #592]	; (800a6e8 <_dtoa_r+0x2d8>)
 800a496:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800a498:	2b00      	cmp	r3, #0
 800a49a:	d0f0      	beq.n	800a47e <_dtoa_r+0x6e>
 800a49c:	78c3      	ldrb	r3, [r0, #3]
 800a49e:	2b00      	cmp	r3, #0
 800a4a0:	f000 80b8 	beq.w	800a614 <_dtoa_r+0x204>
 800a4a4:	f100 0308 	add.w	r3, r0, #8
 800a4a8:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 800a4aa:	6013      	str	r3, [r2, #0]
 800a4ac:	b019      	add	sp, #100	; 0x64
 800a4ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a4b2:	9a01      	ldr	r2, [sp, #4]
 800a4b4:	2301      	movs	r3, #1
 800a4b6:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
 800a4ba:	602b      	str	r3, [r5, #0]
 800a4bc:	f8cd 9004 	str.w	r9, [sp, #4]
 800a4c0:	e7c2      	b.n	800a448 <_dtoa_r+0x38>
 800a4c2:	4620      	mov	r0, r4
 800a4c4:	ec47 6b10 	vmov	d0, r6, r7
 800a4c8:	a917      	add	r1, sp, #92	; 0x5c
 800a4ca:	aa16      	add	r2, sp, #88	; 0x58
 800a4cc:	f001 fc6e 	bl	800bdac <__d2b>
 800a4d0:	ea5f 5519 	movs.w	r5, r9, lsr #20
 800a4d4:	4683      	mov	fp, r0
 800a4d6:	f040 808d 	bne.w	800a5f4 <_dtoa_r+0x1e4>
 800a4da:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 800a4de:	9d17      	ldr	r5, [sp, #92]	; 0x5c
 800a4e0:	f46f 6382 	mvn.w	r3, #1040	; 0x410
 800a4e4:	4445      	add	r5, r8
 800a4e6:	429d      	cmp	r5, r3
 800a4e8:	f2c0 829e 	blt.w	800aa28 <_dtoa_r+0x618>
 800a4ec:	4a7f      	ldr	r2, [pc, #508]	; (800a6ec <_dtoa_r+0x2dc>)
 800a4ee:	1b52      	subs	r2, r2, r5
 800a4f0:	fa09 f902 	lsl.w	r9, r9, r2
 800a4f4:	9a00      	ldr	r2, [sp, #0]
 800a4f6:	f205 4312 	addw	r3, r5, #1042	; 0x412
 800a4fa:	fa22 f003 	lsr.w	r0, r2, r3
 800a4fe:	ea49 0000 	orr.w	r0, r9, r0
 800a502:	f7f6 f8fd 	bl	8000700 <__aeabi_ui2d>
 800a506:	2301      	movs	r3, #1
 800a508:	3d01      	subs	r5, #1
 800a50a:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
 800a50e:	930f      	str	r3, [sp, #60]	; 0x3c
 800a510:	2200      	movs	r2, #0
 800a512:	4b77      	ldr	r3, [pc, #476]	; (800a6f0 <_dtoa_r+0x2e0>)
 800a514:	f7f5 ffb6 	bl	8000484 <__aeabi_dsub>
 800a518:	a36b      	add	r3, pc, #428	; (adr r3, 800a6c8 <_dtoa_r+0x2b8>)
 800a51a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a51e:	f7f6 f965 	bl	80007ec <__aeabi_dmul>
 800a522:	a36b      	add	r3, pc, #428	; (adr r3, 800a6d0 <_dtoa_r+0x2c0>)
 800a524:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a528:	f7f5 ffae 	bl	8000488 <__adddf3>
 800a52c:	4606      	mov	r6, r0
 800a52e:	4628      	mov	r0, r5
 800a530:	460f      	mov	r7, r1
 800a532:	f7f6 f8f5 	bl	8000720 <__aeabi_i2d>
 800a536:	a368      	add	r3, pc, #416	; (adr r3, 800a6d8 <_dtoa_r+0x2c8>)
 800a538:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a53c:	f7f6 f956 	bl	80007ec <__aeabi_dmul>
 800a540:	4602      	mov	r2, r0
 800a542:	460b      	mov	r3, r1
 800a544:	4630      	mov	r0, r6
 800a546:	4639      	mov	r1, r7
 800a548:	f7f5 ff9e 	bl	8000488 <__adddf3>
 800a54c:	4606      	mov	r6, r0
 800a54e:	460f      	mov	r7, r1
 800a550:	f7f6 fbe6 	bl	8000d20 <__aeabi_d2iz>
 800a554:	4639      	mov	r1, r7
 800a556:	9005      	str	r0, [sp, #20]
 800a558:	2200      	movs	r2, #0
 800a55a:	4630      	mov	r0, r6
 800a55c:	2300      	movs	r3, #0
 800a55e:	f7f6 fbb7 	bl	8000cd0 <__aeabi_dcmplt>
 800a562:	2800      	cmp	r0, #0
 800a564:	f040 81ab 	bne.w	800a8be <_dtoa_r+0x4ae>
 800a568:	9b05      	ldr	r3, [sp, #20]
 800a56a:	2b16      	cmp	r3, #22
 800a56c:	f200 81a4 	bhi.w	800a8b8 <_dtoa_r+0x4a8>
 800a570:	9a05      	ldr	r2, [sp, #20]
 800a572:	4b60      	ldr	r3, [pc, #384]	; (800a6f4 <_dtoa_r+0x2e4>)
 800a574:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a578:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a57c:	e9dd 2300 	ldrd	r2, r3, [sp]
 800a580:	f7f6 fbc4 	bl	8000d0c <__aeabi_dcmpgt>
 800a584:	2800      	cmp	r0, #0
 800a586:	f000 8255 	beq.w	800aa34 <_dtoa_r+0x624>
 800a58a:	9b05      	ldr	r3, [sp, #20]
 800a58c:	3b01      	subs	r3, #1
 800a58e:	9305      	str	r3, [sp, #20]
 800a590:	2300      	movs	r3, #0
 800a592:	930d      	str	r3, [sp, #52]	; 0x34
 800a594:	ebc5 0508 	rsb	r5, r5, r8
 800a598:	1e6b      	subs	r3, r5, #1
 800a59a:	9306      	str	r3, [sp, #24]
 800a59c:	f100 81a6 	bmi.w	800a8ec <_dtoa_r+0x4dc>
 800a5a0:	2300      	movs	r3, #0
 800a5a2:	9307      	str	r3, [sp, #28]
 800a5a4:	9b05      	ldr	r3, [sp, #20]
 800a5a6:	2b00      	cmp	r3, #0
 800a5a8:	f2c0 8197 	blt.w	800a8da <_dtoa_r+0x4ca>
 800a5ac:	9a06      	ldr	r2, [sp, #24]
 800a5ae:	930c      	str	r3, [sp, #48]	; 0x30
 800a5b0:	4611      	mov	r1, r2
 800a5b2:	4419      	add	r1, r3
 800a5b4:	2300      	movs	r3, #0
 800a5b6:	9106      	str	r1, [sp, #24]
 800a5b8:	930a      	str	r3, [sp, #40]	; 0x28
 800a5ba:	9b03      	ldr	r3, [sp, #12]
 800a5bc:	2b09      	cmp	r3, #9
 800a5be:	d82b      	bhi.n	800a618 <_dtoa_r+0x208>
 800a5c0:	2b05      	cmp	r3, #5
 800a5c2:	f340 8673 	ble.w	800b2ac <_dtoa_r+0xe9c>
 800a5c6:	3b04      	subs	r3, #4
 800a5c8:	9303      	str	r3, [sp, #12]
 800a5ca:	2700      	movs	r7, #0
 800a5cc:	9b03      	ldr	r3, [sp, #12]
 800a5ce:	3b02      	subs	r3, #2
 800a5d0:	2b03      	cmp	r3, #3
 800a5d2:	f200 8651 	bhi.w	800b278 <_dtoa_r+0xe68>
 800a5d6:	e8df f013 	tbh	[pc, r3, lsl #1]
 800a5da:	03d1      	.short	0x03d1
 800a5dc:	02b603c4 	.word	0x02b603c4
 800a5e0:	0666      	.short	0x0666
 800a5e2:	4b41      	ldr	r3, [pc, #260]	; (800a6e8 <_dtoa_r+0x2d8>)
 800a5e4:	4a44      	ldr	r2, [pc, #272]	; (800a6f8 <_dtoa_r+0x2e8>)
 800a5e6:	f3c9 0013 	ubfx	r0, r9, #0, #20
 800a5ea:	2800      	cmp	r0, #0
 800a5ec:	bf14      	ite	ne
 800a5ee:	4618      	movne	r0, r3
 800a5f0:	4610      	moveq	r0, r2
 800a5f2:	e750      	b.n	800a496 <_dtoa_r+0x86>
 800a5f4:	f3c7 0313 	ubfx	r3, r7, #0, #20
 800a5f8:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
 800a5fc:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 800a600:	4630      	mov	r0, r6
 800a602:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 800a606:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
 800a60a:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 800a60e:	e77f      	b.n	800a510 <_dtoa_r+0x100>
 800a610:	483a      	ldr	r0, [pc, #232]	; (800a6fc <_dtoa_r+0x2ec>)
 800a612:	e734      	b.n	800a47e <_dtoa_r+0x6e>
 800a614:	1cc3      	adds	r3, r0, #3
 800a616:	e747      	b.n	800a4a8 <_dtoa_r+0x98>
 800a618:	2100      	movs	r1, #0
 800a61a:	6461      	str	r1, [r4, #68]	; 0x44
 800a61c:	4620      	mov	r0, r4
 800a61e:	468a      	mov	sl, r1
 800a620:	9103      	str	r1, [sp, #12]
 800a622:	f001 f92b 	bl	800b87c <_Balloc>
 800a626:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a62a:	9308      	str	r3, [sp, #32]
 800a62c:	930e      	str	r3, [sp, #56]	; 0x38
 800a62e:	2301      	movs	r3, #1
 800a630:	9009      	str	r0, [sp, #36]	; 0x24
 800a632:	6420      	str	r0, [r4, #64]	; 0x40
 800a634:	930b      	str	r3, [sp, #44]	; 0x2c
 800a636:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800a638:	2b00      	cmp	r3, #0
 800a63a:	f2c0 80d3 	blt.w	800a7e4 <_dtoa_r+0x3d4>
 800a63e:	9a05      	ldr	r2, [sp, #20]
 800a640:	2a0e      	cmp	r2, #14
 800a642:	f300 80cf 	bgt.w	800a7e4 <_dtoa_r+0x3d4>
 800a646:	4b2b      	ldr	r3, [pc, #172]	; (800a6f4 <_dtoa_r+0x2e4>)
 800a648:	f1ba 0f00 	cmp.w	sl, #0
 800a64c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a650:	e9d3 8900 	ldrd	r8, r9, [r3]
 800a654:	f2c0 8395 	blt.w	800ad82 <_dtoa_r+0x972>
 800a658:	e9dd 6700 	ldrd	r6, r7, [sp]
 800a65c:	4642      	mov	r2, r8
 800a65e:	464b      	mov	r3, r9
 800a660:	4630      	mov	r0, r6
 800a662:	4639      	mov	r1, r7
 800a664:	f7f6 f9ec 	bl	8000a40 <__aeabi_ddiv>
 800a668:	f7f6 fb5a 	bl	8000d20 <__aeabi_d2iz>
 800a66c:	4682      	mov	sl, r0
 800a66e:	f7f6 f857 	bl	8000720 <__aeabi_i2d>
 800a672:	4642      	mov	r2, r8
 800a674:	464b      	mov	r3, r9
 800a676:	f7f6 f8b9 	bl	80007ec <__aeabi_dmul>
 800a67a:	460b      	mov	r3, r1
 800a67c:	4602      	mov	r2, r0
 800a67e:	4639      	mov	r1, r7
 800a680:	4630      	mov	r0, r6
 800a682:	f7f5 feff 	bl	8000484 <__aeabi_dsub>
 800a686:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800a688:	f10a 0330 	add.w	r3, sl, #48	; 0x30
 800a68c:	702b      	strb	r3, [r5, #0]
 800a68e:	9b08      	ldr	r3, [sp, #32]
 800a690:	2b01      	cmp	r3, #1
 800a692:	4606      	mov	r6, r0
 800a694:	460f      	mov	r7, r1
 800a696:	f105 0501 	add.w	r5, r5, #1
 800a69a:	d063      	beq.n	800a764 <_dtoa_r+0x354>
 800a69c:	2200      	movs	r2, #0
 800a69e:	4b18      	ldr	r3, [pc, #96]	; (800a700 <_dtoa_r+0x2f0>)
 800a6a0:	f7f6 f8a4 	bl	80007ec <__aeabi_dmul>
 800a6a4:	2200      	movs	r2, #0
 800a6a6:	2300      	movs	r3, #0
 800a6a8:	4606      	mov	r6, r0
 800a6aa:	460f      	mov	r7, r1
 800a6ac:	f7f6 fb06 	bl	8000cbc <__aeabi_dcmpeq>
 800a6b0:	2800      	cmp	r0, #0
 800a6b2:	f040 8084 	bne.w	800a7be <_dtoa_r+0x3ae>
 800a6b6:	f8cd b000 	str.w	fp, [sp]
 800a6ba:	9403      	str	r4, [sp, #12]
 800a6bc:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 800a6c0:	9c08      	ldr	r4, [sp, #32]
 800a6c2:	e02a      	b.n	800a71a <_dtoa_r+0x30a>
 800a6c4:	f3af 8000 	nop.w
 800a6c8:	636f4361 	.word	0x636f4361
 800a6cc:	3fd287a7 	.word	0x3fd287a7
 800a6d0:	8b60c8b3 	.word	0x8b60c8b3
 800a6d4:	3fc68a28 	.word	0x3fc68a28
 800a6d8:	509f79fb 	.word	0x509f79fb
 800a6dc:	3fd34413 	.word	0x3fd34413
 800a6e0:	7ff00000 	.word	0x7ff00000
 800a6e4:	0800cda1 	.word	0x0800cda1
 800a6e8:	0800d568 	.word	0x0800d568
 800a6ec:	fffffc0e 	.word	0xfffffc0e
 800a6f0:	3ff80000 	.word	0x3ff80000
 800a6f4:	0800d578 	.word	0x0800d578
 800a6f8:	0800d55c 	.word	0x0800d55c
 800a6fc:	0800cda0 	.word	0x0800cda0
 800a700:	40240000 	.word	0x40240000
 800a704:	f7f6 f872 	bl	80007ec <__aeabi_dmul>
 800a708:	2200      	movs	r2, #0
 800a70a:	2300      	movs	r3, #0
 800a70c:	4606      	mov	r6, r0
 800a70e:	460f      	mov	r7, r1
 800a710:	f7f6 fad4 	bl	8000cbc <__aeabi_dcmpeq>
 800a714:	2800      	cmp	r0, #0
 800a716:	f040 83e4 	bne.w	800aee2 <_dtoa_r+0xad2>
 800a71a:	4642      	mov	r2, r8
 800a71c:	464b      	mov	r3, r9
 800a71e:	4630      	mov	r0, r6
 800a720:	4639      	mov	r1, r7
 800a722:	f7f6 f98d 	bl	8000a40 <__aeabi_ddiv>
 800a726:	f7f6 fafb 	bl	8000d20 <__aeabi_d2iz>
 800a72a:	4682      	mov	sl, r0
 800a72c:	f7f5 fff8 	bl	8000720 <__aeabi_i2d>
 800a730:	4642      	mov	r2, r8
 800a732:	464b      	mov	r3, r9
 800a734:	f7f6 f85a 	bl	80007ec <__aeabi_dmul>
 800a738:	4602      	mov	r2, r0
 800a73a:	460b      	mov	r3, r1
 800a73c:	4630      	mov	r0, r6
 800a73e:	4639      	mov	r1, r7
 800a740:	f7f5 fea0 	bl	8000484 <__aeabi_dsub>
 800a744:	f10a 0e30 	add.w	lr, sl, #48	; 0x30
 800a748:	f805 eb01 	strb.w	lr, [r5], #1
 800a74c:	ebcb 0e05 	rsb	lr, fp, r5
 800a750:	4574      	cmp	r4, lr
 800a752:	4606      	mov	r6, r0
 800a754:	460f      	mov	r7, r1
 800a756:	f04f 0200 	mov.w	r2, #0
 800a75a:	4bb7      	ldr	r3, [pc, #732]	; (800aa38 <_dtoa_r+0x628>)
 800a75c:	d1d2      	bne.n	800a704 <_dtoa_r+0x2f4>
 800a75e:	f8dd b000 	ldr.w	fp, [sp]
 800a762:	9c03      	ldr	r4, [sp, #12]
 800a764:	4632      	mov	r2, r6
 800a766:	463b      	mov	r3, r7
 800a768:	4630      	mov	r0, r6
 800a76a:	4639      	mov	r1, r7
 800a76c:	f7f5 fe8c 	bl	8000488 <__adddf3>
 800a770:	4606      	mov	r6, r0
 800a772:	460f      	mov	r7, r1
 800a774:	4640      	mov	r0, r8
 800a776:	4649      	mov	r1, r9
 800a778:	4632      	mov	r2, r6
 800a77a:	463b      	mov	r3, r7
 800a77c:	f7f6 faa8 	bl	8000cd0 <__aeabi_dcmplt>
 800a780:	b948      	cbnz	r0, 800a796 <_dtoa_r+0x386>
 800a782:	4640      	mov	r0, r8
 800a784:	4649      	mov	r1, r9
 800a786:	4632      	mov	r2, r6
 800a788:	463b      	mov	r3, r7
 800a78a:	f7f6 fa97 	bl	8000cbc <__aeabi_dcmpeq>
 800a78e:	b1b0      	cbz	r0, 800a7be <_dtoa_r+0x3ae>
 800a790:	f01a 0f01 	tst.w	sl, #1
 800a794:	d013      	beq.n	800a7be <_dtoa_r+0x3ae>
 800a796:	f815 8c01 	ldrb.w	r8, [r5, #-1]
 800a79a:	9909      	ldr	r1, [sp, #36]	; 0x24
 800a79c:	1e6b      	subs	r3, r5, #1
 800a79e:	e004      	b.n	800a7aa <_dtoa_r+0x39a>
 800a7a0:	428b      	cmp	r3, r1
 800a7a2:	f000 8448 	beq.w	800b036 <_dtoa_r+0xc26>
 800a7a6:	f813 8d01 	ldrb.w	r8, [r3, #-1]!
 800a7aa:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 800a7ae:	f103 0501 	add.w	r5, r3, #1
 800a7b2:	461a      	mov	r2, r3
 800a7b4:	d0f4      	beq.n	800a7a0 <_dtoa_r+0x390>
 800a7b6:	f108 0301 	add.w	r3, r8, #1
 800a7ba:	b2db      	uxtb	r3, r3
 800a7bc:	7013      	strb	r3, [r2, #0]
 800a7be:	4620      	mov	r0, r4
 800a7c0:	4659      	mov	r1, fp
 800a7c2:	f001 f881 	bl	800b8c8 <_Bfree>
 800a7c6:	2200      	movs	r2, #0
 800a7c8:	9b05      	ldr	r3, [sp, #20]
 800a7ca:	702a      	strb	r2, [r5, #0]
 800a7cc:	9a04      	ldr	r2, [sp, #16]
 800a7ce:	3301      	adds	r3, #1
 800a7d0:	6013      	str	r3, [r2, #0]
 800a7d2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800a7d4:	2b00      	cmp	r3, #0
 800a7d6:	f000 834b 	beq.w	800ae70 <_dtoa_r+0xa60>
 800a7da:	9809      	ldr	r0, [sp, #36]	; 0x24
 800a7dc:	601d      	str	r5, [r3, #0]
 800a7de:	b019      	add	sp, #100	; 0x64
 800a7e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a7e4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800a7e6:	2a00      	cmp	r2, #0
 800a7e8:	f000 8085 	beq.w	800a8f6 <_dtoa_r+0x4e6>
 800a7ec:	9a03      	ldr	r2, [sp, #12]
 800a7ee:	2a01      	cmp	r2, #1
 800a7f0:	f340 830a 	ble.w	800ae08 <_dtoa_r+0x9f8>
 800a7f4:	9b08      	ldr	r3, [sp, #32]
 800a7f6:	1e5f      	subs	r7, r3, #1
 800a7f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a7fa:	42bb      	cmp	r3, r7
 800a7fc:	f2c0 83a6 	blt.w	800af4c <_dtoa_r+0xb3c>
 800a800:	1bdf      	subs	r7, r3, r7
 800a802:	9b08      	ldr	r3, [sp, #32]
 800a804:	2b00      	cmp	r3, #0
 800a806:	f2c0 84a4 	blt.w	800b152 <_dtoa_r+0xd42>
 800a80a:	9d07      	ldr	r5, [sp, #28]
 800a80c:	9b08      	ldr	r3, [sp, #32]
 800a80e:	9a07      	ldr	r2, [sp, #28]
 800a810:	441a      	add	r2, r3
 800a812:	9207      	str	r2, [sp, #28]
 800a814:	9a06      	ldr	r2, [sp, #24]
 800a816:	4620      	mov	r0, r4
 800a818:	441a      	add	r2, r3
 800a81a:	2101      	movs	r1, #1
 800a81c:	9206      	str	r2, [sp, #24]
 800a81e:	f001 f8ed 	bl	800b9fc <__i2b>
 800a822:	4606      	mov	r6, r0
 800a824:	b165      	cbz	r5, 800a840 <_dtoa_r+0x430>
 800a826:	9906      	ldr	r1, [sp, #24]
 800a828:	2900      	cmp	r1, #0
 800a82a:	460b      	mov	r3, r1
 800a82c:	dd08      	ble.n	800a840 <_dtoa_r+0x430>
 800a82e:	42a9      	cmp	r1, r5
 800a830:	9a07      	ldr	r2, [sp, #28]
 800a832:	bfa8      	it	ge
 800a834:	462b      	movge	r3, r5
 800a836:	1ad2      	subs	r2, r2, r3
 800a838:	1aed      	subs	r5, r5, r3
 800a83a:	1acb      	subs	r3, r1, r3
 800a83c:	9207      	str	r2, [sp, #28]
 800a83e:	9306      	str	r3, [sp, #24]
 800a840:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a842:	2b00      	cmp	r3, #0
 800a844:	dd1a      	ble.n	800a87c <_dtoa_r+0x46c>
 800a846:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a848:	2b00      	cmp	r3, #0
 800a84a:	f000 8378 	beq.w	800af3e <_dtoa_r+0xb2e>
 800a84e:	2f00      	cmp	r7, #0
 800a850:	dd10      	ble.n	800a874 <_dtoa_r+0x464>
 800a852:	4631      	mov	r1, r6
 800a854:	463a      	mov	r2, r7
 800a856:	4620      	mov	r0, r4
 800a858:	f001 f974 	bl	800bb44 <__pow5mult>
 800a85c:	4606      	mov	r6, r0
 800a85e:	465a      	mov	r2, fp
 800a860:	4631      	mov	r1, r6
 800a862:	4620      	mov	r0, r4
 800a864:	f001 f8d4 	bl	800ba10 <__multiply>
 800a868:	4659      	mov	r1, fp
 800a86a:	4680      	mov	r8, r0
 800a86c:	4620      	mov	r0, r4
 800a86e:	f001 f82b 	bl	800b8c8 <_Bfree>
 800a872:	46c3      	mov	fp, r8
 800a874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a876:	1bda      	subs	r2, r3, r7
 800a878:	f040 82a5 	bne.w	800adc6 <_dtoa_r+0x9b6>
 800a87c:	4620      	mov	r0, r4
 800a87e:	2101      	movs	r1, #1
 800a880:	f001 f8bc 	bl	800b9fc <__i2b>
 800a884:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a886:	2b00      	cmp	r3, #0
 800a888:	4680      	mov	r8, r0
 800a88a:	dd38      	ble.n	800a8fe <_dtoa_r+0x4ee>
 800a88c:	4601      	mov	r1, r0
 800a88e:	461a      	mov	r2, r3
 800a890:	4620      	mov	r0, r4
 800a892:	f001 f957 	bl	800bb44 <__pow5mult>
 800a896:	9b03      	ldr	r3, [sp, #12]
 800a898:	2b01      	cmp	r3, #1
 800a89a:	4680      	mov	r8, r0
 800a89c:	f340 8299 	ble.w	800add2 <_dtoa_r+0x9c2>
 800a8a0:	f04f 0900 	mov.w	r9, #0
 800a8a4:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800a8a8:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800a8ac:	6918      	ldr	r0, [r3, #16]
 800a8ae:	f001 f857 	bl	800b960 <__hi0bits>
 800a8b2:	f1c0 0020 	rsb	r0, r0, #32
 800a8b6:	e02c      	b.n	800a912 <_dtoa_r+0x502>
 800a8b8:	2301      	movs	r3, #1
 800a8ba:	930d      	str	r3, [sp, #52]	; 0x34
 800a8bc:	e66a      	b.n	800a594 <_dtoa_r+0x184>
 800a8be:	9805      	ldr	r0, [sp, #20]
 800a8c0:	f7f5 ff2e 	bl	8000720 <__aeabi_i2d>
 800a8c4:	4632      	mov	r2, r6
 800a8c6:	463b      	mov	r3, r7
 800a8c8:	f7f6 f9f8 	bl	8000cbc <__aeabi_dcmpeq>
 800a8cc:	2800      	cmp	r0, #0
 800a8ce:	f47f ae4b 	bne.w	800a568 <_dtoa_r+0x158>
 800a8d2:	9b05      	ldr	r3, [sp, #20]
 800a8d4:	3b01      	subs	r3, #1
 800a8d6:	9305      	str	r3, [sp, #20]
 800a8d8:	e646      	b.n	800a568 <_dtoa_r+0x158>
 800a8da:	9a07      	ldr	r2, [sp, #28]
 800a8dc:	9b05      	ldr	r3, [sp, #20]
 800a8de:	1ad2      	subs	r2, r2, r3
 800a8e0:	425b      	negs	r3, r3
 800a8e2:	930a      	str	r3, [sp, #40]	; 0x28
 800a8e4:	2300      	movs	r3, #0
 800a8e6:	9207      	str	r2, [sp, #28]
 800a8e8:	930c      	str	r3, [sp, #48]	; 0x30
 800a8ea:	e666      	b.n	800a5ba <_dtoa_r+0x1aa>
 800a8ec:	425b      	negs	r3, r3
 800a8ee:	9307      	str	r3, [sp, #28]
 800a8f0:	2300      	movs	r3, #0
 800a8f2:	9306      	str	r3, [sp, #24]
 800a8f4:	e656      	b.n	800a5a4 <_dtoa_r+0x194>
 800a8f6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800a8f8:	9d07      	ldr	r5, [sp, #28]
 800a8fa:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 800a8fc:	e792      	b.n	800a824 <_dtoa_r+0x414>
 800a8fe:	9b03      	ldr	r3, [sp, #12]
 800a900:	2b01      	cmp	r3, #1
 800a902:	f340 82b8 	ble.w	800ae76 <_dtoa_r+0xa66>
 800a906:	f04f 0900 	mov.w	r9, #0
 800a90a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800a90c:	2b00      	cmp	r3, #0
 800a90e:	d1c9      	bne.n	800a8a4 <_dtoa_r+0x494>
 800a910:	2001      	movs	r0, #1
 800a912:	9b06      	ldr	r3, [sp, #24]
 800a914:	4418      	add	r0, r3
 800a916:	f010 001f 	ands.w	r0, r0, #31
 800a91a:	f000 8083 	beq.w	800aa24 <_dtoa_r+0x614>
 800a91e:	f1c0 0320 	rsb	r3, r0, #32
 800a922:	2b04      	cmp	r3, #4
 800a924:	f340 84b9 	ble.w	800b29a <_dtoa_r+0xe8a>
 800a928:	f1c0 001c 	rsb	r0, r0, #28
 800a92c:	9b07      	ldr	r3, [sp, #28]
 800a92e:	4403      	add	r3, r0
 800a930:	9307      	str	r3, [sp, #28]
 800a932:	9b06      	ldr	r3, [sp, #24]
 800a934:	4403      	add	r3, r0
 800a936:	4405      	add	r5, r0
 800a938:	9306      	str	r3, [sp, #24]
 800a93a:	9b07      	ldr	r3, [sp, #28]
 800a93c:	2b00      	cmp	r3, #0
 800a93e:	dd05      	ble.n	800a94c <_dtoa_r+0x53c>
 800a940:	4659      	mov	r1, fp
 800a942:	461a      	mov	r2, r3
 800a944:	4620      	mov	r0, r4
 800a946:	f001 f94d 	bl	800bbe4 <__lshift>
 800a94a:	4683      	mov	fp, r0
 800a94c:	9b06      	ldr	r3, [sp, #24]
 800a94e:	2b00      	cmp	r3, #0
 800a950:	dd05      	ble.n	800a95e <_dtoa_r+0x54e>
 800a952:	4641      	mov	r1, r8
 800a954:	461a      	mov	r2, r3
 800a956:	4620      	mov	r0, r4
 800a958:	f001 f944 	bl	800bbe4 <__lshift>
 800a95c:	4680      	mov	r8, r0
 800a95e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800a960:	2b00      	cmp	r3, #0
 800a962:	f040 826a 	bne.w	800ae3a <_dtoa_r+0xa2a>
 800a966:	9b08      	ldr	r3, [sp, #32]
 800a968:	2b00      	cmp	r3, #0
 800a96a:	f340 8297 	ble.w	800ae9c <_dtoa_r+0xa8c>
 800a96e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a970:	2b00      	cmp	r3, #0
 800a972:	d171      	bne.n	800aa58 <_dtoa_r+0x648>
 800a974:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 800a978:	9f08      	ldr	r7, [sp, #32]
 800a97a:	464d      	mov	r5, r9
 800a97c:	e002      	b.n	800a984 <_dtoa_r+0x574>
 800a97e:	f000 ffad 	bl	800b8dc <__multadd>
 800a982:	4683      	mov	fp, r0
 800a984:	4641      	mov	r1, r8
 800a986:	4658      	mov	r0, fp
 800a988:	f7ff fcac 	bl	800a2e4 <quorem>
 800a98c:	f100 0c30 	add.w	ip, r0, #48	; 0x30
 800a990:	f805 cb01 	strb.w	ip, [r5], #1
 800a994:	ebc9 0305 	rsb	r3, r9, r5
 800a998:	42bb      	cmp	r3, r7
 800a99a:	4620      	mov	r0, r4
 800a99c:	4659      	mov	r1, fp
 800a99e:	f04f 020a 	mov.w	r2, #10
 800a9a2:	f04f 0300 	mov.w	r3, #0
 800a9a6:	dbea      	blt.n	800a97e <_dtoa_r+0x56e>
 800a9a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a9aa:	9a08      	ldr	r2, [sp, #32]
 800a9ac:	2a01      	cmp	r2, #1
 800a9ae:	bfac      	ite	ge
 800a9b0:	189b      	addge	r3, r3, r2
 800a9b2:	3301      	addlt	r3, #1
 800a9b4:	461d      	mov	r5, r3
 800a9b6:	f04f 0a00 	mov.w	sl, #0
 800a9ba:	4659      	mov	r1, fp
 800a9bc:	2201      	movs	r2, #1
 800a9be:	4620      	mov	r0, r4
 800a9c0:	f8cd c000 	str.w	ip, [sp]
 800a9c4:	f001 f90e 	bl	800bbe4 <__lshift>
 800a9c8:	4641      	mov	r1, r8
 800a9ca:	4683      	mov	fp, r0
 800a9cc:	f001 f960 	bl	800bc90 <__mcmp>
 800a9d0:	2800      	cmp	r0, #0
 800a9d2:	f8dd c000 	ldr.w	ip, [sp]
 800a9d6:	f340 82ef 	ble.w	800afb8 <_dtoa_r+0xba8>
 800a9da:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 800a9de:	9909      	ldr	r1, [sp, #36]	; 0x24
 800a9e0:	1e6b      	subs	r3, r5, #1
 800a9e2:	e004      	b.n	800a9ee <_dtoa_r+0x5de>
 800a9e4:	428b      	cmp	r3, r1
 800a9e6:	f000 8275 	beq.w	800aed4 <_dtoa_r+0xac4>
 800a9ea:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 800a9ee:	2a39      	cmp	r2, #57	; 0x39
 800a9f0:	f103 0501 	add.w	r5, r3, #1
 800a9f4:	d0f6      	beq.n	800a9e4 <_dtoa_r+0x5d4>
 800a9f6:	3201      	adds	r2, #1
 800a9f8:	701a      	strb	r2, [r3, #0]
 800a9fa:	4641      	mov	r1, r8
 800a9fc:	4620      	mov	r0, r4
 800a9fe:	f000 ff63 	bl	800b8c8 <_Bfree>
 800aa02:	2e00      	cmp	r6, #0
 800aa04:	f43f aedb 	beq.w	800a7be <_dtoa_r+0x3ae>
 800aa08:	f1ba 0f00 	cmp.w	sl, #0
 800aa0c:	d005      	beq.n	800aa1a <_dtoa_r+0x60a>
 800aa0e:	45b2      	cmp	sl, r6
 800aa10:	d003      	beq.n	800aa1a <_dtoa_r+0x60a>
 800aa12:	4651      	mov	r1, sl
 800aa14:	4620      	mov	r0, r4
 800aa16:	f000 ff57 	bl	800b8c8 <_Bfree>
 800aa1a:	4631      	mov	r1, r6
 800aa1c:	4620      	mov	r0, r4
 800aa1e:	f000 ff53 	bl	800b8c8 <_Bfree>
 800aa22:	e6cc      	b.n	800a7be <_dtoa_r+0x3ae>
 800aa24:	201c      	movs	r0, #28
 800aa26:	e781      	b.n	800a92c <_dtoa_r+0x51c>
 800aa28:	4b04      	ldr	r3, [pc, #16]	; (800aa3c <_dtoa_r+0x62c>)
 800aa2a:	9a00      	ldr	r2, [sp, #0]
 800aa2c:	1b5b      	subs	r3, r3, r5
 800aa2e:	fa02 f003 	lsl.w	r0, r2, r3
 800aa32:	e566      	b.n	800a502 <_dtoa_r+0xf2>
 800aa34:	900d      	str	r0, [sp, #52]	; 0x34
 800aa36:	e5ad      	b.n	800a594 <_dtoa_r+0x184>
 800aa38:	40240000 	.word	0x40240000
 800aa3c:	fffffbee 	.word	0xfffffbee
 800aa40:	4631      	mov	r1, r6
 800aa42:	2300      	movs	r3, #0
 800aa44:	4620      	mov	r0, r4
 800aa46:	220a      	movs	r2, #10
 800aa48:	f000 ff48 	bl	800b8dc <__multadd>
 800aa4c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800aa4e:	2b00      	cmp	r3, #0
 800aa50:	4606      	mov	r6, r0
 800aa52:	f340 840b 	ble.w	800b26c <_dtoa_r+0xe5c>
 800aa56:	9308      	str	r3, [sp, #32]
 800aa58:	2d00      	cmp	r5, #0
 800aa5a:	dd05      	ble.n	800aa68 <_dtoa_r+0x658>
 800aa5c:	4631      	mov	r1, r6
 800aa5e:	462a      	mov	r2, r5
 800aa60:	4620      	mov	r0, r4
 800aa62:	f001 f8bf 	bl	800bbe4 <__lshift>
 800aa66:	4606      	mov	r6, r0
 800aa68:	f1b9 0f00 	cmp.w	r9, #0
 800aa6c:	f040 82ed 	bne.w	800b04a <_dtoa_r+0xc3a>
 800aa70:	46b1      	mov	r9, r6
 800aa72:	9b08      	ldr	r3, [sp, #32]
 800aa74:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800aa76:	3b01      	subs	r3, #1
 800aa78:	18d3      	adds	r3, r2, r3
 800aa7a:	9308      	str	r3, [sp, #32]
 800aa7c:	9b00      	ldr	r3, [sp, #0]
 800aa7e:	f003 0301 	and.w	r3, r3, #1
 800aa82:	930a      	str	r3, [sp, #40]	; 0x28
 800aa84:	4617      	mov	r7, r2
 800aa86:	4641      	mov	r1, r8
 800aa88:	4658      	mov	r0, fp
 800aa8a:	f7ff fc2b 	bl	800a2e4 <quorem>
 800aa8e:	4631      	mov	r1, r6
 800aa90:	4605      	mov	r5, r0
 800aa92:	4658      	mov	r0, fp
 800aa94:	f001 f8fc 	bl	800bc90 <__mcmp>
 800aa98:	464a      	mov	r2, r9
 800aa9a:	4682      	mov	sl, r0
 800aa9c:	4641      	mov	r1, r8
 800aa9e:	4620      	mov	r0, r4
 800aaa0:	f001 f91a 	bl	800bcd8 <__mdiff>
 800aaa4:	68c2      	ldr	r2, [r0, #12]
 800aaa6:	4603      	mov	r3, r0
 800aaa8:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 800aaac:	2a00      	cmp	r2, #0
 800aaae:	f040 81ba 	bne.w	800ae26 <_dtoa_r+0xa16>
 800aab2:	4619      	mov	r1, r3
 800aab4:	4658      	mov	r0, fp
 800aab6:	f8cd c01c 	str.w	ip, [sp, #28]
 800aaba:	9306      	str	r3, [sp, #24]
 800aabc:	f001 f8e8 	bl	800bc90 <__mcmp>
 800aac0:	9b06      	ldr	r3, [sp, #24]
 800aac2:	9000      	str	r0, [sp, #0]
 800aac4:	4619      	mov	r1, r3
 800aac6:	4620      	mov	r0, r4
 800aac8:	f000 fefe 	bl	800b8c8 <_Bfree>
 800aacc:	9a00      	ldr	r2, [sp, #0]
 800aace:	f8dd c01c 	ldr.w	ip, [sp, #28]
 800aad2:	b92a      	cbnz	r2, 800aae0 <_dtoa_r+0x6d0>
 800aad4:	9b03      	ldr	r3, [sp, #12]
 800aad6:	b91b      	cbnz	r3, 800aae0 <_dtoa_r+0x6d0>
 800aad8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aada:	2b00      	cmp	r3, #0
 800aadc:	f000 83aa 	beq.w	800b234 <_dtoa_r+0xe24>
 800aae0:	f1ba 0f00 	cmp.w	sl, #0
 800aae4:	f2c0 824a 	blt.w	800af7c <_dtoa_r+0xb6c>
 800aae8:	d105      	bne.n	800aaf6 <_dtoa_r+0x6e6>
 800aaea:	9b03      	ldr	r3, [sp, #12]
 800aaec:	b91b      	cbnz	r3, 800aaf6 <_dtoa_r+0x6e6>
 800aaee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aaf0:	2b00      	cmp	r3, #0
 800aaf2:	f000 8243 	beq.w	800af7c <_dtoa_r+0xb6c>
 800aaf6:	2a00      	cmp	r2, #0
 800aaf8:	f300 82bb 	bgt.w	800b072 <_dtoa_r+0xc62>
 800aafc:	9b08      	ldr	r3, [sp, #32]
 800aafe:	f887 c000 	strb.w	ip, [r7]
 800ab02:	f107 0a01 	add.w	sl, r7, #1
 800ab06:	429f      	cmp	r7, r3
 800ab08:	4655      	mov	r5, sl
 800ab0a:	f000 82be 	beq.w	800b08a <_dtoa_r+0xc7a>
 800ab0e:	4659      	mov	r1, fp
 800ab10:	220a      	movs	r2, #10
 800ab12:	2300      	movs	r3, #0
 800ab14:	4620      	mov	r0, r4
 800ab16:	f000 fee1 	bl	800b8dc <__multadd>
 800ab1a:	454e      	cmp	r6, r9
 800ab1c:	4683      	mov	fp, r0
 800ab1e:	4631      	mov	r1, r6
 800ab20:	4620      	mov	r0, r4
 800ab22:	f04f 020a 	mov.w	r2, #10
 800ab26:	f04f 0300 	mov.w	r3, #0
 800ab2a:	f000 8176 	beq.w	800ae1a <_dtoa_r+0xa0a>
 800ab2e:	f000 fed5 	bl	800b8dc <__multadd>
 800ab32:	4649      	mov	r1, r9
 800ab34:	4606      	mov	r6, r0
 800ab36:	220a      	movs	r2, #10
 800ab38:	4620      	mov	r0, r4
 800ab3a:	2300      	movs	r3, #0
 800ab3c:	f000 fece 	bl	800b8dc <__multadd>
 800ab40:	4657      	mov	r7, sl
 800ab42:	4681      	mov	r9, r0
 800ab44:	e79f      	b.n	800aa86 <_dtoa_r+0x676>
 800ab46:	2301      	movs	r3, #1
 800ab48:	930b      	str	r3, [sp, #44]	; 0x2c
 800ab4a:	f1ba 0f00 	cmp.w	sl, #0
 800ab4e:	f340 820c 	ble.w	800af6a <_dtoa_r+0xb5a>
 800ab52:	4656      	mov	r6, sl
 800ab54:	4655      	mov	r5, sl
 800ab56:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
 800ab5a:	f8cd a020 	str.w	sl, [sp, #32]
 800ab5e:	2100      	movs	r1, #0
 800ab60:	2e17      	cmp	r6, #23
 800ab62:	6461      	str	r1, [r4, #68]	; 0x44
 800ab64:	d90a      	bls.n	800ab7c <_dtoa_r+0x76c>
 800ab66:	2201      	movs	r2, #1
 800ab68:	2304      	movs	r3, #4
 800ab6a:	005b      	lsls	r3, r3, #1
 800ab6c:	f103 0014 	add.w	r0, r3, #20
 800ab70:	4286      	cmp	r6, r0
 800ab72:	4611      	mov	r1, r2
 800ab74:	f102 0201 	add.w	r2, r2, #1
 800ab78:	d2f7      	bcs.n	800ab6a <_dtoa_r+0x75a>
 800ab7a:	6461      	str	r1, [r4, #68]	; 0x44
 800ab7c:	4620      	mov	r0, r4
 800ab7e:	f000 fe7d 	bl	800b87c <_Balloc>
 800ab82:	2d0e      	cmp	r5, #14
 800ab84:	9009      	str	r0, [sp, #36]	; 0x24
 800ab86:	6420      	str	r0, [r4, #64]	; 0x40
 800ab88:	f63f ad55 	bhi.w	800a636 <_dtoa_r+0x226>
 800ab8c:	2f00      	cmp	r7, #0
 800ab8e:	f43f ad52 	beq.w	800a636 <_dtoa_r+0x226>
 800ab92:	ed9d 7b00 	vldr	d7, [sp]
 800ab96:	9905      	ldr	r1, [sp, #20]
 800ab98:	2900      	cmp	r1, #0
 800ab9a:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 800ab9e:	f340 8223 	ble.w	800afe8 <_dtoa_r+0xbd8>
 800aba2:	4bb7      	ldr	r3, [pc, #732]	; (800ae80 <_dtoa_r+0xa70>)
 800aba4:	f001 020f 	and.w	r2, r1, #15
 800aba8:	110d      	asrs	r5, r1, #4
 800abaa:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800abae:	06e9      	lsls	r1, r5, #27
 800abb0:	e9d3 6700 	ldrd	r6, r7, [r3]
 800abb4:	f140 81d2 	bpl.w	800af5c <_dtoa_r+0xb4c>
 800abb8:	4bb2      	ldr	r3, [pc, #712]	; (800ae84 <_dtoa_r+0xa74>)
 800abba:	ec51 0b17 	vmov	r0, r1, d7
 800abbe:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 800abc2:	f7f5 ff3d 	bl	8000a40 <__aeabi_ddiv>
 800abc6:	e9cd 0100 	strd	r0, r1, [sp]
 800abca:	f005 050f 	and.w	r5, r5, #15
 800abce:	f04f 0803 	mov.w	r8, #3
 800abd2:	b18d      	cbz	r5, 800abf8 <_dtoa_r+0x7e8>
 800abd4:	f8df 92ac 	ldr.w	r9, [pc, #684]	; 800ae84 <_dtoa_r+0xa74>
 800abd8:	4630      	mov	r0, r6
 800abda:	4639      	mov	r1, r7
 800abdc:	07ea      	lsls	r2, r5, #31
 800abde:	d505      	bpl.n	800abec <_dtoa_r+0x7dc>
 800abe0:	e9d9 2300 	ldrd	r2, r3, [r9]
 800abe4:	f7f5 fe02 	bl	80007ec <__aeabi_dmul>
 800abe8:	f108 0801 	add.w	r8, r8, #1
 800abec:	106d      	asrs	r5, r5, #1
 800abee:	f109 0908 	add.w	r9, r9, #8
 800abf2:	d1f3      	bne.n	800abdc <_dtoa_r+0x7cc>
 800abf4:	4606      	mov	r6, r0
 800abf6:	460f      	mov	r7, r1
 800abf8:	e9dd 0100 	ldrd	r0, r1, [sp]
 800abfc:	4632      	mov	r2, r6
 800abfe:	463b      	mov	r3, r7
 800ac00:	f7f5 ff1e 	bl	8000a40 <__aeabi_ddiv>
 800ac04:	e9cd 0100 	strd	r0, r1, [sp]
 800ac08:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ac0a:	b143      	cbz	r3, 800ac1e <_dtoa_r+0x80e>
 800ac0c:	e9dd 0100 	ldrd	r0, r1, [sp]
 800ac10:	2200      	movs	r2, #0
 800ac12:	4b9d      	ldr	r3, [pc, #628]	; (800ae88 <_dtoa_r+0xa78>)
 800ac14:	f7f6 f85c 	bl	8000cd0 <__aeabi_dcmplt>
 800ac18:	2800      	cmp	r0, #0
 800ac1a:	f040 82ae 	bne.w	800b17a <_dtoa_r+0xd6a>
 800ac1e:	4640      	mov	r0, r8
 800ac20:	f7f5 fd7e 	bl	8000720 <__aeabi_i2d>
 800ac24:	e9dd 2300 	ldrd	r2, r3, [sp]
 800ac28:	f7f5 fde0 	bl	80007ec <__aeabi_dmul>
 800ac2c:	4b97      	ldr	r3, [pc, #604]	; (800ae8c <_dtoa_r+0xa7c>)
 800ac2e:	2200      	movs	r2, #0
 800ac30:	f7f5 fc2a 	bl	8000488 <__adddf3>
 800ac34:	9b08      	ldr	r3, [sp, #32]
 800ac36:	4606      	mov	r6, r0
 800ac38:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 800ac3c:	2b00      	cmp	r3, #0
 800ac3e:	f000 8162 	beq.w	800af06 <_dtoa_r+0xaf6>
 800ac42:	9b05      	ldr	r3, [sp, #20]
 800ac44:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800ac48:	9314      	str	r3, [sp, #80]	; 0x50
 800ac4a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800ac4c:	2b00      	cmp	r3, #0
 800ac4e:	f000 8223 	beq.w	800b098 <_dtoa_r+0xc88>
 800ac52:	4b8b      	ldr	r3, [pc, #556]	; (800ae80 <_dtoa_r+0xa70>)
 800ac54:	498e      	ldr	r1, [pc, #568]	; (800ae90 <_dtoa_r+0xa80>)
 800ac56:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 800ac5a:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 800ac5e:	2000      	movs	r0, #0
 800ac60:	f7f5 feee 	bl	8000a40 <__aeabi_ddiv>
 800ac64:	4632      	mov	r2, r6
 800ac66:	463b      	mov	r3, r7
 800ac68:	f7f5 fc0c 	bl	8000484 <__aeabi_dsub>
 800ac6c:	e9dd 6700 	ldrd	r6, r7, [sp]
 800ac70:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 800ac74:	4639      	mov	r1, r7
 800ac76:	4630      	mov	r0, r6
 800ac78:	f7f6 f852 	bl	8000d20 <__aeabi_d2iz>
 800ac7c:	4605      	mov	r5, r0
 800ac7e:	f7f5 fd4f 	bl	8000720 <__aeabi_i2d>
 800ac82:	3530      	adds	r5, #48	; 0x30
 800ac84:	4602      	mov	r2, r0
 800ac86:	460b      	mov	r3, r1
 800ac88:	4630      	mov	r0, r6
 800ac8a:	4639      	mov	r1, r7
 800ac8c:	f7f5 fbfa 	bl	8000484 <__aeabi_dsub>
 800ac90:	fa5f f885 	uxtb.w	r8, r5
 800ac94:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800ac96:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 800ac9a:	f885 8000 	strb.w	r8, [r5]
 800ac9e:	4606      	mov	r6, r0
 800aca0:	460f      	mov	r7, r1
 800aca2:	3501      	adds	r5, #1
 800aca4:	f7f6 f814 	bl	8000cd0 <__aeabi_dcmplt>
 800aca8:	2800      	cmp	r0, #0
 800acaa:	f040 82a7 	bne.w	800b1fc <_dtoa_r+0xdec>
 800acae:	4632      	mov	r2, r6
 800acb0:	463b      	mov	r3, r7
 800acb2:	2000      	movs	r0, #0
 800acb4:	4974      	ldr	r1, [pc, #464]	; (800ae88 <_dtoa_r+0xa78>)
 800acb6:	f7f5 fbe5 	bl	8000484 <__aeabi_dsub>
 800acba:	4602      	mov	r2, r0
 800acbc:	460b      	mov	r3, r1
 800acbe:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800acc2:	f7f6 f823 	bl	8000d0c <__aeabi_dcmpgt>
 800acc6:	2800      	cmp	r0, #0
 800acc8:	f040 82ad 	bne.w	800b226 <_dtoa_r+0xe16>
 800accc:	f1b9 0f01 	cmp.w	r9, #1
 800acd0:	f340 8184 	ble.w	800afdc <_dtoa_r+0xbcc>
 800acd4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800acd6:	f8cd b000 	str.w	fp, [sp]
 800acda:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
 800acde:	4499      	add	r9, r3
 800ace0:	46a0      	mov	r8, r4
 800ace2:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
 800ace6:	e00d      	b.n	800ad04 <_dtoa_r+0x8f4>
 800ace8:	2000      	movs	r0, #0
 800acea:	4967      	ldr	r1, [pc, #412]	; (800ae88 <_dtoa_r+0xa78>)
 800acec:	f7f5 fbca 	bl	8000484 <__aeabi_dsub>
 800acf0:	4652      	mov	r2, sl
 800acf2:	465b      	mov	r3, fp
 800acf4:	f7f5 ffec 	bl	8000cd0 <__aeabi_dcmplt>
 800acf8:	2800      	cmp	r0, #0
 800acfa:	f040 828f 	bne.w	800b21c <_dtoa_r+0xe0c>
 800acfe:	454d      	cmp	r5, r9
 800ad00:	f000 8167 	beq.w	800afd2 <_dtoa_r+0xbc2>
 800ad04:	4650      	mov	r0, sl
 800ad06:	4659      	mov	r1, fp
 800ad08:	2200      	movs	r2, #0
 800ad0a:	4b62      	ldr	r3, [pc, #392]	; (800ae94 <_dtoa_r+0xa84>)
 800ad0c:	f7f5 fd6e 	bl	80007ec <__aeabi_dmul>
 800ad10:	2200      	movs	r2, #0
 800ad12:	4b60      	ldr	r3, [pc, #384]	; (800ae94 <_dtoa_r+0xa84>)
 800ad14:	4682      	mov	sl, r0
 800ad16:	468b      	mov	fp, r1
 800ad18:	4630      	mov	r0, r6
 800ad1a:	4639      	mov	r1, r7
 800ad1c:	f7f5 fd66 	bl	80007ec <__aeabi_dmul>
 800ad20:	460f      	mov	r7, r1
 800ad22:	4606      	mov	r6, r0
 800ad24:	f7f5 fffc 	bl	8000d20 <__aeabi_d2iz>
 800ad28:	4604      	mov	r4, r0
 800ad2a:	f7f5 fcf9 	bl	8000720 <__aeabi_i2d>
 800ad2e:	4602      	mov	r2, r0
 800ad30:	460b      	mov	r3, r1
 800ad32:	4630      	mov	r0, r6
 800ad34:	4639      	mov	r1, r7
 800ad36:	f7f5 fba5 	bl	8000484 <__aeabi_dsub>
 800ad3a:	3430      	adds	r4, #48	; 0x30
 800ad3c:	b2e4      	uxtb	r4, r4
 800ad3e:	4652      	mov	r2, sl
 800ad40:	465b      	mov	r3, fp
 800ad42:	f805 4b01 	strb.w	r4, [r5], #1
 800ad46:	4606      	mov	r6, r0
 800ad48:	460f      	mov	r7, r1
 800ad4a:	f7f5 ffc1 	bl	8000cd0 <__aeabi_dcmplt>
 800ad4e:	4632      	mov	r2, r6
 800ad50:	463b      	mov	r3, r7
 800ad52:	2800      	cmp	r0, #0
 800ad54:	d0c8      	beq.n	800ace8 <_dtoa_r+0x8d8>
 800ad56:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800ad58:	f8dd b000 	ldr.w	fp, [sp]
 800ad5c:	9305      	str	r3, [sp, #20]
 800ad5e:	4644      	mov	r4, r8
 800ad60:	e52d      	b.n	800a7be <_dtoa_r+0x3ae>
 800ad62:	2300      	movs	r3, #0
 800ad64:	930b      	str	r3, [sp, #44]	; 0x2c
 800ad66:	9b05      	ldr	r3, [sp, #20]
 800ad68:	4453      	add	r3, sl
 800ad6a:	930e      	str	r3, [sp, #56]	; 0x38
 800ad6c:	3301      	adds	r3, #1
 800ad6e:	2b00      	cmp	r3, #0
 800ad70:	9308      	str	r3, [sp, #32]
 800ad72:	f340 8101 	ble.w	800af78 <_dtoa_r+0xb68>
 800ad76:	9d08      	ldr	r5, [sp, #32]
 800ad78:	462e      	mov	r6, r5
 800ad7a:	e6f0      	b.n	800ab5e <_dtoa_r+0x74e>
 800ad7c:	2300      	movs	r3, #0
 800ad7e:	930b      	str	r3, [sp, #44]	; 0x2c
 800ad80:	e6e3      	b.n	800ab4a <_dtoa_r+0x73a>
 800ad82:	9b08      	ldr	r3, [sp, #32]
 800ad84:	2b00      	cmp	r3, #0
 800ad86:	f73f ac67 	bgt.w	800a658 <_dtoa_r+0x248>
 800ad8a:	f040 80d4 	bne.w	800af36 <_dtoa_r+0xb26>
 800ad8e:	4640      	mov	r0, r8
 800ad90:	2200      	movs	r2, #0
 800ad92:	4b41      	ldr	r3, [pc, #260]	; (800ae98 <_dtoa_r+0xa88>)
 800ad94:	4649      	mov	r1, r9
 800ad96:	f7f5 fd29 	bl	80007ec <__aeabi_dmul>
 800ad9a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800ad9e:	f7f5 ffab 	bl	8000cf8 <__aeabi_dcmpge>
 800ada2:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800ada6:	4646      	mov	r6, r8
 800ada8:	2800      	cmp	r0, #0
 800adaa:	f000 808b 	beq.w	800aec4 <_dtoa_r+0xab4>
 800adae:	ea6f 030a 	mvn.w	r3, sl
 800adb2:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800adb4:	9305      	str	r3, [sp, #20]
 800adb6:	4641      	mov	r1, r8
 800adb8:	4620      	mov	r0, r4
 800adba:	f000 fd85 	bl	800b8c8 <_Bfree>
 800adbe:	2e00      	cmp	r6, #0
 800adc0:	f47f ae2b 	bne.w	800aa1a <_dtoa_r+0x60a>
 800adc4:	e4fb      	b.n	800a7be <_dtoa_r+0x3ae>
 800adc6:	4659      	mov	r1, fp
 800adc8:	4620      	mov	r0, r4
 800adca:	f000 febb 	bl	800bb44 <__pow5mult>
 800adce:	4683      	mov	fp, r0
 800add0:	e554      	b.n	800a87c <_dtoa_r+0x46c>
 800add2:	9b00      	ldr	r3, [sp, #0]
 800add4:	2b00      	cmp	r3, #0
 800add6:	f47f ad63 	bne.w	800a8a0 <_dtoa_r+0x490>
 800adda:	9b01      	ldr	r3, [sp, #4]
 800addc:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800ade0:	2b00      	cmp	r3, #0
 800ade2:	f47f ad90 	bne.w	800a906 <_dtoa_r+0x4f6>
 800ade6:	9b01      	ldr	r3, [sp, #4]
 800ade8:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 800adec:	0d3f      	lsrs	r7, r7, #20
 800adee:	053f      	lsls	r7, r7, #20
 800adf0:	2f00      	cmp	r7, #0
 800adf2:	f000 821c 	beq.w	800b22e <_dtoa_r+0xe1e>
 800adf6:	9b07      	ldr	r3, [sp, #28]
 800adf8:	3301      	adds	r3, #1
 800adfa:	9307      	str	r3, [sp, #28]
 800adfc:	9b06      	ldr	r3, [sp, #24]
 800adfe:	3301      	adds	r3, #1
 800ae00:	9306      	str	r3, [sp, #24]
 800ae02:	f04f 0901 	mov.w	r9, #1
 800ae06:	e580      	b.n	800a90a <_dtoa_r+0x4fa>
 800ae08:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800ae0a:	2a00      	cmp	r2, #0
 800ae0c:	f000 81a7 	beq.w	800b15e <_dtoa_r+0xd4e>
 800ae10:	f203 4333 	addw	r3, r3, #1075	; 0x433
 800ae14:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800ae16:	9d07      	ldr	r5, [sp, #28]
 800ae18:	e4f9      	b.n	800a80e <_dtoa_r+0x3fe>
 800ae1a:	f000 fd5f 	bl	800b8dc <__multadd>
 800ae1e:	4657      	mov	r7, sl
 800ae20:	4606      	mov	r6, r0
 800ae22:	4681      	mov	r9, r0
 800ae24:	e62f      	b.n	800aa86 <_dtoa_r+0x676>
 800ae26:	4601      	mov	r1, r0
 800ae28:	4620      	mov	r0, r4
 800ae2a:	f8cd c000 	str.w	ip, [sp]
 800ae2e:	f000 fd4b 	bl	800b8c8 <_Bfree>
 800ae32:	2201      	movs	r2, #1
 800ae34:	f8dd c000 	ldr.w	ip, [sp]
 800ae38:	e652      	b.n	800aae0 <_dtoa_r+0x6d0>
 800ae3a:	4658      	mov	r0, fp
 800ae3c:	4641      	mov	r1, r8
 800ae3e:	f000 ff27 	bl	800bc90 <__mcmp>
 800ae42:	2800      	cmp	r0, #0
 800ae44:	f6bf ad8f 	bge.w	800a966 <_dtoa_r+0x556>
 800ae48:	9f05      	ldr	r7, [sp, #20]
 800ae4a:	4659      	mov	r1, fp
 800ae4c:	2300      	movs	r3, #0
 800ae4e:	4620      	mov	r0, r4
 800ae50:	220a      	movs	r2, #10
 800ae52:	3f01      	subs	r7, #1
 800ae54:	9705      	str	r7, [sp, #20]
 800ae56:	f000 fd41 	bl	800b8dc <__multadd>
 800ae5a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800ae5c:	4683      	mov	fp, r0
 800ae5e:	2b00      	cmp	r3, #0
 800ae60:	f47f adee 	bne.w	800aa40 <_dtoa_r+0x630>
 800ae64:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800ae66:	2b00      	cmp	r3, #0
 800ae68:	f340 81f5 	ble.w	800b256 <_dtoa_r+0xe46>
 800ae6c:	9308      	str	r3, [sp, #32]
 800ae6e:	e581      	b.n	800a974 <_dtoa_r+0x564>
 800ae70:	9809      	ldr	r0, [sp, #36]	; 0x24
 800ae72:	f7ff bb04 	b.w	800a47e <_dtoa_r+0x6e>
 800ae76:	9b00      	ldr	r3, [sp, #0]
 800ae78:	2b00      	cmp	r3, #0
 800ae7a:	f47f ad44 	bne.w	800a906 <_dtoa_r+0x4f6>
 800ae7e:	e7ac      	b.n	800adda <_dtoa_r+0x9ca>
 800ae80:	0800d578 	.word	0x0800d578
 800ae84:	0800d650 	.word	0x0800d650
 800ae88:	3ff00000 	.word	0x3ff00000
 800ae8c:	401c0000 	.word	0x401c0000
 800ae90:	3fe00000 	.word	0x3fe00000
 800ae94:	40240000 	.word	0x40240000
 800ae98:	40140000 	.word	0x40140000
 800ae9c:	9b03      	ldr	r3, [sp, #12]
 800ae9e:	2b02      	cmp	r3, #2
 800aea0:	f77f ad65 	ble.w	800a96e <_dtoa_r+0x55e>
 800aea4:	9b08      	ldr	r3, [sp, #32]
 800aea6:	2b00      	cmp	r3, #0
 800aea8:	d181      	bne.n	800adae <_dtoa_r+0x99e>
 800aeaa:	4641      	mov	r1, r8
 800aeac:	2205      	movs	r2, #5
 800aeae:	4620      	mov	r0, r4
 800aeb0:	f000 fd14 	bl	800b8dc <__multadd>
 800aeb4:	4680      	mov	r8, r0
 800aeb6:	4641      	mov	r1, r8
 800aeb8:	4658      	mov	r0, fp
 800aeba:	f000 fee9 	bl	800bc90 <__mcmp>
 800aebe:	2800      	cmp	r0, #0
 800aec0:	f77f af75 	ble.w	800adae <_dtoa_r+0x99e>
 800aec4:	9a05      	ldr	r2, [sp, #20]
 800aec6:	9909      	ldr	r1, [sp, #36]	; 0x24
 800aec8:	2331      	movs	r3, #49	; 0x31
 800aeca:	3201      	adds	r2, #1
 800aecc:	9205      	str	r2, [sp, #20]
 800aece:	700b      	strb	r3, [r1, #0]
 800aed0:	1c4d      	adds	r5, r1, #1
 800aed2:	e770      	b.n	800adb6 <_dtoa_r+0x9a6>
 800aed4:	9a05      	ldr	r2, [sp, #20]
 800aed6:	3201      	adds	r2, #1
 800aed8:	9205      	str	r2, [sp, #20]
 800aeda:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800aedc:	2331      	movs	r3, #49	; 0x31
 800aede:	7013      	strb	r3, [r2, #0]
 800aee0:	e58b      	b.n	800a9fa <_dtoa_r+0x5ea>
 800aee2:	f8dd b000 	ldr.w	fp, [sp]
 800aee6:	9c03      	ldr	r4, [sp, #12]
 800aee8:	e469      	b.n	800a7be <_dtoa_r+0x3ae>
 800aeea:	4640      	mov	r0, r8
 800aeec:	f7f5 fc18 	bl	8000720 <__aeabi_i2d>
 800aef0:	e9dd 2300 	ldrd	r2, r3, [sp]
 800aef4:	f7f5 fc7a 	bl	80007ec <__aeabi_dmul>
 800aef8:	2200      	movs	r2, #0
 800aefa:	4bc2      	ldr	r3, [pc, #776]	; (800b204 <_dtoa_r+0xdf4>)
 800aefc:	f7f5 fac4 	bl	8000488 <__adddf3>
 800af00:	4606      	mov	r6, r0
 800af02:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 800af06:	2200      	movs	r2, #0
 800af08:	4bbf      	ldr	r3, [pc, #764]	; (800b208 <_dtoa_r+0xdf8>)
 800af0a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800af0e:	f7f5 fab9 	bl	8000484 <__aeabi_dsub>
 800af12:	4632      	mov	r2, r6
 800af14:	463b      	mov	r3, r7
 800af16:	4680      	mov	r8, r0
 800af18:	4689      	mov	r9, r1
 800af1a:	f7f5 fef7 	bl	8000d0c <__aeabi_dcmpgt>
 800af1e:	2800      	cmp	r0, #0
 800af20:	f040 80b6 	bne.w	800b090 <_dtoa_r+0xc80>
 800af24:	4632      	mov	r2, r6
 800af26:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 800af2a:	4640      	mov	r0, r8
 800af2c:	4649      	mov	r1, r9
 800af2e:	f7f5 fecf 	bl	8000cd0 <__aeabi_dcmplt>
 800af32:	2800      	cmp	r0, #0
 800af34:	d052      	beq.n	800afdc <_dtoa_r+0xbcc>
 800af36:	f04f 0800 	mov.w	r8, #0
 800af3a:	4646      	mov	r6, r8
 800af3c:	e737      	b.n	800adae <_dtoa_r+0x99e>
 800af3e:	4659      	mov	r1, fp
 800af40:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800af42:	4620      	mov	r0, r4
 800af44:	f000 fdfe 	bl	800bb44 <__pow5mult>
 800af48:	4683      	mov	fp, r0
 800af4a:	e497      	b.n	800a87c <_dtoa_r+0x46c>
 800af4c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800af4e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800af50:	970a      	str	r7, [sp, #40]	; 0x28
 800af52:	1afb      	subs	r3, r7, r3
 800af54:	441a      	add	r2, r3
 800af56:	920c      	str	r2, [sp, #48]	; 0x30
 800af58:	2700      	movs	r7, #0
 800af5a:	e452      	b.n	800a802 <_dtoa_r+0x3f2>
 800af5c:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 800af60:	f04f 0802 	mov.w	r8, #2
 800af64:	ed8d 7b00 	vstr	d7, [sp]
 800af68:	e633      	b.n	800abd2 <_dtoa_r+0x7c2>
 800af6a:	2501      	movs	r5, #1
 800af6c:	950e      	str	r5, [sp, #56]	; 0x38
 800af6e:	9508      	str	r5, [sp, #32]
 800af70:	46aa      	mov	sl, r5
 800af72:	2100      	movs	r1, #0
 800af74:	6461      	str	r1, [r4, #68]	; 0x44
 800af76:	e601      	b.n	800ab7c <_dtoa_r+0x76c>
 800af78:	461d      	mov	r5, r3
 800af7a:	e7fa      	b.n	800af72 <_dtoa_r+0xb62>
 800af7c:	2a00      	cmp	r2, #0
 800af7e:	dd15      	ble.n	800afac <_dtoa_r+0xb9c>
 800af80:	4659      	mov	r1, fp
 800af82:	2201      	movs	r2, #1
 800af84:	4620      	mov	r0, r4
 800af86:	f8cd c000 	str.w	ip, [sp]
 800af8a:	f000 fe2b 	bl	800bbe4 <__lshift>
 800af8e:	4641      	mov	r1, r8
 800af90:	4683      	mov	fp, r0
 800af92:	f000 fe7d 	bl	800bc90 <__mcmp>
 800af96:	2800      	cmp	r0, #0
 800af98:	f8dd c000 	ldr.w	ip, [sp]
 800af9c:	f340 8154 	ble.w	800b248 <_dtoa_r+0xe38>
 800afa0:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 800afa4:	f000 8111 	beq.w	800b1ca <_dtoa_r+0xdba>
 800afa8:	f10c 0c01 	add.w	ip, ip, #1
 800afac:	46b2      	mov	sl, r6
 800afae:	f887 c000 	strb.w	ip, [r7]
 800afb2:	1c7d      	adds	r5, r7, #1
 800afb4:	464e      	mov	r6, r9
 800afb6:	e520      	b.n	800a9fa <_dtoa_r+0x5ea>
 800afb8:	d104      	bne.n	800afc4 <_dtoa_r+0xbb4>
 800afba:	f01c 0f01 	tst.w	ip, #1
 800afbe:	d001      	beq.n	800afc4 <_dtoa_r+0xbb4>
 800afc0:	e50b      	b.n	800a9da <_dtoa_r+0x5ca>
 800afc2:	4615      	mov	r5, r2
 800afc4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 800afc8:	2b30      	cmp	r3, #48	; 0x30
 800afca:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 800afce:	d0f8      	beq.n	800afc2 <_dtoa_r+0xbb2>
 800afd0:	e513      	b.n	800a9fa <_dtoa_r+0x5ea>
 800afd2:	f8dd b000 	ldr.w	fp, [sp]
 800afd6:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
 800afda:	4644      	mov	r4, r8
 800afdc:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 800afe0:	e9cd 2300 	strd	r2, r3, [sp]
 800afe4:	f7ff bb27 	b.w	800a636 <_dtoa_r+0x226>
 800afe8:	9b05      	ldr	r3, [sp, #20]
 800afea:	425d      	negs	r5, r3
 800afec:	2d00      	cmp	r5, #0
 800afee:	f000 80bd 	beq.w	800b16c <_dtoa_r+0xd5c>
 800aff2:	4b86      	ldr	r3, [pc, #536]	; (800b20c <_dtoa_r+0xdfc>)
 800aff4:	f005 020f 	and.w	r2, r5, #15
 800aff8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800affc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b000:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800b004:	f7f5 fbf2 	bl	80007ec <__aeabi_dmul>
 800b008:	112d      	asrs	r5, r5, #4
 800b00a:	e9cd 0100 	strd	r0, r1, [sp]
 800b00e:	f000 8127 	beq.w	800b260 <_dtoa_r+0xe50>
 800b012:	4e7f      	ldr	r6, [pc, #508]	; (800b210 <_dtoa_r+0xe00>)
 800b014:	f04f 0802 	mov.w	r8, #2
 800b018:	07eb      	lsls	r3, r5, #31
 800b01a:	d505      	bpl.n	800b028 <_dtoa_r+0xc18>
 800b01c:	e9d6 2300 	ldrd	r2, r3, [r6]
 800b020:	f7f5 fbe4 	bl	80007ec <__aeabi_dmul>
 800b024:	f108 0801 	add.w	r8, r8, #1
 800b028:	106d      	asrs	r5, r5, #1
 800b02a:	f106 0608 	add.w	r6, r6, #8
 800b02e:	d1f3      	bne.n	800b018 <_dtoa_r+0xc08>
 800b030:	e9cd 0100 	strd	r0, r1, [sp]
 800b034:	e5e8      	b.n	800ac08 <_dtoa_r+0x7f8>
 800b036:	9a05      	ldr	r2, [sp, #20]
 800b038:	3201      	adds	r2, #1
 800b03a:	9205      	str	r2, [sp, #20]
 800b03c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b03e:	2330      	movs	r3, #48	; 0x30
 800b040:	7013      	strb	r3, [r2, #0]
 800b042:	2331      	movs	r3, #49	; 0x31
 800b044:	7013      	strb	r3, [r2, #0]
 800b046:	f7ff bbba 	b.w	800a7be <_dtoa_r+0x3ae>
 800b04a:	6871      	ldr	r1, [r6, #4]
 800b04c:	4620      	mov	r0, r4
 800b04e:	f000 fc15 	bl	800b87c <_Balloc>
 800b052:	6933      	ldr	r3, [r6, #16]
 800b054:	1c9a      	adds	r2, r3, #2
 800b056:	4605      	mov	r5, r0
 800b058:	0092      	lsls	r2, r2, #2
 800b05a:	f106 010c 	add.w	r1, r6, #12
 800b05e:	300c      	adds	r0, #12
 800b060:	f7f5 f972 	bl	8000348 <memcpy>
 800b064:	4620      	mov	r0, r4
 800b066:	4629      	mov	r1, r5
 800b068:	2201      	movs	r2, #1
 800b06a:	f000 fdbb 	bl	800bbe4 <__lshift>
 800b06e:	4681      	mov	r9, r0
 800b070:	e4ff      	b.n	800aa72 <_dtoa_r+0x662>
 800b072:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 800b076:	f000 80a8 	beq.w	800b1ca <_dtoa_r+0xdba>
 800b07a:	f10c 0c01 	add.w	ip, ip, #1
 800b07e:	46b2      	mov	sl, r6
 800b080:	f887 c000 	strb.w	ip, [r7]
 800b084:	1c7d      	adds	r5, r7, #1
 800b086:	464e      	mov	r6, r9
 800b088:	e4b7      	b.n	800a9fa <_dtoa_r+0x5ea>
 800b08a:	46b2      	mov	sl, r6
 800b08c:	464e      	mov	r6, r9
 800b08e:	e494      	b.n	800a9ba <_dtoa_r+0x5aa>
 800b090:	f04f 0800 	mov.w	r8, #0
 800b094:	4646      	mov	r6, r8
 800b096:	e715      	b.n	800aec4 <_dtoa_r+0xab4>
 800b098:	495c      	ldr	r1, [pc, #368]	; (800b20c <_dtoa_r+0xdfc>)
 800b09a:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
 800b09e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 800b0a2:	4632      	mov	r2, r6
 800b0a4:	9315      	str	r3, [sp, #84]	; 0x54
 800b0a6:	e9d1 0100 	ldrd	r0, r1, [r1]
 800b0aa:	463b      	mov	r3, r7
 800b0ac:	f7f5 fb9e 	bl	80007ec <__aeabi_dmul>
 800b0b0:	e9dd 6700 	ldrd	r6, r7, [sp]
 800b0b4:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
 800b0b8:	4639      	mov	r1, r7
 800b0ba:	4630      	mov	r0, r6
 800b0bc:	f7f5 fe30 	bl	8000d20 <__aeabi_d2iz>
 800b0c0:	4605      	mov	r5, r0
 800b0c2:	f7f5 fb2d 	bl	8000720 <__aeabi_i2d>
 800b0c6:	4602      	mov	r2, r0
 800b0c8:	460b      	mov	r3, r1
 800b0ca:	4630      	mov	r0, r6
 800b0cc:	4639      	mov	r1, r7
 800b0ce:	f7f5 f9d9 	bl	8000484 <__aeabi_dsub>
 800b0d2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800b0d4:	3530      	adds	r5, #48	; 0x30
 800b0d6:	f1b9 0f01 	cmp.w	r9, #1
 800b0da:	7015      	strb	r5, [r2, #0]
 800b0dc:	4606      	mov	r6, r0
 800b0de:	460f      	mov	r7, r1
 800b0e0:	f102 0501 	add.w	r5, r2, #1
 800b0e4:	d023      	beq.n	800b12e <_dtoa_r+0xd1e>
 800b0e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800b0e8:	f8cd b000 	str.w	fp, [sp]
 800b0ec:	444b      	add	r3, r9
 800b0ee:	4698      	mov	r8, r3
 800b0f0:	46a9      	mov	r9, r5
 800b0f2:	46ab      	mov	fp, r5
 800b0f4:	2200      	movs	r2, #0
 800b0f6:	4b47      	ldr	r3, [pc, #284]	; (800b214 <_dtoa_r+0xe04>)
 800b0f8:	f7f5 fb78 	bl	80007ec <__aeabi_dmul>
 800b0fc:	460f      	mov	r7, r1
 800b0fe:	4606      	mov	r6, r0
 800b100:	f7f5 fe0e 	bl	8000d20 <__aeabi_d2iz>
 800b104:	4605      	mov	r5, r0
 800b106:	f7f5 fb0b 	bl	8000720 <__aeabi_i2d>
 800b10a:	3530      	adds	r5, #48	; 0x30
 800b10c:	4602      	mov	r2, r0
 800b10e:	460b      	mov	r3, r1
 800b110:	4630      	mov	r0, r6
 800b112:	4639      	mov	r1, r7
 800b114:	f7f5 f9b6 	bl	8000484 <__aeabi_dsub>
 800b118:	f809 5b01 	strb.w	r5, [r9], #1
 800b11c:	45c1      	cmp	r9, r8
 800b11e:	d1e9      	bne.n	800b0f4 <_dtoa_r+0xce4>
 800b120:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800b122:	465d      	mov	r5, fp
 800b124:	f8dd b000 	ldr.w	fp, [sp]
 800b128:	4606      	mov	r6, r0
 800b12a:	460f      	mov	r7, r1
 800b12c:	441d      	add	r5, r3
 800b12e:	2200      	movs	r2, #0
 800b130:	4b39      	ldr	r3, [pc, #228]	; (800b218 <_dtoa_r+0xe08>)
 800b132:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
 800b136:	f7f5 f9a7 	bl	8000488 <__adddf3>
 800b13a:	4632      	mov	r2, r6
 800b13c:	463b      	mov	r3, r7
 800b13e:	f7f5 fdc7 	bl	8000cd0 <__aeabi_dcmplt>
 800b142:	2800      	cmp	r0, #0
 800b144:	d047      	beq.n	800b1d6 <_dtoa_r+0xdc6>
 800b146:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800b148:	9305      	str	r3, [sp, #20]
 800b14a:	f815 8c01 	ldrb.w	r8, [r5, #-1]
 800b14e:	f7ff bb24 	b.w	800a79a <_dtoa_r+0x38a>
 800b152:	9b07      	ldr	r3, [sp, #28]
 800b154:	9a08      	ldr	r2, [sp, #32]
 800b156:	1a9d      	subs	r5, r3, r2
 800b158:	2300      	movs	r3, #0
 800b15a:	f7ff bb58 	b.w	800a80e <_dtoa_r+0x3fe>
 800b15e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800b160:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800b162:	9d07      	ldr	r5, [sp, #28]
 800b164:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 800b168:	f7ff bb51 	b.w	800a80e <_dtoa_r+0x3fe>
 800b16c:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 800b170:	f04f 0802 	mov.w	r8, #2
 800b174:	ed8d 7b00 	vstr	d7, [sp]
 800b178:	e546      	b.n	800ac08 <_dtoa_r+0x7f8>
 800b17a:	9b08      	ldr	r3, [sp, #32]
 800b17c:	2b00      	cmp	r3, #0
 800b17e:	f43f aeb4 	beq.w	800aeea <_dtoa_r+0xada>
 800b182:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 800b184:	2d00      	cmp	r5, #0
 800b186:	f77f af29 	ble.w	800afdc <_dtoa_r+0xbcc>
 800b18a:	2200      	movs	r2, #0
 800b18c:	4b21      	ldr	r3, [pc, #132]	; (800b214 <_dtoa_r+0xe04>)
 800b18e:	e9dd 0100 	ldrd	r0, r1, [sp]
 800b192:	f7f5 fb2b 	bl	80007ec <__aeabi_dmul>
 800b196:	4606      	mov	r6, r0
 800b198:	460f      	mov	r7, r1
 800b19a:	f108 0001 	add.w	r0, r8, #1
 800b19e:	e9cd 6700 	strd	r6, r7, [sp]
 800b1a2:	f7f5 fabd 	bl	8000720 <__aeabi_i2d>
 800b1a6:	4602      	mov	r2, r0
 800b1a8:	460b      	mov	r3, r1
 800b1aa:	4630      	mov	r0, r6
 800b1ac:	4639      	mov	r1, r7
 800b1ae:	f7f5 fb1d 	bl	80007ec <__aeabi_dmul>
 800b1b2:	4b14      	ldr	r3, [pc, #80]	; (800b204 <_dtoa_r+0xdf4>)
 800b1b4:	2200      	movs	r2, #0
 800b1b6:	f7f5 f967 	bl	8000488 <__adddf3>
 800b1ba:	9b05      	ldr	r3, [sp, #20]
 800b1bc:	3b01      	subs	r3, #1
 800b1be:	4606      	mov	r6, r0
 800b1c0:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
 800b1c4:	9314      	str	r3, [sp, #80]	; 0x50
 800b1c6:	46a9      	mov	r9, r5
 800b1c8:	e53f      	b.n	800ac4a <_dtoa_r+0x83a>
 800b1ca:	2239      	movs	r2, #57	; 0x39
 800b1cc:	46b2      	mov	sl, r6
 800b1ce:	703a      	strb	r2, [r7, #0]
 800b1d0:	464e      	mov	r6, r9
 800b1d2:	1c7d      	adds	r5, r7, #1
 800b1d4:	e403      	b.n	800a9de <_dtoa_r+0x5ce>
 800b1d6:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 800b1da:	2000      	movs	r0, #0
 800b1dc:	490e      	ldr	r1, [pc, #56]	; (800b218 <_dtoa_r+0xe08>)
 800b1de:	f7f5 f951 	bl	8000484 <__aeabi_dsub>
 800b1e2:	4632      	mov	r2, r6
 800b1e4:	463b      	mov	r3, r7
 800b1e6:	f7f5 fd91 	bl	8000d0c <__aeabi_dcmpgt>
 800b1ea:	b908      	cbnz	r0, 800b1f0 <_dtoa_r+0xde0>
 800b1ec:	e6f6      	b.n	800afdc <_dtoa_r+0xbcc>
 800b1ee:	4615      	mov	r5, r2
 800b1f0:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 800b1f4:	2b30      	cmp	r3, #48	; 0x30
 800b1f6:	f105 32ff 	add.w	r2, r5, #4294967295	; 0xffffffff
 800b1fa:	d0f8      	beq.n	800b1ee <_dtoa_r+0xdde>
 800b1fc:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800b1fe:	9305      	str	r3, [sp, #20]
 800b200:	f7ff badd 	b.w	800a7be <_dtoa_r+0x3ae>
 800b204:	401c0000 	.word	0x401c0000
 800b208:	40140000 	.word	0x40140000
 800b20c:	0800d578 	.word	0x0800d578
 800b210:	0800d650 	.word	0x0800d650
 800b214:	40240000 	.word	0x40240000
 800b218:	3fe00000 	.word	0x3fe00000
 800b21c:	4643      	mov	r3, r8
 800b21e:	f8dd b000 	ldr.w	fp, [sp]
 800b222:	46a0      	mov	r8, r4
 800b224:	461c      	mov	r4, r3
 800b226:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800b228:	9305      	str	r3, [sp, #20]
 800b22a:	f7ff bab6 	b.w	800a79a <_dtoa_r+0x38a>
 800b22e:	46b9      	mov	r9, r7
 800b230:	f7ff bb6b 	b.w	800a90a <_dtoa_r+0x4fa>
 800b234:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
 800b238:	d0c7      	beq.n	800b1ca <_dtoa_r+0xdba>
 800b23a:	f1ba 0f00 	cmp.w	sl, #0
 800b23e:	f77f aeb5 	ble.w	800afac <_dtoa_r+0xb9c>
 800b242:	f105 0c31 	add.w	ip, r5, #49	; 0x31
 800b246:	e6b1      	b.n	800afac <_dtoa_r+0xb9c>
 800b248:	f47f aeb0 	bne.w	800afac <_dtoa_r+0xb9c>
 800b24c:	f01c 0f01 	tst.w	ip, #1
 800b250:	f43f aeac 	beq.w	800afac <_dtoa_r+0xb9c>
 800b254:	e6a4      	b.n	800afa0 <_dtoa_r+0xb90>
 800b256:	9b03      	ldr	r3, [sp, #12]
 800b258:	2b02      	cmp	r3, #2
 800b25a:	dc04      	bgt.n	800b266 <_dtoa_r+0xe56>
 800b25c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b25e:	e605      	b.n	800ae6c <_dtoa_r+0xa5c>
 800b260:	f04f 0802 	mov.w	r8, #2
 800b264:	e4d0      	b.n	800ac08 <_dtoa_r+0x7f8>
 800b266:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b268:	9308      	str	r3, [sp, #32]
 800b26a:	e61b      	b.n	800aea4 <_dtoa_r+0xa94>
 800b26c:	9b03      	ldr	r3, [sp, #12]
 800b26e:	2b02      	cmp	r3, #2
 800b270:	dcf9      	bgt.n	800b266 <_dtoa_r+0xe56>
 800b272:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b274:	f7ff bbef 	b.w	800aa56 <_dtoa_r+0x646>
 800b278:	2500      	movs	r5, #0
 800b27a:	6465      	str	r5, [r4, #68]	; 0x44
 800b27c:	4629      	mov	r1, r5
 800b27e:	4620      	mov	r0, r4
 800b280:	f000 fafc 	bl	800b87c <_Balloc>
 800b284:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b288:	9308      	str	r3, [sp, #32]
 800b28a:	930e      	str	r3, [sp, #56]	; 0x38
 800b28c:	2301      	movs	r3, #1
 800b28e:	9009      	str	r0, [sp, #36]	; 0x24
 800b290:	46aa      	mov	sl, r5
 800b292:	6420      	str	r0, [r4, #64]	; 0x40
 800b294:	930b      	str	r3, [sp, #44]	; 0x2c
 800b296:	f7ff b9ce 	b.w	800a636 <_dtoa_r+0x226>
 800b29a:	f43f ab4e 	beq.w	800a93a <_dtoa_r+0x52a>
 800b29e:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
 800b2a2:	f7ff bb43 	b.w	800a92c <_dtoa_r+0x51c>
 800b2a6:	2301      	movs	r3, #1
 800b2a8:	930b      	str	r3, [sp, #44]	; 0x2c
 800b2aa:	e55c      	b.n	800ad66 <_dtoa_r+0x956>
 800b2ac:	2701      	movs	r7, #1
 800b2ae:	f7ff b98d 	b.w	800a5cc <_dtoa_r+0x1bc>
 800b2b2:	bf00      	nop

0800b2b4 <_localeconv_r>:
 800b2b4:	4800      	ldr	r0, [pc, #0]	; (800b2b8 <_localeconv_r+0x4>)
 800b2b6:	4770      	bx	lr
 800b2b8:	20000d2c 	.word	0x20000d2c

0800b2bc <_malloc_r>:
 800b2bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b2c0:	f101 050b 	add.w	r5, r1, #11
 800b2c4:	2d16      	cmp	r5, #22
 800b2c6:	b083      	sub	sp, #12
 800b2c8:	4606      	mov	r6, r0
 800b2ca:	d927      	bls.n	800b31c <_malloc_r+0x60>
 800b2cc:	f035 0507 	bics.w	r5, r5, #7
 800b2d0:	f100 80b6 	bmi.w	800b440 <_malloc_r+0x184>
 800b2d4:	42a9      	cmp	r1, r5
 800b2d6:	f200 80b3 	bhi.w	800b440 <_malloc_r+0x184>
 800b2da:	f000 facb 	bl	800b874 <__malloc_lock>
 800b2de:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 800b2e2:	d222      	bcs.n	800b32a <_malloc_r+0x6e>
 800b2e4:	4fc2      	ldr	r7, [pc, #776]	; (800b5f0 <_malloc_r+0x334>)
 800b2e6:	08e8      	lsrs	r0, r5, #3
 800b2e8:	eb07 03c0 	add.w	r3, r7, r0, lsl #3
 800b2ec:	68dc      	ldr	r4, [r3, #12]
 800b2ee:	429c      	cmp	r4, r3
 800b2f0:	f000 81c8 	beq.w	800b684 <_malloc_r+0x3c8>
 800b2f4:	6863      	ldr	r3, [r4, #4]
 800b2f6:	68e1      	ldr	r1, [r4, #12]
 800b2f8:	68a5      	ldr	r5, [r4, #8]
 800b2fa:	f023 0303 	bic.w	r3, r3, #3
 800b2fe:	4423      	add	r3, r4
 800b300:	4630      	mov	r0, r6
 800b302:	685a      	ldr	r2, [r3, #4]
 800b304:	60e9      	str	r1, [r5, #12]
 800b306:	f042 0201 	orr.w	r2, r2, #1
 800b30a:	608d      	str	r5, [r1, #8]
 800b30c:	605a      	str	r2, [r3, #4]
 800b30e:	f000 fab3 	bl	800b878 <__malloc_unlock>
 800b312:	3408      	adds	r4, #8
 800b314:	4620      	mov	r0, r4
 800b316:	b003      	add	sp, #12
 800b318:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b31c:	2910      	cmp	r1, #16
 800b31e:	f200 808f 	bhi.w	800b440 <_malloc_r+0x184>
 800b322:	f000 faa7 	bl	800b874 <__malloc_lock>
 800b326:	2510      	movs	r5, #16
 800b328:	e7dc      	b.n	800b2e4 <_malloc_r+0x28>
 800b32a:	0a68      	lsrs	r0, r5, #9
 800b32c:	f000 808f 	beq.w	800b44e <_malloc_r+0x192>
 800b330:	2804      	cmp	r0, #4
 800b332:	f200 8154 	bhi.w	800b5de <_malloc_r+0x322>
 800b336:	09a8      	lsrs	r0, r5, #6
 800b338:	3038      	adds	r0, #56	; 0x38
 800b33a:	0041      	lsls	r1, r0, #1
 800b33c:	4fac      	ldr	r7, [pc, #688]	; (800b5f0 <_malloc_r+0x334>)
 800b33e:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 800b342:	68cc      	ldr	r4, [r1, #12]
 800b344:	42a1      	cmp	r1, r4
 800b346:	d106      	bne.n	800b356 <_malloc_r+0x9a>
 800b348:	e00c      	b.n	800b364 <_malloc_r+0xa8>
 800b34a:	2a00      	cmp	r2, #0
 800b34c:	f280 8082 	bge.w	800b454 <_malloc_r+0x198>
 800b350:	68e4      	ldr	r4, [r4, #12]
 800b352:	42a1      	cmp	r1, r4
 800b354:	d006      	beq.n	800b364 <_malloc_r+0xa8>
 800b356:	6863      	ldr	r3, [r4, #4]
 800b358:	f023 0303 	bic.w	r3, r3, #3
 800b35c:	1b5a      	subs	r2, r3, r5
 800b35e:	2a0f      	cmp	r2, #15
 800b360:	ddf3      	ble.n	800b34a <_malloc_r+0x8e>
 800b362:	3801      	subs	r0, #1
 800b364:	3001      	adds	r0, #1
 800b366:	49a2      	ldr	r1, [pc, #648]	; (800b5f0 <_malloc_r+0x334>)
 800b368:	693c      	ldr	r4, [r7, #16]
 800b36a:	f101 0e08 	add.w	lr, r1, #8
 800b36e:	4574      	cmp	r4, lr
 800b370:	f000 817d 	beq.w	800b66e <_malloc_r+0x3b2>
 800b374:	6863      	ldr	r3, [r4, #4]
 800b376:	f023 0303 	bic.w	r3, r3, #3
 800b37a:	1b5a      	subs	r2, r3, r5
 800b37c:	2a0f      	cmp	r2, #15
 800b37e:	f300 8163 	bgt.w	800b648 <_malloc_r+0x38c>
 800b382:	2a00      	cmp	r2, #0
 800b384:	f8c1 e014 	str.w	lr, [r1, #20]
 800b388:	f8c1 e010 	str.w	lr, [r1, #16]
 800b38c:	da73      	bge.n	800b476 <_malloc_r+0x1ba>
 800b38e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800b392:	f080 8139 	bcs.w	800b608 <_malloc_r+0x34c>
 800b396:	08db      	lsrs	r3, r3, #3
 800b398:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
 800b39c:	ea4f 0ca3 	mov.w	ip, r3, asr #2
 800b3a0:	684a      	ldr	r2, [r1, #4]
 800b3a2:	f8d8 9008 	ldr.w	r9, [r8, #8]
 800b3a6:	f8c4 9008 	str.w	r9, [r4, #8]
 800b3aa:	2301      	movs	r3, #1
 800b3ac:	fa03 f30c 	lsl.w	r3, r3, ip
 800b3b0:	4313      	orrs	r3, r2
 800b3b2:	f8c4 800c 	str.w	r8, [r4, #12]
 800b3b6:	604b      	str	r3, [r1, #4]
 800b3b8:	f8c8 4008 	str.w	r4, [r8, #8]
 800b3bc:	f8c9 400c 	str.w	r4, [r9, #12]
 800b3c0:	1082      	asrs	r2, r0, #2
 800b3c2:	2401      	movs	r4, #1
 800b3c4:	4094      	lsls	r4, r2
 800b3c6:	429c      	cmp	r4, r3
 800b3c8:	d862      	bhi.n	800b490 <_malloc_r+0x1d4>
 800b3ca:	4223      	tst	r3, r4
 800b3cc:	d106      	bne.n	800b3dc <_malloc_r+0x120>
 800b3ce:	f020 0003 	bic.w	r0, r0, #3
 800b3d2:	0064      	lsls	r4, r4, #1
 800b3d4:	4223      	tst	r3, r4
 800b3d6:	f100 0004 	add.w	r0, r0, #4
 800b3da:	d0fa      	beq.n	800b3d2 <_malloc_r+0x116>
 800b3dc:	eb07 08c0 	add.w	r8, r7, r0, lsl #3
 800b3e0:	46c4      	mov	ip, r8
 800b3e2:	4681      	mov	r9, r0
 800b3e4:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800b3e8:	459c      	cmp	ip, r3
 800b3ea:	d107      	bne.n	800b3fc <_malloc_r+0x140>
 800b3ec:	e141      	b.n	800b672 <_malloc_r+0x3b6>
 800b3ee:	2900      	cmp	r1, #0
 800b3f0:	f280 8151 	bge.w	800b696 <_malloc_r+0x3da>
 800b3f4:	68db      	ldr	r3, [r3, #12]
 800b3f6:	459c      	cmp	ip, r3
 800b3f8:	f000 813b 	beq.w	800b672 <_malloc_r+0x3b6>
 800b3fc:	685a      	ldr	r2, [r3, #4]
 800b3fe:	f022 0203 	bic.w	r2, r2, #3
 800b402:	1b51      	subs	r1, r2, r5
 800b404:	290f      	cmp	r1, #15
 800b406:	ddf2      	ble.n	800b3ee <_malloc_r+0x132>
 800b408:	461c      	mov	r4, r3
 800b40a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 800b40e:	f854 8f08 	ldr.w	r8, [r4, #8]!
 800b412:	195a      	adds	r2, r3, r5
 800b414:	f045 0901 	orr.w	r9, r5, #1
 800b418:	f041 0501 	orr.w	r5, r1, #1
 800b41c:	f8c3 9004 	str.w	r9, [r3, #4]
 800b420:	4630      	mov	r0, r6
 800b422:	f8c8 c00c 	str.w	ip, [r8, #12]
 800b426:	f8cc 8008 	str.w	r8, [ip, #8]
 800b42a:	617a      	str	r2, [r7, #20]
 800b42c:	613a      	str	r2, [r7, #16]
 800b42e:	f8c2 e00c 	str.w	lr, [r2, #12]
 800b432:	f8c2 e008 	str.w	lr, [r2, #8]
 800b436:	6055      	str	r5, [r2, #4]
 800b438:	5051      	str	r1, [r2, r1]
 800b43a:	f000 fa1d 	bl	800b878 <__malloc_unlock>
 800b43e:	e769      	b.n	800b314 <_malloc_r+0x58>
 800b440:	2400      	movs	r4, #0
 800b442:	230c      	movs	r3, #12
 800b444:	4620      	mov	r0, r4
 800b446:	6033      	str	r3, [r6, #0]
 800b448:	b003      	add	sp, #12
 800b44a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b44e:	217e      	movs	r1, #126	; 0x7e
 800b450:	203f      	movs	r0, #63	; 0x3f
 800b452:	e773      	b.n	800b33c <_malloc_r+0x80>
 800b454:	4423      	add	r3, r4
 800b456:	68e1      	ldr	r1, [r4, #12]
 800b458:	685a      	ldr	r2, [r3, #4]
 800b45a:	68a5      	ldr	r5, [r4, #8]
 800b45c:	f042 0201 	orr.w	r2, r2, #1
 800b460:	60e9      	str	r1, [r5, #12]
 800b462:	4630      	mov	r0, r6
 800b464:	608d      	str	r5, [r1, #8]
 800b466:	605a      	str	r2, [r3, #4]
 800b468:	f000 fa06 	bl	800b878 <__malloc_unlock>
 800b46c:	3408      	adds	r4, #8
 800b46e:	4620      	mov	r0, r4
 800b470:	b003      	add	sp, #12
 800b472:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b476:	4423      	add	r3, r4
 800b478:	4630      	mov	r0, r6
 800b47a:	685a      	ldr	r2, [r3, #4]
 800b47c:	f042 0201 	orr.w	r2, r2, #1
 800b480:	605a      	str	r2, [r3, #4]
 800b482:	f000 f9f9 	bl	800b878 <__malloc_unlock>
 800b486:	3408      	adds	r4, #8
 800b488:	4620      	mov	r0, r4
 800b48a:	b003      	add	sp, #12
 800b48c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b490:	68bc      	ldr	r4, [r7, #8]
 800b492:	6863      	ldr	r3, [r4, #4]
 800b494:	f023 0803 	bic.w	r8, r3, #3
 800b498:	4545      	cmp	r5, r8
 800b49a:	d804      	bhi.n	800b4a6 <_malloc_r+0x1ea>
 800b49c:	ebc5 0308 	rsb	r3, r5, r8
 800b4a0:	2b0f      	cmp	r3, #15
 800b4a2:	f300 808c 	bgt.w	800b5be <_malloc_r+0x302>
 800b4a6:	4b53      	ldr	r3, [pc, #332]	; (800b5f4 <_malloc_r+0x338>)
 800b4a8:	f8df a158 	ldr.w	sl, [pc, #344]	; 800b604 <_malloc_r+0x348>
 800b4ac:	681a      	ldr	r2, [r3, #0]
 800b4ae:	f8da 3000 	ldr.w	r3, [sl]
 800b4b2:	3301      	adds	r3, #1
 800b4b4:	442a      	add	r2, r5
 800b4b6:	eb04 0b08 	add.w	fp, r4, r8
 800b4ba:	f000 8150 	beq.w	800b75e <_malloc_r+0x4a2>
 800b4be:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 800b4c2:	320f      	adds	r2, #15
 800b4c4:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 800b4c8:	f022 020f 	bic.w	r2, r2, #15
 800b4cc:	4611      	mov	r1, r2
 800b4ce:	4630      	mov	r0, r6
 800b4d0:	9201      	str	r2, [sp, #4]
 800b4d2:	f7fc fff5 	bl	80084c0 <_sbrk_r>
 800b4d6:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b4da:	4681      	mov	r9, r0
 800b4dc:	9a01      	ldr	r2, [sp, #4]
 800b4de:	f000 8147 	beq.w	800b770 <_malloc_r+0x4b4>
 800b4e2:	4583      	cmp	fp, r0
 800b4e4:	f200 80ee 	bhi.w	800b6c4 <_malloc_r+0x408>
 800b4e8:	4b43      	ldr	r3, [pc, #268]	; (800b5f8 <_malloc_r+0x33c>)
 800b4ea:	6819      	ldr	r1, [r3, #0]
 800b4ec:	45cb      	cmp	fp, r9
 800b4ee:	4411      	add	r1, r2
 800b4f0:	6019      	str	r1, [r3, #0]
 800b4f2:	f000 8142 	beq.w	800b77a <_malloc_r+0x4be>
 800b4f6:	f8da 0000 	ldr.w	r0, [sl]
 800b4fa:	f8df e108 	ldr.w	lr, [pc, #264]	; 800b604 <_malloc_r+0x348>
 800b4fe:	3001      	adds	r0, #1
 800b500:	bf1b      	ittet	ne
 800b502:	ebcb 0b09 	rsbne	fp, fp, r9
 800b506:	4459      	addne	r1, fp
 800b508:	f8ce 9000 	streq.w	r9, [lr]
 800b50c:	6019      	strne	r1, [r3, #0]
 800b50e:	f019 0107 	ands.w	r1, r9, #7
 800b512:	f000 8107 	beq.w	800b724 <_malloc_r+0x468>
 800b516:	f1c1 0008 	rsb	r0, r1, #8
 800b51a:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
 800b51e:	4481      	add	r9, r0
 800b520:	3108      	adds	r1, #8
 800b522:	444a      	add	r2, r9
 800b524:	f3c2 020b 	ubfx	r2, r2, #0, #12
 800b528:	ebc2 0a01 	rsb	sl, r2, r1
 800b52c:	4651      	mov	r1, sl
 800b52e:	4630      	mov	r0, r6
 800b530:	9301      	str	r3, [sp, #4]
 800b532:	f7fc ffc5 	bl	80084c0 <_sbrk_r>
 800b536:	1c43      	adds	r3, r0, #1
 800b538:	9b01      	ldr	r3, [sp, #4]
 800b53a:	f000 812c 	beq.w	800b796 <_malloc_r+0x4da>
 800b53e:	ebc9 0200 	rsb	r2, r9, r0
 800b542:	4452      	add	r2, sl
 800b544:	f042 0201 	orr.w	r2, r2, #1
 800b548:	6819      	ldr	r1, [r3, #0]
 800b54a:	f8c7 9008 	str.w	r9, [r7, #8]
 800b54e:	4451      	add	r1, sl
 800b550:	42bc      	cmp	r4, r7
 800b552:	f8c9 2004 	str.w	r2, [r9, #4]
 800b556:	6019      	str	r1, [r3, #0]
 800b558:	f8df a09c 	ldr.w	sl, [pc, #156]	; 800b5f8 <_malloc_r+0x33c>
 800b55c:	d016      	beq.n	800b58c <_malloc_r+0x2d0>
 800b55e:	f1b8 0f0f 	cmp.w	r8, #15
 800b562:	f240 80ee 	bls.w	800b742 <_malloc_r+0x486>
 800b566:	6862      	ldr	r2, [r4, #4]
 800b568:	f1a8 030c 	sub.w	r3, r8, #12
 800b56c:	f023 0307 	bic.w	r3, r3, #7
 800b570:	18e0      	adds	r0, r4, r3
 800b572:	f002 0201 	and.w	r2, r2, #1
 800b576:	f04f 0e05 	mov.w	lr, #5
 800b57a:	431a      	orrs	r2, r3
 800b57c:	2b0f      	cmp	r3, #15
 800b57e:	6062      	str	r2, [r4, #4]
 800b580:	f8c0 e004 	str.w	lr, [r0, #4]
 800b584:	f8c0 e008 	str.w	lr, [r0, #8]
 800b588:	f200 8109 	bhi.w	800b79e <_malloc_r+0x4e2>
 800b58c:	4b1b      	ldr	r3, [pc, #108]	; (800b5fc <_malloc_r+0x340>)
 800b58e:	68bc      	ldr	r4, [r7, #8]
 800b590:	681a      	ldr	r2, [r3, #0]
 800b592:	4291      	cmp	r1, r2
 800b594:	bf88      	it	hi
 800b596:	6019      	strhi	r1, [r3, #0]
 800b598:	4b19      	ldr	r3, [pc, #100]	; (800b600 <_malloc_r+0x344>)
 800b59a:	681a      	ldr	r2, [r3, #0]
 800b59c:	4291      	cmp	r1, r2
 800b59e:	6862      	ldr	r2, [r4, #4]
 800b5a0:	bf88      	it	hi
 800b5a2:	6019      	strhi	r1, [r3, #0]
 800b5a4:	f022 0203 	bic.w	r2, r2, #3
 800b5a8:	4295      	cmp	r5, r2
 800b5aa:	eba2 0305 	sub.w	r3, r2, r5
 800b5ae:	d801      	bhi.n	800b5b4 <_malloc_r+0x2f8>
 800b5b0:	2b0f      	cmp	r3, #15
 800b5b2:	dc04      	bgt.n	800b5be <_malloc_r+0x302>
 800b5b4:	4630      	mov	r0, r6
 800b5b6:	f000 f95f 	bl	800b878 <__malloc_unlock>
 800b5ba:	2400      	movs	r4, #0
 800b5bc:	e6aa      	b.n	800b314 <_malloc_r+0x58>
 800b5be:	1962      	adds	r2, r4, r5
 800b5c0:	f043 0301 	orr.w	r3, r3, #1
 800b5c4:	f045 0501 	orr.w	r5, r5, #1
 800b5c8:	6065      	str	r5, [r4, #4]
 800b5ca:	4630      	mov	r0, r6
 800b5cc:	60ba      	str	r2, [r7, #8]
 800b5ce:	6053      	str	r3, [r2, #4]
 800b5d0:	f000 f952 	bl	800b878 <__malloc_unlock>
 800b5d4:	3408      	adds	r4, #8
 800b5d6:	4620      	mov	r0, r4
 800b5d8:	b003      	add	sp, #12
 800b5da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b5de:	2814      	cmp	r0, #20
 800b5e0:	d968      	bls.n	800b6b4 <_malloc_r+0x3f8>
 800b5e2:	2854      	cmp	r0, #84	; 0x54
 800b5e4:	f200 8097 	bhi.w	800b716 <_malloc_r+0x45a>
 800b5e8:	0b28      	lsrs	r0, r5, #12
 800b5ea:	306e      	adds	r0, #110	; 0x6e
 800b5ec:	0041      	lsls	r1, r0, #1
 800b5ee:	e6a5      	b.n	800b33c <_malloc_r+0x80>
 800b5f0:	20000d64 	.word	0x20000d64
 800b5f4:	2000bf24 	.word	0x2000bf24
 800b5f8:	2000bf28 	.word	0x2000bf28
 800b5fc:	2000bf20 	.word	0x2000bf20
 800b600:	2000bf1c 	.word	0x2000bf1c
 800b604:	20001170 	.word	0x20001170
 800b608:	0a5a      	lsrs	r2, r3, #9
 800b60a:	2a04      	cmp	r2, #4
 800b60c:	d955      	bls.n	800b6ba <_malloc_r+0x3fe>
 800b60e:	2a14      	cmp	r2, #20
 800b610:	f200 80a7 	bhi.w	800b762 <_malloc_r+0x4a6>
 800b614:	325b      	adds	r2, #91	; 0x5b
 800b616:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 800b61a:	eb07 0c8c 	add.w	ip, r7, ip, lsl #2
 800b61e:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 800b7dc <_malloc_r+0x520>
 800b622:	f8dc 1008 	ldr.w	r1, [ip, #8]
 800b626:	4561      	cmp	r1, ip
 800b628:	d07f      	beq.n	800b72a <_malloc_r+0x46e>
 800b62a:	684a      	ldr	r2, [r1, #4]
 800b62c:	f022 0203 	bic.w	r2, r2, #3
 800b630:	4293      	cmp	r3, r2
 800b632:	d202      	bcs.n	800b63a <_malloc_r+0x37e>
 800b634:	6889      	ldr	r1, [r1, #8]
 800b636:	458c      	cmp	ip, r1
 800b638:	d1f7      	bne.n	800b62a <_malloc_r+0x36e>
 800b63a:	68ca      	ldr	r2, [r1, #12]
 800b63c:	687b      	ldr	r3, [r7, #4]
 800b63e:	60e2      	str	r2, [r4, #12]
 800b640:	60a1      	str	r1, [r4, #8]
 800b642:	6094      	str	r4, [r2, #8]
 800b644:	60cc      	str	r4, [r1, #12]
 800b646:	e6bb      	b.n	800b3c0 <_malloc_r+0x104>
 800b648:	1963      	adds	r3, r4, r5
 800b64a:	f042 0701 	orr.w	r7, r2, #1
 800b64e:	f045 0501 	orr.w	r5, r5, #1
 800b652:	6065      	str	r5, [r4, #4]
 800b654:	4630      	mov	r0, r6
 800b656:	614b      	str	r3, [r1, #20]
 800b658:	610b      	str	r3, [r1, #16]
 800b65a:	f8c3 e00c 	str.w	lr, [r3, #12]
 800b65e:	f8c3 e008 	str.w	lr, [r3, #8]
 800b662:	605f      	str	r7, [r3, #4]
 800b664:	509a      	str	r2, [r3, r2]
 800b666:	3408      	adds	r4, #8
 800b668:	f000 f906 	bl	800b878 <__malloc_unlock>
 800b66c:	e652      	b.n	800b314 <_malloc_r+0x58>
 800b66e:	684b      	ldr	r3, [r1, #4]
 800b670:	e6a6      	b.n	800b3c0 <_malloc_r+0x104>
 800b672:	f109 0901 	add.w	r9, r9, #1
 800b676:	f019 0f03 	tst.w	r9, #3
 800b67a:	f10c 0c08 	add.w	ip, ip, #8
 800b67e:	f47f aeb1 	bne.w	800b3e4 <_malloc_r+0x128>
 800b682:	e02c      	b.n	800b6de <_malloc_r+0x422>
 800b684:	f104 0308 	add.w	r3, r4, #8
 800b688:	6964      	ldr	r4, [r4, #20]
 800b68a:	42a3      	cmp	r3, r4
 800b68c:	bf08      	it	eq
 800b68e:	3002      	addeq	r0, #2
 800b690:	f43f ae69 	beq.w	800b366 <_malloc_r+0xaa>
 800b694:	e62e      	b.n	800b2f4 <_malloc_r+0x38>
 800b696:	441a      	add	r2, r3
 800b698:	461c      	mov	r4, r3
 800b69a:	6851      	ldr	r1, [r2, #4]
 800b69c:	68db      	ldr	r3, [r3, #12]
 800b69e:	f854 5f08 	ldr.w	r5, [r4, #8]!
 800b6a2:	f041 0101 	orr.w	r1, r1, #1
 800b6a6:	6051      	str	r1, [r2, #4]
 800b6a8:	4630      	mov	r0, r6
 800b6aa:	60eb      	str	r3, [r5, #12]
 800b6ac:	609d      	str	r5, [r3, #8]
 800b6ae:	f000 f8e3 	bl	800b878 <__malloc_unlock>
 800b6b2:	e62f      	b.n	800b314 <_malloc_r+0x58>
 800b6b4:	305b      	adds	r0, #91	; 0x5b
 800b6b6:	0041      	lsls	r1, r0, #1
 800b6b8:	e640      	b.n	800b33c <_malloc_r+0x80>
 800b6ba:	099a      	lsrs	r2, r3, #6
 800b6bc:	3238      	adds	r2, #56	; 0x38
 800b6be:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 800b6c2:	e7aa      	b.n	800b61a <_malloc_r+0x35e>
 800b6c4:	42bc      	cmp	r4, r7
 800b6c6:	4b45      	ldr	r3, [pc, #276]	; (800b7dc <_malloc_r+0x520>)
 800b6c8:	f43f af0e 	beq.w	800b4e8 <_malloc_r+0x22c>
 800b6cc:	689c      	ldr	r4, [r3, #8]
 800b6ce:	6862      	ldr	r2, [r4, #4]
 800b6d0:	f022 0203 	bic.w	r2, r2, #3
 800b6d4:	e768      	b.n	800b5a8 <_malloc_r+0x2ec>
 800b6d6:	f8d8 8000 	ldr.w	r8, [r8]
 800b6da:	4598      	cmp	r8, r3
 800b6dc:	d17c      	bne.n	800b7d8 <_malloc_r+0x51c>
 800b6de:	f010 0f03 	tst.w	r0, #3
 800b6e2:	f1a8 0308 	sub.w	r3, r8, #8
 800b6e6:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 800b6ea:	d1f4      	bne.n	800b6d6 <_malloc_r+0x41a>
 800b6ec:	687b      	ldr	r3, [r7, #4]
 800b6ee:	ea23 0304 	bic.w	r3, r3, r4
 800b6f2:	607b      	str	r3, [r7, #4]
 800b6f4:	0064      	lsls	r4, r4, #1
 800b6f6:	429c      	cmp	r4, r3
 800b6f8:	f63f aeca 	bhi.w	800b490 <_malloc_r+0x1d4>
 800b6fc:	2c00      	cmp	r4, #0
 800b6fe:	f43f aec7 	beq.w	800b490 <_malloc_r+0x1d4>
 800b702:	4223      	tst	r3, r4
 800b704:	4648      	mov	r0, r9
 800b706:	f47f ae69 	bne.w	800b3dc <_malloc_r+0x120>
 800b70a:	0064      	lsls	r4, r4, #1
 800b70c:	4223      	tst	r3, r4
 800b70e:	f100 0004 	add.w	r0, r0, #4
 800b712:	d0fa      	beq.n	800b70a <_malloc_r+0x44e>
 800b714:	e662      	b.n	800b3dc <_malloc_r+0x120>
 800b716:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
 800b71a:	d818      	bhi.n	800b74e <_malloc_r+0x492>
 800b71c:	0be8      	lsrs	r0, r5, #15
 800b71e:	3077      	adds	r0, #119	; 0x77
 800b720:	0041      	lsls	r1, r0, #1
 800b722:	e60b      	b.n	800b33c <_malloc_r+0x80>
 800b724:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800b728:	e6fb      	b.n	800b522 <_malloc_r+0x266>
 800b72a:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800b72e:	1092      	asrs	r2, r2, #2
 800b730:	f04f 0c01 	mov.w	ip, #1
 800b734:	fa0c f202 	lsl.w	r2, ip, r2
 800b738:	4313      	orrs	r3, r2
 800b73a:	f8c8 3004 	str.w	r3, [r8, #4]
 800b73e:	460a      	mov	r2, r1
 800b740:	e77d      	b.n	800b63e <_malloc_r+0x382>
 800b742:	2301      	movs	r3, #1
 800b744:	f8c9 3004 	str.w	r3, [r9, #4]
 800b748:	464c      	mov	r4, r9
 800b74a:	2200      	movs	r2, #0
 800b74c:	e72c      	b.n	800b5a8 <_malloc_r+0x2ec>
 800b74e:	f240 5354 	movw	r3, #1364	; 0x554
 800b752:	4298      	cmp	r0, r3
 800b754:	d81c      	bhi.n	800b790 <_malloc_r+0x4d4>
 800b756:	0ca8      	lsrs	r0, r5, #18
 800b758:	307c      	adds	r0, #124	; 0x7c
 800b75a:	0041      	lsls	r1, r0, #1
 800b75c:	e5ee      	b.n	800b33c <_malloc_r+0x80>
 800b75e:	3210      	adds	r2, #16
 800b760:	e6b4      	b.n	800b4cc <_malloc_r+0x210>
 800b762:	2a54      	cmp	r2, #84	; 0x54
 800b764:	d823      	bhi.n	800b7ae <_malloc_r+0x4f2>
 800b766:	0b1a      	lsrs	r2, r3, #12
 800b768:	326e      	adds	r2, #110	; 0x6e
 800b76a:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 800b76e:	e754      	b.n	800b61a <_malloc_r+0x35e>
 800b770:	68bc      	ldr	r4, [r7, #8]
 800b772:	6862      	ldr	r2, [r4, #4]
 800b774:	f022 0203 	bic.w	r2, r2, #3
 800b778:	e716      	b.n	800b5a8 <_malloc_r+0x2ec>
 800b77a:	f3cb 000b 	ubfx	r0, fp, #0, #12
 800b77e:	2800      	cmp	r0, #0
 800b780:	f47f aeb9 	bne.w	800b4f6 <_malloc_r+0x23a>
 800b784:	4442      	add	r2, r8
 800b786:	68bb      	ldr	r3, [r7, #8]
 800b788:	f042 0201 	orr.w	r2, r2, #1
 800b78c:	605a      	str	r2, [r3, #4]
 800b78e:	e6fd      	b.n	800b58c <_malloc_r+0x2d0>
 800b790:	21fc      	movs	r1, #252	; 0xfc
 800b792:	207e      	movs	r0, #126	; 0x7e
 800b794:	e5d2      	b.n	800b33c <_malloc_r+0x80>
 800b796:	2201      	movs	r2, #1
 800b798:	f04f 0a00 	mov.w	sl, #0
 800b79c:	e6d4      	b.n	800b548 <_malloc_r+0x28c>
 800b79e:	f104 0108 	add.w	r1, r4, #8
 800b7a2:	4630      	mov	r0, r6
 800b7a4:	f000 fcbc 	bl	800c120 <_free_r>
 800b7a8:	f8da 1000 	ldr.w	r1, [sl]
 800b7ac:	e6ee      	b.n	800b58c <_malloc_r+0x2d0>
 800b7ae:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 800b7b2:	d804      	bhi.n	800b7be <_malloc_r+0x502>
 800b7b4:	0bda      	lsrs	r2, r3, #15
 800b7b6:	3277      	adds	r2, #119	; 0x77
 800b7b8:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 800b7bc:	e72d      	b.n	800b61a <_malloc_r+0x35e>
 800b7be:	f240 5154 	movw	r1, #1364	; 0x554
 800b7c2:	428a      	cmp	r2, r1
 800b7c4:	d804      	bhi.n	800b7d0 <_malloc_r+0x514>
 800b7c6:	0c9a      	lsrs	r2, r3, #18
 800b7c8:	327c      	adds	r2, #124	; 0x7c
 800b7ca:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 800b7ce:	e724      	b.n	800b61a <_malloc_r+0x35e>
 800b7d0:	f04f 0cfc 	mov.w	ip, #252	; 0xfc
 800b7d4:	227e      	movs	r2, #126	; 0x7e
 800b7d6:	e720      	b.n	800b61a <_malloc_r+0x35e>
 800b7d8:	687b      	ldr	r3, [r7, #4]
 800b7da:	e78b      	b.n	800b6f4 <_malloc_r+0x438>
 800b7dc:	20000d64 	.word	0x20000d64

0800b7e0 <memchr>:
 800b7e0:	0783      	lsls	r3, r0, #30
 800b7e2:	b470      	push	{r4, r5, r6}
 800b7e4:	b2c9      	uxtb	r1, r1
 800b7e6:	d040      	beq.n	800b86a <memchr+0x8a>
 800b7e8:	1e54      	subs	r4, r2, #1
 800b7ea:	2a00      	cmp	r2, #0
 800b7ec:	d03f      	beq.n	800b86e <memchr+0x8e>
 800b7ee:	7803      	ldrb	r3, [r0, #0]
 800b7f0:	428b      	cmp	r3, r1
 800b7f2:	bf18      	it	ne
 800b7f4:	1c43      	addne	r3, r0, #1
 800b7f6:	d106      	bne.n	800b806 <memchr+0x26>
 800b7f8:	e01d      	b.n	800b836 <memchr+0x56>
 800b7fa:	b1f4      	cbz	r4, 800b83a <memchr+0x5a>
 800b7fc:	7802      	ldrb	r2, [r0, #0]
 800b7fe:	428a      	cmp	r2, r1
 800b800:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 800b804:	d017      	beq.n	800b836 <memchr+0x56>
 800b806:	f013 0f03 	tst.w	r3, #3
 800b80a:	4618      	mov	r0, r3
 800b80c:	f103 0301 	add.w	r3, r3, #1
 800b810:	d1f3      	bne.n	800b7fa <memchr+0x1a>
 800b812:	2c03      	cmp	r4, #3
 800b814:	d814      	bhi.n	800b840 <memchr+0x60>
 800b816:	b184      	cbz	r4, 800b83a <memchr+0x5a>
 800b818:	7803      	ldrb	r3, [r0, #0]
 800b81a:	428b      	cmp	r3, r1
 800b81c:	d00b      	beq.n	800b836 <memchr+0x56>
 800b81e:	1905      	adds	r5, r0, r4
 800b820:	1c43      	adds	r3, r0, #1
 800b822:	e002      	b.n	800b82a <memchr+0x4a>
 800b824:	7802      	ldrb	r2, [r0, #0]
 800b826:	428a      	cmp	r2, r1
 800b828:	d005      	beq.n	800b836 <memchr+0x56>
 800b82a:	42ab      	cmp	r3, r5
 800b82c:	4618      	mov	r0, r3
 800b82e:	f103 0301 	add.w	r3, r3, #1
 800b832:	d1f7      	bne.n	800b824 <memchr+0x44>
 800b834:	2000      	movs	r0, #0
 800b836:	bc70      	pop	{r4, r5, r6}
 800b838:	4770      	bx	lr
 800b83a:	4620      	mov	r0, r4
 800b83c:	bc70      	pop	{r4, r5, r6}
 800b83e:	4770      	bx	lr
 800b840:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 800b844:	4602      	mov	r2, r0
 800b846:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 800b84a:	4610      	mov	r0, r2
 800b84c:	3204      	adds	r2, #4
 800b84e:	6803      	ldr	r3, [r0, #0]
 800b850:	4073      	eors	r3, r6
 800b852:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
 800b856:	ea25 0303 	bic.w	r3, r5, r3
 800b85a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800b85e:	d1da      	bne.n	800b816 <memchr+0x36>
 800b860:	3c04      	subs	r4, #4
 800b862:	2c03      	cmp	r4, #3
 800b864:	4610      	mov	r0, r2
 800b866:	d8f0      	bhi.n	800b84a <memchr+0x6a>
 800b868:	e7d5      	b.n	800b816 <memchr+0x36>
 800b86a:	4614      	mov	r4, r2
 800b86c:	e7d1      	b.n	800b812 <memchr+0x32>
 800b86e:	4610      	mov	r0, r2
 800b870:	e7e1      	b.n	800b836 <memchr+0x56>
 800b872:	bf00      	nop

0800b874 <__malloc_lock>:
 800b874:	4770      	bx	lr
 800b876:	bf00      	nop

0800b878 <__malloc_unlock>:
 800b878:	4770      	bx	lr
 800b87a:	bf00      	nop

0800b87c <_Balloc>:
 800b87c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800b87e:	b570      	push	{r4, r5, r6, lr}
 800b880:	4605      	mov	r5, r0
 800b882:	460c      	mov	r4, r1
 800b884:	b14b      	cbz	r3, 800b89a <_Balloc+0x1e>
 800b886:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800b88a:	b180      	cbz	r0, 800b8ae <_Balloc+0x32>
 800b88c:	6802      	ldr	r2, [r0, #0]
 800b88e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 800b892:	2300      	movs	r3, #0
 800b894:	6103      	str	r3, [r0, #16]
 800b896:	60c3      	str	r3, [r0, #12]
 800b898:	bd70      	pop	{r4, r5, r6, pc}
 800b89a:	2104      	movs	r1, #4
 800b89c:	2221      	movs	r2, #33	; 0x21
 800b89e:	f000 fbc1 	bl	800c024 <_calloc_r>
 800b8a2:	64e8      	str	r0, [r5, #76]	; 0x4c
 800b8a4:	4603      	mov	r3, r0
 800b8a6:	2800      	cmp	r0, #0
 800b8a8:	d1ed      	bne.n	800b886 <_Balloc+0xa>
 800b8aa:	2000      	movs	r0, #0
 800b8ac:	bd70      	pop	{r4, r5, r6, pc}
 800b8ae:	2101      	movs	r1, #1
 800b8b0:	fa01 f604 	lsl.w	r6, r1, r4
 800b8b4:	1d72      	adds	r2, r6, #5
 800b8b6:	4628      	mov	r0, r5
 800b8b8:	0092      	lsls	r2, r2, #2
 800b8ba:	f000 fbb3 	bl	800c024 <_calloc_r>
 800b8be:	2800      	cmp	r0, #0
 800b8c0:	d0f3      	beq.n	800b8aa <_Balloc+0x2e>
 800b8c2:	6044      	str	r4, [r0, #4]
 800b8c4:	6086      	str	r6, [r0, #8]
 800b8c6:	e7e4      	b.n	800b892 <_Balloc+0x16>

0800b8c8 <_Bfree>:
 800b8c8:	b131      	cbz	r1, 800b8d8 <_Bfree+0x10>
 800b8ca:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800b8cc:	684a      	ldr	r2, [r1, #4]
 800b8ce:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800b8d2:	6008      	str	r0, [r1, #0]
 800b8d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 800b8d8:	4770      	bx	lr
 800b8da:	bf00      	nop

0800b8dc <__multadd>:
 800b8dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b8de:	690c      	ldr	r4, [r1, #16]
 800b8e0:	b083      	sub	sp, #12
 800b8e2:	460d      	mov	r5, r1
 800b8e4:	4606      	mov	r6, r0
 800b8e6:	f101 0e14 	add.w	lr, r1, #20
 800b8ea:	2700      	movs	r7, #0
 800b8ec:	f8de 1000 	ldr.w	r1, [lr]
 800b8f0:	b288      	uxth	r0, r1
 800b8f2:	0c09      	lsrs	r1, r1, #16
 800b8f4:	fb02 3300 	mla	r3, r2, r0, r3
 800b8f8:	fb02 f101 	mul.w	r1, r2, r1
 800b8fc:	eb01 4113 	add.w	r1, r1, r3, lsr #16
 800b900:	3701      	adds	r7, #1
 800b902:	b29b      	uxth	r3, r3
 800b904:	eb03 4301 	add.w	r3, r3, r1, lsl #16
 800b908:	42bc      	cmp	r4, r7
 800b90a:	f84e 3b04 	str.w	r3, [lr], #4
 800b90e:	ea4f 4311 	mov.w	r3, r1, lsr #16
 800b912:	dceb      	bgt.n	800b8ec <__multadd+0x10>
 800b914:	b13b      	cbz	r3, 800b926 <__multadd+0x4a>
 800b916:	68aa      	ldr	r2, [r5, #8]
 800b918:	4294      	cmp	r4, r2
 800b91a:	da07      	bge.n	800b92c <__multadd+0x50>
 800b91c:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 800b920:	3401      	adds	r4, #1
 800b922:	6153      	str	r3, [r2, #20]
 800b924:	612c      	str	r4, [r5, #16]
 800b926:	4628      	mov	r0, r5
 800b928:	b003      	add	sp, #12
 800b92a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b92c:	6869      	ldr	r1, [r5, #4]
 800b92e:	9301      	str	r3, [sp, #4]
 800b930:	3101      	adds	r1, #1
 800b932:	4630      	mov	r0, r6
 800b934:	f7ff ffa2 	bl	800b87c <_Balloc>
 800b938:	692a      	ldr	r2, [r5, #16]
 800b93a:	3202      	adds	r2, #2
 800b93c:	f105 010c 	add.w	r1, r5, #12
 800b940:	4607      	mov	r7, r0
 800b942:	0092      	lsls	r2, r2, #2
 800b944:	300c      	adds	r0, #12
 800b946:	f7f4 fcff 	bl	8000348 <memcpy>
 800b94a:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 800b94c:	6869      	ldr	r1, [r5, #4]
 800b94e:	9b01      	ldr	r3, [sp, #4]
 800b950:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 800b954:	6028      	str	r0, [r5, #0]
 800b956:	f842 5021 	str.w	r5, [r2, r1, lsl #2]
 800b95a:	463d      	mov	r5, r7
 800b95c:	e7de      	b.n	800b91c <__multadd+0x40>
 800b95e:	bf00      	nop

0800b960 <__hi0bits>:
 800b960:	0c03      	lsrs	r3, r0, #16
 800b962:	041b      	lsls	r3, r3, #16
 800b964:	b9b3      	cbnz	r3, 800b994 <__hi0bits+0x34>
 800b966:	0400      	lsls	r0, r0, #16
 800b968:	2310      	movs	r3, #16
 800b96a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 800b96e:	bf04      	itt	eq
 800b970:	0200      	lsleq	r0, r0, #8
 800b972:	3308      	addeq	r3, #8
 800b974:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 800b978:	bf04      	itt	eq
 800b97a:	0100      	lsleq	r0, r0, #4
 800b97c:	3304      	addeq	r3, #4
 800b97e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 800b982:	bf04      	itt	eq
 800b984:	0080      	lsleq	r0, r0, #2
 800b986:	3302      	addeq	r3, #2
 800b988:	2800      	cmp	r0, #0
 800b98a:	db07      	blt.n	800b99c <__hi0bits+0x3c>
 800b98c:	0042      	lsls	r2, r0, #1
 800b98e:	d403      	bmi.n	800b998 <__hi0bits+0x38>
 800b990:	2020      	movs	r0, #32
 800b992:	4770      	bx	lr
 800b994:	2300      	movs	r3, #0
 800b996:	e7e8      	b.n	800b96a <__hi0bits+0xa>
 800b998:	1c58      	adds	r0, r3, #1
 800b99a:	4770      	bx	lr
 800b99c:	4618      	mov	r0, r3
 800b99e:	4770      	bx	lr

0800b9a0 <__lo0bits>:
 800b9a0:	6803      	ldr	r3, [r0, #0]
 800b9a2:	f013 0207 	ands.w	r2, r3, #7
 800b9a6:	d007      	beq.n	800b9b8 <__lo0bits+0x18>
 800b9a8:	07d9      	lsls	r1, r3, #31
 800b9aa:	d420      	bmi.n	800b9ee <__lo0bits+0x4e>
 800b9ac:	079a      	lsls	r2, r3, #30
 800b9ae:	d420      	bmi.n	800b9f2 <__lo0bits+0x52>
 800b9b0:	089b      	lsrs	r3, r3, #2
 800b9b2:	6003      	str	r3, [r0, #0]
 800b9b4:	2002      	movs	r0, #2
 800b9b6:	4770      	bx	lr
 800b9b8:	b299      	uxth	r1, r3
 800b9ba:	b909      	cbnz	r1, 800b9c0 <__lo0bits+0x20>
 800b9bc:	0c1b      	lsrs	r3, r3, #16
 800b9be:	2210      	movs	r2, #16
 800b9c0:	f013 0fff 	tst.w	r3, #255	; 0xff
 800b9c4:	bf04      	itt	eq
 800b9c6:	0a1b      	lsreq	r3, r3, #8
 800b9c8:	3208      	addeq	r2, #8
 800b9ca:	0719      	lsls	r1, r3, #28
 800b9cc:	bf04      	itt	eq
 800b9ce:	091b      	lsreq	r3, r3, #4
 800b9d0:	3204      	addeq	r2, #4
 800b9d2:	0799      	lsls	r1, r3, #30
 800b9d4:	bf04      	itt	eq
 800b9d6:	089b      	lsreq	r3, r3, #2
 800b9d8:	3202      	addeq	r2, #2
 800b9da:	07d9      	lsls	r1, r3, #31
 800b9dc:	d404      	bmi.n	800b9e8 <__lo0bits+0x48>
 800b9de:	085b      	lsrs	r3, r3, #1
 800b9e0:	d101      	bne.n	800b9e6 <__lo0bits+0x46>
 800b9e2:	2020      	movs	r0, #32
 800b9e4:	4770      	bx	lr
 800b9e6:	3201      	adds	r2, #1
 800b9e8:	6003      	str	r3, [r0, #0]
 800b9ea:	4610      	mov	r0, r2
 800b9ec:	4770      	bx	lr
 800b9ee:	2000      	movs	r0, #0
 800b9f0:	4770      	bx	lr
 800b9f2:	085b      	lsrs	r3, r3, #1
 800b9f4:	6003      	str	r3, [r0, #0]
 800b9f6:	2001      	movs	r0, #1
 800b9f8:	4770      	bx	lr
 800b9fa:	bf00      	nop

0800b9fc <__i2b>:
 800b9fc:	b510      	push	{r4, lr}
 800b9fe:	460c      	mov	r4, r1
 800ba00:	2101      	movs	r1, #1
 800ba02:	f7ff ff3b 	bl	800b87c <_Balloc>
 800ba06:	2201      	movs	r2, #1
 800ba08:	6144      	str	r4, [r0, #20]
 800ba0a:	6102      	str	r2, [r0, #16]
 800ba0c:	bd10      	pop	{r4, pc}
 800ba0e:	bf00      	nop

0800ba10 <__multiply>:
 800ba10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ba14:	690f      	ldr	r7, [r1, #16]
 800ba16:	6916      	ldr	r6, [r2, #16]
 800ba18:	42b7      	cmp	r7, r6
 800ba1a:	b083      	sub	sp, #12
 800ba1c:	460d      	mov	r5, r1
 800ba1e:	4614      	mov	r4, r2
 800ba20:	f2c0 808d 	blt.w	800bb3e <__multiply+0x12e>
 800ba24:	4633      	mov	r3, r6
 800ba26:	463e      	mov	r6, r7
 800ba28:	461f      	mov	r7, r3
 800ba2a:	68ab      	ldr	r3, [r5, #8]
 800ba2c:	6869      	ldr	r1, [r5, #4]
 800ba2e:	eb06 0807 	add.w	r8, r6, r7
 800ba32:	4598      	cmp	r8, r3
 800ba34:	bfc8      	it	gt
 800ba36:	3101      	addgt	r1, #1
 800ba38:	f7ff ff20 	bl	800b87c <_Balloc>
 800ba3c:	f100 0c14 	add.w	ip, r0, #20
 800ba40:	eb0c 0988 	add.w	r9, ip, r8, lsl #2
 800ba44:	45cc      	cmp	ip, r9
 800ba46:	9000      	str	r0, [sp, #0]
 800ba48:	d205      	bcs.n	800ba56 <__multiply+0x46>
 800ba4a:	4663      	mov	r3, ip
 800ba4c:	2100      	movs	r1, #0
 800ba4e:	f843 1b04 	str.w	r1, [r3], #4
 800ba52:	4599      	cmp	r9, r3
 800ba54:	d8fb      	bhi.n	800ba4e <__multiply+0x3e>
 800ba56:	f104 0214 	add.w	r2, r4, #20
 800ba5a:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
 800ba5e:	f105 0314 	add.w	r3, r5, #20
 800ba62:	4552      	cmp	r2, sl
 800ba64:	eb03 0e86 	add.w	lr, r3, r6, lsl #2
 800ba68:	d254      	bcs.n	800bb14 <__multiply+0x104>
 800ba6a:	f8cd 9004 	str.w	r9, [sp, #4]
 800ba6e:	4699      	mov	r9, r3
 800ba70:	f852 3b04 	ldr.w	r3, [r2], #4
 800ba74:	fa1f fb83 	uxth.w	fp, r3
 800ba78:	f1bb 0f00 	cmp.w	fp, #0
 800ba7c:	d020      	beq.n	800bac0 <__multiply+0xb0>
 800ba7e:	2000      	movs	r0, #0
 800ba80:	464f      	mov	r7, r9
 800ba82:	4666      	mov	r6, ip
 800ba84:	4605      	mov	r5, r0
 800ba86:	e000      	b.n	800ba8a <__multiply+0x7a>
 800ba88:	461e      	mov	r6, r3
 800ba8a:	f857 4b04 	ldr.w	r4, [r7], #4
 800ba8e:	6830      	ldr	r0, [r6, #0]
 800ba90:	b2a1      	uxth	r1, r4
 800ba92:	b283      	uxth	r3, r0
 800ba94:	fb0b 3101 	mla	r1, fp, r1, r3
 800ba98:	0c24      	lsrs	r4, r4, #16
 800ba9a:	0c00      	lsrs	r0, r0, #16
 800ba9c:	194b      	adds	r3, r1, r5
 800ba9e:	fb0b 0004 	mla	r0, fp, r4, r0
 800baa2:	eb00 4013 	add.w	r0, r0, r3, lsr #16
 800baa6:	b299      	uxth	r1, r3
 800baa8:	4633      	mov	r3, r6
 800baaa:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 800baae:	45be      	cmp	lr, r7
 800bab0:	ea4f 4510 	mov.w	r5, r0, lsr #16
 800bab4:	f843 1b04 	str.w	r1, [r3], #4
 800bab8:	d8e6      	bhi.n	800ba88 <__multiply+0x78>
 800baba:	6075      	str	r5, [r6, #4]
 800babc:	f852 3c04 	ldr.w	r3, [r2, #-4]
 800bac0:	ea5f 4b13 	movs.w	fp, r3, lsr #16
 800bac4:	d020      	beq.n	800bb08 <__multiply+0xf8>
 800bac6:	f8dc 3000 	ldr.w	r3, [ip]
 800baca:	4667      	mov	r7, ip
 800bacc:	4618      	mov	r0, r3
 800bace:	464d      	mov	r5, r9
 800bad0:	2100      	movs	r1, #0
 800bad2:	e000      	b.n	800bad6 <__multiply+0xc6>
 800bad4:	4637      	mov	r7, r6
 800bad6:	882c      	ldrh	r4, [r5, #0]
 800bad8:	0c00      	lsrs	r0, r0, #16
 800bada:	fb0b 0004 	mla	r0, fp, r4, r0
 800bade:	4401      	add	r1, r0
 800bae0:	b29c      	uxth	r4, r3
 800bae2:	463e      	mov	r6, r7
 800bae4:	ea44 4301 	orr.w	r3, r4, r1, lsl #16
 800bae8:	f846 3b04 	str.w	r3, [r6], #4
 800baec:	6878      	ldr	r0, [r7, #4]
 800baee:	f855 4b04 	ldr.w	r4, [r5], #4
 800baf2:	b283      	uxth	r3, r0
 800baf4:	0c24      	lsrs	r4, r4, #16
 800baf6:	fb0b 3404 	mla	r4, fp, r4, r3
 800bafa:	eb04 4311 	add.w	r3, r4, r1, lsr #16
 800bafe:	45ae      	cmp	lr, r5
 800bb00:	ea4f 4113 	mov.w	r1, r3, lsr #16
 800bb04:	d8e6      	bhi.n	800bad4 <__multiply+0xc4>
 800bb06:	607b      	str	r3, [r7, #4]
 800bb08:	4592      	cmp	sl, r2
 800bb0a:	f10c 0c04 	add.w	ip, ip, #4
 800bb0e:	d8af      	bhi.n	800ba70 <__multiply+0x60>
 800bb10:	f8dd 9004 	ldr.w	r9, [sp, #4]
 800bb14:	f1b8 0f00 	cmp.w	r8, #0
 800bb18:	dd0b      	ble.n	800bb32 <__multiply+0x122>
 800bb1a:	f859 3c04 	ldr.w	r3, [r9, #-4]
 800bb1e:	f1a9 0904 	sub.w	r9, r9, #4
 800bb22:	b11b      	cbz	r3, 800bb2c <__multiply+0x11c>
 800bb24:	e005      	b.n	800bb32 <__multiply+0x122>
 800bb26:	f859 3d04 	ldr.w	r3, [r9, #-4]!
 800bb2a:	b913      	cbnz	r3, 800bb32 <__multiply+0x122>
 800bb2c:	f1b8 0801 	subs.w	r8, r8, #1
 800bb30:	d1f9      	bne.n	800bb26 <__multiply+0x116>
 800bb32:	9800      	ldr	r0, [sp, #0]
 800bb34:	f8c0 8010 	str.w	r8, [r0, #16]
 800bb38:	b003      	add	sp, #12
 800bb3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bb3e:	4615      	mov	r5, r2
 800bb40:	460c      	mov	r4, r1
 800bb42:	e772      	b.n	800ba2a <__multiply+0x1a>

0800bb44 <__pow5mult>:
 800bb44:	f012 0303 	ands.w	r3, r2, #3
 800bb48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bb4c:	4614      	mov	r4, r2
 800bb4e:	4607      	mov	r7, r0
 800bb50:	460e      	mov	r6, r1
 800bb52:	d12d      	bne.n	800bbb0 <__pow5mult+0x6c>
 800bb54:	10a4      	asrs	r4, r4, #2
 800bb56:	d01c      	beq.n	800bb92 <__pow5mult+0x4e>
 800bb58:	6cbd      	ldr	r5, [r7, #72]	; 0x48
 800bb5a:	b395      	cbz	r5, 800bbc2 <__pow5mult+0x7e>
 800bb5c:	07e3      	lsls	r3, r4, #31
 800bb5e:	f04f 0800 	mov.w	r8, #0
 800bb62:	d406      	bmi.n	800bb72 <__pow5mult+0x2e>
 800bb64:	1064      	asrs	r4, r4, #1
 800bb66:	d014      	beq.n	800bb92 <__pow5mult+0x4e>
 800bb68:	6828      	ldr	r0, [r5, #0]
 800bb6a:	b1a8      	cbz	r0, 800bb98 <__pow5mult+0x54>
 800bb6c:	4605      	mov	r5, r0
 800bb6e:	07e3      	lsls	r3, r4, #31
 800bb70:	d5f8      	bpl.n	800bb64 <__pow5mult+0x20>
 800bb72:	4638      	mov	r0, r7
 800bb74:	4631      	mov	r1, r6
 800bb76:	462a      	mov	r2, r5
 800bb78:	f7ff ff4a 	bl	800ba10 <__multiply>
 800bb7c:	b1b6      	cbz	r6, 800bbac <__pow5mult+0x68>
 800bb7e:	6872      	ldr	r2, [r6, #4]
 800bb80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800bb82:	1064      	asrs	r4, r4, #1
 800bb84:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800bb88:	6031      	str	r1, [r6, #0]
 800bb8a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 800bb8e:	4606      	mov	r6, r0
 800bb90:	d1ea      	bne.n	800bb68 <__pow5mult+0x24>
 800bb92:	4630      	mov	r0, r6
 800bb94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bb98:	4629      	mov	r1, r5
 800bb9a:	462a      	mov	r2, r5
 800bb9c:	4638      	mov	r0, r7
 800bb9e:	f7ff ff37 	bl	800ba10 <__multiply>
 800bba2:	6028      	str	r0, [r5, #0]
 800bba4:	f8c0 8000 	str.w	r8, [r0]
 800bba8:	4605      	mov	r5, r0
 800bbaa:	e7e0      	b.n	800bb6e <__pow5mult+0x2a>
 800bbac:	4606      	mov	r6, r0
 800bbae:	e7d9      	b.n	800bb64 <__pow5mult+0x20>
 800bbb0:	1e5a      	subs	r2, r3, #1
 800bbb2:	4d0b      	ldr	r5, [pc, #44]	; (800bbe0 <__pow5mult+0x9c>)
 800bbb4:	2300      	movs	r3, #0
 800bbb6:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 800bbba:	f7ff fe8f 	bl	800b8dc <__multadd>
 800bbbe:	4606      	mov	r6, r0
 800bbc0:	e7c8      	b.n	800bb54 <__pow5mult+0x10>
 800bbc2:	2101      	movs	r1, #1
 800bbc4:	4638      	mov	r0, r7
 800bbc6:	f7ff fe59 	bl	800b87c <_Balloc>
 800bbca:	f240 2171 	movw	r1, #625	; 0x271
 800bbce:	2201      	movs	r2, #1
 800bbd0:	2300      	movs	r3, #0
 800bbd2:	6141      	str	r1, [r0, #20]
 800bbd4:	6102      	str	r2, [r0, #16]
 800bbd6:	4605      	mov	r5, r0
 800bbd8:	64b8      	str	r0, [r7, #72]	; 0x48
 800bbda:	6003      	str	r3, [r0, #0]
 800bbdc:	e7be      	b.n	800bb5c <__pow5mult+0x18>
 800bbde:	bf00      	nop
 800bbe0:	0800d640 	.word	0x0800d640

0800bbe4 <__lshift>:
 800bbe4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800bbe8:	690f      	ldr	r7, [r1, #16]
 800bbea:	688b      	ldr	r3, [r1, #8]
 800bbec:	ea4f 1962 	mov.w	r9, r2, asr #5
 800bbf0:	444f      	add	r7, r9
 800bbf2:	1c7d      	adds	r5, r7, #1
 800bbf4:	429d      	cmp	r5, r3
 800bbf6:	460e      	mov	r6, r1
 800bbf8:	4614      	mov	r4, r2
 800bbfa:	6849      	ldr	r1, [r1, #4]
 800bbfc:	4680      	mov	r8, r0
 800bbfe:	dd04      	ble.n	800bc0a <__lshift+0x26>
 800bc00:	005b      	lsls	r3, r3, #1
 800bc02:	429d      	cmp	r5, r3
 800bc04:	f101 0101 	add.w	r1, r1, #1
 800bc08:	dcfa      	bgt.n	800bc00 <__lshift+0x1c>
 800bc0a:	4640      	mov	r0, r8
 800bc0c:	f7ff fe36 	bl	800b87c <_Balloc>
 800bc10:	f1b9 0f00 	cmp.w	r9, #0
 800bc14:	f100 0114 	add.w	r1, r0, #20
 800bc18:	dd09      	ble.n	800bc2e <__lshift+0x4a>
 800bc1a:	2300      	movs	r3, #0
 800bc1c:	469e      	mov	lr, r3
 800bc1e:	460a      	mov	r2, r1
 800bc20:	3301      	adds	r3, #1
 800bc22:	454b      	cmp	r3, r9
 800bc24:	f842 eb04 	str.w	lr, [r2], #4
 800bc28:	d1fa      	bne.n	800bc20 <__lshift+0x3c>
 800bc2a:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 800bc2e:	6932      	ldr	r2, [r6, #16]
 800bc30:	f106 0314 	add.w	r3, r6, #20
 800bc34:	f014 0c1f 	ands.w	ip, r4, #31
 800bc38:	eb03 0e82 	add.w	lr, r3, r2, lsl #2
 800bc3c:	d01f      	beq.n	800bc7e <__lshift+0x9a>
 800bc3e:	f1cc 0920 	rsb	r9, ip, #32
 800bc42:	2200      	movs	r2, #0
 800bc44:	681c      	ldr	r4, [r3, #0]
 800bc46:	fa04 f40c 	lsl.w	r4, r4, ip
 800bc4a:	4314      	orrs	r4, r2
 800bc4c:	468a      	mov	sl, r1
 800bc4e:	f841 4b04 	str.w	r4, [r1], #4
 800bc52:	f853 4b04 	ldr.w	r4, [r3], #4
 800bc56:	459e      	cmp	lr, r3
 800bc58:	fa24 f209 	lsr.w	r2, r4, r9
 800bc5c:	d8f2      	bhi.n	800bc44 <__lshift+0x60>
 800bc5e:	f8ca 2004 	str.w	r2, [sl, #4]
 800bc62:	b102      	cbz	r2, 800bc66 <__lshift+0x82>
 800bc64:	1cbd      	adds	r5, r7, #2
 800bc66:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 800bc6a:	6872      	ldr	r2, [r6, #4]
 800bc6c:	3d01      	subs	r5, #1
 800bc6e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800bc72:	6105      	str	r5, [r0, #16]
 800bc74:	6031      	str	r1, [r6, #0]
 800bc76:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
 800bc7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800bc7e:	3904      	subs	r1, #4
 800bc80:	f853 2b04 	ldr.w	r2, [r3], #4
 800bc84:	f841 2f04 	str.w	r2, [r1, #4]!
 800bc88:	459e      	cmp	lr, r3
 800bc8a:	d8f9      	bhi.n	800bc80 <__lshift+0x9c>
 800bc8c:	e7eb      	b.n	800bc66 <__lshift+0x82>
 800bc8e:	bf00      	nop

0800bc90 <__mcmp>:
 800bc90:	6902      	ldr	r2, [r0, #16]
 800bc92:	690b      	ldr	r3, [r1, #16]
 800bc94:	1ad2      	subs	r2, r2, r3
 800bc96:	d113      	bne.n	800bcc0 <__mcmp+0x30>
 800bc98:	009b      	lsls	r3, r3, #2
 800bc9a:	3014      	adds	r0, #20
 800bc9c:	3114      	adds	r1, #20
 800bc9e:	4419      	add	r1, r3
 800bca0:	b410      	push	{r4}
 800bca2:	4403      	add	r3, r0
 800bca4:	e001      	b.n	800bcaa <__mcmp+0x1a>
 800bca6:	4298      	cmp	r0, r3
 800bca8:	d20c      	bcs.n	800bcc4 <__mcmp+0x34>
 800bcaa:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 800bcae:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 800bcb2:	4294      	cmp	r4, r2
 800bcb4:	d0f7      	beq.n	800bca6 <__mcmp+0x16>
 800bcb6:	d309      	bcc.n	800bccc <__mcmp+0x3c>
 800bcb8:	2001      	movs	r0, #1
 800bcba:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bcbe:	4770      	bx	lr
 800bcc0:	4610      	mov	r0, r2
 800bcc2:	4770      	bx	lr
 800bcc4:	2000      	movs	r0, #0
 800bcc6:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bcca:	4770      	bx	lr
 800bccc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800bcd0:	f85d 4b04 	ldr.w	r4, [sp], #4
 800bcd4:	4770      	bx	lr
 800bcd6:	bf00      	nop

0800bcd8 <__mdiff>:
 800bcd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bcdc:	460e      	mov	r6, r1
 800bcde:	4605      	mov	r5, r0
 800bce0:	4611      	mov	r1, r2
 800bce2:	4630      	mov	r0, r6
 800bce4:	4614      	mov	r4, r2
 800bce6:	f7ff ffd3 	bl	800bc90 <__mcmp>
 800bcea:	1e07      	subs	r7, r0, #0
 800bcec:	d054      	beq.n	800bd98 <__mdiff+0xc0>
 800bcee:	db4d      	blt.n	800bd8c <__mdiff+0xb4>
 800bcf0:	f04f 0800 	mov.w	r8, #0
 800bcf4:	6871      	ldr	r1, [r6, #4]
 800bcf6:	4628      	mov	r0, r5
 800bcf8:	f7ff fdc0 	bl	800b87c <_Balloc>
 800bcfc:	6937      	ldr	r7, [r6, #16]
 800bcfe:	6923      	ldr	r3, [r4, #16]
 800bd00:	f8c0 800c 	str.w	r8, [r0, #12]
 800bd04:	3614      	adds	r6, #20
 800bd06:	f104 0214 	add.w	r2, r4, #20
 800bd0a:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 800bd0e:	f100 0514 	add.w	r5, r0, #20
 800bd12:	eb06 0e87 	add.w	lr, r6, r7, lsl #2
 800bd16:	2300      	movs	r3, #0
 800bd18:	f856 8b04 	ldr.w	r8, [r6], #4
 800bd1c:	f852 4b04 	ldr.w	r4, [r2], #4
 800bd20:	fa13 f388 	uxtah	r3, r3, r8
 800bd24:	b2a1      	uxth	r1, r4
 800bd26:	0c24      	lsrs	r4, r4, #16
 800bd28:	1a59      	subs	r1, r3, r1
 800bd2a:	ebc4 4318 	rsb	r3, r4, r8, lsr #16
 800bd2e:	eb03 4321 	add.w	r3, r3, r1, asr #16
 800bd32:	b289      	uxth	r1, r1
 800bd34:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800bd38:	4594      	cmp	ip, r2
 800bd3a:	f845 1b04 	str.w	r1, [r5], #4
 800bd3e:	ea4f 4323 	mov.w	r3, r3, asr #16
 800bd42:	4634      	mov	r4, r6
 800bd44:	d8e8      	bhi.n	800bd18 <__mdiff+0x40>
 800bd46:	45b6      	cmp	lr, r6
 800bd48:	46ac      	mov	ip, r5
 800bd4a:	d915      	bls.n	800bd78 <__mdiff+0xa0>
 800bd4c:	f854 2b04 	ldr.w	r2, [r4], #4
 800bd50:	fa13 f182 	uxtah	r1, r3, r2
 800bd54:	0c13      	lsrs	r3, r2, #16
 800bd56:	eb03 4321 	add.w	r3, r3, r1, asr #16
 800bd5a:	b289      	uxth	r1, r1
 800bd5c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800bd60:	45a6      	cmp	lr, r4
 800bd62:	f845 1b04 	str.w	r1, [r5], #4
 800bd66:	ea4f 4323 	mov.w	r3, r3, asr #16
 800bd6a:	d8ef      	bhi.n	800bd4c <__mdiff+0x74>
 800bd6c:	43f6      	mvns	r6, r6
 800bd6e:	4476      	add	r6, lr
 800bd70:	f026 0503 	bic.w	r5, r6, #3
 800bd74:	3504      	adds	r5, #4
 800bd76:	4465      	add	r5, ip
 800bd78:	3d04      	subs	r5, #4
 800bd7a:	b921      	cbnz	r1, 800bd86 <__mdiff+0xae>
 800bd7c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 800bd80:	3f01      	subs	r7, #1
 800bd82:	2b00      	cmp	r3, #0
 800bd84:	d0fa      	beq.n	800bd7c <__mdiff+0xa4>
 800bd86:	6107      	str	r7, [r0, #16]
 800bd88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bd8c:	4633      	mov	r3, r6
 800bd8e:	f04f 0801 	mov.w	r8, #1
 800bd92:	4626      	mov	r6, r4
 800bd94:	461c      	mov	r4, r3
 800bd96:	e7ad      	b.n	800bcf4 <__mdiff+0x1c>
 800bd98:	4628      	mov	r0, r5
 800bd9a:	4639      	mov	r1, r7
 800bd9c:	f7ff fd6e 	bl	800b87c <_Balloc>
 800bda0:	2301      	movs	r3, #1
 800bda2:	6147      	str	r7, [r0, #20]
 800bda4:	6103      	str	r3, [r0, #16]
 800bda6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bdaa:	bf00      	nop

0800bdac <__d2b>:
 800bdac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bdb0:	ec57 6b10 	vmov	r6, r7, d0
 800bdb4:	b083      	sub	sp, #12
 800bdb6:	4688      	mov	r8, r1
 800bdb8:	2101      	movs	r1, #1
 800bdba:	463c      	mov	r4, r7
 800bdbc:	f3c7 550a 	ubfx	r5, r7, #20, #11
 800bdc0:	4617      	mov	r7, r2
 800bdc2:	f7ff fd5b 	bl	800b87c <_Balloc>
 800bdc6:	f3c4 0413 	ubfx	r4, r4, #0, #20
 800bdca:	4681      	mov	r9, r0
 800bdcc:	b10d      	cbz	r5, 800bdd2 <__d2b+0x26>
 800bdce:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
 800bdd2:	9401      	str	r4, [sp, #4]
 800bdd4:	b31e      	cbz	r6, 800be1e <__d2b+0x72>
 800bdd6:	a802      	add	r0, sp, #8
 800bdd8:	f840 6d08 	str.w	r6, [r0, #-8]!
 800bddc:	f7ff fde0 	bl	800b9a0 <__lo0bits>
 800bde0:	2800      	cmp	r0, #0
 800bde2:	d134      	bne.n	800be4e <__d2b+0xa2>
 800bde4:	e89d 000c 	ldmia.w	sp, {r2, r3}
 800bde8:	f8c9 2014 	str.w	r2, [r9, #20]
 800bdec:	2b00      	cmp	r3, #0
 800bdee:	bf14      	ite	ne
 800bdf0:	2402      	movne	r4, #2
 800bdf2:	2401      	moveq	r4, #1
 800bdf4:	f8c9 3018 	str.w	r3, [r9, #24]
 800bdf8:	f8c9 4010 	str.w	r4, [r9, #16]
 800bdfc:	b9dd      	cbnz	r5, 800be36 <__d2b+0x8a>
 800bdfe:	eb09 0384 	add.w	r3, r9, r4, lsl #2
 800be02:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 800be06:	f8c8 0000 	str.w	r0, [r8]
 800be0a:	6918      	ldr	r0, [r3, #16]
 800be0c:	f7ff fda8 	bl	800b960 <__hi0bits>
 800be10:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
 800be14:	6038      	str	r0, [r7, #0]
 800be16:	4648      	mov	r0, r9
 800be18:	b003      	add	sp, #12
 800be1a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800be1e:	a801      	add	r0, sp, #4
 800be20:	f7ff fdbe 	bl	800b9a0 <__lo0bits>
 800be24:	2401      	movs	r4, #1
 800be26:	9b01      	ldr	r3, [sp, #4]
 800be28:	f8c9 3014 	str.w	r3, [r9, #20]
 800be2c:	3020      	adds	r0, #32
 800be2e:	f8c9 4010 	str.w	r4, [r9, #16]
 800be32:	2d00      	cmp	r5, #0
 800be34:	d0e3      	beq.n	800bdfe <__d2b+0x52>
 800be36:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 800be3a:	4405      	add	r5, r0
 800be3c:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 800be40:	f8c8 5000 	str.w	r5, [r8]
 800be44:	6038      	str	r0, [r7, #0]
 800be46:	4648      	mov	r0, r9
 800be48:	b003      	add	sp, #12
 800be4a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800be4e:	e89d 000c 	ldmia.w	sp, {r2, r3}
 800be52:	f1c0 0120 	rsb	r1, r0, #32
 800be56:	fa03 f101 	lsl.w	r1, r3, r1
 800be5a:	430a      	orrs	r2, r1
 800be5c:	40c3      	lsrs	r3, r0
 800be5e:	9301      	str	r3, [sp, #4]
 800be60:	f8c9 2014 	str.w	r2, [r9, #20]
 800be64:	e7c2      	b.n	800bdec <__d2b+0x40>
 800be66:	bf00      	nop

0800be68 <__fpclassifyd>:
 800be68:	ec53 2b10 	vmov	r2, r3, d0
 800be6c:	b410      	push	{r4}
 800be6e:	f033 4400 	bics.w	r4, r3, #2147483648	; 0x80000000
 800be72:	d008      	beq.n	800be86 <__fpclassifyd+0x1e>
 800be74:	4911      	ldr	r1, [pc, #68]	; (800bebc <__fpclassifyd+0x54>)
 800be76:	f5a3 1080 	sub.w	r0, r3, #1048576	; 0x100000
 800be7a:	4288      	cmp	r0, r1
 800be7c:	d808      	bhi.n	800be90 <__fpclassifyd+0x28>
 800be7e:	2004      	movs	r0, #4
 800be80:	f85d 4b04 	ldr.w	r4, [sp], #4
 800be84:	4770      	bx	lr
 800be86:	b91a      	cbnz	r2, 800be90 <__fpclassifyd+0x28>
 800be88:	2002      	movs	r0, #2
 800be8a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800be8e:	4770      	bx	lr
 800be90:	f103 43ff 	add.w	r3, r3, #2139095040	; 0x7f800000
 800be94:	4909      	ldr	r1, [pc, #36]	; (800bebc <__fpclassifyd+0x54>)
 800be96:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 800be9a:	428b      	cmp	r3, r1
 800be9c:	d9ef      	bls.n	800be7e <__fpclassifyd+0x16>
 800be9e:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
 800bea2:	d201      	bcs.n	800bea8 <__fpclassifyd+0x40>
 800bea4:	2003      	movs	r0, #3
 800bea6:	e7eb      	b.n	800be80 <__fpclassifyd+0x18>
 800bea8:	4b05      	ldr	r3, [pc, #20]	; (800bec0 <__fpclassifyd+0x58>)
 800beaa:	429c      	cmp	r4, r3
 800beac:	d001      	beq.n	800beb2 <__fpclassifyd+0x4a>
 800beae:	2000      	movs	r0, #0
 800beb0:	e7e6      	b.n	800be80 <__fpclassifyd+0x18>
 800beb2:	fab2 f082 	clz	r0, r2
 800beb6:	0940      	lsrs	r0, r0, #5
 800beb8:	e7e2      	b.n	800be80 <__fpclassifyd+0x18>
 800beba:	bf00      	nop
 800bebc:	7fdfffff 	.word	0x7fdfffff
 800bec0:	7ff00000 	.word	0x7ff00000

0800bec4 <strlen>:
 800bec4:	f020 0103 	bic.w	r1, r0, #3
 800bec8:	f010 0003 	ands.w	r0, r0, #3
 800becc:	f1c0 0000 	rsb	r0, r0, #0
 800bed0:	f851 3b04 	ldr.w	r3, [r1], #4
 800bed4:	f100 0c04 	add.w	ip, r0, #4
 800bed8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 800bedc:	f06f 0200 	mvn.w	r2, #0
 800bee0:	bf1c      	itt	ne
 800bee2:	fa22 f20c 	lsrne.w	r2, r2, ip
 800bee6:	4313      	orrne	r3, r2
 800bee8:	f04f 0c01 	mov.w	ip, #1
 800beec:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800bef0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800bef4:	eba3 020c 	sub.w	r2, r3, ip
 800bef8:	ea22 0203 	bic.w	r2, r2, r3
 800befc:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800bf00:	bf04      	itt	eq
 800bf02:	f851 3b04 	ldreq.w	r3, [r1], #4
 800bf06:	3004      	addeq	r0, #4
 800bf08:	d0f4      	beq.n	800bef4 <strlen+0x30>
 800bf0a:	f1c2 0100 	rsb	r1, r2, #0
 800bf0e:	ea02 0201 	and.w	r2, r2, r1
 800bf12:	fab2 f282 	clz	r2, r2
 800bf16:	f1c2 021f 	rsb	r2, r2, #31
 800bf1a:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800bf1e:	4770      	bx	lr

0800bf20 <__ssprint_r>:
 800bf20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bf24:	6893      	ldr	r3, [r2, #8]
 800bf26:	f8d2 8000 	ldr.w	r8, [r2]
 800bf2a:	b083      	sub	sp, #12
 800bf2c:	4691      	mov	r9, r2
 800bf2e:	2b00      	cmp	r3, #0
 800bf30:	d072      	beq.n	800c018 <__ssprint_r+0xf8>
 800bf32:	4607      	mov	r7, r0
 800bf34:	f04f 0b00 	mov.w	fp, #0
 800bf38:	6808      	ldr	r0, [r1, #0]
 800bf3a:	688b      	ldr	r3, [r1, #8]
 800bf3c:	460d      	mov	r5, r1
 800bf3e:	465c      	mov	r4, fp
 800bf40:	2c00      	cmp	r4, #0
 800bf42:	d045      	beq.n	800bfd0 <__ssprint_r+0xb0>
 800bf44:	429c      	cmp	r4, r3
 800bf46:	461e      	mov	r6, r3
 800bf48:	469a      	mov	sl, r3
 800bf4a:	d348      	bcc.n	800bfde <__ssprint_r+0xbe>
 800bf4c:	89ab      	ldrh	r3, [r5, #12]
 800bf4e:	f413 6f90 	tst.w	r3, #1152	; 0x480
 800bf52:	d02d      	beq.n	800bfb0 <__ssprint_r+0x90>
 800bf54:	696e      	ldr	r6, [r5, #20]
 800bf56:	6929      	ldr	r1, [r5, #16]
 800bf58:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 800bf5c:	ebc1 0a00 	rsb	sl, r1, r0
 800bf60:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
 800bf64:	1c60      	adds	r0, r4, #1
 800bf66:	1076      	asrs	r6, r6, #1
 800bf68:	4450      	add	r0, sl
 800bf6a:	4286      	cmp	r6, r0
 800bf6c:	4632      	mov	r2, r6
 800bf6e:	bf3c      	itt	cc
 800bf70:	4606      	movcc	r6, r0
 800bf72:	4632      	movcc	r2, r6
 800bf74:	055b      	lsls	r3, r3, #21
 800bf76:	d535      	bpl.n	800bfe4 <__ssprint_r+0xc4>
 800bf78:	4611      	mov	r1, r2
 800bf7a:	4638      	mov	r0, r7
 800bf7c:	f7ff f99e 	bl	800b2bc <_malloc_r>
 800bf80:	2800      	cmp	r0, #0
 800bf82:	d039      	beq.n	800bff8 <__ssprint_r+0xd8>
 800bf84:	4652      	mov	r2, sl
 800bf86:	6929      	ldr	r1, [r5, #16]
 800bf88:	9001      	str	r0, [sp, #4]
 800bf8a:	f7f4 f9dd 	bl	8000348 <memcpy>
 800bf8e:	89aa      	ldrh	r2, [r5, #12]
 800bf90:	9b01      	ldr	r3, [sp, #4]
 800bf92:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 800bf96:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800bf9a:	81aa      	strh	r2, [r5, #12]
 800bf9c:	ebca 0206 	rsb	r2, sl, r6
 800bfa0:	eb03 000a 	add.w	r0, r3, sl
 800bfa4:	616e      	str	r6, [r5, #20]
 800bfa6:	612b      	str	r3, [r5, #16]
 800bfa8:	6028      	str	r0, [r5, #0]
 800bfaa:	60aa      	str	r2, [r5, #8]
 800bfac:	4626      	mov	r6, r4
 800bfae:	46a2      	mov	sl, r4
 800bfb0:	4652      	mov	r2, sl
 800bfb2:	4659      	mov	r1, fp
 800bfb4:	f000 f98c 	bl	800c2d0 <memmove>
 800bfb8:	f8d9 2008 	ldr.w	r2, [r9, #8]
 800bfbc:	68ab      	ldr	r3, [r5, #8]
 800bfbe:	6828      	ldr	r0, [r5, #0]
 800bfc0:	1b9b      	subs	r3, r3, r6
 800bfc2:	4450      	add	r0, sl
 800bfc4:	1b14      	subs	r4, r2, r4
 800bfc6:	60ab      	str	r3, [r5, #8]
 800bfc8:	6028      	str	r0, [r5, #0]
 800bfca:	f8c9 4008 	str.w	r4, [r9, #8]
 800bfce:	b31c      	cbz	r4, 800c018 <__ssprint_r+0xf8>
 800bfd0:	f8d8 b000 	ldr.w	fp, [r8]
 800bfd4:	f8d8 4004 	ldr.w	r4, [r8, #4]
 800bfd8:	f108 0808 	add.w	r8, r8, #8
 800bfdc:	e7b0      	b.n	800bf40 <__ssprint_r+0x20>
 800bfde:	4626      	mov	r6, r4
 800bfe0:	46a2      	mov	sl, r4
 800bfe2:	e7e5      	b.n	800bfb0 <__ssprint_r+0x90>
 800bfe4:	4638      	mov	r0, r7
 800bfe6:	f000 f9d7 	bl	800c398 <_realloc_r>
 800bfea:	4603      	mov	r3, r0
 800bfec:	2800      	cmp	r0, #0
 800bfee:	d1d5      	bne.n	800bf9c <__ssprint_r+0x7c>
 800bff0:	4638      	mov	r0, r7
 800bff2:	6929      	ldr	r1, [r5, #16]
 800bff4:	f000 f894 	bl	800c120 <_free_r>
 800bff8:	230c      	movs	r3, #12
 800bffa:	603b      	str	r3, [r7, #0]
 800bffc:	89ab      	ldrh	r3, [r5, #12]
 800bffe:	2200      	movs	r2, #0
 800c000:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c004:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800c008:	81ab      	strh	r3, [r5, #12]
 800c00a:	f8c9 2008 	str.w	r2, [r9, #8]
 800c00e:	f8c9 2004 	str.w	r2, [r9, #4]
 800c012:	b003      	add	sp, #12
 800c014:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c018:	2000      	movs	r0, #0
 800c01a:	f8c9 0004 	str.w	r0, [r9, #4]
 800c01e:	b003      	add	sp, #12
 800c020:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c024 <_calloc_r>:
 800c024:	b510      	push	{r4, lr}
 800c026:	fb02 f101 	mul.w	r1, r2, r1
 800c02a:	f7ff f947 	bl	800b2bc <_malloc_r>
 800c02e:	4604      	mov	r4, r0
 800c030:	b168      	cbz	r0, 800c04e <_calloc_r+0x2a>
 800c032:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800c036:	f022 0203 	bic.w	r2, r2, #3
 800c03a:	3a04      	subs	r2, #4
 800c03c:	2a24      	cmp	r2, #36	; 0x24
 800c03e:	d818      	bhi.n	800c072 <_calloc_r+0x4e>
 800c040:	2a13      	cmp	r2, #19
 800c042:	d806      	bhi.n	800c052 <_calloc_r+0x2e>
 800c044:	4603      	mov	r3, r0
 800c046:	2200      	movs	r2, #0
 800c048:	601a      	str	r2, [r3, #0]
 800c04a:	605a      	str	r2, [r3, #4]
 800c04c:	609a      	str	r2, [r3, #8]
 800c04e:	4620      	mov	r0, r4
 800c050:	bd10      	pop	{r4, pc}
 800c052:	2300      	movs	r3, #0
 800c054:	2a1b      	cmp	r2, #27
 800c056:	6003      	str	r3, [r0, #0]
 800c058:	6043      	str	r3, [r0, #4]
 800c05a:	d90f      	bls.n	800c07c <_calloc_r+0x58>
 800c05c:	2a24      	cmp	r2, #36	; 0x24
 800c05e:	6083      	str	r3, [r0, #8]
 800c060:	60c3      	str	r3, [r0, #12]
 800c062:	bf05      	ittet	eq
 800c064:	6103      	streq	r3, [r0, #16]
 800c066:	6143      	streq	r3, [r0, #20]
 800c068:	f100 0310 	addne.w	r3, r0, #16
 800c06c:	f100 0318 	addeq.w	r3, r0, #24
 800c070:	e7e9      	b.n	800c046 <_calloc_r+0x22>
 800c072:	2100      	movs	r1, #0
 800c074:	f7fc fe38 	bl	8008ce8 <memset>
 800c078:	4620      	mov	r0, r4
 800c07a:	bd10      	pop	{r4, pc}
 800c07c:	f100 0308 	add.w	r3, r0, #8
 800c080:	e7e1      	b.n	800c046 <_calloc_r+0x22>
 800c082:	bf00      	nop

0800c084 <_malloc_trim_r>:
 800c084:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c086:	4f23      	ldr	r7, [pc, #140]	; (800c114 <_malloc_trim_r+0x90>)
 800c088:	460c      	mov	r4, r1
 800c08a:	4606      	mov	r6, r0
 800c08c:	f7ff fbf2 	bl	800b874 <__malloc_lock>
 800c090:	68bb      	ldr	r3, [r7, #8]
 800c092:	685d      	ldr	r5, [r3, #4]
 800c094:	f025 0503 	bic.w	r5, r5, #3
 800c098:	1b29      	subs	r1, r5, r4
 800c09a:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 800c09e:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 800c0a2:	f021 010f 	bic.w	r1, r1, #15
 800c0a6:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 800c0aa:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 800c0ae:	db07      	blt.n	800c0c0 <_malloc_trim_r+0x3c>
 800c0b0:	4630      	mov	r0, r6
 800c0b2:	2100      	movs	r1, #0
 800c0b4:	f7fc fa04 	bl	80084c0 <_sbrk_r>
 800c0b8:	68bb      	ldr	r3, [r7, #8]
 800c0ba:	442b      	add	r3, r5
 800c0bc:	4298      	cmp	r0, r3
 800c0be:	d004      	beq.n	800c0ca <_malloc_trim_r+0x46>
 800c0c0:	4630      	mov	r0, r6
 800c0c2:	f7ff fbd9 	bl	800b878 <__malloc_unlock>
 800c0c6:	2000      	movs	r0, #0
 800c0c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c0ca:	4630      	mov	r0, r6
 800c0cc:	4261      	negs	r1, r4
 800c0ce:	f7fc f9f7 	bl	80084c0 <_sbrk_r>
 800c0d2:	3001      	adds	r0, #1
 800c0d4:	d00d      	beq.n	800c0f2 <_malloc_trim_r+0x6e>
 800c0d6:	4b10      	ldr	r3, [pc, #64]	; (800c118 <_malloc_trim_r+0x94>)
 800c0d8:	68ba      	ldr	r2, [r7, #8]
 800c0da:	6819      	ldr	r1, [r3, #0]
 800c0dc:	1b2d      	subs	r5, r5, r4
 800c0de:	f045 0501 	orr.w	r5, r5, #1
 800c0e2:	4630      	mov	r0, r6
 800c0e4:	1b09      	subs	r1, r1, r4
 800c0e6:	6055      	str	r5, [r2, #4]
 800c0e8:	6019      	str	r1, [r3, #0]
 800c0ea:	f7ff fbc5 	bl	800b878 <__malloc_unlock>
 800c0ee:	2001      	movs	r0, #1
 800c0f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c0f2:	4630      	mov	r0, r6
 800c0f4:	2100      	movs	r1, #0
 800c0f6:	f7fc f9e3 	bl	80084c0 <_sbrk_r>
 800c0fa:	68ba      	ldr	r2, [r7, #8]
 800c0fc:	1a83      	subs	r3, r0, r2
 800c0fe:	2b0f      	cmp	r3, #15
 800c100:	ddde      	ble.n	800c0c0 <_malloc_trim_r+0x3c>
 800c102:	4c06      	ldr	r4, [pc, #24]	; (800c11c <_malloc_trim_r+0x98>)
 800c104:	4904      	ldr	r1, [pc, #16]	; (800c118 <_malloc_trim_r+0x94>)
 800c106:	6824      	ldr	r4, [r4, #0]
 800c108:	f043 0301 	orr.w	r3, r3, #1
 800c10c:	1b00      	subs	r0, r0, r4
 800c10e:	6053      	str	r3, [r2, #4]
 800c110:	6008      	str	r0, [r1, #0]
 800c112:	e7d5      	b.n	800c0c0 <_malloc_trim_r+0x3c>
 800c114:	20000d64 	.word	0x20000d64
 800c118:	2000bf28 	.word	0x2000bf28
 800c11c:	20001170 	.word	0x20001170

0800c120 <_free_r>:
 800c120:	2900      	cmp	r1, #0
 800c122:	d04e      	beq.n	800c1c2 <_free_r+0xa2>
 800c124:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c128:	460c      	mov	r4, r1
 800c12a:	4680      	mov	r8, r0
 800c12c:	f7ff fba2 	bl	800b874 <__malloc_lock>
 800c130:	f854 7c04 	ldr.w	r7, [r4, #-4]
 800c134:	4962      	ldr	r1, [pc, #392]	; (800c2c0 <_free_r+0x1a0>)
 800c136:	f027 0201 	bic.w	r2, r7, #1
 800c13a:	f1a4 0508 	sub.w	r5, r4, #8
 800c13e:	18ab      	adds	r3, r5, r2
 800c140:	688e      	ldr	r6, [r1, #8]
 800c142:	6858      	ldr	r0, [r3, #4]
 800c144:	429e      	cmp	r6, r3
 800c146:	f020 0003 	bic.w	r0, r0, #3
 800c14a:	d05a      	beq.n	800c202 <_free_r+0xe2>
 800c14c:	07fe      	lsls	r6, r7, #31
 800c14e:	6058      	str	r0, [r3, #4]
 800c150:	d40b      	bmi.n	800c16a <_free_r+0x4a>
 800c152:	f854 7c08 	ldr.w	r7, [r4, #-8]
 800c156:	1bed      	subs	r5, r5, r7
 800c158:	f101 0e08 	add.w	lr, r1, #8
 800c15c:	68ac      	ldr	r4, [r5, #8]
 800c15e:	4574      	cmp	r4, lr
 800c160:	443a      	add	r2, r7
 800c162:	d067      	beq.n	800c234 <_free_r+0x114>
 800c164:	68ef      	ldr	r7, [r5, #12]
 800c166:	60e7      	str	r7, [r4, #12]
 800c168:	60bc      	str	r4, [r7, #8]
 800c16a:	181c      	adds	r4, r3, r0
 800c16c:	6864      	ldr	r4, [r4, #4]
 800c16e:	07e4      	lsls	r4, r4, #31
 800c170:	d40c      	bmi.n	800c18c <_free_r+0x6c>
 800c172:	4f54      	ldr	r7, [pc, #336]	; (800c2c4 <_free_r+0x1a4>)
 800c174:	689c      	ldr	r4, [r3, #8]
 800c176:	42bc      	cmp	r4, r7
 800c178:	4402      	add	r2, r0
 800c17a:	d07c      	beq.n	800c276 <_free_r+0x156>
 800c17c:	68d8      	ldr	r0, [r3, #12]
 800c17e:	60e0      	str	r0, [r4, #12]
 800c180:	f042 0301 	orr.w	r3, r2, #1
 800c184:	6084      	str	r4, [r0, #8]
 800c186:	606b      	str	r3, [r5, #4]
 800c188:	50aa      	str	r2, [r5, r2]
 800c18a:	e003      	b.n	800c194 <_free_r+0x74>
 800c18c:	f042 0301 	orr.w	r3, r2, #1
 800c190:	606b      	str	r3, [r5, #4]
 800c192:	50aa      	str	r2, [r5, r2]
 800c194:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800c198:	d214      	bcs.n	800c1c4 <_free_r+0xa4>
 800c19a:	08d2      	lsrs	r2, r2, #3
 800c19c:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 800c1a0:	6848      	ldr	r0, [r1, #4]
 800c1a2:	689f      	ldr	r7, [r3, #8]
 800c1a4:	60af      	str	r7, [r5, #8]
 800c1a6:	1092      	asrs	r2, r2, #2
 800c1a8:	2401      	movs	r4, #1
 800c1aa:	fa04 f202 	lsl.w	r2, r4, r2
 800c1ae:	4310      	orrs	r0, r2
 800c1b0:	60eb      	str	r3, [r5, #12]
 800c1b2:	6048      	str	r0, [r1, #4]
 800c1b4:	609d      	str	r5, [r3, #8]
 800c1b6:	60fd      	str	r5, [r7, #12]
 800c1b8:	4640      	mov	r0, r8
 800c1ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800c1be:	f7ff bb5b 	b.w	800b878 <__malloc_unlock>
 800c1c2:	4770      	bx	lr
 800c1c4:	0a53      	lsrs	r3, r2, #9
 800c1c6:	2b04      	cmp	r3, #4
 800c1c8:	d847      	bhi.n	800c25a <_free_r+0x13a>
 800c1ca:	0993      	lsrs	r3, r2, #6
 800c1cc:	f103 0438 	add.w	r4, r3, #56	; 0x38
 800c1d0:	0060      	lsls	r0, r4, #1
 800c1d2:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 800c1d6:	493a      	ldr	r1, [pc, #232]	; (800c2c0 <_free_r+0x1a0>)
 800c1d8:	6883      	ldr	r3, [r0, #8]
 800c1da:	4283      	cmp	r3, r0
 800c1dc:	d043      	beq.n	800c266 <_free_r+0x146>
 800c1de:	6859      	ldr	r1, [r3, #4]
 800c1e0:	f021 0103 	bic.w	r1, r1, #3
 800c1e4:	4291      	cmp	r1, r2
 800c1e6:	d902      	bls.n	800c1ee <_free_r+0xce>
 800c1e8:	689b      	ldr	r3, [r3, #8]
 800c1ea:	4298      	cmp	r0, r3
 800c1ec:	d1f7      	bne.n	800c1de <_free_r+0xbe>
 800c1ee:	68da      	ldr	r2, [r3, #12]
 800c1f0:	60ea      	str	r2, [r5, #12]
 800c1f2:	60ab      	str	r3, [r5, #8]
 800c1f4:	4640      	mov	r0, r8
 800c1f6:	6095      	str	r5, [r2, #8]
 800c1f8:	60dd      	str	r5, [r3, #12]
 800c1fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800c1fe:	f7ff bb3b 	b.w	800b878 <__malloc_unlock>
 800c202:	07ff      	lsls	r7, r7, #31
 800c204:	4402      	add	r2, r0
 800c206:	d407      	bmi.n	800c218 <_free_r+0xf8>
 800c208:	f854 3c08 	ldr.w	r3, [r4, #-8]
 800c20c:	1aed      	subs	r5, r5, r3
 800c20e:	441a      	add	r2, r3
 800c210:	68a8      	ldr	r0, [r5, #8]
 800c212:	68eb      	ldr	r3, [r5, #12]
 800c214:	60c3      	str	r3, [r0, #12]
 800c216:	6098      	str	r0, [r3, #8]
 800c218:	4b2b      	ldr	r3, [pc, #172]	; (800c2c8 <_free_r+0x1a8>)
 800c21a:	681b      	ldr	r3, [r3, #0]
 800c21c:	f042 0001 	orr.w	r0, r2, #1
 800c220:	429a      	cmp	r2, r3
 800c222:	6068      	str	r0, [r5, #4]
 800c224:	608d      	str	r5, [r1, #8]
 800c226:	d3c7      	bcc.n	800c1b8 <_free_r+0x98>
 800c228:	4b28      	ldr	r3, [pc, #160]	; (800c2cc <_free_r+0x1ac>)
 800c22a:	4640      	mov	r0, r8
 800c22c:	6819      	ldr	r1, [r3, #0]
 800c22e:	f7ff ff29 	bl	800c084 <_malloc_trim_r>
 800c232:	e7c1      	b.n	800c1b8 <_free_r+0x98>
 800c234:	1819      	adds	r1, r3, r0
 800c236:	6849      	ldr	r1, [r1, #4]
 800c238:	07c9      	lsls	r1, r1, #31
 800c23a:	d409      	bmi.n	800c250 <_free_r+0x130>
 800c23c:	68d9      	ldr	r1, [r3, #12]
 800c23e:	689b      	ldr	r3, [r3, #8]
 800c240:	4402      	add	r2, r0
 800c242:	f042 0001 	orr.w	r0, r2, #1
 800c246:	60d9      	str	r1, [r3, #12]
 800c248:	608b      	str	r3, [r1, #8]
 800c24a:	6068      	str	r0, [r5, #4]
 800c24c:	50aa      	str	r2, [r5, r2]
 800c24e:	e7b3      	b.n	800c1b8 <_free_r+0x98>
 800c250:	f042 0301 	orr.w	r3, r2, #1
 800c254:	606b      	str	r3, [r5, #4]
 800c256:	50aa      	str	r2, [r5, r2]
 800c258:	e7ae      	b.n	800c1b8 <_free_r+0x98>
 800c25a:	2b14      	cmp	r3, #20
 800c25c:	d814      	bhi.n	800c288 <_free_r+0x168>
 800c25e:	f103 045b 	add.w	r4, r3, #91	; 0x5b
 800c262:	0060      	lsls	r0, r4, #1
 800c264:	e7b5      	b.n	800c1d2 <_free_r+0xb2>
 800c266:	684a      	ldr	r2, [r1, #4]
 800c268:	10a4      	asrs	r4, r4, #2
 800c26a:	2001      	movs	r0, #1
 800c26c:	40a0      	lsls	r0, r4
 800c26e:	4302      	orrs	r2, r0
 800c270:	604a      	str	r2, [r1, #4]
 800c272:	461a      	mov	r2, r3
 800c274:	e7bc      	b.n	800c1f0 <_free_r+0xd0>
 800c276:	f042 0301 	orr.w	r3, r2, #1
 800c27a:	614d      	str	r5, [r1, #20]
 800c27c:	610d      	str	r5, [r1, #16]
 800c27e:	60ec      	str	r4, [r5, #12]
 800c280:	60ac      	str	r4, [r5, #8]
 800c282:	606b      	str	r3, [r5, #4]
 800c284:	50aa      	str	r2, [r5, r2]
 800c286:	e797      	b.n	800c1b8 <_free_r+0x98>
 800c288:	2b54      	cmp	r3, #84	; 0x54
 800c28a:	d804      	bhi.n	800c296 <_free_r+0x176>
 800c28c:	0b13      	lsrs	r3, r2, #12
 800c28e:	f103 046e 	add.w	r4, r3, #110	; 0x6e
 800c292:	0060      	lsls	r0, r4, #1
 800c294:	e79d      	b.n	800c1d2 <_free_r+0xb2>
 800c296:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 800c29a:	d804      	bhi.n	800c2a6 <_free_r+0x186>
 800c29c:	0bd3      	lsrs	r3, r2, #15
 800c29e:	f103 0477 	add.w	r4, r3, #119	; 0x77
 800c2a2:	0060      	lsls	r0, r4, #1
 800c2a4:	e795      	b.n	800c1d2 <_free_r+0xb2>
 800c2a6:	f240 5054 	movw	r0, #1364	; 0x554
 800c2aa:	4283      	cmp	r3, r0
 800c2ac:	d804      	bhi.n	800c2b8 <_free_r+0x198>
 800c2ae:	0c93      	lsrs	r3, r2, #18
 800c2b0:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 800c2b4:	0060      	lsls	r0, r4, #1
 800c2b6:	e78c      	b.n	800c1d2 <_free_r+0xb2>
 800c2b8:	20fc      	movs	r0, #252	; 0xfc
 800c2ba:	247e      	movs	r4, #126	; 0x7e
 800c2bc:	e789      	b.n	800c1d2 <_free_r+0xb2>
 800c2be:	bf00      	nop
 800c2c0:	20000d64 	.word	0x20000d64
 800c2c4:	20000d6c 	.word	0x20000d6c
 800c2c8:	2000116c 	.word	0x2000116c
 800c2cc:	2000bf24 	.word	0x2000bf24

0800c2d0 <memmove>:
 800c2d0:	4288      	cmp	r0, r1
 800c2d2:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c2d4:	d90d      	bls.n	800c2f2 <memmove+0x22>
 800c2d6:	188b      	adds	r3, r1, r2
 800c2d8:	4298      	cmp	r0, r3
 800c2da:	d20a      	bcs.n	800c2f2 <memmove+0x22>
 800c2dc:	1881      	adds	r1, r0, r2
 800c2de:	2a00      	cmp	r2, #0
 800c2e0:	d054      	beq.n	800c38c <memmove+0xbc>
 800c2e2:	1a9a      	subs	r2, r3, r2
 800c2e4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800c2e8:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800c2ec:	4293      	cmp	r3, r2
 800c2ee:	d1f9      	bne.n	800c2e4 <memmove+0x14>
 800c2f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c2f2:	2a0f      	cmp	r2, #15
 800c2f4:	d948      	bls.n	800c388 <memmove+0xb8>
 800c2f6:	ea40 0301 	orr.w	r3, r0, r1
 800c2fa:	079b      	lsls	r3, r3, #30
 800c2fc:	d147      	bne.n	800c38e <memmove+0xbe>
 800c2fe:	f100 0410 	add.w	r4, r0, #16
 800c302:	f101 0310 	add.w	r3, r1, #16
 800c306:	4615      	mov	r5, r2
 800c308:	f853 6c10 	ldr.w	r6, [r3, #-16]
 800c30c:	f844 6c10 	str.w	r6, [r4, #-16]
 800c310:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 800c314:	f844 6c0c 	str.w	r6, [r4, #-12]
 800c318:	f853 6c08 	ldr.w	r6, [r3, #-8]
 800c31c:	f844 6c08 	str.w	r6, [r4, #-8]
 800c320:	3d10      	subs	r5, #16
 800c322:	f853 6c04 	ldr.w	r6, [r3, #-4]
 800c326:	f844 6c04 	str.w	r6, [r4, #-4]
 800c32a:	2d0f      	cmp	r5, #15
 800c32c:	f103 0310 	add.w	r3, r3, #16
 800c330:	f104 0410 	add.w	r4, r4, #16
 800c334:	d8e8      	bhi.n	800c308 <memmove+0x38>
 800c336:	f1a2 0310 	sub.w	r3, r2, #16
 800c33a:	f023 030f 	bic.w	r3, r3, #15
 800c33e:	f002 0e0f 	and.w	lr, r2, #15
 800c342:	3310      	adds	r3, #16
 800c344:	f1be 0f03 	cmp.w	lr, #3
 800c348:	4419      	add	r1, r3
 800c34a:	4403      	add	r3, r0
 800c34c:	d921      	bls.n	800c392 <memmove+0xc2>
 800c34e:	1f1e      	subs	r6, r3, #4
 800c350:	460d      	mov	r5, r1
 800c352:	4674      	mov	r4, lr
 800c354:	3c04      	subs	r4, #4
 800c356:	f855 7b04 	ldr.w	r7, [r5], #4
 800c35a:	f846 7f04 	str.w	r7, [r6, #4]!
 800c35e:	2c03      	cmp	r4, #3
 800c360:	d8f8      	bhi.n	800c354 <memmove+0x84>
 800c362:	f1ae 0404 	sub.w	r4, lr, #4
 800c366:	f024 0403 	bic.w	r4, r4, #3
 800c36a:	3404      	adds	r4, #4
 800c36c:	4423      	add	r3, r4
 800c36e:	4421      	add	r1, r4
 800c370:	f002 0203 	and.w	r2, r2, #3
 800c374:	b152      	cbz	r2, 800c38c <memmove+0xbc>
 800c376:	3b01      	subs	r3, #1
 800c378:	440a      	add	r2, r1
 800c37a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800c37e:	f803 4f01 	strb.w	r4, [r3, #1]!
 800c382:	4291      	cmp	r1, r2
 800c384:	d1f9      	bne.n	800c37a <memmove+0xaa>
 800c386:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c388:	4603      	mov	r3, r0
 800c38a:	e7f3      	b.n	800c374 <memmove+0xa4>
 800c38c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c38e:	4603      	mov	r3, r0
 800c390:	e7f1      	b.n	800c376 <memmove+0xa6>
 800c392:	4672      	mov	r2, lr
 800c394:	e7ee      	b.n	800c374 <memmove+0xa4>
 800c396:	bf00      	nop

0800c398 <_realloc_r>:
 800c398:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c39c:	4617      	mov	r7, r2
 800c39e:	b083      	sub	sp, #12
 800c3a0:	460e      	mov	r6, r1
 800c3a2:	2900      	cmp	r1, #0
 800c3a4:	f000 80e7 	beq.w	800c576 <_realloc_r+0x1de>
 800c3a8:	4681      	mov	r9, r0
 800c3aa:	f107 050b 	add.w	r5, r7, #11
 800c3ae:	f7ff fa61 	bl	800b874 <__malloc_lock>
 800c3b2:	f856 3c04 	ldr.w	r3, [r6, #-4]
 800c3b6:	2d16      	cmp	r5, #22
 800c3b8:	f023 0403 	bic.w	r4, r3, #3
 800c3bc:	f1a6 0808 	sub.w	r8, r6, #8
 800c3c0:	d84c      	bhi.n	800c45c <_realloc_r+0xc4>
 800c3c2:	2210      	movs	r2, #16
 800c3c4:	4615      	mov	r5, r2
 800c3c6:	42af      	cmp	r7, r5
 800c3c8:	d84d      	bhi.n	800c466 <_realloc_r+0xce>
 800c3ca:	4294      	cmp	r4, r2
 800c3cc:	f280 8084 	bge.w	800c4d8 <_realloc_r+0x140>
 800c3d0:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 800c780 <_realloc_r+0x3e8>
 800c3d4:	f8db 0008 	ldr.w	r0, [fp, #8]
 800c3d8:	eb08 0104 	add.w	r1, r8, r4
 800c3dc:	4288      	cmp	r0, r1
 800c3de:	f000 80d6 	beq.w	800c58e <_realloc_r+0x1f6>
 800c3e2:	6848      	ldr	r0, [r1, #4]
 800c3e4:	f020 0e01 	bic.w	lr, r0, #1
 800c3e8:	448e      	add	lr, r1
 800c3ea:	f8de e004 	ldr.w	lr, [lr, #4]
 800c3ee:	f01e 0f01 	tst.w	lr, #1
 800c3f2:	d13f      	bne.n	800c474 <_realloc_r+0xdc>
 800c3f4:	f020 0003 	bic.w	r0, r0, #3
 800c3f8:	4420      	add	r0, r4
 800c3fa:	4290      	cmp	r0, r2
 800c3fc:	f280 80c1 	bge.w	800c582 <_realloc_r+0x1ea>
 800c400:	07db      	lsls	r3, r3, #31
 800c402:	f100 808f 	bmi.w	800c524 <_realloc_r+0x18c>
 800c406:	f856 3c08 	ldr.w	r3, [r6, #-8]
 800c40a:	ebc3 0a08 	rsb	sl, r3, r8
 800c40e:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c412:	f023 0303 	bic.w	r3, r3, #3
 800c416:	eb00 0e03 	add.w	lr, r0, r3
 800c41a:	4596      	cmp	lr, r2
 800c41c:	db34      	blt.n	800c488 <_realloc_r+0xf0>
 800c41e:	68cb      	ldr	r3, [r1, #12]
 800c420:	688a      	ldr	r2, [r1, #8]
 800c422:	4657      	mov	r7, sl
 800c424:	60d3      	str	r3, [r2, #12]
 800c426:	609a      	str	r2, [r3, #8]
 800c428:	f857 1f08 	ldr.w	r1, [r7, #8]!
 800c42c:	f8da 300c 	ldr.w	r3, [sl, #12]
 800c430:	60cb      	str	r3, [r1, #12]
 800c432:	1f22      	subs	r2, r4, #4
 800c434:	2a24      	cmp	r2, #36	; 0x24
 800c436:	6099      	str	r1, [r3, #8]
 800c438:	f200 8136 	bhi.w	800c6a8 <_realloc_r+0x310>
 800c43c:	2a13      	cmp	r2, #19
 800c43e:	f240 80fd 	bls.w	800c63c <_realloc_r+0x2a4>
 800c442:	6833      	ldr	r3, [r6, #0]
 800c444:	f8ca 3008 	str.w	r3, [sl, #8]
 800c448:	6873      	ldr	r3, [r6, #4]
 800c44a:	f8ca 300c 	str.w	r3, [sl, #12]
 800c44e:	2a1b      	cmp	r2, #27
 800c450:	f200 8140 	bhi.w	800c6d4 <_realloc_r+0x33c>
 800c454:	3608      	adds	r6, #8
 800c456:	f10a 0310 	add.w	r3, sl, #16
 800c45a:	e0f0      	b.n	800c63e <_realloc_r+0x2a6>
 800c45c:	f025 0507 	bic.w	r5, r5, #7
 800c460:	2d00      	cmp	r5, #0
 800c462:	462a      	mov	r2, r5
 800c464:	daaf      	bge.n	800c3c6 <_realloc_r+0x2e>
 800c466:	230c      	movs	r3, #12
 800c468:	2000      	movs	r0, #0
 800c46a:	f8c9 3000 	str.w	r3, [r9]
 800c46e:	b003      	add	sp, #12
 800c470:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c474:	07d9      	lsls	r1, r3, #31
 800c476:	d455      	bmi.n	800c524 <_realloc_r+0x18c>
 800c478:	f856 3c08 	ldr.w	r3, [r6, #-8]
 800c47c:	ebc3 0a08 	rsb	sl, r3, r8
 800c480:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c484:	f023 0303 	bic.w	r3, r3, #3
 800c488:	4423      	add	r3, r4
 800c48a:	4293      	cmp	r3, r2
 800c48c:	db4a      	blt.n	800c524 <_realloc_r+0x18c>
 800c48e:	4657      	mov	r7, sl
 800c490:	f8da 100c 	ldr.w	r1, [sl, #12]
 800c494:	f857 0f08 	ldr.w	r0, [r7, #8]!
 800c498:	1f22      	subs	r2, r4, #4
 800c49a:	2a24      	cmp	r2, #36	; 0x24
 800c49c:	60c1      	str	r1, [r0, #12]
 800c49e:	6088      	str	r0, [r1, #8]
 800c4a0:	f200 810e 	bhi.w	800c6c0 <_realloc_r+0x328>
 800c4a4:	2a13      	cmp	r2, #19
 800c4a6:	f240 8109 	bls.w	800c6bc <_realloc_r+0x324>
 800c4aa:	6831      	ldr	r1, [r6, #0]
 800c4ac:	f8ca 1008 	str.w	r1, [sl, #8]
 800c4b0:	6871      	ldr	r1, [r6, #4]
 800c4b2:	f8ca 100c 	str.w	r1, [sl, #12]
 800c4b6:	2a1b      	cmp	r2, #27
 800c4b8:	f200 8121 	bhi.w	800c6fe <_realloc_r+0x366>
 800c4bc:	3608      	adds	r6, #8
 800c4be:	f10a 0210 	add.w	r2, sl, #16
 800c4c2:	6831      	ldr	r1, [r6, #0]
 800c4c4:	6011      	str	r1, [r2, #0]
 800c4c6:	6871      	ldr	r1, [r6, #4]
 800c4c8:	6051      	str	r1, [r2, #4]
 800c4ca:	68b1      	ldr	r1, [r6, #8]
 800c4cc:	6091      	str	r1, [r2, #8]
 800c4ce:	461c      	mov	r4, r3
 800c4d0:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c4d4:	463e      	mov	r6, r7
 800c4d6:	46d0      	mov	r8, sl
 800c4d8:	1b62      	subs	r2, r4, r5
 800c4da:	2a0f      	cmp	r2, #15
 800c4dc:	f003 0301 	and.w	r3, r3, #1
 800c4e0:	d80e      	bhi.n	800c500 <_realloc_r+0x168>
 800c4e2:	4323      	orrs	r3, r4
 800c4e4:	4444      	add	r4, r8
 800c4e6:	f8c8 3004 	str.w	r3, [r8, #4]
 800c4ea:	6863      	ldr	r3, [r4, #4]
 800c4ec:	f043 0301 	orr.w	r3, r3, #1
 800c4f0:	6063      	str	r3, [r4, #4]
 800c4f2:	4648      	mov	r0, r9
 800c4f4:	f7ff f9c0 	bl	800b878 <__malloc_unlock>
 800c4f8:	4630      	mov	r0, r6
 800c4fa:	b003      	add	sp, #12
 800c4fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c500:	eb08 0105 	add.w	r1, r8, r5
 800c504:	431d      	orrs	r5, r3
 800c506:	f042 0301 	orr.w	r3, r2, #1
 800c50a:	440a      	add	r2, r1
 800c50c:	f8c8 5004 	str.w	r5, [r8, #4]
 800c510:	604b      	str	r3, [r1, #4]
 800c512:	6853      	ldr	r3, [r2, #4]
 800c514:	f043 0301 	orr.w	r3, r3, #1
 800c518:	3108      	adds	r1, #8
 800c51a:	6053      	str	r3, [r2, #4]
 800c51c:	4648      	mov	r0, r9
 800c51e:	f7ff fdff 	bl	800c120 <_free_r>
 800c522:	e7e6      	b.n	800c4f2 <_realloc_r+0x15a>
 800c524:	4639      	mov	r1, r7
 800c526:	4648      	mov	r0, r9
 800c528:	f7fe fec8 	bl	800b2bc <_malloc_r>
 800c52c:	4607      	mov	r7, r0
 800c52e:	b1d8      	cbz	r0, 800c568 <_realloc_r+0x1d0>
 800c530:	f856 3c04 	ldr.w	r3, [r6, #-4]
 800c534:	f023 0201 	bic.w	r2, r3, #1
 800c538:	4442      	add	r2, r8
 800c53a:	f1a0 0108 	sub.w	r1, r0, #8
 800c53e:	4291      	cmp	r1, r2
 800c540:	f000 80ac 	beq.w	800c69c <_realloc_r+0x304>
 800c544:	1f22      	subs	r2, r4, #4
 800c546:	2a24      	cmp	r2, #36	; 0x24
 800c548:	f200 8099 	bhi.w	800c67e <_realloc_r+0x2e6>
 800c54c:	2a13      	cmp	r2, #19
 800c54e:	d86a      	bhi.n	800c626 <_realloc_r+0x28e>
 800c550:	4603      	mov	r3, r0
 800c552:	4632      	mov	r2, r6
 800c554:	6811      	ldr	r1, [r2, #0]
 800c556:	6019      	str	r1, [r3, #0]
 800c558:	6851      	ldr	r1, [r2, #4]
 800c55a:	6059      	str	r1, [r3, #4]
 800c55c:	6892      	ldr	r2, [r2, #8]
 800c55e:	609a      	str	r2, [r3, #8]
 800c560:	4631      	mov	r1, r6
 800c562:	4648      	mov	r0, r9
 800c564:	f7ff fddc 	bl	800c120 <_free_r>
 800c568:	4648      	mov	r0, r9
 800c56a:	f7ff f985 	bl	800b878 <__malloc_unlock>
 800c56e:	4638      	mov	r0, r7
 800c570:	b003      	add	sp, #12
 800c572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c576:	4611      	mov	r1, r2
 800c578:	b003      	add	sp, #12
 800c57a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c57e:	f7fe be9d 	b.w	800b2bc <_malloc_r>
 800c582:	68ca      	ldr	r2, [r1, #12]
 800c584:	6889      	ldr	r1, [r1, #8]
 800c586:	4604      	mov	r4, r0
 800c588:	60ca      	str	r2, [r1, #12]
 800c58a:	6091      	str	r1, [r2, #8]
 800c58c:	e7a4      	b.n	800c4d8 <_realloc_r+0x140>
 800c58e:	6841      	ldr	r1, [r0, #4]
 800c590:	f021 0103 	bic.w	r1, r1, #3
 800c594:	4421      	add	r1, r4
 800c596:	f105 0010 	add.w	r0, r5, #16
 800c59a:	4281      	cmp	r1, r0
 800c59c:	da5b      	bge.n	800c656 <_realloc_r+0x2be>
 800c59e:	07db      	lsls	r3, r3, #31
 800c5a0:	d4c0      	bmi.n	800c524 <_realloc_r+0x18c>
 800c5a2:	f856 3c08 	ldr.w	r3, [r6, #-8]
 800c5a6:	ebc3 0a08 	rsb	sl, r3, r8
 800c5aa:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c5ae:	f023 0303 	bic.w	r3, r3, #3
 800c5b2:	eb01 0c03 	add.w	ip, r1, r3
 800c5b6:	4560      	cmp	r0, ip
 800c5b8:	f73f af66 	bgt.w	800c488 <_realloc_r+0xf0>
 800c5bc:	4657      	mov	r7, sl
 800c5be:	f8da 300c 	ldr.w	r3, [sl, #12]
 800c5c2:	f857 1f08 	ldr.w	r1, [r7, #8]!
 800c5c6:	1f22      	subs	r2, r4, #4
 800c5c8:	2a24      	cmp	r2, #36	; 0x24
 800c5ca:	60cb      	str	r3, [r1, #12]
 800c5cc:	6099      	str	r1, [r3, #8]
 800c5ce:	f200 80b8 	bhi.w	800c742 <_realloc_r+0x3aa>
 800c5d2:	2a13      	cmp	r2, #19
 800c5d4:	f240 80a9 	bls.w	800c72a <_realloc_r+0x392>
 800c5d8:	6833      	ldr	r3, [r6, #0]
 800c5da:	f8ca 3008 	str.w	r3, [sl, #8]
 800c5de:	6873      	ldr	r3, [r6, #4]
 800c5e0:	f8ca 300c 	str.w	r3, [sl, #12]
 800c5e4:	2a1b      	cmp	r2, #27
 800c5e6:	f200 80b5 	bhi.w	800c754 <_realloc_r+0x3bc>
 800c5ea:	3608      	adds	r6, #8
 800c5ec:	f10a 0310 	add.w	r3, sl, #16
 800c5f0:	6832      	ldr	r2, [r6, #0]
 800c5f2:	601a      	str	r2, [r3, #0]
 800c5f4:	6872      	ldr	r2, [r6, #4]
 800c5f6:	605a      	str	r2, [r3, #4]
 800c5f8:	68b2      	ldr	r2, [r6, #8]
 800c5fa:	609a      	str	r2, [r3, #8]
 800c5fc:	eb0a 0205 	add.w	r2, sl, r5
 800c600:	ebc5 030c 	rsb	r3, r5, ip
 800c604:	f043 0301 	orr.w	r3, r3, #1
 800c608:	f8cb 2008 	str.w	r2, [fp, #8]
 800c60c:	6053      	str	r3, [r2, #4]
 800c60e:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c612:	f003 0301 	and.w	r3, r3, #1
 800c616:	431d      	orrs	r5, r3
 800c618:	4648      	mov	r0, r9
 800c61a:	f8ca 5004 	str.w	r5, [sl, #4]
 800c61e:	f7ff f92b 	bl	800b878 <__malloc_unlock>
 800c622:	4638      	mov	r0, r7
 800c624:	e769      	b.n	800c4fa <_realloc_r+0x162>
 800c626:	6833      	ldr	r3, [r6, #0]
 800c628:	6003      	str	r3, [r0, #0]
 800c62a:	6873      	ldr	r3, [r6, #4]
 800c62c:	6043      	str	r3, [r0, #4]
 800c62e:	2a1b      	cmp	r2, #27
 800c630:	d829      	bhi.n	800c686 <_realloc_r+0x2ee>
 800c632:	f100 0308 	add.w	r3, r0, #8
 800c636:	f106 0208 	add.w	r2, r6, #8
 800c63a:	e78b      	b.n	800c554 <_realloc_r+0x1bc>
 800c63c:	463b      	mov	r3, r7
 800c63e:	6832      	ldr	r2, [r6, #0]
 800c640:	601a      	str	r2, [r3, #0]
 800c642:	6872      	ldr	r2, [r6, #4]
 800c644:	605a      	str	r2, [r3, #4]
 800c646:	68b2      	ldr	r2, [r6, #8]
 800c648:	609a      	str	r2, [r3, #8]
 800c64a:	463e      	mov	r6, r7
 800c64c:	4674      	mov	r4, lr
 800c64e:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c652:	46d0      	mov	r8, sl
 800c654:	e740      	b.n	800c4d8 <_realloc_r+0x140>
 800c656:	eb08 0205 	add.w	r2, r8, r5
 800c65a:	1b4b      	subs	r3, r1, r5
 800c65c:	f043 0301 	orr.w	r3, r3, #1
 800c660:	f8cb 2008 	str.w	r2, [fp, #8]
 800c664:	6053      	str	r3, [r2, #4]
 800c666:	f856 3c04 	ldr.w	r3, [r6, #-4]
 800c66a:	f003 0301 	and.w	r3, r3, #1
 800c66e:	431d      	orrs	r5, r3
 800c670:	4648      	mov	r0, r9
 800c672:	f846 5c04 	str.w	r5, [r6, #-4]
 800c676:	f7ff f8ff 	bl	800b878 <__malloc_unlock>
 800c67a:	4630      	mov	r0, r6
 800c67c:	e73d      	b.n	800c4fa <_realloc_r+0x162>
 800c67e:	4631      	mov	r1, r6
 800c680:	f7ff fe26 	bl	800c2d0 <memmove>
 800c684:	e76c      	b.n	800c560 <_realloc_r+0x1c8>
 800c686:	68b3      	ldr	r3, [r6, #8]
 800c688:	6083      	str	r3, [r0, #8]
 800c68a:	68f3      	ldr	r3, [r6, #12]
 800c68c:	60c3      	str	r3, [r0, #12]
 800c68e:	2a24      	cmp	r2, #36	; 0x24
 800c690:	d02c      	beq.n	800c6ec <_realloc_r+0x354>
 800c692:	f100 0310 	add.w	r3, r0, #16
 800c696:	f106 0210 	add.w	r2, r6, #16
 800c69a:	e75b      	b.n	800c554 <_realloc_r+0x1bc>
 800c69c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800c6a0:	f022 0203 	bic.w	r2, r2, #3
 800c6a4:	4414      	add	r4, r2
 800c6a6:	e717      	b.n	800c4d8 <_realloc_r+0x140>
 800c6a8:	4631      	mov	r1, r6
 800c6aa:	4638      	mov	r0, r7
 800c6ac:	4674      	mov	r4, lr
 800c6ae:	463e      	mov	r6, r7
 800c6b0:	f7ff fe0e 	bl	800c2d0 <memmove>
 800c6b4:	46d0      	mov	r8, sl
 800c6b6:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c6ba:	e70d      	b.n	800c4d8 <_realloc_r+0x140>
 800c6bc:	463a      	mov	r2, r7
 800c6be:	e700      	b.n	800c4c2 <_realloc_r+0x12a>
 800c6c0:	4631      	mov	r1, r6
 800c6c2:	4638      	mov	r0, r7
 800c6c4:	461c      	mov	r4, r3
 800c6c6:	463e      	mov	r6, r7
 800c6c8:	f7ff fe02 	bl	800c2d0 <memmove>
 800c6cc:	46d0      	mov	r8, sl
 800c6ce:	f8da 3004 	ldr.w	r3, [sl, #4]
 800c6d2:	e701      	b.n	800c4d8 <_realloc_r+0x140>
 800c6d4:	68b3      	ldr	r3, [r6, #8]
 800c6d6:	f8ca 3010 	str.w	r3, [sl, #16]
 800c6da:	68f3      	ldr	r3, [r6, #12]
 800c6dc:	f8ca 3014 	str.w	r3, [sl, #20]
 800c6e0:	2a24      	cmp	r2, #36	; 0x24
 800c6e2:	d018      	beq.n	800c716 <_realloc_r+0x37e>
 800c6e4:	3610      	adds	r6, #16
 800c6e6:	f10a 0318 	add.w	r3, sl, #24
 800c6ea:	e7a8      	b.n	800c63e <_realloc_r+0x2a6>
 800c6ec:	6933      	ldr	r3, [r6, #16]
 800c6ee:	6103      	str	r3, [r0, #16]
 800c6f0:	6973      	ldr	r3, [r6, #20]
 800c6f2:	6143      	str	r3, [r0, #20]
 800c6f4:	f106 0218 	add.w	r2, r6, #24
 800c6f8:	f100 0318 	add.w	r3, r0, #24
 800c6fc:	e72a      	b.n	800c554 <_realloc_r+0x1bc>
 800c6fe:	68b1      	ldr	r1, [r6, #8]
 800c700:	f8ca 1010 	str.w	r1, [sl, #16]
 800c704:	68f1      	ldr	r1, [r6, #12]
 800c706:	f8ca 1014 	str.w	r1, [sl, #20]
 800c70a:	2a24      	cmp	r2, #36	; 0x24
 800c70c:	d00f      	beq.n	800c72e <_realloc_r+0x396>
 800c70e:	3610      	adds	r6, #16
 800c710:	f10a 0218 	add.w	r2, sl, #24
 800c714:	e6d5      	b.n	800c4c2 <_realloc_r+0x12a>
 800c716:	6933      	ldr	r3, [r6, #16]
 800c718:	f8ca 3018 	str.w	r3, [sl, #24]
 800c71c:	6973      	ldr	r3, [r6, #20]
 800c71e:	f8ca 301c 	str.w	r3, [sl, #28]
 800c722:	3618      	adds	r6, #24
 800c724:	f10a 0320 	add.w	r3, sl, #32
 800c728:	e789      	b.n	800c63e <_realloc_r+0x2a6>
 800c72a:	463b      	mov	r3, r7
 800c72c:	e760      	b.n	800c5f0 <_realloc_r+0x258>
 800c72e:	6932      	ldr	r2, [r6, #16]
 800c730:	f8ca 2018 	str.w	r2, [sl, #24]
 800c734:	6972      	ldr	r2, [r6, #20]
 800c736:	f8ca 201c 	str.w	r2, [sl, #28]
 800c73a:	3618      	adds	r6, #24
 800c73c:	f10a 0220 	add.w	r2, sl, #32
 800c740:	e6bf      	b.n	800c4c2 <_realloc_r+0x12a>
 800c742:	4631      	mov	r1, r6
 800c744:	4638      	mov	r0, r7
 800c746:	f8cd c004 	str.w	ip, [sp, #4]
 800c74a:	f7ff fdc1 	bl	800c2d0 <memmove>
 800c74e:	f8dd c004 	ldr.w	ip, [sp, #4]
 800c752:	e753      	b.n	800c5fc <_realloc_r+0x264>
 800c754:	68b3      	ldr	r3, [r6, #8]
 800c756:	f8ca 3010 	str.w	r3, [sl, #16]
 800c75a:	68f3      	ldr	r3, [r6, #12]
 800c75c:	f8ca 3014 	str.w	r3, [sl, #20]
 800c760:	2a24      	cmp	r2, #36	; 0x24
 800c762:	d003      	beq.n	800c76c <_realloc_r+0x3d4>
 800c764:	3610      	adds	r6, #16
 800c766:	f10a 0318 	add.w	r3, sl, #24
 800c76a:	e741      	b.n	800c5f0 <_realloc_r+0x258>
 800c76c:	6933      	ldr	r3, [r6, #16]
 800c76e:	f8ca 3018 	str.w	r3, [sl, #24]
 800c772:	6973      	ldr	r3, [r6, #20]
 800c774:	f8ca 301c 	str.w	r3, [sl, #28]
 800c778:	3618      	adds	r6, #24
 800c77a:	f10a 0320 	add.w	r3, sl, #32
 800c77e:	e737      	b.n	800c5f0 <_realloc_r+0x258>
 800c780:	20000d64 	.word	0x20000d64
