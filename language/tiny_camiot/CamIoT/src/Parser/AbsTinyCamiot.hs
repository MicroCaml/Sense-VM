-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Parser.AbsTinyCamiot where

import Prelude (Char, Double, Integer, String, map, fmap)
import qualified Prelude as C (Eq, Ord, Show, Read, Functor)
import qualified Data.String

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype UIdent = UIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

data Def a
    = DEquation a Ident [Pat a] (Exp a)
    | DTypeSig a Ident Type
    | DDataDec a UIdent [Ident] [ConstructorDec a]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Def where
    fmap f x = case x of
        DEquation a ident pats exp -> DEquation (f a) ident (map (fmap f) pats) (fmap f exp)
        DTypeSig a ident type_ -> DTypeSig (f a) ident type_
        DDataDec a uident idents constructordecs -> DDataDec (f a) uident idents (map (fmap f) constructordecs)

data ConstructorDec a = ConstDec a UIdent Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor ConstructorDec where
    fmap f x = case x of
        ConstDec a uident type_ -> ConstDec (f a) uident type_

data Type
    = TLam Type Type
    | TVar Ident
    | TNil 
    | TAdt UIdent [Type]
    | TTup [Type]
    | TBool
    | TInt
    | TFloat
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Exp a
    = ECase a (Exp a) [PatMatch a]
    | ELet a (Pat a) (Exp a) (Exp a)
    | ELetR a (Pat a) (Exp a) (Exp a)
    | ELam a (Pat a) (Exp a)
    | EIf a (Exp a) (Exp a) (Exp a)
    | EApp a (Exp a) (Exp a)
    | EOr a (Exp a) (Exp a)
    | EAnd a (Exp a) (Exp a)
    | ERel a (Exp a) (RelOp a) (Exp a)
    | EAdd a (Exp a) (AddOp a) (Exp a)
    | EMul a (Exp a) (MulOp a) (Exp a)
    | ETup a [Exp a]
    | ENot a (Exp a)
    | EVar a Ident
    | EUVar a UIdent
    | EConst a (Const a)
    | ETyped a (Exp a) Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Exp where
    fmap f x = case x of
        ECase a exp patmatchs -> ECase (f a) (fmap f exp) (map (fmap f) patmatchs)
        ELet a pat exp1 exp2 -> ELet (f a) (fmap f pat) (fmap f exp1) (fmap f exp2)
        ELetR a pat exp1 exp2 -> ELetR (f a) (fmap f pat) (fmap f exp1) (fmap f exp2)
        ELam a pat exp -> ELam (f a) (fmap f pat) (fmap f exp)
        EIf a exp1 exp2 exp3 -> EIf (f a) (fmap f exp1) (fmap f exp2) (fmap f exp3)
        EApp a exp1 exp2 -> EApp (f a) (fmap f exp1) (fmap f exp2)
        EOr a exp1 exp2 -> EOr (f a) (fmap f exp1) (fmap f exp2)
        EAnd a exp1 exp2 -> EAnd (f a) (fmap f exp1) (fmap f exp2)
        ERel a exp1 relop exp2 -> ERel (f a) (fmap f exp1) (fmap f relop) (fmap f exp2)
        EAdd a exp1 addop exp2 -> EAdd (f a) (fmap f exp1) (fmap f addop) (fmap f exp2)
        EMul a exp1 mulop exp2 -> EMul (f a) (fmap f exp1) (fmap f mulop) (fmap f exp2)
        ETup a tupexps -> ETup (f a) (map (fmap f) tupexps)
        ENot a exp -> ENot (f a) (fmap f exp)
        EVar a ident -> EVar (f a) ident
        EUVar a uident -> EUVar (f a) uident
        EConst a const -> EConst (f a) (fmap f const)
        ETyped a exp type_ -> ETyped (f a) (fmap f exp) type_

data AddOp a = Plus a | Minus a | AddOpTyped a (AddOp a) Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)
        AddOpTyped a addop type_ -> AddOpTyped (f a) (fmap f addop) type_

data MulOp a = Times a | Div a | MulOpTyped a (MulOp a) Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        MulOpTyped a mulop type_ -> MulOpTyped (f a) (fmap f mulop) type_

data RelOp a
    = LTC a
    | LEC a
    | GTC a
    | GEC a
    | EQC a
    | RelOpTyped a (RelOp a) Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor RelOp where
    fmap f x = case x of
        LTC a -> LTC (f a)
        LEC a -> LEC (f a)
        GTC a -> GTC (f a)
        GEC a -> GEC (f a)
        EQC a -> EQC (f a)
        RelOpTyped a relop type_ -> RelOpTyped (f a) (fmap f relop) type_

data Con a = Constructor a UIdent
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Con where
    fmap f x = case x of
        Constructor a uident -> Constructor (f a) uident

data Const a
    = CInt a Integer | CFloat a Double | CTrue a | CFalse a | CNil a
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Const where
    fmap f x = case x of
        CInt a integer -> CInt (f a) integer
        CFloat a double -> CFloat (f a) double
        CTrue a -> CTrue (f a)
        CFalse a -> CFalse (f a)
        CNil a -> CNil (f a)

data Pat a
    = PConst a (Const a)
    | PVar a Ident
    | PZAdt a UIdent
    | PNAdt a UIdent [Pat a]
    | PWild a
    | PNil a
    | PTup a [Pat a]
    | PLay a Ident (Pat a)
    | PTyped a (Pat a) Type
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Pat where
    fmap f x = case x of
        PConst a const -> PConst (f a) (fmap f const)
        PVar a ident -> PVar (f a) ident
        PZAdt a uident -> PZAdt (f a) uident
        PNAdt a uident adtpats -> PNAdt (f a) uident (map (fmap f) adtpats)
        PWild a -> PWild (f a)
        PNil a -> PNil (f a)
        PTup a tuppats -> PTup (f a) (map (fmap f) tuppats)
        PLay a ident pat -> PLay (f a) ident (fmap f pat)
        PTyped a pat type_ -> PTyped (f a) (fmap f pat) type_

data PatMatch a = PM a (Pat a) (Exp a)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor PatMatch where
    fmap f x = case x of
        PM a pat exp -> PM (f a) (fmap f pat) (fmap f exp)

