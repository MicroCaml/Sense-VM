
comment "--" ;
comment "{-" "-}" ;

token UIdent (upper (letter | digit | '_')*) ;

-- Layout

layout "where", "of";
layout toplevel ;

-- Programs

-- commenting this out removes 1 shift reduce
separator    Def   ";" ; -- Moving this here changes the behavior

DEquation.   Def ::= Ident [Pat] "=" Exp ; -- List so that we can have f a b = ...
DTypeSig.    Def ::= Ident ":" Type ;
DDataDec.    Def ::= "data" UIdent [Ident] "where" "{" [ConstructorDec] "}" ;

ConstDec. ConstructorDec ::= UIdent ":" Type ;
separator ConstructorDec ";" ;

separator    Ident "" ;


-- types

-- This gives some shift/reduce conflicts (7), but it seems to parse
-- as we want it to anyway! If you remove the [Type] after UIdent
-- it will remove all shift/reduce conflicts.
TLam.	Type  ::= Type1 "->" Type ;
TPair.  Type1 ::= Type2 "*" Type1 ;
TVar.   Type2 ::= Ident ;
TAdt.   Type2 ::= UIdent [Type] ;

-- Set these as internals, in the AST we can inspect a TAdt to see if it's a Int []
-- and return a TInt instead.
internal TInt.   Type ::= ;
internal TFloat. Type ::= ;
internal TBool.  Type ::= ;

separator Type "" ;
coercions Type 2 ;

-- Expressions

-- We want a different separator for these than for ordinary Exp
ETupExp. TupExp ::= Exp ;
separator nonempty TupExp "," ;

ETup.   Exp  ::= "(" [TupExp] ")" ;
ECase.  Exp  ::= "case" Exp "of" "{" [PatMatch] "}";
ELet.   Exp  ::= "let"    Pat "=" Exp "in" Exp ;
ELetR.  Exp  ::= "letrec" Pat "=" Exp "in" Exp ;
ELam.   Exp  ::= "\\" Pat "->" Exp ;
EIf.    Exp  ::= "if" Exp "then" Exp "else" Exp ;
ECon.   Exp  ::= Con [Exp] ;
EApp.   Exp1 ::= Exp2 Exp1 ; 
EOr.    Exp1 ::= Exp2 "||" Exp1 ;
EAnd.   Exp2 ::= Exp3 "&&" Exp2 ;
ERel.   Exp3 ::= Exp3 RelOp Exp4 ;
EAdd.   Exp4 ::= Exp4 AddOp Exp5 ;
EMul.   Exp5 ::= Exp5 MulOp Exp6 ;
ENot.   Exp6 ::= "!" Exp7 ;
EVar.   Exp7 ::= Ident ;
EConst. Exp7 ::= Const ;

Plus.  AddOp ::= "+" ;
Minus. AddOp ::= "-" ;

Times. MulOp ::= "*" ;
Div.   MulOp ::= "/" ;

LTC. RelOp ::= "<" ;
LEC. RelOp ::= "<=" ;
GTC. RelOp ::= ">" ;
GEC. RelOp ::= ">=" ;
EQC. RelOp ::= "==" ;

coercions Exp 7 ;
separator Exp "" ;

-- Constructor

Constructor. Con ::= UIdent ;

-- Constants

CInt.     Const ::= Integer ;
CFloat.   Const ::= Double ;
CTrue.    Const ::= "True" ;
CFalse.   Const ::= "False" ;
CNil.     Const ::= "()" ;

-- Patterns

PConst. Pat  ::= Const ;
PVar.   Pat  ::= Ident ;
PAdt.   Pat  ::= UIdent [Pat] ;
PWild.  Pat  ::= "_" ;
PNIl.   Pat  ::= "(" ")" ;
PTup.   Pat1 ::= "(" Pat "," Pat ")" ;
PLay.   Pat2 ::= Ident "as" Pat ;

separator Pat "" ;
coercions Pat 2 ;

-- Pattern matching

PM. PatMatch ::= Pat "->" Exp ;

separator PatMatch ";"; 