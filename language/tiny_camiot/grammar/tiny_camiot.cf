


token UIdent (upper (letter | digit | '_')*) ;

-- Programs

-- A program is a sequence of definitions
Program. Prg ::= [Def] ;

layout "where", "of";

Equation. Def ::= Ident [Pat] "=" Exp ; -- List so that we can have f a b = ...
TypeSig.  Def ::= Ident ":" Type ;
DataDec.  Def ::= "data" UIdent [Ident] "where" "{" [ConstructorDec] "}";

ConstDec. ConstructorDec ::= UIdent "::" Type ;
separator ConstructorDec ";" ;

-- commenting this out removes 1 shift reduce
separator    Def   "" ;
separator    Ident "" ;


-- types
-- This gives some shift/reduce conflicts (7), but it seems to parse
-- as we want it to anyway! If you remove the [Type] after UIdent
-- it will remove all shift/reduce conflicts.
TLam.	Type  ::= Type1 "->" Type ;
TPair.  Type1  ::= Type2 "*" Type1 ; -- want * to bind harder than ->, I figured
TInt. 	Type2 ::= "Int" ; -- TODO I would want these to be captured by TAdt but it doesn't seem to work...
TFloat. Type2 ::= "Float" ;
TBool.  Type2 ::= "Bool" ;
TVar. 	Type2 ::= Ident ;
TAdt.   Type2 ::= UIdent [Type] ;
-- removed a ( Type ) rule, coerce will insert it.
separator Type "" ;
coercions Type 2 ;

-- Expressions
-- The indices on the "Exp" sets precedence levels.
-- Fix the precedences so they make sense.

-- I think this might make sense, but we should try to produce a test suite to test this.
-- I took some inspiration from various other .bnfc-files.

-- 1: An expression of higher levels can be used on lower levels.
-- 2: Any level expression is lifted to highest by wrapping in parentheses.

{- Layout syntax! See the rule for case of, there is some extra fluff there, e.g {}.
   Only works with the Haskell version! If it sees the {} and stuff it will work
   as intended, as the rule will match. If it does not see a { after of, it will
   insert one and insert the ; at appropriate places. Only demand is that we write each
   of the case branches starting on the same column. -}

ETup.   Exp  ::= "(" Exp "," Exp ")" ;
ECase.  Exp  ::= "case" Exp "of" "{" [PatMatch] "}";
ELet.   Exp  ::= "let"    Pat "=" Exp "in" Exp ;
ELetR.  Exp  ::= "letrec" Pat "=" Exp "in" Exp ;
ELam.   Exp  ::= "\\" Pat "->" Exp ;
EIf.    Exp  ::= "if" Exp "then" Exp "else" Exp ;
ECon.   Exp  ::= Con Exp ;
EApp.   Exp1 ::= Exp2 Exp1 ;
EOr.    Exp1 ::= Exp2 "||" Exp1 ;
EAnd.   Exp2 ::= Exp3 "&&" Exp2 ;
ERel.   Exp3 ::= Exp3 RelOp Exp4 ;
EAdd.   Exp4 ::= Exp4 AddOp Exp5 ;
EMul.   Exp5 ::= Exp5 MulOp Exp6 ;
ENot.   Exp6 ::= "!" Exp7 ;
EVar.   Exp7 ::= Ident ;
EConst. Exp7 ::= Const ;

Plus.  AddOp ::= "+" ;
Minus. AddOp ::= "-" ;

Times. MulOp ::= "*" ;
Div.   MulOp ::= "/" ;

LTC. RelOp ::= "<" ;
LEC. RelOp ::= "<=" ;
GTC. RelOp ::= ">" ;
GEC. RelOp ::= ">=" ;
EQC. RelOp ::= "==" ;

coercions Exp 7 ;

-- Constructor
Constructor. Con ::= UIdent ;


-- Constants
CInt.     Const ::= Integer ;
CFloat.   Const ::= Double ;
CTrue.    Const ::= "True" ;
CFalse.   Const ::= "False" ;

-- Patterns

PVar.   Pat  ::=  Ident ;
PConst. Pat  ::=  Const ;
PNil.   Pat  ::=  "(" ")";
PTup.   Pat1 ::=  "(" Pat "," Pat ")" ;
PLay.   Pat2 ::=  Ident "as" Pat ;

separator Pat "" ;
coercions Pat 2 ;

-- Pattern matching

-- TODO we cannot match on constants atm
PMConPat.  PatMatch ::= Con Pat "->" Exp ;
PMConst.   PatMatch ::= Const "->" Exp ;
separator PatMatch ";"; 

