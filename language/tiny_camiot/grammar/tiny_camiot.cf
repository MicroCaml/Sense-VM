
comment "--" ;
comment "{-" "-}" ;

token UIdent (upper (letter | digit | '_')*) ;

-- Layout

layout "where", "of";
layout toplevel ;

-- Programs

-- commenting this out removes 1 shift reduce
separator    Def   ";" ; -- Moving this here changes the behavior

Equation.   Def ::= Ident [Pat] "=" Exp ; -- List so that we can have f a b = ...
TypeSig.    Def ::= Ident ":" Type ;
DataDec.    Def ::= "data" UIdent [Ident] "where" "{" [ConstructorDec] "}";

ConstDec. ConstructorDec ::= UIdent "::" Type ;
separator ConstructorDec ";" ;

separator    Ident "" ;


-- types

-- This gives some shift/reduce conflicts (7), but it seems to parse
-- as we want it to anyway! If you remove the [Type] after UIdent
-- it will remove all shift/reduce conflicts.
TLam.	  Type  ::= Type1 "->" Type ;
TPair.  Type1 ::= Type2 "*" Type1 ;
TInt.   Type2 ::= "Int" ; -- TODO I would want these to be captured by TAdt but it doesn't seem to work...
TFloat. Type2 ::= "Float" ;
TBool.  Type2 ::= "Bool" ;
TVar.   Type2 ::= Ident ;
TAdt.   Type2 ::= UIdent [Type] ;

separator Type "" ;
coercions Type 2 ;

-- Expressions

ETup.   Exp  ::= "(" Exp "," Exp ")" ;
ECase.  Exp  ::= "case" Exp "of" "{" [PatMatch] "}";
ELet.   Exp  ::= "let"    Pat "=" Exp "in" Exp ;
ELetR.  Exp  ::= "letrec" Pat "=" Exp "in" Exp ;
ELam.   Exp  ::= "\\" Pat "->" Exp ;
EIf.    Exp  ::= "if" Exp "then" Exp "else" Exp ;
ECon.   Exp  ::= Con Exp ;
EApp.   Exp1 ::= Exp2 Exp1 ; 
EOr.    Exp1 ::= Exp2 "||" Exp1 ;
EAnd.   Exp2 ::= Exp3 "&&" Exp2 ;
ERel.   Exp3 ::= Exp3 RelOp Exp4 ;
EAdd.   Exp4 ::= Exp4 AddOp Exp5 ;
EMul.   Exp5 ::= Exp5 MulOp Exp6 ;
ENot.   Exp6 ::= "!" Exp7 ;
EVar.   Exp7 ::= Ident ;
EConst. Exp7 ::= Const ;

Plus.  AddOp ::= "+" ;
Minus. AddOp ::= "-" ;

Times. MulOp ::= "*" ;
Div.   MulOp ::= "/" ;

LTC. RelOp ::= "<" ;
LEC. RelOp ::= "<=" ;
GTC. RelOp ::= ">" ;
GEC. RelOp ::= ">=" ;
EQC. RelOp ::= "==" ;

coercions Exp 7 ;

-- Constructor
Constructor. Con ::= UIdent ;

-- Constants
CInt.     Const ::= Integer ;
CFloat.   Const ::= Double ;
CTrue.    Const ::= "True" ;
CFalse.   Const ::= "False" ;

-- Patterns

PVar.   Pat  ::=  Ident ;
PConst. Pat  ::=  Const ;
PNil.   Pat  ::=  "(" ")";
PTup.   Pat1 ::=  "(" Pat "," Pat ")" ;
PLay.   Pat2 ::=  Ident "as" Pat ;

separator Pat "" ;
coercions Pat 2 ;

-- Pattern matching

-- TODO we cannot match on constants atm
PMConPat.  PatMatch ::= Con Pat "->" Exp ;
PMConst.   PatMatch ::= Const "->" Exp ;
separator PatMatch ";"; 

